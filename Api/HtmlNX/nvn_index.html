<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVN Programming Guide | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_page_graphics_for_n_x.html">Graphics Environment for NX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NVN Programming Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#nvn_guide_sec_1">1. Introduction</a></li>
<li class="level1"><a href="#nvn_guide_sec_2">2. API Object Types</a><ul><li class="level2"><a href="#nvn_guide_sec_2_1">2.1. Devices</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_2">2.2. Queues</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_3">2.3. Command Buffers</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_4">2.4. Program Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_5">2.5. Builder and Compiled GPU Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_6">2.6. Render State Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_7">2.7. Sync Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_8">2.8. Memory Pool Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_9">2.9. Texture and Sampler Pool Objects</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_10">2.10. Object Handles and Addresses</a></li>
<li class="level2"><a href="#nvn_guide_sec_2_11">2.11. Object Model and Lifetime</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_memory_pools">3. Memory Pool Objects</a><ul><li class="level2"><a href="#nvn_guide_memory_mappings">3.1. GPU Memory Mappings</a></li>
<li class="level2"><a href="#nvn_guide_memory_pool_coherency">3.2. CPU Access and Coherency</a></li>
<li class="level2"><a href="#nvn_guide_memory_pool_aliasing">3.3. Memory Pool Aliasing</a></li>
<li class="level2"><a href="#nvn_guide_resource_alignment">3.4. Memory Resource Alignment</a></li>
<li class="level2"><a href="#nvn_guide_memory_pools_windows">3.5. Memory Pools on Windows</a><ul><li class="level3"><a href="#autotoc_md64">CPU-Cached Memory Pools</a></li>
<li class="level3"><a href="#autotoc_md65">CPU-Uncached Memory Pools</a></li>
<li class="level3"><a href="#autotoc_md66">Virtual Memory Pools</a></li>
<li class="level3"><a href="#autotoc_md67">Packaged Resource Sets</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_buffers">4. Buffer Objects</a></li>
<li class="level1"><a href="#nvn_guide_textures">5. Texture Objects</a><ul><li class="level2"><a href="#nvn_guide_texture_initilization">5.1. Texture Initialization</a></li>
<li class="level2"><a href="#nvn_guide_native_texture_format">5.2. Native NX block format</a><ul><li class="level3"><a href="#autotoc_md68">Minimal texture layout</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_packaged_texture_data">5.3. Packaged Texture Data</a><ul><li class="level3"><a href="#autotoc_md69">Packaged Texture Data on Windows</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_texture_views">5.4. Texture Views</a></li>
<li class="level2"><a href="#nvn_guide_texture_pools">5.5. Texture Pools and Registration</a></li>
<li class="level2"><a href="#nvn_guide_sec_5_6">5.6. Texture and Image Handles</a></li>
<li class="level2"><a href="#nvn_guide_sparse_texture">5.7. Sparse Textures</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_samplers">6. Sampler Objects</a><ul><li class="level2"><a href="#nvn_guide_sec_6_1">6.1. Sampler Interactions with Textures</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_programs">7. Program Objects</a><ul><li class="level2"><a href="#nvn_guide_sec_7_1">7.1. Compiled Shader Code</a></li>
<li class="level2"><a href="#nvn_guide_sec_7_2">7.2. Shader Scratch Memory</a></li>
<li class="level2"><a href="#nvn_guide_sec_7_3">7.3. Shader Resources</a><ul><li class="level3"><a href="#autotoc_md70">Uniforms</a></li>
<li class="level3"><a href="#autotoc_md71">Bindless Resources</a></li>
<li class="level3"><a href="#autotoc_md72">Separate Samplers and Textures</a></li>
<li class="level3"><a href="#autotoc_md73">Shader Subroutines</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_command_buffers">8. Command Buffer Objects</a><ul><li class="level2"><a href="#nvn_guide_sec_8_1">8.1. Command Set Recording and Submission</a></li>
<li class="level2"><a href="#nvn_guide_command_buffer_memory_management">8.2. Command Buffer Memory Management</a><ul><li class="level3"><a href="#autotoc_md74">Initial Memory Allocations</a></li>
<li class="level3"><a href="#autotoc_md75">Characteristics of memory to assign to command memory and control memory</a></li>
<li class="level3"><a href="#autotoc_md76">Recording to the command memory and the control memory</a></li>
<li class="level3"><a href="#nvn_guide_command_buffer_memory_callbacks">Command Buffer Memory Callbacks</a></li>
<li class="level3"><a href="#autotoc_md77">How command memory and/or the control memory is used</a></li>
<li class="level3"><a href="#autotoc_md78">Measuring the command memory and the control memory usage</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_8_3">8.3. Command Buffer Calls and Copies</a></li>
<li class="level2"><a href="#nvn_guide_sec_8_4">8.4. Command Buffer Memory Usage</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_formats">9. Formats</a><ul><li class="level2"><a href="#nvn_guide_format_encodings">9.1. Component Encodings</a></li>
<li class="level2"><a href="#nvn_guide_sec_9_2">9.2. Depth/Stencil Formats</a></li>
<li class="level2"><a href="#nvn_guide_sec_9_3">9.3. Packed Formats</a></li>
<li class="level2"><a href="#nvn_guide_compressed_formats">9.4. Compressed Formats</a></li>
<li class="level2"><a href="#nvn_guide_srgb">9.5. sRGB Formats</a></li>
<li class="level2"><a href="#nvn_guide_formats_table">9.6. Formats Table</a></li>
<li class="level2"><a href="#nvn_guide_formats_restrictions_on_Windows">9.7. Formats Restriction on the NVN Windows Reference Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_rendering">10. Graphics Primitive Processing</a><ul><li class="level2"><a href="#nvn_guide_sec_10_1">10.1. Draw Calls</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_2">10.2. Vertex Shaders</a><ul><li class="level3"><a href="#nvn_guide_vertex">Vertex Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_10_3">10.3. Tessellation Control Shaders</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_4">10.4. Tessellation Evaluation Shaders</a><ul><li class="level3"><a href="#nvn_tessellation_execution_modes">Tessellation execution mode parameters</a></li>
<li class="level3"><a href="#autotoc_md79">Tessellated primitive orientation</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_10_5">10.5. Geometry Shaders</a><ul><li class="level3"><a href="#autotoc_md80">Passthrough Geometry Shaders</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_10_6">10.6. Transform Feedback</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_7">10.7. Viewport Selection</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_8">10.8. Viewport Swizzle</a></li>
<li class="level2"><a href="#nvn_guide_clipping">10.9. Primitive Clipping</a></li>
<li class="level2"><a href="#nvn_guide_viewport">10.10. Viewport Transformation</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_11">10.11. Rasterization</a><ul><li class="level3"><a href="#nvn_guide_conservative_rasterization">Conservative Rasterization</a></li>
<li class="level3"><a href="#autotoc_md81">Target-Independent Rasterization</a></li>
<li class="level3"><a href="#autotoc_md82">Programmable Sample Locations</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_10_12">10.12. Early Per-Fragment Tests</a></li>
<li class="level2"><a href="#nvn_guide_sec_10_13">10.13. Fragment Shaders</a></li>
<li class="level2"><a href="#nvn_guide_per_fragment">10.14. Per-Fragment Operations</a><ul><li class="level3"><a href="#autotoc_md83">Multisample Fragment Operations</a></li>
<li class="level3"><a href="#autotoc_md84">Alpha Test</a></li>
<li class="level3"><a href="#autotoc_md85">Depth Bounds Test</a></li>
<li class="level3"><a href="#autotoc_md86">Depth and Stencil Test</a></li>
<li class="level3"><a href="#autotoc_md87">Coverage-to-Color</a></li>
<li class="level3"><a href="#autotoc_md88">Blending and Logical Operations</a></li>
<li class="level3"><a href="#autotoc_md89">Framebuffer Color Writes</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_draw_texture">10.15. DrawTexture Primitives</a></li>
<li class="level2"><a href="#nvn_guide_framebuffer_clears">10.16. Framebuffer Clears</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_sec_11">11. Compute Shader Dispatch</a></li>
<li class="level1"><a href="#nvn_guide_copy_commands">12. Data Copy Commands</a></li>
<li class="level1"><a href="#nvn_guide_barriers">13. Barriers</a><ul><ul><li class="level3"><a href="#autotoc_md90">Examples</a></li>
</ul>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_sync">14. Sync Objects</a></li>
<li class="level1"><a href="#nvn_guide_event_object">15. Event objects</a><ul><li class="level2"><a href="#nvn_guide_sec_15_1">15.1. Creating an event object</a></li>
<li class="level2"><a href="#nvn_guide_sec_15_2">15.2. Signaling an event</a></li>
<li class="level2"><a href="#nvn_guide_sec_15_3">15.3. Waiting for an event</a><ul><li class="level3"><a href="#autotoc_md91">Unblocking the GPU before presenting a texture</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_render_targets">16. Render Targets</a></li>
<li class="level1"><a href="#nvn_guide_sec_17">17. Multithreading</a></li>
<li class="level1"><a href="#nvn_guide_counters">18. Counters</a><ul><li class="level2"><a href="#nvn_guide_counter_resolution_of_timestamp">18.1. Resolution of timestamp</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_presentation">19. Displaying Textures On-Screen</a><ul><li class="level2"><a href="#nvn_guide_sec_19_1">19.1. Presentation sample code</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_sec_20">20. Application Debugging</a><ul><li class="level2"><a href="#nvn_guide_debug_layer">20.1. Debug Layer</a><ul><li class="level3"><a href="#nvn_guide_global_debug_cb">Global Debug Callback</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_20_2">20.2. Debug Labels, Markers, and Groups</a></li>
<li class="level2"><a href="#nvn_guide_api_object_tracking">20.3. API Object Tracking</a></li>
<li class="level2"><a href="#nvn_guide_sec_20_4">20.4. GPU error reporting</a><ul><li class="level3"><a href="#autotoc_md92">Pushbuffer DMA error</a></li>
<li class="level3"><a href="#autotoc_md93">Graphics engine exception.</a></li>
<li class="level3"><a href="#autotoc_md94">MMU fault</a></li>
<li class="level3"><a href="#autotoc_md95">Timeout error</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_sec_20_5">20.5. GPU error recovery</a></li>
<li class="level2"><a href="#nvn_guide_sec_20_6">20.6. Checkpoint Markers</a><ul><li class="level3"><a href="#autotoc_md96">Checkpoint Marker Memory</a></li>
<li class="level3"><a href="#autotoc_md97">Checkpoint Marker Overhead</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_tiled_caching">21. Tiled Caching</a><ul><ul><ul><li class="level4"><a href="#autotoc_md98">Temporarily disable tiled caching for tiled caching-unfriendly rendering</a></li>
<li class="level4"><a href="#autotoc_md99">Custom resolve pass at end of the frame</a></li>
</ul>
</ul>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_zcull">22. ZCull</a><ul><li class="level2"><a href="#nvn_guide_zcull_save_restore">22.1. ZCull Save and Restore</a><ul><li class="level3"><a href="#autotoc_md100">ZCull Invalidate Optimizations</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_adaptive_zcull">22.2. Adaptive ZCull</a></li>
<li class="level2"><a href="#nvn_zcull_stencil">22.3. ZCull stencil culling</a></li>
<li class="level2"><a href="#nvn_zcull_disabling_ZF32_Compression">22.4. ZF32 Compression Considerations</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_frame_buffer_compression">23. Framebuffer Compression</a><ul><li class="level2"><a href="#nvn_guide_frame_buffer_compression_requirements">23.1. Framebuffer Compression Requirements</a></li>
<li class="level2"><a href="#nvn_guide_sec_23_2">23.2. Framebuffer Compression Action</a></li>
<li class="level2"><a href="#nvn_guide_fast_clear">23.3. Fast Clear</a><ul><li class="level3"><a href="#autotoc_md101">Fast Clear Requirements and API</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_color_reduction">23.4. Color Reduction</a><ul><li class="level3"><a href="#autotoc_md102">Description of lossy color reduction</a></li>
<li class="level3"><a href="#autotoc_md103">Color Reduction Requirements</a></li>
<li class="level3"><a href="#autotoc_md104">Lossy reducible format classes and thresholds</a></li>
<li class="level3"><a href="#autotoc_md105">Color reduction API</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_platforms">24. Platform Details</a><ul><li class="level2"><a href="#nvn_guide_sec_24_1">24.1. API Headers</a></li>
<li class="level2"><a href="#nvn_guide_sec_24_2">24.2. Fastpath Functions</a></li>
<li class="level2"><a href="#nvn_guide_API_Versions">24.3. API Versions</a></li>
<li class="level2"><a href="#nvn_guide_bootstrapping">24.4. Bootstrapping NVN</a><ul><li class="level3"><a href="#nvn_guide_bootstrapping_nvn_on_windows">Bootstrapping NVN on Windows</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_native_NX_platform">24.5. Native NX Platform</a><ul><li class="level3"><a href="#autotoc_md106">Memory Usage</a></li>
<li class="level3"><a href="#nvn_guide_optimal_queue_memory_size">Optimal queue memory size</a></li>
<li class="level3"><a href="#nvn_guide_memory_pools_firmware_memory_usage">Firmware memory usage of memory pools</a></li>
<li class="level3"><a href="#nvn_guide_virtual_address_space_use_of_memory_pool">Virtual address space use of memory pools</a></li>
<li class="level3"><a href="#autotoc_md107">Performance Notes</a></li>
<li class="level3"><a href="#autotoc_md108">Forcibly Closing Applications and the number of Active Graphics Resources</a></li>
<li class="level3"><a href="#autotoc_md109">Device Information Constants</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_guide_Windows_Reference_Implementation">24.6. Windows Reference Implementation Details</a><ul><li class="level3"><a href="#autotoc_md110">GPUs supported by the Windows Reference Implementation</a><ul><li class="level4"><a href="#autotoc_md111">Second-Generation Maxwell GPUs</a></li>
<li class="level4"><a href="#autotoc_md112">Pascal GPUs</a></li>
<li class="level4"><a href="#autotoc_md113">Volta GPUs</a></li>
<li class="level4"><a href="#autotoc_md114">Turing GPUs</a></li>
<li class="level4"><a href="#autotoc_md115">Ampere GPUs</a></li>
<li class="level4"><a href="#autotoc_md116">First-Generation Maxwell GPUs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#nvn_guide_sec_25">25. NVN and OpenGL ES</a><ul><li class="level2"><a href="#nvn_guide_sec_25_1">25.1. Creating an OpenGL ES context</a></li>
<li class="level2"><a href="#nvn_guide_ogl_interop">25.2. NVN and OpenGL ES Interoperation</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_nvn_ProgrammingGuide"></a></p>
<h1><a class="anchor" id="nvn_guide_sec_1"></a>
1. Introduction</h1>
<p>NVN is a 3D graphics API that can be used to develop applications that run on the NX platform. Some major design points for NVN include:</p>
<ul>
<li>Robust feature set: Provide support for most graphics features provided by the NX platform through OpenGL ES 3.1, OpenGL 4.5, and other OpenGL and OpenGL ES extensions that can be supported on NX.</li>
<li>Efficient multi-threading support: Allow applications to use multiple CPU threads to generate work for the GPU to process, but without incurring significant locking overhead. The goal is to allow applications with multi-threaded graphics "job systems" to run efficiently on multiple CPU cores.</li>
<li>Pre-validation of GPU state: Provide an API that allows GPU state and commands to be generated once but used many times for rendering. In some cases, allow GPU state to be built off-line, before the application runs.</li>
<li>Reduced run-time overhead: Provide an API that is an extremely thin layer on top of GPU hardware, where commands can be sent immediately to GPU with minimal CPU overhead.</li>
<li>Application flexibility: Allow applications to change graphics state at a fine granularity without having to build or cache monolithic "pipeline" objects that represent the entire GPU state.</li>
<li>Explicit application control of memory resources: Allow applications to have explicit control over the memory used by the GPU and driver for textures, buffers, and other GPU resources.</li>
<li>Optional debug layer: Allow application developers to opt into notifications about incorrect API usage, but without incurring error checking overhead in applications that have already been debugged.</li>
<li>Reference implementation on non-NX platforms: Provide a reference implementation that can be used on Microsoft Windows with NVIDIA GPUs and behaves as closely as possible to the NX implementation. This allows application code to be developed and debugged on Windows with only minimal differences from the native NX device that might require #ifdefs or alternate code paths.</li>
<li>C and C++ interfaces: Provide both a C interface matching the set of function entry points provided by the driver, as well as an object-oriented C++ class interface for programmer convenience.</li>
</ul>
<p>This programming guide assumes a basic understanding of 3D graphics concepts and of 3D graphics APIs such as OpenGL and OpenGL ES. In particular, NVN uses programmable shaders written using the OpenGL Shading Language (version 4.50, with support for all earlier versions) and the OpenGL ES Shading Language (version 3.10, with support for all earlier versions). More information on the OpenGL APIs and shading languages can be found at the <a href="https://www.opengl.org/registry/">OpenGL Registry</a> and <a href="https://www.khronos.org/registry/gles/">OpenGL ES Registry</a>. The OpenGL Shading Language support provided for NVN includes a variety of extensions documented at the OpenGL and OpenGL ES registry pages.</p>
<p>This guide often refers to methods and enumerant definitions of the C++ interface for NVN. Readers interested in using the C interface should keep in mind that every method in the C++ interface has an equivalent C function. For example, <a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a> in the C++ interface behaves identically to <code>nvnDeviceInitialize</code> in the C interface, and the enum <a class="el" href="structnvn_1_1_min_filter.html#ab99e2fc3e21b743eab81636673e89f75a4d120111888131b59a4d5b95ea9614d8" title="Returns the weighted average of the nearest texels to the sample location in the base texture image.">nvn::MinFilter::LINEAR</a> in the C++ interface is equivalent to <code>NVN_MIN_FILTER_LINEAR</code> in the C interface.</p>
<p>NVN has both a native NX implementation and a Windows reference implementation. Additional platform-specific details on these implementations can be found in the <a href="#nvn_guide_platforms">NVN platform details section of this guide</a>.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: In this document, we use term "NVN driver". The "NVN driver" includes the library, the kernel mode driver and the firmware.</p>
<p>On NX, kernel mode driver and firmware we keep the backward compatibility. All the changes are made to the library. Since application package (.nsp file) have nnSDK.nso included, and nnSDK.nso file includes NVN library, the .nsp file built using old SDK should run with the latest firmware.</p>
<p>For the detail information of NX Platform please refer to the <a href="#nvn_guide_native_NX_platform">Native NX Platform</a> section.</p>
<p>On Windows, the "NVN driver" consists of 'nvn.dll', which implements the NVN API, and a Windows Display Driver, which acts as a device driver for the NVIDIA display adapter and provides services required by nvn.dll. Publicly-released Windows Display Drivers are not compatible with nvn.dll; a compatible Display Driver is provided with the SDK. For further details about the relationship between nvn.dll and the Windows Display Driver, see <a href="#nvn_guide_bootstrapping_nvn_on_windows">Bootstrapping NVN on Windows</a>. </p>
</blockquote>
<h1><a class="anchor" id="nvn_guide_sec_2"></a>
2. API Object Types</h1>
<p>The C and C++ interfaces for the NVN API define a number of different objects for use by applications. NVN objects are represented as structures or C++ classes, many of which are fully opaque to the application and exposed externally as an array of <code>char</code>. The application provides the memory for these data structures and passes pointers to these structures when calling NVN functions.</p>
<p>While storage for NVN objects is provided by the application, some NVN objects need to be registered with the driver before being used. For example, the NVN device object (<a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">nvn::Device</a>) must be registered via <a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a>. Additionally, objects that need to be registered also need to be released before the application frees their underlying memory. The NVN device object is released by calling <a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930" title="Finalize a Device object.">nvn::Device::Finalize</a>.</p>
<p>Applications must be careful not to create and use unregistered copies of NVN objects. It is an error to pass an unregistered NVN object to an NVN entry point. Doing so will result in an error callback if the NVN debug layer is enabled and will have undefined results if the debug layer is disabled. For example, it is possible to pass a full NVN object structure to a function by copy instead of by reference, and then pass a pointer to the copy to NVN entry points. The following code: </p><pre class="fragment">void draw30Triangles(NVNcommandBuffer cmdBuf)
{
   nvnCommandBufferDrawArrays(&amp;cmdBuf, NVN_DRAW_PRIMITIVE_TRIANGLES, 0, 90);
}

void render(NVNdevice *device)
{
  NVNcommandBuffer cmdBuf;
  nvnCommandBufferInitialize(&amp;cmdBuf, device);
  ...
  draw30Triangles(cmdBuf);
}
</pre><p> appears intended to submit a draw call to the command buffer object <code>cmdBuf</code> initialized in <code>render</code>. However, it actually works on an unregistered copy of the command buffer because the parameter <code>cmdBuf</code> is passed by copy to the function <code>draw30Triangles</code>. Even though the function call makes a complete copy of the NVN command buffer object in question, <code>nvnCommandBufferDrawArrays</code> will update only the local copy of the command buffer. The original command buffer would be unmodified and would not have any records of the inserted draw call.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_1"></a>
2.1. Devices</h2>
<p>The <b>device</b> object, represented by the class <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">nvn::Device</a>, is used to represent a GPU in the system. The device object is a parent of all other objects (queues, memory allocations, command buffers, etc.) that are used by the GPU.</p>
<p>Before using a device object, it must be initialized using <a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a>. The initial state of the device is obtained from a provided <a class="el" href="classnvn_1_1_device_builder.html" title="Object specifying state used to construct new device objects.">nvn::DeviceBuilder</a> object. When the device is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930" title="Finalize a Device object.">nvn::Device::Finalize</a>.</p>
<p>When a device object is finalized, any unfinalized queues created from the device are automatically finalized. All other objects created directly or indirectly from the device become invalid, and using any such object in NVN could result in crashes or other undefined behavior. Finalizing an object after finalizing the device used to create it counts as a use and may cause problems.</p>
<p>If a device is finalized when terminating an application, it is not necessary to finalize other API objects created using the device as long as those objects are not used after device finalization. If an application continues to use NVN after finalizing a device, we recommend that applications explicitly finalize all objects created using the device.</p>
<p>When using the debug layer, finalizing a device may generate debug layer messages for unfinalized objects in any remaining memory pools. These can safely be ignored when terminating an application.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_2"></a>
2.2. Queues</h2>
<p>The <b>queue</b> object, represented by the class <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a>, is used to submit commands to the GPU. Commands can be submitted to queues directly using the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a> methods or indirectly by submitting commands to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> object and then submitting compiled command sets using <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a>.</p>
<p>Before using a queue object, it must be initialized and associated with a device using <a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a>. The initial state of the queue is obtained from a provided <a class="el" href="classnvn_1_1_queue_builder.html" title="Object specifying state used to construct new queue objects.">nvn::QueueBuilder</a> object. When the queue is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a" title="Finalize a Queue object.">nvn::Queue::Finalize</a>. Finalizing a queue will wait for the completion of all commands previously submitted to the queue, including those sent by the driver during queue initialization.</p>
<p>Commands submitted to each queue are processed mostly in order by the GPU. Each queue has its own GPU state, and commands submitted directly to the queue or indirectly via command sets will update the GPU state. Commands updating GPU state will be executed in the order in which they were submitted to the queue, with commands stored in command sets being executed in the order in which they were added using <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> methods. Rendering commands will be executed using a GPU state that reflects all commands submitted prior to the rendering commands. Rendering commands submitted to queues are executed by the GPU in a pipeline. Writes to individual pixels of render targets using clears, copies, and fragment shader outputs will be executed in order, but may not be well-ordered relative to other operations. For example, if primitive A renders to texture T (used a render target) and then primitive B reads from from texture T as a texture, there is no guarantee that primitive B sees the rendering results from primitive A. To ensure proper ordering in such cases, applications must use <a href="#nvn_guide_barriers">barriers</a>.</p>
<p>Commands submitted to one queue are processed independently from commands submitted to other queues. Except when <a href="#nvn_guide_sync">sync objects</a> are used, the order of execution of commands submitted to separate queues is undefined.</p>
<p>Each queue has its own independent copy of NVN state; commands setting state on one queue have no effect on rendering commands submitted to different queues.</p>
<p>Each queue requires several blocks of per-queue memory for GPU command execution, including:</p>
<ul>
<li>embedded command buffer memory for submitting commands to the GPU, whose size is programmed by <a class="el" href="classnvn_1_1_queue_builder.html#a76497ef69027c2e3f91b6babdb6c8d37" title="Specify the size of the internal command buffer used by a Queue object.">nvn::QueueBuilder::SetCommandMemorySize</a>;</li>
<li>embedded control memory for submitting commands to the GPU, whose size is programmed by <a class="el" href="classnvn_1_1_queue_builder.html#ae05f5d8a9bead915062735cd08f08ccf" title="Specify the size of the control memory buffer used by a Queue object.">nvn::QueueBuilder::SetControlMemorySize</a>;</li>
<li>ring buffers holding information on compute shader dispatches to be processed by the GPU, whose size is programmed by <a class="el" href="classnvn_1_1_queue_builder.html#a8de929159ce70f00fec8c1d58057359b" title="Specify the size of the internal buffers used for compute dispatches in a Queue object.">nvn::QueueBuilder::SetComputeMemorySize</a>;</li>
<li>an optional scratch buffer for processing fragment shaders using the NV_fragment_shader_interlock GLSL language extension, which can be disabled using <a class="el" href="structnvn_1_1_queue_flags.html#af08cb0d3c086f2a3d6df1dceaf7bf1aea92e47f80ee452cb5db94e338a09b3e28" title="Disable support for fragment shader interlocks.">nvn::QueueFlags::NO_FRAGMENT_INTERLOCK</a>; and</li>
<li>a scratch buffer of implementation-dependent size for other GPU operations.</li>
</ul>
<p>For API command buffers, control memory is used to process command sets when SubmitCommands is called. The contents of control memory consists of:</p>
<ul>
<li>"GPFIFO entries" that tell the hardware to fetch and execute X bytes of GPU command memory from GPU virtual address Y; and</li>
<li>"tokens" that are inserted for the driver to do required additional processing work at SubmitCommands time.</li>
</ul>
<p>When Queue::SubmitCommands is called, GPFIFO entries in the command set are copied into the queue's control memory. Driver code processing tokens and implementing other Queue APIs will write GPU commands to the queue's command memory and insert GPFIFO entries to instruct the GPU to fetch those commands. GPFIFO entries in queue control memory are buffered and sent to nvservices when Queue::Flush is called or when the internal control memory is full. Maxwell Technical Overview gives more information about GPFIFO and how the command is transferred to GPU.</p>
<p>On NX, applications can provide a single block of per-queue memory to service these needs using the command <a class="el" href="classnvn_1_1_queue_builder.html#a13ec77274022e7c8053ea1af3e11813e" title="Provides memory to be used by queues pools initialized using a QueueBuilder.">nvn::QueueBuilder::SetQueueMemory</a>. The required memory size can be queried using <a class="el" href="classnvn_1_1_queue_builder.html#a644add6adf21a6fc5d5089187b6304c9" title="Query the amount of extra memory needed for a queue initialized using a QueueBuilder.">nvn::QueueBuilder::GetQueueMemorySize</a>. The optimal memory size can be determined using the <a href="#nvn_guide_optimal_queue_memory_size">dedicated nvn:Queue API</a>. If no memory is provided, per-queue memory will be allocated by the NVN driver via the allocation callback function programmed with <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a>. On Windows, queue memory will always be allocated by the driver. The embedded queue command buffer is automatically managed by the NVN driver, but applications can set a flush threshold via <a class="el" href="classnvn_1_1_queue_builder.html#ae0f00eed8522cd97598478deb49845f8" title="Specify a flush threshold for a new Queue object.">nvn::QueueBuilder::SetCommandFlushThreshold</a> to specify how frequently the queue will be flushed automatically for applications that require a significant amount of queue command memory per frame.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_3"></a>
2.3. Command Buffers</h2>
<p>The <b>command buffer</b> object, represented by the class <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a>, is used to build collections of commands (called <em>command sets</em>) to submit to a queue. Command buffers use memory provided by the application to record commands. A command set is constructed by starting recording using <a class="el" href="classnvn_1_1_command_buffer.html#a569698f00f43c1074330c137b97f9e81" title="Begin recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::BeginRecording</a>, inserting commands using other <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> methods, and then ending recording using <a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording</a>. A command handle (<a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb" title="GPU handle used to refer to a command buffer object.">nvn::CommandHandle</a>) representing the command set is returned by <a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording</a>, and that handle can be used once or multiple times to submit the command set to the queue for processing using <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands()</a>. The query function <a class="el" href="classnvn_1_1_command_buffer.html#a3fc63cb352e55cb62e5accc5983d9d1a" title="Query whether the command buffer is currently recording.">nvn::CommandBuffer::IsRecording</a> can be used to determine if a command buffer object is currently recording commands.</p>
<p>Before using a command buffer object, it must be initialized and associated with a device using <a class="el" href="classnvn_1_1_command_buffer.html#ab065aa237a8b8c7c96d1f7eef1cdfae4" title="Initializes a CommandBuffer object for the specified device.">nvn::CommandBuffer::Initialize</a>. When the command buffer is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_command_buffer.html#aa1f051d9b59715ee1d64f025bf4f30f1" title="Finalize a CommandBuffer object.">nvn::CommandBuffer::Finalize</a>. Applications must also provide the command buffer object with memory so it can construct command sets.</p>
<p>Command buffer objects are not associated with a specific queue; the command handle for a given command set can be submitted to any queue. When command sets containing rendering commands are submitted to a queue, any state needed by those commands not explicitly set in the command buffer will be inherited from the state of the queue. State changes made in a submitted command set will also affect future commands submitted to the same queue.</p>
<p>Command buffers are discussed in more detail in <a href="#nvn_guide_command_buffers">a separate section of this guide</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_4"></a>
2.4. Program Objects</h2>
<p>The <b>program object</b>, represented by the class <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a>, is a container holding code for one or multiple shaders. Each NVN shader consists of executable code plus additional meta-information produced by compiling source code written in the OpenGL Shading Language (GLSL). There are several types of shaders:</p>
<ul>
<li>Vertex shaders are used to transform each vertex provided by the application, computing attributes (including position) used by subsequent programmable shaders and fixed-function units. An active vertex shader is required for all draw calls.</li>
<li>Tessellation control shaders are used to transform patch primitives provided by the application. They consume the patch provided by the application and produce a new fixed-size patch, computing attributes for patch vertices plus levels of detail that will be used by the fixed-function tessellator. The tessellation control shader is optional and should only be used to process patch primitives.</li>
<li>Tessellation evaluation shaders are used to compute the position and attributes of new vertices produced when the fixed-function tessellator subdivides a patch primitive. The tessellation evaluation shader is optional and should only be used to process patch primitives.</li>
<li>Geometry shaders are used to process point, line, or triangle primitives produced by the application. The geometry shader consumes each input primitive and emits new vertices that are arranged into output primitives used by subsequent pipeline stages. The geometry shader is optional. Each geometry shader has an expected input primitive type and should only be used with input primitives with compatible types.</li>
<li>Fragment shaders are used to compute attributes of fragments produced by the rasterizer. Each fragment corresponds to a pixel stored in the framebuffer.</li>
<li>Compute shaders are used to perform generic processing of arrays of data, arranged into <b>work groups</b>.</li>
</ul>
<p>Before using a program object, it must be initialized and associated with a device using <a class="el" href="classnvn_1_1_program.html#a2bf86820737ab112fcc993736f8bfe3c" title="Initialize a Program object for the specified device.">nvn::Program::Initialize</a>. When the program is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_program.html#a365787d302b9b33508787046ab18d083" title="Finalize a Program object.">nvn::Program::Finalize</a>.</p>
<p>To use the shaders in a program object when rendering primitives, the program can be bound via <a class="el" href="classnvn_1_1_command_buffer.html#a533458762741e1851a0d64a766593b5d" title="Bind or unbind shaders in a Program object for subsequent rendering commands.">nvn::CommandBuffer::BindProgram</a>.</p>
<p>Programs are discussed in more detail in <a href="#nvn_guide_programs">a separate section of this guide</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_5"></a>
2.5. Builder and Compiled GPU Objects</h2>
<p>Some NVN objects used by the GPU are initialized using <b>builder objects</b>. An application programs the builder object with the state to be used when the GPU object is initialized and then passes the builder object to the Initialize method of the GPU object. Each GPU object created using a builder object will be created using the current state of the builder object. These compiled GPU objects will be immutable; once created, their state may not be changed.</p>
<p>Before using a builder object to create compiled GPU objects, it must be associated with a device using the SetDevice method (for example, <a class="el" href="classnvn_1_1_buffer_builder.html#ab511cf35bb80c9f59e82d86c6187b517" title="Set the Device associated with a BufferBuilder object.">nvn::BufferBuilder::SetDevice</a> for the <a class="el" href="classnvn_1_1_buffer_builder.html" title="Object specifying state used to construct new buffer objects.">nvn::BufferBuilder</a> class). Additionally, default values for all builder state can be programmed using the SetDefaults methods (for example, <a class="el" href="classnvn_1_1_texture_builder.html#ab871783968d4bc3e50fa80f7c84bfec5" title="Set default state for the TextureBuilder object.">nvn::TextureBuilder::SetDefaults</a>). Builder objects do not need to be registered with the NVN driver. No Initialize or Finalize methods are provided, and it is not necessary to notify the driver before freeing the memory used by a builder object.</p>
<p>A builder object can be used to create one or multiple compiled GPU objects. All relevant state in a builder object must be initialized (explicitly or using the SetDefaults method) prior to creating GPU objects; uninitialized values can lead to memory corruption or crashes during creation or when the object is used. The state in a builder object can be changed at any time, and the new state will be used when creating future compiled GPU objects. The state of builder objects can be reset to default values at any time using the SetDefaults() method. Changing state in a builder object has no effect on any compiled GPU objects previously created from the builder.</p>
<p>The set of builder objects supported by NVN, and their corresponding compiled GPU objects, is listed in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Builder Object   </th><th class="markdownTableHeadNone">Compiled Object    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_buffer_builder.html" title="Object specifying state used to construct new buffer objects.">nvn::BufferBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_texture_builder.html" title="Object specifying state used to construct new texture objects.">nvn::TextureBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_sampler_builder.html" title="Object specifying state used to construct new sampler objects.">nvn::SamplerBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">nvn::MemoryPoolBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a>   </td></tr>
</table>
<p>In the C++ interface, builder object methods that update object state return a reference to the builder object, which can then be used in a subsequent builder object method if desired. For example, the following code can be used to configure a sampler builder with default state except for a LOD bias of -0.5 and a red border color.</p>
<pre>
    float red[] = { 1.0, 0.0, 0.0, 1.0 };
    <a class="el" href="classnvn_1_1_sampler_builder.html" title="Object specifying state used to construct new sampler objects.">nvn::SamplerBuilder</a> sb;
    sb.SetDefaults().SetLodBias(-0.5).SetBorderColor(red);
</pre><p>Builder objects are only used to create new compiled GPU objects; they have no effect on the processing of NVN commands.</p>
<p>Compiled objects cannot be edited once created, but can be bound for use by the GPU. These objects are discussed in subsequent sections of this guide.</p>
<ul>
<li><a href="#nvn_guide_buffers">nvn::Buffer</a> represents GPU memory holding data that can be accessed by various fixed-function and programmable units of the GPU.</li>
<li><a href="#nvn_guide_textures">nvn::Texture</a> represents GPU memory holding arrays of image data (texels) that can be read and written by programmable shaders on the GPU. Two-dimensional textures and arrays can also be used as <b>render targets</b> that hold the final values of primitives rendered by the GPU.</li>
<li><a href="#nvn_guide_samplers">nvn::Sampler</a> is a GPU object that can be used to control how texture objects are read in programmable shaders. The sampler object controls how the fixed-function texture hardware constructs filtered results when sampling from texture memory.</li>
<li><a href="#nvn_guide_memory_pools">nvn::MemoryPool</a> is an object representing a block of memory that can be accessed by the CPU and GPU, and can be used to create other objects, such as buffers and textures, with data stored in pool memory.</li>
</ul>
<p>In addition to being used to initialize compiled GPU objects, several other builder object types are used to initialize non-compiled NVN API objects:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Builder Object   </th><th class="markdownTableHeadNone">API Object    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device_builder.html" title="Object specifying state used to construct new device objects.">nvn::DeviceBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">nvn::Device</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue_builder.html" title="Object specifying state used to construct new queue objects.">nvn::QueueBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_window_builder.html" title="Object specifying state used to construct new window objects.">nvn::WindowBuilder</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a>   </td></tr>
</table>
<h2><a class="anchor" id="nvn_guide_sec_2_6"></a>
2.6. Render State Objects</h2>
<p>State used to render primitives is programmed through individual commands or via <b>render state objects</b>. Render state objects hold a collection of related state values that are programmed as a unit when the state object is bound. State objects do not need to be registered with the NVN driver. No Initialize or Finalize methods are provided, and it is not necessary to notify the driver before freeing the memory used by a state object.</p>
<p>The contents of render state objects are only used when inserting commands to bind the state object in command buffers. Render state objects can be changed at any time; binding commands will use the current contents of the state object at the time of the bind call. Changing the contents of a state object does not affect the behavior of any previous bind command using the same state object; such commands will use the old contents of the state object.</p>
<p>The render state objects currently supported in NVN are as follows:</p>
<ul>
<li><a class="el" href="classnvn_1_1_blend_state.html" title="API state object controlling blending for one color target.">nvn::BlendState</a> contains the state controlling the blending equations used for one color buffer.</li>
<li><a class="el" href="classnvn_1_1_channel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">nvn::ChannelMaskState</a> contains color channel write enables used for all color buffers.</li>
<li><a class="el" href="classnvn_1_1_color_state.html" title="API state object controlling processing of color values.">nvn::ColorState</a> contains state to configure the writing of color values to the framebuffer, including blend enables and logical operation modes.</li>
<li><a class="el" href="classnvn_1_1_depth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">nvn::DepthStencilState</a> contains control information to configure the operation of the depth and stencil tests.</li>
<li><a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing.">nvn::MultisampleState</a> contains information required for multisample rasterization.</li>
<li><a class="el" href="classnvn_1_1_polygon_state.html" title="API state object controlling rasterization of polygons.">nvn::PolygonState</a> contains state controlling the rasterization of primitives.</li>
<li><a class="el" href="classnvn_1_1_vertex_attrib_state.html" title="API state object controlling vertex attrib state.">nvn::VertexAttribState</a> contains state describing the layout of one vertex attribute in memory.</li>
<li><a class="el" href="classnvn_1_1_vertex_stream_state.html" title="API state object controlling vertex stream state.">nvn::VertexStreamState</a> contains state describing the layout of one vertex stream in memory. A vertex stream represents a collection of vertex attributes stored in a structure with a common stride between structures.</li>
</ul>
<blockquote class="doxtable">
<p><b>NOTE</b>: <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> has some similarities to render state objects in that binding the object changes a collection of GPU state (descriptors for multiple shaders). However, this object stores a possibly large set of pre-compiled state. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_sec_2_7"></a>
2.7. Sync Objects</h2>
<p>The <b>sync object</b>, represented by the class <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> is used to track the completion of previously submitted GPU commands. Before using a sync object, it must be initialized and associated with a device using <a class="el" href="classnvn_1_1_sync.html#a2a560c21696b35e39f5aa18dc5c382d4" title="Initialize a Sync object for the specified device.">nvn::Sync::Initialize</a>. When the sync object is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_sync.html#ab87eb51b8df4843608d0e78adaa304fe" title="Finalize a Sync object.">nvn::Sync::Finalize</a>.</p>
<p>Sync objects are discussed in more detail in <a href="#nvn_guide_sync">a separate section of this guide</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_8"></a>
2.8. Memory Pool Objects</h2>
<p>The <b>memory pool object</b>, represented by the class <a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a> is used to manage a block of memory providing storage for <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a>, <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a>, <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a>, <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a>, <a class="el" href="classnvn_1_1_texture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">nvn::TexturePool</a>, and <a class="el" href="classnvn_1_1_sampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">nvn::SamplerPool</a> objects. Before using a memory pool object, it must be initialized and associated with a device using <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>. When the memory pool object is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a>.</p>
<p>When a memory pool object is finalized, any objects using memory provided by the memory pool become invalid, and using any such object in NVN could result in crashes or other undefined behavior.</p>
<p>Memory pool objects are discussed in more detail in <a href="#nvn_guide_memory_pools">a separate section of this guide</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_9"></a>
2.9. Texture and Sampler Pool Objects</h2>
<p>The <b>texture pool object</b> and <b>sampler pool object</b>, represented by the classes <a class="el" href="classnvn_1_1_texture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">nvn::TexturePool</a> and <a class="el" href="classnvn_1_1_sampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">nvn::SamplerPool</a> are used to manage blocks of memory obtained from a memory pool that are used to store descriptor structures representing <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> objects. Before using a texture or sampler pool object, it must be initialized using <a class="el" href="classnvn_1_1_texture_pool.html#acd9a0e9b98c9c1a8781e649ded11aa1e" title="Initialize a TexturePool object.">nvn::TexturePool::Initialize</a> or <a class="el" href="classnvn_1_1_sampler_pool.html#aa142c9deaf8467d8bbb60d54bce3591f" title="Initialize a SamplerPool object.">nvn::SamplerPool::Initialize</a>. To use descriptors stored in a texture or sampler pool for rendering, the pools must be set in the rendering state using <a class="el" href="classnvn_1_1_command_buffer.html#a25f10e3257fe549de368e842e61ee8ee" title="Specify a new texture pool used for subsequent rendering operations.">nvn::CommandBuffer::SetTexturePool</a> or <a class="el" href="classnvn_1_1_command_buffer.html#ad36725731839793d678ce0243df56f94" title="Specify a new sampler pool used for subsequent rendering operations.">nvn::CommandBuffer::SetSamplerPool</a>. When a texture or sampler pool is no longer in use, it should be cleaned up using <a class="el" href="classnvn_1_1_texture_pool.html#a114339daf6d467b300a79dfbe107b73a" title="Finalize a TexturePool object.">nvn::TexturePool::Finalize</a> or <a class="el" href="classnvn_1_1_sampler_pool.html#a3a4699bacdacb42e814f08464101db67" title="Finalize a SamplerPool object.">nvn::SamplerPool::Finalize</a>.</p>
<p>Texture and sampler pool objects are discussed in more detail in <a href="#nvn_guide_texture_pools">a separate section of this guide</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_10"></a>
2.10. Object Handles and Addresses</h2>
<p>Some NVN object types that are directly referenced by the GPU will be prepared by the driver for direct GPU access. Commands using such objects, such as those binding vertex buffers or textures or submitting command buffers, are often called frequently. To reduce the overhead involved in these commands, NVN accepts <b>object handles</b> that are used to refer to the objects by the GPU. Object handles themselves are opaque 64-bit values that may refer to a GPU virtual address for the object, a GPU virtual address for a data structure describing the object (for example, all of the state present in a texture), or some other information uniquely identifying the object. By using handles directly in NVN commands instead of using the objects' CPU pointers, we can avoid extra CPU memory accesses in these frequently-used commands.</p>
<p>To get an object handle, applications should first create an object and then use one of the query methods from the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Handle Type   </th><th class="markdownTableHeadNone">Handle Query Method    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_buffer.html#a470e8ee3cdf0bc1c369dc0a936f70807" title="Query the GPU address of the data store of a buffer object.">nvn::Buffer::GetAddress()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool.html#a22af25aa47763d17a5dec5b15835b6ce" title="Query the GPU address of the data store of a memory pool object.">nvn::MemoryPool::GetBufferAddress()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb" title="GPU handle used to refer to a command buffer object.">nvn::CommandHandle</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08" title="GPU handle used to refer to a texture object for texture mapping operations.">nvn::TextureHandle</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#a8d1c52b97f2667307df5e299c637fa41" title="Get a handle for a combined pair of Texture and Sampler objects.">nvn::Device::GetTextureHandle()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2" title="GPU handle used to refer to a texture object for image load and store operations.">nvn::ImageHandle</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#a9e1c4bf2070f7657bea6caf219556836" title="Get a handle to use for image loads and stores to a Texture object.">nvn::Device::GetImageHandle()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_separate_texture_handle.html" title="Structure containing a GPU handle used to refer to a separate texture object for texture mapping oper...">nvn::SeparateTextureHandle</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#a7e764abad3e6e33d4cd0c5e352f4bcd9" title="Get a handle for a separate Texture object.">nvn::Device::GetSeparateTextureHandle()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_separate_sampler_handle.html" title="Structure containing a GPU handle used to refer to a separate sampler object for texture mapping oper...">nvn::SeparateSamplerHandle</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#af27ddc3288d516169a135a2bfc64536d" title="Get a handle for a separate Sampler object.">nvn::Device::GetSeparateSamplerHandle()</a>   </td></tr>
</table>
<p>Once queried, object handles remain valid for the lifetime of the underlying object. Once an object is freed, all handles referencing that object become invalid. It is not necessary to separately free object handles, and no API methods are provided to allow a handle to be freed manually. If a handle is used in rendering commands after the underlying object is freed, the use is considered invalid and can result in undefined behavior, including GPU exceptions and program termination.</p>
<p>For buffer objects, the handle is the virtual address that the GPU uses to refer to the underlying memory. Applications may construct a handle for a range of a buffer object by simply adding the offset (in bytes) of the first byte of the range to the <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a> of the buffer object. Applications can also query a buffer address for the first byte of a memory pool using nvn::MemoryPoolGetBufferAddress without creating a buffer object.</p>
<p>For textures, there are three different object handle types that can refer to the same underlying texture:</p>
<ul>
<li><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08" title="GPU handle used to refer to a texture object for texture mapping operations.">nvn::TextureHandle</a> is used to bind the combined texture/sampler for texture mapping operations in the shader (e.g., the texture() GLSL built-in). Bindless texture accesses via the <a href="https://www.opengl.org/registry/specs/NV/bindless_texture.txt">NV_bindless_texture extension</a> are also supported, where the handle can be passed to the shader as a data value and used to perform texture accesses.</li>
<li><a class="el" href="structnvn_1_1_separate_texture_handle.html" title="Structure containing a GPU handle used to refer to a separate texture object for texture mapping oper...">nvn::SeparateTextureHandle</a> is used to bind a texture-only handle (without sampler information) for texture mapping operations in shaders utilizing separate textures and samplers via the <code>GL_NV_separate_texture_types</code> extension. Bindless texture accesses via the <a href="https://www.opengl.org/registry/specs/NV/bindless_texture.txt">NV_bindless_texture extension</a> are also supported, where the handle can be passed to the shader as a data value and used to be combined with a sampler-only handle in the shader to perform texture accesses.</li>
<li><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2" title="GPU handle used to refer to a texture object for image load and store operations.">nvn::ImageHandle</a> is used to bind the texture for image load/store operations in the shader (e.g., the imageLoad() and imageStore() GLSL built-ins).</li>
</ul>
<p>While texture and image descriptors are both stored in the texture pool, the texture and image handle types store different data and use different encodings. Applications must use the correct handle type to refer to the object. Using a texture handle to perform an image access or vice versa may result in crashes or undefined behavior. Along the same lines, using a separate texture handle where a combined sampler/texture handle is expected, or vice-versa, will lead to undefined behavior.</p>
<h2><a class="anchor" id="nvn_guide_sec_2_11"></a>
2.11. Object Model and Lifetime</h2>
<p>NVN objects are referred to in the NVN API by pointers to application-provided data structures of the appropriate type. Objects from classes with Initialize and Finalize methods must be registered with the driver before they are first used and released before applications release the object memory. Finalizing an object returns that object to the unregistered state. For objects requiring registration, passing a pointer to an unregistered object to any NVN API other than initialization methods is illegal, and can result in application crashes or undefined behavior.</p>
<p>Mutable NVN objects (e.g., builder and render state objects) may be edited by any CPU thread. NVN APIs editing or using mutable objects are not thread safe. Applications should not attempt to edit or use mutable NVN objects concurrently with multiple CPU threads; doing so can result in corruption or application crashes.</p>
<p>Some NVN objects are backed by a GPU memory allocation provided by a memory pool. Prior to releasing a memory pool, applications must ensure that all GPU commands referring to objects with storage provided by the memory pool have completed execution. Using <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">nvn::Queue::Finish</a> or waiting on the completion of a sync object with <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> (after <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a>) will ensure that all previous references to the object made by a queue. If an application has used objects associated with a memory pool with multiple queue objects, it is necessary to wait for completion on all such queues.</p>
<h1><a class="anchor" id="nvn_guide_memory_pools"></a>
3. Memory Pool Objects</h1>
<p>NVN API objects requiring GPU-accessible memory (buffers and textures) are allocated using memory from <b>memory pools</b>, represented by the <a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a> object. Memory pool objects are registered using <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize()</a> and released using <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize()</a>. The following sections are focused on the use of memory pools on the NX platform. The implementation of memory pools on the Windows reference implementation is very similar to that of NX, but there are some significant behavioral differences discussed in a <a href="#nvn_guide_memory_pools_windows">separate subsection</a>.</p>
<p>The properties of a memory pool are specified using an <a class="el" href="classnvn_1_1_memory_pool_builder.html" title="Object specifying state used to construct new memory pool objects.">nvn::MemoryPoolBuilder</a> object passed to <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>. Each memory pool belongs to a device object, programmed by <a class="el" href="classnvn_1_1_memory_pool_builder.html#a496ab03dc6a59d18bd20155db9ff6489" title="Set the Device associated with a MemoryPoolBuilder object.">nvn::MemoryPoolBuilder::SetDevice</a>.</p>
<p>The memory used by the memory pool is programmed in a memory pool builder using <a class="el" href="classnvn_1_1_memory_pool_builder.html#a2101949c9372178c1ed735015461fde5" title="Provides memory to be used by memory pools initialized using a MemoryPoolBuilder.">nvn::MemoryPoolBuilder::SetStorage</a>. The address of the memory is provided by the <code>memory</code> parameter and its size (in bytes) specified by the <code>size</code> parameter. <code>memory</code> must be aligned to a multiple of 4KB, given by the value of <code>NVN_MEMORY_POOL_STORAGE_ALIGNMENT</code>. <code>size</code> must be a multiple of 4KB, given by the value of <code>NVN_MEMORY_POOL_STORAGE_GRANULARITY</code>. On NX, when a memory pool builder is used to initialize a new <a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a> object, the ownership of the memory provided by the <code>memory</code> pointer in the builder is transferred to the memory pool object. Applications should not directly access memory owned by a memory pool object after the pool is initialized. Instead, applications should obtain a CPU pointer to that memory by calling <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map</a>. The memory provided for a memory pool must not be freed or reused by the application until the pool is finalized by <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a>. On NX, applications must provide storage for all memory pools, except for virtual memory pools (discussed below). Memory pool initialization for non-virtual pools will fail if the provided memory pool builder has a NULL <code>memory</code> parameter.</p>
<p>Various other properties of the memory pool are programmed using flags passed to nvn::MemoryPool::SetFlags. In particular, flags are provided to specify how the pool memory is accessed by the CPU and GPU. Applications must set exactly one of the following bits to indicate how pool memory will be accessed by the CPU:</p>
<ul>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a> indicates that pool memory will not be accessed by the CPU. On NX, initializing a memory pool with CPU_NO_ACCESS does not change existing CPU memory mappings and thus will not prevent applications from accessing the pool memory using the pointer provided to <a class="el" href="classnvn_1_1_memory_pool_builder.html#a2101949c9372178c1ed735015461fde5" title="Provides memory to be used by memory pools initialized using a MemoryPoolBuilder.">nvn::MemoryPoolBuilder::SetStorage</a>. On the Windows reference implementation, CPU_NO_ACCESS pools will be stored in video memory that will not be accessible by the CPU. On all platforms, <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map</a> will return NULL for CPU_NO_ACCESS pools.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> indicates that the pool memory will be accessed by the CPU, but not stored in CPU caches. Writing sequentially to pool memory with the CPU will be fast, but reads and non-sequential writes will be slower due to the lack of caching support.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> indicates that the pool memory will be accessed by the CPU and stored in CPU caches. CPU reads and writes will be fast, but applications will need to manually manage cache coherency when pool memory is also accessed by the GPU.</li>
</ul>
<p>Applications must also set exactly one of the following bits to indicate how pool memory is accessed by the GPU:</p>
<ul>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a82454078e08d859b53b6fc954fe955be" title="Indicates that the memory pool will not be accessed by the GPU.">nvn::MemoryPoolFlags::GPU_NO_ACCESS</a> indicates that pool memory will not be accessed by the GPU.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356afb36e42ea7fdd4da445f195ccd641c58" title="Indicates that the memory pool will be accessed by the GPU without caching.">nvn::MemoryPoolFlags::GPU_UNCACHED</a> indicates that the pool memory will be accessed by the GPU, but not stored in GPU caches. Using GPU_UNCACHED memory for resources like textures that will be accessed repeatedly and/or randomly by the GPU will result in poor performance. GPU-uncached memory is useful for single-use command buffers, which can be fetched sequentially by the GPU without contending for space in the GPU caches. GPU-uncached memory may also be useful for one-time writes like counter reports.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b" title="Indicates that the memory pool will be accessed by the GPU with caching.">nvn::MemoryPoolFlags::GPU_CACHED</a> indicates that the pool memory will be accessed by the GPU and stored in GPU caches.</li>
</ul>
<p>Applications may set a number of additional flags specifying special properties of memory pools:</p>
<ul>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1ffdc01c00bf57c8a42913d7600f9233" title="Indicates that the memory pool may be used to store shader code for execution.">nvn::MemoryPoolFlags::SHADER_CODE</a> indicates that pool memory can be used to hold executable shader code.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a> indicates that pool memory can be used to hold textures whose contents can be transparently compressed using hardware framebuffer compression. GPU compression can reduce the bandwidth required to read and write compressible textures, but does not reduce the total amount of storage allocated for a compressible texture. Note that not all portions of a compressible texture will be compressed by the GPU. Compressible memory pools consume slightly more firmware memory than normal memory pools. The compression resources are also finite and can easily be exhausted by creating many small compressible memory pools. For more information, see <a href="#nvn_guide_memory_pools_firmware_memory_usage">Firmware memory usage of memory pools</a>.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a> indicates that the pool contains only physical memory, which can be mapped into GPU-accessible virtual address ranges provided by virtual memory pools.</li>
<li><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a> indicates that the pool has no physical memory and provides only a GPU-accessible virtual address space that can be used to hold buffer and texture resources. Applications manage the address space of virtual memory pools by mapping physical memory pages belonging to physical memory pools into the virtual memory pool's address space.</li>
</ul>
<p>Memory pools created with neither the PHYSICAL nor the VIRTUAL bit set are considered "normal" memory pools. These pools contain both physical memory and GPU virtual address space, where GPU memory mappings managed by the NVN driver.</p>
<p>For the physical and virtual memory pools, there are some additional restrictions on pool usage:</p>
<ul>
<li>Physical memory pools do not have GPU memory mappings and must be created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a82454078e08d859b53b6fc954fe955be" title="Indicates that the memory pool will not be accessed by the GPU.">nvn::MemoryPoolFlags::GPU_NO_ACCESS</a>. On NX, applications must provide memory for all physical pools by providing a non-NULL storage pointer.</li>
<li>Virtual memory pools do not have CPU memory mappings and must be created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a>. Virtual memory pools do not own any memory and must be initialized with a NULL storage pointer.</li>
<li>The size of physical and virtual memory pools must be a multiple of the GPU page size (<a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae49ce57d078023cc8ca0890cd3ee8957" title="Size of memory pages used in physical and virtual memory pools.">nvn::DeviceInfo::MEMORY_POOL_PAGE_SIZE</a>), as described in the <a href="#nvn_guide_memory_mappings">memory mapping section of this guide</a>.</li>
<li>To use compressible textures with physical and virtual memory pools, any physical memory pool providing storage for the texture must be allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a>. The virtual memory pool does not need to be allocated with the COMPRESSIBLE flag, which is ignored for virtual pools.</li>
<li>In the current NVN implementation, shaders may not be run from physical or virtual memory pools. Memory pools with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1ffdc01c00bf57c8a42913d7600f9233" title="Indicates that the memory pool may be used to store shader code for execution.">nvn::MemoryPoolFlags::SHADER_CODE</a> set may not set either <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a> or <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a>.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_memory_mappings"></a>
3.1. GPU Memory Mappings</h2>
<p>When the GPU accesses buffers and textures stored in memory pools, it does so using its own dedicated virtual address space, where GPU virtual addresses are remapped to point at underlying physical memory.</p>
<p><em>Virtual memory pools</em> (created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a>) provide a dedicated virtual address range that the GPU can use to access buffers and textures created from the pool. A virtual memory pool has no associated physical memory, and its virtual address range is initially unpopulated. Pages from <em>physical memory pools</em> (created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a>) can be mapped into the a virtual memory pool's address range using the command <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>. Physical and virtual pools are broken up into a collection of fixed-size <em>pages</em>. The page size is typically 64KB and can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae49ce57d078023cc8ca0890cd3ee8957" title="Size of memory pages used in physical and virtual memory pools.">nvn::DeviceInfo::MEMORY_POOL_PAGE_SIZE</a>.</p>
<p><a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> accepts an array of structures of the type <a class="el" href="structnvn_1_1_mapping_request.html" title="Data structure describing a virtual memory pool mapping request.">nvn::MappingRequest</a> that each describe a single memory mapping to perform. Each mapping request takes a contiguous set of pages in a physical memory pool and maps them into a contiguous range of pages in the virtual memory pool.</p>
<ul>
<li><em>physicalPool</em> identifies the physical memory pool providing memory for the mapping. NULL is allowed and is used to indicate that the virtual memory pages should be unmapped without assigning new physical pages. When non-NULL, <em>physicalPool</em> must identify a memory pool created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a>.</li>
<li><em>physicalOffset</em> identifies the offset of the first mapped page in the physical memory pool, in bytes.</li>
<li><em>virtualOffset</em> identifies the offset of the first mapped page in the virtual memory pool, in bytes.</li>
<li><em>size</em> identifies the size of the new mapping, in bytes.</li>
<li><em>storageClass</em> identifies the special storage class used for the mapping. The storage class must be programmed to match the storage class required for texture or buffer resources using the memory range.</li>
</ul>
<p>The sizes and offsets in each mapping request must be a multiple of the memory pool page size. MapVirtual processes all mapping requests in the provided array before returning to the application. Multiple mapping requests are supported in a single command, which can amortize the fixed overhead involved in setting up new page translations across multiple mappings. When MapVirtual completes, the new GPU virtual address mappings are available for all subsequent commands submitted to queues. MapVirtual does not ensure the completion of previous commands submitted to NVN queues. If the mapping for a page of a virtual memory pool is updated while the GPU is still processing commands using the old memory mappings, the update could lead to corruption or GPU errors. Applications should wait for the completion of previous GPU commands referencing a page of virtual memory using <a href="#nvn_guide_sync">sync objects</a> before changing the physical memory or storage class associated with that virtual page.</p>
<p>Before finalizing physical memory pools, developers must ensure that none of their pages are mapped in any virtual memory pools. This can be achieved either by finalizing such virtual memory pools, or by unmapping the relevant virtual address ranges with MapVirtual.</p>
<p>In its initial state, a virtual memory pool has no physical memory associated with it. If the GPU attempts to access virtual memory pool page with no physical memory on NX or second-generation Maxwell GPU, writes will be discarded and reads will always treat the memory as filled with zero values. On older GPUs on the Windows reference implementation, the driver will map a page of scratch memory into all unpopulated portions of a virtual memory pool. Reads will return undefined values and writes will have no effect other than updating this scratch memory.</p>
<p>Every buffer and texture resource allocated in a virtual memory pool has a required <em>storage class</em> that must be used when establishing memory mappings for the virtual address range containing the resource. When the GPU accesses mapped virtual memory, the storage class associated with the mapping is used to optimize accesses to the mapped physical memory. These optimizations include automatic hardware-based compression of blocks of texels for textures using <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a>. The storage class is an implementation-dependent integer value of the type NVNstorageClass. All buffers, as well as linear and buffer textures, use a single storage class given by the value of the constant <code>NVN_STORAGE_CLASS_BUFFER</code>. For other textures, the required storage class is a function of the texture's format, sample count, and <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> bit, and can be queried using <a class="el" href="classnvn_1_1_texture_builder.html#a30b02de21313a0dbc259bcc58b3b8d13" title="Returns the storage class needed for virtual memory mappings for a texture to be created using the pr...">nvn::TextureBuilder::GetStorageClass</a> (before texture initialization) or <a class="el" href="classnvn_1_1_texture.html#a946b6f25c189cbe85c89c62b2d782872" title="Returns the storage class needed for virtual memory mappings for a Texture object.">nvn::Texture::GetStorageClass</a> (after initialization). When using compressible textures in a virtual memory pool, the physical memory pools providing storage for the texture should be allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a>.</p>
<p>While the storage class is implementation-dependent, the following table can be used to determine if two textures use the same storage class. The format class for a texture can be derived from its format using the <a href="#nvn_guide_formats_table">NVN formats table</a>. If a texture has the COMPRESSIBLE bit set, the "Compressible" column should be consulted; otherwise, the "Non-Compressible" column should be consulted.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format Class   </th><th class="markdownTableHeadNone">Non-Compressible   </th><th class="markdownTableHeadNone">Compressible    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8-bit color (C8)   </td><td class="markdownTableBodyNone">generic color   </td><td class="markdownTableBodyNone">generic color    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">16-bit color (C16)   </td><td class="markdownTableBodyNone">generic color   </td><td class="markdownTableBodyNone">generic color    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32-bit color (C32)   </td><td class="markdownTableBodyNone">generic color   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">64-bit color (C64)   </td><td class="markdownTableBodyNone">generic color   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">128-bit color (C128)   </td><td class="markdownTableBodyNone">generic color   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8-bit stencil (S8)   </td><td class="markdownTableBodyNone">unsupported   </td><td class="markdownTableBodyNone">specific, all sample counts    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16-bit depth (Z16)   </td><td class="markdownTableBodyNone">unsupported   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">32-bit depth/stencil (Z24S8)   </td><td class="markdownTableBodyNone">unsupported   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32-bit depth (Z32)   </td><td class="markdownTableBodyNone">unsupported   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">64-bit depth/stencil (Z32S8)   </td><td class="markdownTableBodyNone">unsupported   </td><td class="markdownTableBodyNone">specific, per sample count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">buffer and linear textures   </td><td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">buffer   </td></tr>
</table>
<p>If the table entry for a texture reads "generic color", the storage class matches any other texture also using "generic color". If the table entry reads "specific, per sample count", the storage class matches only those textures with the same format class and sample count. If the entry reads "specific, all sample counts", the storage class matches only those textures with the same format class, regardless of sample count. For buffer textures (using the target <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a>) and linear textures (created with <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> or <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>), the storage class <code>NVN_STORAGE_CLASS_BUFFER</code> will be used regardless of the format class. Textures using the buffer or generic color storage class will not be compressed by hardware, even if compression is requested by setting the COMPRESSIBLE bit.</p>
<p>When the GPU accesses a texture or buffer, the GPU virtual memory mapping used by the accessed memory must use the storage class required for the texture or buffer. If the virtual memory mapping uses a non-matching storage class, the results of the memory access are undefined and will likely result in GPU errors. Because GPU virtual memory mappings are always aligned to memory pool page boundaries (64KB), textures or buffers using different storage classes must not be allocated in the same page of a virtual memory pool. Textures with different storage classes can share the same page of physical storage if they have separate mappings with the appropriate storage classes. However, sharing the same physical page between resources using buffer and non-buffer storage classes may result in aliasing issues discussed in the <a href="#nvn_guide_memory_pool_aliasing">memory pool aliasing</a> section of this guide.</p>
<p>In addition to physical and virtual memory pools, NVN supports "normal" memory pools allocated with neither the physical (<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a>) nor the virtual (<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a>) flag set. Such memory pools will include both physical memory and GPU virtual address space. The NVN driver will automatically map all of the physical memory belonging to a normal memory pool into the GPU virtual address space when the pool is initialized. When applications create textures using a compressible storage class in normal memory pools (using <a class="el" href="classnvn_1_1_texture.html#ac369f6845c5776de5dbedc84b9191e4c" title="Initialize a texture object from a texture builder using storage provided by a memory pool.">nvn::Texture::Initialize</a>), the driver will automatically remap the physical storage used by the texture in the GPU virtual address space using an appropriate storage class. These memory mappings done during initialization of compressible textures will have overhead similar to calls to <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>; frequent calls should be avoided if possible. Compressible textures stored in normal memory pools should be aligned to memory pool page boundaries and should not share memory with other textures using a different storage class. The values returned by <a class="el" href="classnvn_1_1_texture_builder.html#aaa72b43ff8357a290cf3286c8cb9200d" title="Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the ...">nvn::TextureBuilder::GetStorageAlignment</a> and <a class="el" href="classnvn_1_1_texture_builder.html#a7589199c99ddaf5c78fa2411105cf2ff" title="Returns the amount of memory (in bytes) required to hold a texture to be created using the provided T...">nvn::TextureBuilder::GetStorageSize</a> for such textures will be padded to page boundaries. Normal memory pools do not require applications to determine the storage class for textures and do not allow applications to explicitly control virtual memory mappings using <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>.</p>
<h2><a class="anchor" id="nvn_guide_memory_pool_coherency"></a>
3.2. CPU Access and Coherency</h2>
<p>The memory pool flags govern how the memory belonging to the memory pool may be accessed by application code running on the CPU. For pools using the flags CPU_CACHED or CPU_UNCACHED, the command <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map()</a> may be used to get a pointer to the memory of the pool. Such mappings are persistent; the pointer returned will be valid until the memory pool is deleted. There is no command to unmap the memory of a pool. Pools using the flag CPU_NO_ACCESS may not be mapped; a NULL pointer will be returned by <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map()</a>.</p>
<p>Memory belonging to CPU_UNCACHED pools may be accessed by applications using a pointer returned by <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map()</a>. Such accesses will be coherent with GPU accesses to the memory pool.</p>
<ul>
<li>When an application writes to a CPU_UNCACHED pool with the CPU, the values written will automatically be available to any NVN commands submitted after the CPU write. Any NVN commands submitted to queues prior to the CPU write that have not completed execution may or may not see the values written by the CPU.</li>
<li>When an application reads from a CPU_UNCACHED pool with the CPU, the values returned will reflect the results of any previously submitted NVN commands that have completed execution and have been flushed for CPU access.</li>
</ul>
<p>NVN commands submitting work to the GPU using queues will return to the application before that work is processed by the GPU. <a href="#nvn_guide_sync">Sync objects</a> can be used to determine if previously submitted commands have completed execution on the GPU. To ensure that GPU writes are visible for subsequent CPU accesses, the <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> or <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> command must set the flag <a class="el" href="structnvn_1_1_sync_flag_bits.html#ac1ec0d9eacc08a459d9780280227013ca2fccff48d70ff398363e997420ee7fa5" title="Ensures that all GPU memory transactions performed for commands prior to the fence will be visible to...">nvn::SyncFlagBits::FLUSH_FOR_CPU</a>.</p>
<p>Memory belonging to pools of type CPU_CACHED may also be accessed by applications using a pointer returned by <a class="el" href="classnvn_1_1_memory_pool.html#a8b7eb49d46edd507b8f2858c90ae4af7" title="Returns a CPU pointer to the memory owned by the MemoryPool object.">nvn::MemoryPool::Map()</a>. Such accesses will not be coherent with GPU accesses.</p>
<ul>
<li>When an application writes to a CPU_CACHED pool with the CPU, the values written might not be observed by subsequent GPU commands until the CPU writes are flushed by <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange()</a> or <a class="el" href="classnvn_1_1_buffer.html#a33d9a879a34a17e9328d4c593d817fdd" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU.">nvn::Buffer::FlushMappedRange()</a>.</li>
<li>When an application reads from the memory of a CPU_CACHED pool with the CPU, the values returned may not reflect previous GPU writes until cached CPU memory is invalidated by <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange()</a> or <a class="el" href="classnvn_1_1_buffer.html#ae1c2622cb7e529955750fba45b21a01b" title="Invalidate CPU caches for a range of a buffer that may have been written by the GPU.">nvn::Buffer::InvalidateMappedRange()</a>.</li>
</ul>
<p>For CPU_CACHED pools on NX, the implementation of <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> and <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange</a> uses the operating system function <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> to flush and invalidate CPU cache lines. Calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="Writes the data stored in data cache to memory and then invalidates the pertinent cache line.">nn::os::FlushDataCache</a> directly in application code will have the same effect as calling the NVN FlushMappedRange and InvalidateMappedRange entry points. Note that CPU-cached memory pools on the Windows reference implementation <a href="#nvn_guide_memory_pools_windows">have special semantics</a> that require the use of NVN's FlushMappedRange and InvalidateMappedRange functions. Using operating system services to flush or invalidate cache lines on Windows is insufficient to synchronize the CPU mapping with GPU accesses to the same memory.</p>
<p>The NX device is not I/O-coherent, so care must be taken to avoid overlapping cached memory regions where the CPU and GPU may be performing unserialized accesses. Note that while the size of CPU cache lines is 64 bytes on the NX device, the size of a GPU cache line is 128 bytes. If an application defines adjacent cached memory ranges for unserialized access by the CPU and GPU, the boundary between the two ranges should be aligned to 128 bytes to avoid possible data corruption.</p>
<h2><a class="anchor" id="nvn_guide_memory_pool_aliasing"></a>
3.3. Memory Pool Aliasing</h2>
<p>Buffer and texture objects are created by specifying a memory pool and offset in the pool. The NVN API does not prohibit applications from specifying buffers or textures that overlap in memory. However, there are significant limitations on memory aliasing that applications must obey.</p>
<p>When an application uses a page of a physical memory pool in a virtual mapping with a compressible storage class, the GPU compression hardware may store texels in the physical memory using a compressed form specific to the storage class. Additional compression-related information for that page may be stored in other on-chip resources. If the same physical storage is then used in a virtual memory mapping using a different storage class, reads from the second mapping will return undefined values and could also result in GPU errors. When using a single physical memory page in multiple virtual mappings with different compressible storage classes, applications must ensure that the GPU accesses only one mapping at a time. To do so, applications should wait on the completion of commands using the old mapping using <a href="#nvn_guide_sync">synchronization objects</a> or insert <a href="#nvn_guide_barriers">barriers</a> between commands using the old and new mapping. Additionally, before using a new mapping of a potentially compressed memory page, the application must clear the memory using <a class="el" href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f" title="Clear a color buffer using floating-point clear color values.">nvn::CommandBuffer::ClearColor</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a9a0f6d9771cdf2c4d2ec99fcbc366640" title="Clear a depth/stencil buffer.">nvn::CommandBuffer::ClearDepthStencil</a>. Accessing the new memory mapping without a clear could cause the GPU to interpret the memory using the old storage class and result in undefined behavior and possible GPU errors.</p>
<p>Additionally, for textures with storage classes other than <code>NVN_STORAGE_CLASS_BUFFER</code>, the GPU memory subsystem rearranges the contents of the texture in its physical memory pages for optimal texture access. This transformation can cause the addresses used by a texture and a buffer in the same physical page to collide, even if their nominal virtual address ranges within the page don't overlap. Applications must not place buffer and texture resources within the same 4KB-aligned range of any physical memory page. If this rule is violated, writes to the buffer could overwrite portions of the texture and vice versa.</p>
<p>When textures overlap in physical memory, the following conditions must all be satisfied for correct access:</p>
<ul>
<li>they are both compressible or both non-compressible;</li>
<li>they have the same format;</li>
<li>they have the same storage class.</li>
</ul>
<p>It does not matter here if both textures are in different virtual pools or in different ranges of the same virtual pool.</p>
<p>If textures A and B are compressible and have different formats but use the same storage class, clearing A and then reading B will always produce consistent results. For example, if A had a format of RF32 and it is cleared to 1.0 (0x3f80000) and B had a format of RGBA8UI, reading through B will produce (0x00, 0x00, 0x80, 0x3F).</p>
<p>All compressible textures that share the same physical page of a non-virtual memory pool must use the same storage class. Failure to adhere to this rule can cause unpredictable results, including GPU exceptions. The storage class for the memory pages used by such textures is needed for efficient compression by the hardware and is established when the texture object is created. If texture B is created in a memory pool range already occupied by texture A, texture B will update the overlapping area of memory to use its storage class. Any subsequent accesses to texture A will now produce erroneous texels and may result in GPU errors if the format of texture A is incompatible with the new storage class for texture B.</p>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: When using NVIDIA GPUs prior to the second generation of the Maxwell GPU family (GeForce GTX 960 and above) on the Windows reference implementation, an application must not place textures and buffers within the same **64**KB-aligned range of the pool. </p>
</blockquote>
<p>On the NX device, each storage class also has an associated <em>raw storage class</em> that is used to perform format-specific optimizations when the GPU's L2 cache reads data from or writes data to main memory. These transformations of the data loaded from or stored to memory are performed even for non-compressible storage classes. The raw storage classes associated with a texture can be queried with <a class="el" href="classnvn_1_1_texture.html#a563f5d557ee354b06bdb640ffc3c05c4" title="Query the raw storage class associated with this Texture object.">nvn::Texture::GetRawStorageClass</a> and <a class="el" href="classnvn_1_1_texture_builder.html#a09b99eb88195e9e73d0fa6dfc38aa78f" title="Query the raw storage class associated with this TextureBuilder object.">nvn::TextureBuilder::GetRawStorageClass</a>. Buffer objects, buffer textures, and linear textures always have a raw storage class of <a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfa28ff8009c9cb9070985c288f07087aed" title="Raw storage class used for linear and buffer textures and Buffer objects.">nvn::RawStorageClass::LINEAR</a>. The full set of raw storage classes is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Raw Storage Class   </th><th class="markdownTableHeadNone">Uses    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfaf35eb13a52df91dbe1daf7249b5106c7" title="No raw storage class.">nvn::RawStorageClass::NONE</a>   </td><td class="markdownTableBodyNone">Textures with no valid format (<a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aecf603ba72eafffa746f230c20cc707d" title="Placeholder enum indicating no defined format; never valid.">nvn::Format::NONE</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfa28ff8009c9cb9070985c288f07087aed" title="Raw storage class used for linear and buffer textures and Buffer objects.">nvn::RawStorageClass::LINEAR</a>   </td><td class="markdownTableBodyNone">Buffer objects, buffer textures, linear textures    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfa0d2fe89eae0d212f3410a4d45d1e0831" title="Raw storage class used for textures (other than linear and buffer textures) using any color texture f...">nvn::RawStorageClass::COLOR_AND_ZF32</a>   </td><td class="markdownTableBodyNone">Textures using any color format or <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfa5017665c7963dabad984fa2a05e864ba" title="Raw storage class used for textures (other than linear and buffer textures) using Format::STENCIL8 or...">nvn::RawStorageClass::S8_AND_Z16</a>   </td><td class="markdownTableBodyNone">Textures using <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a> or <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component.">nvn::Format::DEPTH16</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfadda5a48f8b454b52814e0a4a75aec8d2" title="Raw storage class used for textures (other than linear and buffer textures) using Format::DEPTH24 or ...">nvn::RawStorageClass::Z24_AND_Z24S8</a>   </td><td class="markdownTableBodyNone">Textures using <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a74df5a03a4702521794089f23c4f364b" title="A 24-bit unsigned normalized depth component in the LSBs of a 32-bit word.">nvn::Format::DEPTH24</a> or <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9745a145c841e60ff50d7a0fe0469e1f" title="A 24-bit unsigned normalized depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH24_STENCIL8</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_raw_storage_class.html#a224336d95fd6e0635404da805d0ab9cfa7fceff75c167b89156d5163138916f0d" title="Raw storage class used for textures (other than linear and buffer textures) using Format::DEPTH32F_ST...">nvn::RawStorageClass::ZF32S8</a>   </td><td class="markdownTableBodyNone">Textures using <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57b3319d5b05a91d1599dfbbf4edc924" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH32F_STENCIL8</a>   </td></tr>
</table>
<p>When any portion of a physical memory page is shared by resources (buffers or textures) requiring different raw storage classes, applications must ensure that the GPU accesses only one resource at a time. Additionally, before reusing the physical memory with a new raw storage class, applications must first ensure that the GPU's L2 cache is invalidated. If the L2 cache contains an active cache line using the old raw storage class, and that cache line is later overwritten using the new raw storage class, the new data could be incorrectly written to main memory using the format-specific optimizations for the old raw storage class. The L2 cache can be invalidated manually using the command <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">nvn::CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aa9b1e43aeb830c6a60bfdca764d8ac5f" title="Invalidates the L2 cache.">nvn::BarrierBits::INVALIDATE_L2_CACHE</a> bit set. Additionally, whenever commands submitted to a queue are flushed for processing by the GPU, NVN will automatically invalidate the L2 cache before any of the new commands are processed by the GPU. Manual invalidation is required whenever the commands submitted in a single queue flush use two resources with incompatible raw storage classes that share the same physical memory.</p>
<blockquote class="doxtable">
<p><b>PERFORMANCE NOTE</b>: Cache invalidations using <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aa9b1e43aeb830c6a60bfdca764d8ac5f" title="Invalidates the L2 cache.">nvn::BarrierBits::INVALIDATE_L2_CACHE</a> perform a wait-for-idle operation and invalidate the GPU's L2 cache. This is an expensive operation and should only be done if required. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: On the Windows reference implementation, raw storage classes have no effect on the data written to main memory. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_resource_alignment"></a>
3.4. Memory Resource Alignment</h2>
<p>When using buffers, textures, or other resources created from memory pools, the memory used by the GPU often needs to be aligned according to GPU hardware requirements. The minimum required alignment for a resource is a function of how the resource is used.</p>
<p>When creating a buffer or texture resource, applications specify an offset relative to the base address of the memory pool. Additionally, when using a buffer resource, applications can add an additional offset into the buffer address (<a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a>) or specify an additional offset relative to the base of the buffer object. The sum of these offsets must be a multiple of the required alignment value in the table below. Since the GPU mappings of memory pools are always aligned to GPU page boundaries, the base address of the pool has no effect on the final alignment of resources created from the pool.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Resource Usage   </th><th class="markdownTableHeadNone">Required Alignment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Vertex buffer   </td><td class="markdownTableBodyNone">format-specific, 1B to 4B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Index buffer   </td><td class="markdownTableBodyNone">index size, 1B to 4B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Uniform buffer   </td><td class="markdownTableBodyNone">256B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Shader Storage buffer   </td><td class="markdownTableBodyNone">shader usage-specific, 1B to 32B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bindless buffer access   </td><td class="markdownTableBodyNone">shader usage-specific, 1B to 32B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Transform feedback data buffer   </td><td class="markdownTableBodyNone">4B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Transform feedback control buffer   </td><td class="markdownTableBodyNone">4B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Indirect draw buffer   </td><td class="markdownTableBodyNone">4B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Counter reports   </td><td class="markdownTableBodyNone">16B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Buffer textures, most cases   </td><td class="markdownTableBodyNone">format-specific, 1B to 16B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linear textures   </td><td class="markdownTableBodyNone">32B-128B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">All other textures   </td><td class="markdownTableBodyNone">512B minimum    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Shader code (<a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>)   </td><td class="markdownTableBodyNone">256B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Command buffer, used as command memory   </td><td class="markdownTableBodyNone">4B    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Command buffer, used as control memory   </td><td class="markdownTableBodyNone">8B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Buffer memory for copy commands   </td><td class="markdownTableBodyNone">none (1B)   </td></tr>
</table>
<p>For vertex attributes, the address used to fetch values from memory is computed by adding:</p>
<ul>
<li>the base address of the memory pool holding the bound Buffer</li>
<li>the offset of the bound Buffer</li>
<li>the offset relative to the bound Buffer specified in the binding</li>
<li><em>x</em> times the stride specified for the buffer binding point, where <em>x</em> is the vertex (or instance) index</li>
<li>the offset of the attribute relative to its buffer binding</li>
</ul>
<p>For vertex attribute formats with 8-, 16-, or 32-bit components, the address must be a multiple of the component size (1, 2, or 4 bytes) for all values of <em>x</em>. For packed vertex attribute formats, the address must be a multiple of the packed word size.</p>
<p>For index buffers, the required alignment must be 1, 2, or 4 bytes, depending on the index type specified in the draw call.</p>
<p>For shader storage buffers, the base address of the bound buffer must be aligned to ensure that every member of the storage block using the buffer is aligned to its minimum alignment requirement. The minimum alignment requirements for data types in NVN are:</p>
<ul>
<li>32 bytes, for 3- or 4-component vectors with 64-bit components, or double-precision matrix types with columns or rows stored using such vectors;</li>
<li>16 bytes, for 3- or 4-component vectors with 32-bit components, 2-component vectors with 64-bit components, or matrix types with columns or rows stored using such vectors;</li>
<li>8 bytes, for 3- or 4-component vectors with 16-bit components, 2-component vectors with 32-bit components, 64-bit scalar types, or matrices of type <code>mat2</code>;</li>
<li>4 bytes, for 3- or 4-component vectors with 8-bit components, 2-component vectors with 16-bit components, or 32-bit scalar types'</li>
<li>2 bytes, for 2-component vectors with 8-bit components or 16-bit scalar types;</li>
<li>1 byte, for 8-bit scalar types.</li>
</ul>
<p>These requirements are equivalent to similar alignment requirements documented in the OpenGL Specification.</p>
<p>For bindless buffer accesses using GPU pointers, the pointers used must be aligned so that all data types accessed using the pointer are aligned to their minimum required alignments, as documented above. Bindless memory accesses using GPU pointers in GLSL shaders are supported via the <a href="https://www.opengl.org/registry/specs/NV/shader_buffer_load.txt">NV_shader_buffer_load</a> and <a href="https://www.opengl.org/registry/specs/NV/shader_buffer_store.txt">NV_shader_buffer_store</a> extensions. GPU pointers used in shaders should be initialized with <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a> values computed using base buffer addresses returned by <a class="el" href="classnvn_1_1_buffer.html#a470e8ee3cdf0bc1c369dc0a936f70807" title="Query the GPU address of the data store of a buffer object.">nvn::Buffer::GetAddress()</a>.</p>
<p>For buffer textures (using a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a>), the required alignment for textures with a format of <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a821c14e8dec351b783ac10e6b69d47fb" title="Three 32-bit floating-point components.">nvn::Format::RGB32F</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2557ddb79e33e7b2b07d571dba77248e" title="Three 32-bit unsigned integer components.">nvn::Format::RGB32UI</a>, or Format::RGB32I is 4 bytes. For all other formats, the required alignment is the size (in bytes) of a single texel (1, 2, 4, 8, or 16 bytes).</p>
<p>For linear render targets (created using <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>), the required alignment for the texture is given by the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da61c146cbc11a83d809d4235911070188" title="Minimum alignment required for stride in linear render targets, in bytes.">nvn::DeviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT</a> (128B). For other linear textures (created using <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a>), the required alignment is given by the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab372d74472a67ab624b370707234a0bf" title="Minimum alignment required for stride in linear textures, in bytes.">nvn::DeviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT</a> (32B).</p>
<p>For non-buffer and non-linear textures, the minimum alignment is at least 512B. When a texture is compressible (using <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a>), its virtual mapping may require a special storage class that prevents it from sharing a memory page with other textures. For such textures, the alignment and total size can be padded to the GPU memory pool page size (64KB) to isolate the texture from other allocations. The required alignment for all textures can be queried from the NVN implementation by calling <a class="el" href="classnvn_1_1_texture_builder.html#aaa72b43ff8357a290cf3286c8cb9200d" title="Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the ...">nvn::TextureBuilder::GetStorageAlignment</a>. As mentioned in the <a href="#nvn_guide_memory_pool_aliasing">memory pool aliasing section</a>, such textures may not share a 4KB-aligned range of a physical memory page with buffers.</p>
<p>For copy commands (<a class="el" href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924" title="Schedule a copy of data from one Buffer object into another Buffer object.">nvn::CommandBuffer::CopyBufferToBuffer</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a>), there are no alignment requirements on the buffer addresses used for the source and/or destination of the copy.</p>
<h2><a class="anchor" id="nvn_guide_memory_pools_windows"></a>
3.5. Memory Pools on Windows</h2>
<p>Support for memory pools on the Windows reference implementation has a number of significant differences from the support on NX. NX has a unified memory architecture where the same memory used for regular CPU accesses is also used for GPU accesses. The Windows reference implementation uses discrete GPUs that can access CPU-accessible memory but also have their own dedicated video memory. The memory used by NVN memory pools depends on the memory pool flags provided when the memory pool is initialized:</p>
<ul>
<li>Physical memory pools (created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a>) are created using high-performance GPU video memory and have no CPU-accessible memory mapping.</li>
<li>Virtual memory pools (created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a>) have no associated physical memory. Since virtual memory pools can only be populated with memory from physical memory pools, all resources stored in virtual memory pools will use GPU video memory.</li>
<li>Regular (non-physical, non-virtual) memory pools are allocated according to CPU access flags:<ul>
<li>Memory pools created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a> are created using GPU video memory and have no CPU-accessible mapping.</li>
<li>Memory pools created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> are created using driver-allocated system memory and can be accessed directly by both the CPU and GPU. CPU mappings for this memory support CPU write combining but will not be cached by the CPU. Sequential writes to such pools using the CPU will be fast, but random-access writes and all reads will be slower due to the lack of caching.</li>
<li>Memory pools created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> are created with two separate memory allocations. All GPU accesses are performed using a dedicated GPU video memory allocation. A second copy of the memory pool allocated in cached system memory will be used for CPU reads and writes. The two copies of the memory pool may be synchronized using the commands <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> and <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange</a>.</li>
</ul>
</li>
</ul>
<p>Because most memory pools use GPU video memory, the amount of memory available for NVN memory pools on Windows is limited by the amount of physical video memory attached to the GPU. <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a> may return NVN_FALSE if the video memory on the discrete GPU is exhausted. Reducing the size of the memory pool and/or shutting down other applications that consume video memory may resolve this error.</p>
<p>The storage for all memory pools on Windows will be allocated by the driver. NVN will not use the memory passed to <a class="el" href="classnvn_1_1_memory_pool_builder.html#a2101949c9372178c1ed735015461fde5" title="Provides memory to be used by memory pools initialized using a MemoryPoolBuilder.">nvn::MemoryPoolBuilder::SetStorage</a> after a memory pool is initialized. If a memory pool is initialized with a NULL storage pointer, the contents of the allocated memory pool will be uninitialized. If a non-NULL storage pointer is provided, the contents of the allocated memory pool are initialized by copying the <code>size</code> bytes pointed to by <code>memory</code>. On Windows, applications may free any memory passed to <a class="el" href="classnvn_1_1_memory_pool_builder.html#a2101949c9372178c1ed735015461fde5" title="Provides memory to be used by memory pools initialized using a MemoryPoolBuilder.">nvn::MemoryPoolBuilder::SetStorage</a> after <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>. However, on NX, this memory may not be freed or reused until the pool is finalized.</p>
<h3><a class="anchor" id="autotoc_md64"></a>
CPU-Cached Memory Pools</h3>
<p>On the Windows reference implementation, memory pools allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> contain two separate memory allocations. The copy in GPU video memory is used for all GPU accesses. The copy in CPU-accessible system memory is treated as a cache, which needs to be manually flushed and invalidated via <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> and <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange</a> as required.</p>
<p>In this implementation, <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> copies the specified range of the memory pool from the system memory allocation to the video memory allocation. <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange</a> copies the specified range of the memory pool from the video memory allocation to the system memory allocation. If one portion of such a range has been modified by the CPU and another portion has been modified by the GPU, FlushMappedRange will overwrite data written by the GPU and InvalidateMappedRange will overwrite data written by the CPU.</p>
<p>Textures using non-buffer storage classes in CPU-cached pools will be stored in the video memory allocation using an opaque GPU-optimized form that can not be easily interpreted by the CPU. Calling FlushMappedRange on a range containing such textures will corrupt the contents in the video memory allocation. Calling InvalidateMappedRange will overwrite the system memory allocation with scrambled data. Additionally, the destination of copies performed by FlushMappedRange will be treated as a buffer resource, whose storage may collide with and corrupt any non-buffer textures found in the same 4KB or 64KB-aligned memory pool range, as discussed in the <a href="#nvn_guide_memory_pool_aliasing">memory pool aliasing section of this guide</a>.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
CPU-Uncached Memory Pools</h3>
<p>On the Windows reference implementation, memory pools using the CPU access type CPU_UNCACHED are created using system memory and have a single GPU mapping using the buffer storage class. As a result, textures using non-buffer storage classes are not supported in uncached memory pools. Only buffer textures (<a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a>) and linear textures (<a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> or <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>) may be allocated from a CPU_UNCACHED pool.</p>
<p>Additionally, memory mappings performed for virtual memory pools on the Windows reference implementation require physical storage in GPU video memory. As a result, physical memory pools created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">nvn::MemoryPoolFlags::PHYSICAL</a> may not be allocated with the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> bit set.</p>
<h3><a class="anchor" id="autotoc_md66"></a>
Virtual Memory Pools</h3>
<p>On the Windows reference implementation, second-generation Maxwell GPUs provide dedicated hardware support for GPU accesses to unpopulated portions of a virtual memory pool, where reads will return zero and writes will be discarded. On older GPUs, no such support is provided, and the driver will instead map a page of scratch memory into all unpopulated portions of a virtual memory pool. On these platforms, reads will return undefined values and writes will have no effect other than updating this scratch memory. Applications can query the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da658ee81bd14e3f5446fc499046677789" title="1 if the implementation always returns zero values when reading from unpopulated portions of virtual ...">nvn::DeviceInfo::SUPPORTS_ZERO_FROM_UNMAPPED_VIRTUAL_POOL_PAGES</a> to determine if hardware support for accessing unpopulated portions of a virtual pool is provided (if the property is 1) or simulated via scratch memory (0).</p>
<h3><a class="anchor" id="autotoc_md67"></a>
Packaged Resource Sets</h3>
<p>With the availability of the <a href="#nvn_guide_packaged_texture_data">NVN texture packager</a>, applications can be written for NX that assemble large blocks of memory containing both buffer and texture resources. Such "resource sets" can be used by loading the entire block into memory and then setting up texture and buffer objects that point to appropriate subsets of the block. The assembly of these resource sets must account for <a href="#nvn_guide_resource_alignment">alignment requirements</a> and avoid storing texture and buffer resources in the same <a href="#nvn_guide_memory_pool_aliasing">4KB-aligned pool ranges</a>, but impose no other requirements on applications. The Windows reference implementation has several architectural details that make the use of NX resource sets more difficult:</p>
<ul>
<li>The GPU-optimized representation produced by the NVN texture packager for non-buffer textures on NX does not match the optimized representations used by GPUs on the Windows reference implementation.</li>
<li>On GPUs older than second-generation Maxwell GPUs, textures and buffer resources can not be stored in the same 64KB-aligned pool range. NX and second-generation Maxwell GPUs only restrict such resources to smaller 4KB-aligned ranges.</li>
<li>The copies used to implement <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> on Windows are buffer copies. Performing a copy using FlushMappedRange will write garbage data to portions of the flushed range containing non-buffer textures. Additionally, such writes could corrupt other non-buffer textures in the same 4KB- or 64KB-aligned range of the memory pool, even if the nominal address range used by such textures does not overlap the flushed range.</li>
</ul>
<p>Developers wishing to use identical code to load packaged resource sets on both NX and the Windows reference implementation can take the following steps:</p>
<ul>
<li>If application code must support older GPUs on Windows, the resource set must be packaged to avoid placing buffer resources and non-buffer texture resources in the same 64KB-aligned range of the resource set.</li>
<li>Applications should allocate and copy the memory of the resource set into a CPU_CACHED memory pool, since non-buffer textures are not supported in CPU_UNCACHED pools on Windows.</li>
<li>After loading the resource set into CPU-accessible pool memory, applications can call FlushMappedRange once to flush the entire pool. On NX, this will simply flush the CPU caches. On the Windows reference implementation, this will copy the contents of the resource set to the video memory copy of the pool. The portions of the video memory copy containing buffer data will be copied correctly. The portions of the video memory copy containing non-buffer texture data will hold garbage data, which can be fixed for packaged texture data when setting up texture objects using the resource set. The system memory copy will remain in the original NX-friendly form.</li>
<li>When setting up texture objects for the non-buffer textures in the resource set, applications should call <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a> to point at the packaged texture data in the loaded resource set. On NX, SetPackagedTextureData has no effect. On Windows, a non-NULL packaged texture data pointer will cause the NVN driver to schedule GPU copies that read from the NX-optimized texture data in the original system memory copy and write the texels to video memory using an optimized form appropriate to the GPU being used.</li>
<li>After using SetPackagedTextureData to initialize textures in the resource set, applications should be careful when flushing portions of the memory pool containing non-buffer textures, since redundant flushes could corrupt textures in the flushed range and possibly corrupt neighboring textures outside the flushed range.</li>
</ul>
<h1><a class="anchor" id="nvn_guide_buffers"></a>
4. Buffer Objects</h1>
<p>The <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a> object represents a block of memory that can be read or written by fixed-function units on the GPU as well as programmable shaders, with a variety of different uses:</p>
<ul>
<li>fetching vertex attribute values describing the attributes of a vertex in a primitive to be rendered;</li>
<li>fetching index values describing the topology of a primitive to be rendered;</li>
<li>fetching indirect draw structures describing an entire primitive to be rendered;</li>
<li>fetching uniform values in a programmable shader;</li>
<li>performing random-access reads and writes to memory in a programmable shader;</li>
<li>storing control information or vertex data when capturing transformed primitives prior to primitive assembly and rasterization;</li>
<li>reporting the values of GPU hardware counters;</li>
<li>fetching programable shader code loaded into buffer memory;</li>
<li>copying data between buffers;</li>
<li>copying data to upload or download a texture image.</li>
</ul>
<p>To create a new buffer, applications should specify the parameters describing the buffer using the <a class="el" href="classnvn_1_1_buffer_builder.html" title="Object specifying state used to construct new buffer objects.">nvn::BufferBuilder</a> class and then use the buffer builder to initialize the <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a> object using <a class="el" href="classnvn_1_1_buffer.html#a9cddfdbd6a339b5d12602b27401f6550" title="Initialize a new buffer object from a buffer builder.">nvn::Buffer::Initialize</a>. Buffer objects are created using a range of the storage from a memory pool, which is specified in the buffer builder using <a class="el" href="classnvn_1_1_buffer_builder.html#a017e4d5974bf2b4687ec70658afd8857" title="Set the range of a MemoryPool used for a Buffer object created from the BufferBuilder.">nvn::BufferBuilder::SetStorage</a>.</p>
<p>While a buffer object can be accessed by the GPU in a variety of ways, it can also be accessed by the CPU unless created from a pool allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a>. CPU mappings of buffer objects and the set of operations required to keep CPU and GPU views of the memory consistent are discussed in more detail in the <a href="#nvn_guide_memory_pools">memory pool section of this guide</a>.</p>
<h1><a class="anchor" id="nvn_guide_textures"></a>
5. Texture Objects</h1>
<p>The <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object, together with the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> object, is used by programmable shaders to access the contents of images stored in memory and use the image data when rendering primitives.</p>
<h2><a class="anchor" id="nvn_guide_texture_initilization"></a>
5.1. Texture Initialization</h2>
<p>To create a new texture, applications should specify the parameters describing the full texture allocation using the <a class="el" href="classnvn_1_1_texture_builder.html" title="Object specifying state used to construct new texture objects.">nvn::TextureBuilder</a> class and then use the texture builder to initialize the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object using <a class="el" href="classnvn_1_1_texture.html#ac369f6845c5776de5dbedc84b9191e4c" title="Initialize a texture object from a texture builder using storage provided by a memory pool.">nvn::Texture::Initialize</a>.</p>
<p>NVN supports a number of different types of texture objects. The type of the texture, also called the <em>texture target</em> can be specified using <a class="el" href="classnvn_1_1_texture_builder.html#ab6737d358f37898135592922d86e3100" title="Set the target (texture type) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetTarget</a>. The supported targets are as follows:</p>
<ul>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a2df223e19709155c2986ab25c341e01a" title="One-dimensional texture.">nvn::TextureTarget::TARGET_1D</a>, <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8c499dff06e2171624572ec97051b75c" title="Two-dimensional texture.">nvn::TextureTarget::TARGET_2D</a>, and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86ab113a9348993bfbcc81eaf36dad73ae6" title="Three-dimensional texture.">nvn::TextureTarget::TARGET_3D</a> specify one-, two-, and three-dimensional images that can be sampled in GLSL shaders using normalized texture coordinates. (Normalized coordinates use the value 0.0 to indicate one edge of the texture image and 1.0 to indicate the opposite edge.) Mipmapping (a set of images with multiple resolutions), filtering the values of multiple texels in a computed footprint, and a full set of coordinate wrap modes are supported for these targets.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86af8292b0591c18d9b82cd66ed06d6e34c" title="Array of one-dimensional textures.">nvn::TextureTarget::TARGET_1D_ARRAY</a> and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86ab30b71fec0699e9a966e3c06a42b6487" title="Array of two-dimensional textures.">nvn::TextureTarget::TARGET_2D_ARRAY</a> specify arrays of one-, and two-dimensional images that can be sampled in GLSL shaders using normalized texture coordinates. These textures are made up of a collection of independent images, with each image being referred to as a separate <em>layer</em>. The number of layers in the array is given by the height (TARGET_1D_ARRAY) or depth (TARGET_2D_ARRAY) in the texture builder. Mipmapping, texture filtering, and a full set of coordinate wrap modes are supported. Filtering is supported within a single texture layer, but array textures do not support filtering between layers.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8fca32f85ac2fdb4850903b5f5f9078d" title="Two-dimensional texture, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE</a> specifies a two-dimensional image where each pixel is holds an array of <em>samples</em>. Mipmapping, texture filtering, and coordinate wrap modes are not supported. Multisample textures may only be accessed a sample at a time using the <code>texelFetch</code> GLSL built-in function.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86adae55e7e5918dcaf98121d6cc5816003" title="Array of two-dimensional textures, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE_ARRAY</a> specifies an array of two-dimensional multisample images, with each pixel holding an array of samples. The number of layers in the array is given by the depth in the texture builder. As with TARGET_2D_MULTISAMPLE, these textures may only be accessed a sample at a time in shaders using the <code>texelFetch</code> GLSL built-in function.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a505a74176236dd724a336accb9fafd3c" title="Two-dimensional texture, accessed with non-normalized coordinates.">nvn::TextureTarget::TARGET_RECTANGLE</a> specifies a two-dimensional image that can be sampled in GLSL shaders using non-normalized texture coordinates. If the texture is of size <em>w</em> x <em>h</em>, the coordinate (0,0) refers to the origin in one corner of the texture and (w,h) refers to the opposite corner. Rectangle textures do not support mipmapping, but do support filtering. Wrap modes that clamp at the edge of textures are supported, but modes that wrap to the other side of the texture are not.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a17c2bd47992f9b52df6d0bbd30579e69" title="Cube map texture, with six two-dimensional cube faces.">nvn::TextureTarget::TARGET_CUBEMAP</a> specifies an array of six two-dimensional images arranged in a cube, accessed in GLSL shaders using three-dimensional texture coordinates. The coordinates are projected onto one of the six cube faces and are used to access texels in that face. Mipmapping and filtering are supported, including filtering between faces near the edges and corners where cube faces meet. All cube faces must be square, where the width and height programmed in the texture builder are equal.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86afc724c2360384d08d04ac183015edcf2" title="Array of cube map textures, each with six two-dimensional cube faces.">nvn::TextureTarget::TARGET_CUBEMAP_ARRAY</a> specifies an array of cube map images. The width and height in the texture builder specify the size of each cube face. The depth in the texture builder specifies the total number of cube faces in the array, which must be a multiple of six. When used as a texture, the number of layers is given by the number of faces divided by six. Mipmapping and filtering are supported in the same manner as cube maps, with filtering supported only within a single cube layer (set of six faces) as with other array textures.</li>
<li><a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a> specifies a one-dimensional image that can be sampled with the <code>texelFetch</code> built-in function. Mipmapping, filtering between texels, and wrap modes are not supported. Unlike other texture targets, buffer textures are stored in linear arrays in memory and can share the same memory with buffer objects.</li>
</ul>
<p>The size of the texture to initialize is specified with <a class="el" href="classnvn_1_1_texture_builder.html#adbe7f1ed9dd0cb0407e0a9c413d378aa" title="Set the width (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetWidth</a>, <a class="el" href="classnvn_1_1_texture_builder.html#ac3a6536d81e3b3cf98b739ec65ac170d" title="Set the height (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetHeight</a>, and <a class="el" href="classnvn_1_1_texture_builder.html#ad247335f10a8df2769ac732d0e3ebfa9" title="Set the depth (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetDepth</a>. Additionally, the size for multiple dimensions of the texture may be specified in a single call using <a class="el" href="classnvn_1_1_texture_builder.html#a9baabe01a3ced0a5503d65c5c3aa6862" title="Set the width (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSize1D</a>, <a class="el" href="classnvn_1_1_texture_builder.html#abaecc090ee735b91a11ff491ee304df4" title="Set the width and height (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSize2D</a>, and <a class="el" href="classnvn_1_1_texture_builder.html#a442fc2837a8d1ca3699b381bdd6ce086" title="Set the width, height, and depth (in texels) for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSize3D</a>.</p>
<p>For nvn::TextureTarget::TEXTURE_CUBEMAP and nvn::TextureTarget::TEXTURE_CUBEMAP_ARRAY targets, the six images are treated as forming an axis-aligned cube. Each (x,y,z) coordinate in a three-dimensional coordinate system is projected onto one of the six cube map faces according to the component with the largest magnitude. The order of the cube faces in the six images is defined in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Face Number   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">positive X face, covering areas where +x &gt; max(abs(y), abs(z))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">negative X face, covering areas where -x &gt; max(abs(y), abs(z))    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">positive Y face, covering areas where +y &gt; max(abs(x), abs(z))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">negative Y face, covering areas where -y &gt; max(abs(x), abs(z))    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">positive Z face, covering areas where +z &gt; max(abs(x), abs(y))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">negative Z face, covering areas where -z &gt; max(abs(x), abs(y))   </td></tr>
</table>
<p>For multisample texture targets, the number of samples stored in each texel is specified using <a class="el" href="classnvn_1_1_texture_builder.html#a4ee76a7901a4b6af384922d288de1c71" title="Set the sample count for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSamples</a>. Sample counts of 2, 4, and 8 are supported.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: On the second-generation Maxwell GPUs and NX, multisample textures with a format of <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a> support sample counts of 16. This is not well-supported in the current implementation of the API, but is expected to be supported in a future version. </p>
</blockquote>
<p>For texture targets supporting mipmapping, the texture is made up of multiple <em>mipmap levels</em> of decreasing size. For example, if a two-dimensional texture with a size of 256x256 has a full set of mipmaps, it will also contain lower-resolution images with sizes of 128x128, 64x64, 32x32, 16x16, 8x8, 4x4, 2x2, and 1x1. The number of mipmap levels for a texture is specified using <a class="el" href="classnvn_1_1_texture_builder.html#ab7d8c1e46f91da76175d700f8d4a8008" title="Set the number of mipmap levels for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetLevels</a>. The number of levels must be in the range [1, 1 + floor(log<sub>2</sub> <em>max_size</em>)], where <em>max_size</em> is the largest dimension of the texture. Textures with a level count of 1 include only a single level, and textures with targets not supporting mipmapping must have a level count of 1.</p>
<p>The format of the texture specifies how the individual texels in memory are used to produce color values when fetched, and is specified using <a class="el" href="classnvn_1_1_texture_builder.html#af96a628821f8cdc4c0fd5bf18dad16c0" title="Set the Format for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetFormat</a>. Formats are discussed in more detail <a href="#nvn_guide_formats">later in this document</a>.</p>
<p>When performing texture lookups, individual texel values or filtered results are converted from their format to a canonical four-component (R,G,B,A) vector in a fixed manner described in the formats section. Additionally, a texture may be configured to produce a final (R,G,B,A) vector from the original vector using <em>texture swizzles</em> programmed via <a class="el" href="classnvn_1_1_texture_builder.html#a345a8121dd0c0087c058226663126eac" title="Set the texture swizzle for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSwizzle</a>. Each component of the final vector can be selected from the original (R,G,B,A) or from the constant values 0 and 1. For example, NVN does not support texture formats like "BGRA8", where blue is stored in the least signficant bits of a 32-bit texel, and alpha is stored in the most significant bits. To use BGRA8 texel data without additional conversions, the texture can be programmed using an RGBA8 format and a texture swizzle that swaps the R and B components, as follows: </p><pre class="fragment">nvn::TextureBuilder tb;
tb.SetFormat(nvn::Format::RGBA8);
tb.SetSwizzle(nvn::TextureSwizzle::B, nvn::TextureSwizzle::G,
              nvn::TextureSwizzle::R, nvn::TextureSwizzle::A);
</pre><p> Similarly, a single-channel image can use swizzles to produce a grayscale value with: </p><pre class="fragment">nvn::TextureBuilder tb;
tb.SetFormat(nvn::Format::R8);
tb.SetSwizzle(nvn::TextureSwizzle::R, nvn::TextureSwizzle::R,
              nvn::TextureSwizzle::R, nvn::TextureSwizzle::ONE);
</pre><p> The component remapping capability provided by <a class="el" href="classnvn_1_1_texture_builder.html#a345a8121dd0c0087c058226663126eac" title="Set the texture swizzle for Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetSwizzle</a> and <a class="el" href="classnvn_1_1_texture_view.html#a949224c910a7905ced9728f330534df7" title="Update a texture view to select an alternate component swizzle.">nvn::TextureView::SetSwizzle</a> is supported only for the following use cases:</p>
<ul>
<li>texture lookups using GLSL built-ins such as <code>texture</code> and <code>texelFetch</code></li>
<li>image loads using the GLSL built-in <code>imageLoad</code>, but only when the image variable being accessed is declared without a format layout qualifier (e.g., <code>rgba8</code>)</li>
</ul>
<p>Texture swizzles have no effect when the texture is used as a render target (e.g., <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>) or as the source or destination of a copy command (e.g., <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>, <a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a>). Texture swizzles also have no effect when the texture is used for image loads if the image variable is declared with a format layout qualifier. The results of image stores using the GLSL built-in <code>imageStore</code> are undefined if the provided image descriptor uses non-default texture swizzles.</p>
<p>Textures with formats having depth and stencil components (such as <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9745a145c841e60ff50d7a0fe0469e1f" title="A 24-bit unsigned normalized depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH24_STENCIL8</a>) can access only one of the two components at a time. The component accessed in texture lookups from such formats can be specified with <a class="el" href="classnvn_1_1_texture_builder.html#a8aea66e0c8af01f43872c3632a7b5924" title="Set the values returned for depth/stencil Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetDepthStencilMode</a>. To access both depth and stencil values in a single shader, applications can <a href="#nvn_guide_texture_views">use texture views</a> to specify an alternate depth/stencil mode for particular texture accesses. When swizzles are used with depth/stencil textures, the red component of the input vector contains the depth value for <a class="el" href="structnvn_1_1_texture_depth_stencil_mode.html#a9e5440037111eb2ffbf759ec9db9f1d6ac8a695ee6059c3b025d957f65bc39942" title="Return depth data as floating-point values.">nvn::TextureDepthStencilMode::DEPTH</a> and the stencil value for <a class="el" href="structnvn_1_1_texture_depth_stencil_mode.html#a9e5440037111eb2ffbf759ec9db9f1d6aa61144ff54cf3ea7cb280f15db8a26b2" title="Return stencil data as unsigned integer values.">nvn::TextureDepthStencilMode::STENCIL</a>.</p>
<p>In addition to programming all the parameters describing the structure of a texture to be created in the texture builder, an application must also provide the texture builder with the memory needed to store the texture, using <a class="el" href="classnvn_1_1_texture_builder.html#ac4fa1d578633296d4db3f171a75c71db" title="Set the location in a MemoryPool used for a Texture object created from the TextureBuilder.">nvn::TextureBuilder::SetStorage</a>. This command specifies a texture pool to use, along with an offset (in bytes) in that pool. The amount of memory pool storage required to hold the texture is an implementation-dependent function of the parameters in the texture builder, and can be queried from the driver using <a class="el" href="classnvn_1_1_texture_builder.html#a7589199c99ddaf5c78fa2411105cf2ff" title="Returns the amount of memory (in bytes) required to hold a texture to be created using the provided T...">nvn::TextureBuilder::GetStorageSize</a>. Additionally, the minimum alignment for the texture can be queried using <a class="el" href="classnvn_1_1_texture_builder.html#aaa72b43ff8357a290cf3286c8cb9200d" title="Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the ...">nvn::TextureBuilder::GetStorageAlignment</a>. Applications should ensure that the memory used for textures other than buffer textures (<a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a>) and linear textures (<a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> or <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>) do not share the same memory pool page with non-texture resources, as described in the <a href="#nvn_guide_memory_pool_aliasing">memory pool section of the guide</a>.</p>
<p>The texture builder class has a number of flags of type <a class="el" href="structnvn_1_1_texture_flags.html" title="Identifies special properties of texture allocations.">nvn::TextureFlags</a> that describe special properties of the texture allocation. Texture flags can be set before texture initialization using <a class="el" href="classnvn_1_1_texture_builder.html#a11f7525e0d1c3c010612c1d9bc1fcbbf" title="Set flags indentifying special properties of Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetFlags</a>.</p>
<ul>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea867ccb57db3565319f3d648cfcab1d3e" title="This texture can be displayed on-screen.">nvn::TextureFlags::DISPLAY</a> indicates that the texture can be <a href="#nvn_guide_presentation">displayed on-screen</a> using an <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> object and <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>.</li>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eab45b39317b1371ae6098be940331e789" title="This texture can be used to hold images produced by the GPU video decode engine.">nvn::TextureFlags::VIDEO_DECODE</a> indicates that the contents of the texture may be produced by the GPU video decode engine. To use a texture with the video decode engine, a specific memory organization is required that may not be used by equivalent textures without the VIDEO_DECODE bit set.</li>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea3aa6e85a939227e1408fe669c7b37c5f" title="This texture can be used for image loads and stores.">nvn::TextureFlags::IMAGE</a> indicates that the texture may be used for image loads and stores, and may have extra alignment requirements on some GPUs.</li>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> indicates that the GPU should attempt to use hardware compression when reading and writing the textures. Compressible textures will typically use a special storage class and have additional alignment restrictions discussed the <a href="#nvn_guide_memory_mappings">GPU memory mappings section of this guide</a>. For compressible textures using a non-virtual memory pool, the memory pool must be must be compressible (initialized using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a>). For compressible textures using a virtual memory pool, the virtual memory pool need not be compressible, but physical memory pools providing storage for the texture should be compressible.</li>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> and <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a> indicate that the texture should be stored as an array of texels in unoptimized linear form. LINEAR_RENDER_TARGET indicates a linear texture that will be used as a render target; LINEAR indicates a texture that will not be used as a render target.</li>
<li><a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaff46064359d3393f15aefecc05d52df7" title="This texture is arranged in memory to store as much of the texture as possible as collections of fixe...">nvn::TextureFlags::SPARSE</a> indicates that the texture images should be arranged in memory as a collection of tiles sized to GPU page sizes and aligned on GPU page boundaries. When a sparse texture is created from a virtual memory pool, applications can make individual tiles of the texture resident or non-resident by mapping or unmapping pages in the virtual memory pool. Sparse textures are discussed further in <a href="#nvn_guide_sparse_texture">a separate section of this guide</a>.</li>
</ul>
<p>Linear textures are only supported for two-dimensional texture targets (nvn::TextureTarget::TEXTURE_2D and nvn::TextureTarget::RECTANGLE). Each row of a linear texture is stored as an array of texels in memory. The number of bytes used per row is called the <em>stride</em> and must be set by the application using <a class="el" href="classnvn_1_1_texture_builder.html#ad841b6afdb37fab6c9a3eee176289134" title="Specify stride for linear textures.">nvn::TextureBuilder::SetStride</a>. The offset of a linear texture and its stride must both be aligned to a multiple of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da61c146cbc11a83d809d4235911070188" title="Minimum alignment required for stride in linear render targets, in bytes.">nvn::DeviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT</a> (128B) for linear render targets or a multiple of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab372d74472a67ab624b370707234a0bf" title="Minimum alignment required for stride in linear textures, in bytes.">nvn::DeviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT</a> (32B) otherwise. Mipmaps are not supported for linear textures. Linear textures may be used as color render targets but not as depth/stencil targets. Additionally, linear textures may not be used as a render target at the same time as any non-linear color or depth/stencil texture. Linear textures use the same storage class as buffers (<code>NVN_STORAGE_CLASS_BUFFER</code>) and can share the same 4KB range of physical memory with buffers without <a href="#nvn_guide_memory_pool_aliasing">memory aliasing issues</a>.</p>
<p>When using NVN and OpenGL/OpenGL ES in a single application, the two APIs can interoperate by creating an NVN texture object that inherits the state and storage from a previously created OpenGL or OpenGL ES texture object instead of using normal texture builder state. To create an NVN texture from a GL texture object, applications should call <a class="el" href="classnvn_1_1_texture_builder.html#a71e4c3993cc1e351373fd1b78f8b6c78" title="Set the name of the OpenGL texture to use as an external texture source.">nvn::TextureBuilder::SetGLTextureName</a> with a non-zero value identifying the GL texture to share. The default value of zero indicates that the texture should be initialized using texture builder state. More details on this support can be found in the <a href="#nvn_guide_ogl_interop">OpenGL and OpenGL interoperation section of this guide</a>.</p>
<p>NVN does not currently support shaders containing image load/store operations on multisample textures. To work around this, applications can create a non-multisample texture which aliases the memory conents of an existing multisample texture and perform the equivalent non-multisample image load/store operations in shaders. Developers need to convert the original position/sample coordinates to position coordinates in the non-multisample texture view of the same memory. Developers should consult the Maxwell Technical Overview for details on how multisampled textures are laid out in memory. Additionally, in order to have the driver interpret the two textures as using the same internal block size, developers must make sure the following flags are programmed consistently when creating both the multisample and non-multisample textures aliasing the same memory:</p>
<ul>
<li>NVN_TEXTURE_FLAGS_VIDEO_DECODE_BIT</li>
<li>NVN_TEXTURE_FLAGS_SPARSE_BIT</li>
<li>NVN_TEXTURE_FLAGS_MINIMAL_LAYOUT_BIT</li>
</ul>
<h2><a class="anchor" id="nvn_guide_native_texture_format"></a>
5.2. Native NX block format</h2>
<p>NVN textures are stored in a block-linear format that is cache friendly for the GPU, with the exception of buffer and linear textures. A texture is divided into blocks, and each block is further divided into gobs (groups-of-bytes). Although the format within a gob is GPU architecture dependent, each gob is always the same size: </p><pre class="fragment">gob_size = 64 bytes x 8 rows x 1 layer = 512 bytes
</pre> <blockquote class="doxtable">
<p><b>NOTE</b>: memory within a single gob is not pitch linear; each gob is further divided into smaller units designed to match the GPU cache sizes. This format is dependent on the GPU. </p>
</blockquote>
<p>The block size may be chosen to some degree by the driver and application. For non-3D non-sparse textures, it must be 1 x N x 1 gobs in size, where 2 &lt;= N &lt;= 32 and N must be a power of 2. For 3D textures, it must be 1 x 1 x N gobs in size, where 2 &lt;= N &lt;= 32 and N must be a power of 2. For sparse textures, N is chosen based on format to always align to page size exactly, allowing for texture regions to be mapped in / out one page at a time.</p>
<p>The driver may only control the block size of texture mipmap level 0. To determine the proper block size for texture mipmap level 0, the driver starts with N = 16 (ie 1x16x1 or 1x1x16 gobs per block) and then shrinks N as long as the size of 1 block is more than 1.5x height / depth of the texture. The layout of mipmap level 0 is chosen by driver software. For mipmap levels greater than 0 the hardware device further shrinks the layout to choose the smallest size N that will fit the image, or N = 1. This mip level shrinking logic is wired into hardware and cannot be controlled by software.</p>
<h3><a class="anchor" id="autotoc_md68"></a>
Minimal texture layout</h3>
<p>When a texture is created with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea70e79a59df6f39fc17791fd4c82a4bf7" title="Use minimal storage layout for texture.">nvn::TextureFlags::MINIMAL_LAYOUT</a> bit set, the driver will choose the smallest block size possible for level 0 (1x1x1 gobs per block). This will reduce the padding needed when texture size misaligns with block size, and may be useful in cases where the application developer wishes to save texture storage memory.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: This affects cache efficiency and can potentially have minor impact on performance. Fast clears are also disabled with this layout. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_packaged_texture_data"></a>
5.3. Packaged Texture Data</h2>
<p>Applications can use the NVN Texture Packager tool to convert texture data to the native representation supported by the NX device. When using packaged texture data, applications can load the texels directly into memory pool storage without using commands such as <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> to store texels in the native hardware representation.</p>
<p>By default, the NVN Texture Packager and NVN driver will select a preferred memory layout for a texture based on its size and format. If the strategy used to select a preferred memory layout changes, texture assets packaged using the old strategy won't work properly with a driver using the new strategy. To avoid compatibility issues, applications can save the packaged texture layout (of type <a class="el" href="structnvn_1_1_packaged_texture_layout.html" title="Data structure describing the organization of packaged texture data in memory.">nvn::PackagedTextureLayout</a>) when packaging texture assets and pass that layout to the driver using <a class="el" href="classnvn_1_1_texture_builder.html#af082a1dfc28ab6fb1776966449c06f77" title="Specify the layout of packaged texture data used for texture storage.">nvn::TextureBuilder::SetPackagedTextureLayout</a>. When a packaged texture layout is specified in a texture builder, the driver uses that layout directly instead of its current preferred layout. Support for sparse packaged textures can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7140dd6113e48330f26a029ea6059b1f" title="1 if the NVN implementation supports packaged texture data in sparse tiled form; 0 otherwise.">nvn::DeviceInfo::SUPPORTS_SPARSE_TILED_PACKAGED_TEXTURES</a>.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: If packaged texture data are loaded into a non-coherent memory pool using the CPU on NX, applications must call <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> or <a class="el" href="classnvn_1_1_buffer.html#a33d9a879a34a17e9328d4c593d817fdd" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU.">nvn::Buffer::FlushMappedRange</a> to ensure that all texels are visible to the GPU and none are stuck in the CPU cache. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: Packaged texture data should not be used as the source of a GPU copy using <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a>, because that command expects a multi-dimensional array of texels in buffer memory. However, applications may copy packaged texture data from a staging buffer to the final memory location used by the texture using <a class="el" href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924" title="Schedule a copy of data from one Buffer object into another Buffer object.">nvn::CommandBuffer::CopyBufferToBuffer</a> and read back packaged texture data in pitch form using <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a>. </p>
</blockquote>
<p>The NVN Texture Packager tool is discussed in more detail in a separate document.</p>
<h3><a class="anchor" id="autotoc_md69"></a>
Packaged Texture Data on Windows</h3>
<p>On the Windows reference implementation, the native representation for texture images is dependent on the GPU being used and is not compatible with the packaged representation used by the NX. To initialize textures using packaged data on Windows, applications should store the data anywhere in CPU-accessible memory (including the final location used by the texture) and then provide the texture builder with a pointer to that memory using <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a>. When initializing new textures on Windows with a non-NULL packaged texture data pointer in the builder, the driver decodes the packaged texture data and re-encodes it in the final texture storage using the native representation of the target GPU. If the packaged texture data pointer in the builder is NULL, no texels are written to texture storage when the texture is initialized. On the NX implementation, <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a> has no effect.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: When using <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a> with a non-NULL pointer, a re-encoding is performed each time a new texture is initialized using the builder. If an application creates multiple texture objects sharing the same storage, it should set the packaged data pointer to NULL after the first texture is initialized to avoid performing multiple copies. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> should not be called on portions of a memory pool containing texture data. Doing so will overwrite existing texture data with data not arranged using the native representation of the target GPU, and will result in image corruption. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_texture_views"></a>
5.4. Texture Views</h2>
<p>Applications may want to share the memory for a single texture for multiple uses at different times. To do this, an application can create multiple <em>views</em> of the texture memory using the <a class="el" href="classnvn_1_1_texture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">nvn::TextureView</a> class. Example use cases include:</p>
<ul>
<li>Accessing the contents of an RGBA8 texture (a) using an sRGB color space encoding, (b) using a non-sRGB color space encoding, and (c) using an integer format that returns the raw bits of the texture instead of converting to floating-point values in the range [0,1].</li>
<li>Accessing a cube map texture as a cube map when texture mapping, but rendering to or texturing from only a single face in other operations.</li>
<li>Selecting a single mipmap of a mipmapped texture for rendering or texturing operations.</li>
</ul>
<p>Applications can create a new "view" of an existing texture by passing a pointer to an <a class="el" href="classnvn_1_1_texture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">nvn::TextureView</a> object to NVN entry points that accept a texture view:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">nvn::TexturePool::RegisterTexture</a> and <a class="el" href="classnvn_1_1_texture_pool.html#a0dfac012b673d8e809fe86ca9c941b5a" title="Register an image descriptor in a texture pool for use via image loads and stores.">nvn::TexturePool::RegisterImage</a> use texture views to create a texture or image descriptor with an alternate interpretation of the texture's storage, selecting a subset of the mipmap levels and layers of the original or modifying how the storage is interpreted by texture or image accesses in shaders.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> uses texture views to select a mipmap level and set of layers to render to, or to identify the format to use for rendering.</li>
</ul>
<p>In entry points accepting texture views, a NULL pointer is legal and instructs NVN to use all of the properties of the original texture object. In entry points accepting arrays of texture views, a NULL pointer is legal and is functionally equivalent to providing a properly-sized array of texture view pointers, all set to NULL.</p>
<p>The state of a texture view object is programmed using the <a class="el" href="classnvn_1_1_texture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">nvn::TextureView</a> class.</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture_view.html#a7dd5c3353a108819836cb3f6708d35f1" title="Set default state for the TextureView object.">nvn::TextureView::SetDefaults</a> must be used to initialize the texture view to its default state.</li>
<li><a class="el" href="classnvn_1_1_texture_view.html#a95276fc4df6759e1a1c6bb1594ae9f34" title="Update a texture view to select a subset of the mipmap levels in a Texture object.">nvn::TextureView::SetLevels</a> is used to select a subset of the mipmap levels of the original texture. The <em>baseLevel</em> parameter specifies the first level of the view, where the highest resolution mipmap level is numbered zero. If the <em>numLevels</em> parameter is non-zero, it specifies the number of levels in the view. If <em>numLevels</em> is zero, the view selects all mipmap levels of the texture numbered <em>baseLevel</em> or higher.</li>
<li><a class="el" href="classnvn_1_1_texture_view.html#a9816c17a7c3dda5208abd6da607e6433" title="Update a texture view to select a subset of the layers in a Texture object.">nvn::TextureView::SetLayers</a> is used to select a subset of the layers of the original texture. The <em>minLayer</em> parameter specifies the first layer of the texture to select. If the <em>numLayers</em> parameter is non-zero, it specifies the number of layers in the view. If <em>numLayers</em> is zero, the view selects all layers of the texture numbered <em>minLayer</em> or higher.</li>
</ul>
<p>In addition to selecting a subset of layers and levels of the additional texture, some of the other parameters of the texture view may be used to re-interpret the storage of the texture in different ways:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture_view.html#ae66570214bdef0d0c858e8abcc33cbee" title="Update a texture view to select an alternate texture format.">nvn::TextureView::SetFormat</a> can be used to use the storage with a different format.</li>
<li><a class="el" href="classnvn_1_1_texture_view.html#a949224c910a7905ced9728f330534df7" title="Update a texture view to select an alternate component swizzle.">nvn::TextureView::SetSwizzle</a> and <a class="el" href="classnvn_1_1_texture_view.html#a7cf39f78fdb7b38296c60fe87880c2e6" title="Update a texture view to select an alternate depth/stencil mode.">nvn::TextureView::SetDepthStencilMode</a> can be used to select components in the texture view differently than in the original texture.</li>
<li><a class="el" href="classnvn_1_1_texture_view.html#ab74d3429ae55981defd94f8d0a6bef8f" title="Update a texture view to select an alternate texture target.">nvn::TextureView::SetTarget</a> can be used to select a different texture target. For example, when selecting a single face of a cube map, a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8c499dff06e2171624572ec97051b75c" title="Two-dimensional texture.">nvn::TextureTarget::TARGET_2D</a> should be used for the view of the single face.</li>
</ul>
<p>When using a non-NULL texture view, any properties of the texture view that were not explicitly programmed after calling <a class="el" href="classnvn_1_1_texture_view.html#a7dd5c3353a108819836cb3f6708d35f1" title="Set default state for the TextureView object.">nvn::TextureView::SetDefaults</a> will use corresponding values from the texture object used with the view. Texture views without an explicitly programmed set of mipmap levels or layers will use all levels or layers of the original texture. Using a texture view initialized to default state will behave identically to using a NULL texture view pointer, where all properties will come from the texture allocation used with the view.</p>
<p>When creating a texture view to reinterpret the storage of a texture object, not all combinations of view and texture state are legal. Error conditions for texture views include:</p>
<ul>
<li>One or more of the levels or layers programmed in the view don't exist in the texture.</li>
<li>Views selecting a subset of the layers of a texture with a target of TARGET_3D are not supported, except for single-layer views used as a render target.</li>
<li>Views programming an alternate format or target must use a format or target compatible with the original texture allocation.</li>
<li>Some combination of texture formats and view formats may not be supported on the NVN Windows reference implementation. For details, please refer to the section '<a href="#nvn_guide_formats_restrictions_on_Windows">Formats Restrictions on the NVN Windows Reference Implementation</a>'.</li>
</ul>
<p>If the view is not compatible with the texture, the results of using them together are undefined and could result in application hangs or crashes.</p>
<p>For texture views specifying an alternate format:</p>
<ul>
<li>Views with uncompressed color formats are compatible only with textures with uncompressed color formats, and only if both formats have the same number of bits per pixel.</li>
<li>Views with compressed color formats are compatible only with textures with compressed color formats, and only if compression blocks in both formats have the shape (in texels) and storage size (in bytes per block).</li>
<li>Views with depth and stencil formats are compatible only with textures with identical formats.</li>
</ul>
<p>For texture views specifying an alternate target, the view is compatible with a texture only of the targets of the view and the texture are in the same compatibility class according to the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Target   </th><th class="markdownTableHeadNone">Compatibility class    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_1D   </td><td class="markdownTableBodyNone">one-dimensional    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TARGET_2D   </td><td class="markdownTableBodyNone">two-dimensional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_3D   </td><td class="markdownTableBodyNone">three-dimensional    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TARGET_1D_ARRAY   </td><td class="markdownTableBodyNone">one-dimensional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_2D_ARRAY   </td><td class="markdownTableBodyNone">two-dimensional    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TARGET_2D_MULTISAMPLE   </td><td class="markdownTableBodyNone">multisample    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_2D_MULTISAMPLE_ARRAY   </td><td class="markdownTableBodyNone">multisample    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TARGET_RECTANGLE   </td><td class="markdownTableBodyNone">two-dimensional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_CUBEMAP   </td><td class="markdownTableBodyNone">two-dimensional    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TARGET_CUBEMAP_ARRAY   </td><td class="markdownTableBodyNone">two-dimensional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TARGET_BUFFER   </td><td class="markdownTableBodyNone">buffer   </td></tr>
</table>
<p>Texture views allow applications to limit access to only a subset of the storage required by a full texture. If a texture is stored in a <a href="#nvn_guide_memory_mappings">virtual memory pool</a>, applications can limit the amount of physical memory consumed by a texture by unmapping portions of the texture not needed by any view of the texture. The command <a class="el" href="classnvn_1_1_texture.html#ab69367de98777c44d09200f70fa48815" title="Returns the offset (in bytes) of the first byte of storage used by a view of a Texture object.">nvn::Texture::GetViewOffset</a> can be used to determine the memory range required by a given texture view. This command returns the offset (in bytes) of the first byte of storage required by the texture view, relative to the first byte of storage required by the full texture. Textures in NVN are stored in virtually contiguous memory. For array and cube map textures, each layer or face is stored in memory as a unit with offsets increasing by layer number, with the first layer starting at offset zero. For mipmapped textures, each mipmap level in the texture (or in each layer for array and cube map textures) is stored as a unit with offsets increasing by mipmap level number, with mipmap level zero stored with a relative offset of zero.</p>
<p>The range of memory required by a view can be computed by comparing the offset of two texture views. For example, if <em>texture</em> is a 2D array texture with 20 layers and 10 mipmap levels, the memory required for levels 2 through 7 of layer 4 can be determined by:</p>
<ul>
<li>querying the offset of one view selecting level 2 and layer 4 to determine the first byte required; and</li>
<li>querying the offset of a second view selecting level 8 and layer 4 to determine the offset of the first byte beyond the end of the view.</li>
</ul>
<p>This can be done with code like: </p><pre class="fragment">nvn::TextureView view;
view.SetDefaults();
view.SetLayers(4, 1);
view.SetLevels(2, 1);
firstByte = texture.GetViewOffset(&amp;view);
view.SetLevels(8, 1);
lastByte = texture.GetViewOffset(&amp;view) - 1;
</pre><p> If multiple layers are involved in a texture view, the memory required could consist of multiple disjoint memory ranges. Each layer in a texture requires a fixed number of bytes, and the difference in offsets between layers can be determined by simply querying the offset of a texture view selecting layer 1: </p><pre class="fragment">nvn::TextureView view;
view.SetDefaults();
view.SetLayers(1, 1);
layerSize = texture.GetViewOffset(&amp;view);
</pre><p> <a class="el" href="classnvn_1_1_texture_builder.html#a2a7055c5d44da133f100443a431d03b6" title="Returns the offset (in bytes) of the first byte of storage used by a view of a Texture object created...">nvn::TextureBuilder::GetViewOffset</a> can be used to calculate the same offset without first initializing an <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a>.</p>
<h2><a class="anchor" id="nvn_guide_texture_pools"></a>
5.5. Texture Pools and Registration</h2>
<p>Before an application uses textures in programmable shaders, it must</p>
<ul>
<li>create <a class="el" href="classnvn_1_1_texture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">nvn::TexturePool</a> and <a class="el" href="classnvn_1_1_sampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">nvn::SamplerPool</a> objects to hold texture and sampler descriptors;</li>
<li>register individual <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> objects in these pools;</li>
<li>bind texture and sampler pools to the rendering state; and</li>
<li>obtain handles for pairs of texture and sampler objects used for rendering.</li>
</ul>
<p>Texture and sampler pools are blocks of memory, obtained from memory pools, where texture, image, and sampler <em>descriptors</em> are written. A texture descriptor is used to describe the properties of a texture object used for texture fetches using GLSL sampler variables. An image descriptor is used to describe the properties of a texture object for use in loads and stores using GLSL image variables. A sampler descriptor is used to describe the properties of a sampler object used for texture fetches using GLSL sampler variables. Texture and image descriptors consume 32 bytes of memory in a texture pool; sampler descriptors consume 32 bytes of memory in a sampler pool. The size and location of each pool must be 32 byte-aligned. Applications must provide memory when initializing the texture and sampler pool objects using the following commands:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture_pool.html#acd9a0e9b98c9c1a8781e649ded11aa1e" title="Initialize a TexturePool object.">nvn::TexturePool::Initialize</a> provides memory for a texture pool and initializes the texture pool object. A texture pool supports at most 2<sup>20</sup> = 1048576 descriptors.</li>
<li><a class="el" href="classnvn_1_1_sampler_pool.html#aa142c9deaf8467d8bbb60d54bce3591f" title="Initialize a SamplerPool object.">nvn::SamplerPool::Initialize</a> provides memory for a sampler pool and initializes the sampler pool object. A sampler pool supports at most 2<sup>12</sup> = 4096 descriptors.</li>
</ul>
<p>The NVN implementation reserves a number of entries at the beginning of the texture and sampler pools for its own internal usage. The number of reserved entries can be determined by calling <a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c" title="Query properties of a device.">nvn::Device::GetInteger</a>, where querying <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a> and <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver.">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a> returns the number of reserved entries in the texture and sampler pools, respectively.</p>
<p>On NX, any memory pool used to store texture and sampler descriptors must have CPU-accessible storage. It is recommended that you use the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> flag. When using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a>, the NVN implementation will automatically perform CPU cache flushes to make the new descriptors visible to the GPU, but such flushes will incur overhead. On the Windows reference implementation, the CPU-accessible memory requirement is waived; for full performance on the Windows implementation, it is recommended that you instead store sampler and texture descriptors in a memory pool with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a>.)</p>
<p>After texture and sampler pools are initialized, an application can register descriptors in the pools using the following commands:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">nvn::TexturePool::RegisterTexture</a> and <a class="el" href="classnvn_1_1_texture_pool.html#a0dfac012b673d8e809fe86ca9c941b5a" title="Register an image descriptor in a texture pool for use via image loads and stores.">nvn::TexturePool::RegisterImage</a> write a new texture or image descriptor in the texture pool using the entry given by the provided value of <em>id</em>.</li>
<li><a class="el" href="classnvn_1_1_sampler_pool.html#af39ae66ac172ee0c4804ff4b95fc94e7" title="Register a sampler descriptor in a sampler pool for use via texture handles, using a Sampler object.">nvn::SamplerPool::RegisterSampler</a> writes a new descriptor in the sampler pool, using the entry given by the provided value of <em>id</em> and sampler state in the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> object <em>sampler</em>.</li>
<li><a class="el" href="classnvn_1_1_sampler_pool.html#a8ddc47f155142938c3553c6aafcddf37" title="Register a sampler descriptor in a sampler pool for use via texture handles, using SamplerBuilder sta...">nvn::SamplerPool::RegisterSamplerBuilder</a> writes a new descriptor in the sampler pool, using the entry given by the provided value of <em>id</em> and sampler state in the <a class="el" href="classnvn_1_1_sampler_builder.html" title="Object specifying state used to construct new sampler objects.">nvn::SamplerBuilder</a> object <em>builder</em>. This entry point allows applications to register sampler descriptors without creating sampler objects.</li>
</ul>
<p>If any of these commands reuse a pool entry <em>id</em> that had been previously registered, any texture, image, or sampler handles referring to that entry are considered invalid. Applications should ensure that all GPU commands using a previously registered texture or sampler pool entry are complete before reusing it.</p>
<p>Whenever the next set of commands are flushed to the hardware, the texture and sampler descriptor caches will be invalidated automatically.</p>
<p>The <em>id</em> values used when registering textures or samplers in pools are also used to construct texture, image, and sampler handles.</p>
<p>In order to use descriptors in a texture or sampler pool, the pools must also be bound for rendering using <a class="el" href="classnvn_1_1_command_buffer.html#a25f10e3257fe549de368e842e61ee8ee" title="Specify a new texture pool used for subsequent rendering operations.">nvn::CommandBuffer::SetTexturePool</a> and <a class="el" href="classnvn_1_1_command_buffer.html#ad36725731839793d678ce0243df56f94" title="Specify a new sampler pool used for subsequent rendering operations.">nvn::CommandBuffer::SetSamplerPool</a>. Each queue has a single current texture pool and a single current sampler pool. If an application registers textures or samplers in multiple pools, only those texture and image handles created using <em>id</em> values registered in the current pools are valid. Applications can change the current pools associated at any time by submitting a command set containing SetTexturePool and SetSamplerPool commands. However, changing texture or sampler pools frequently may result in poor performance because the GPU will wait for all previously submitted rendering commands to complete before setting up the new pool.</p>
<p>If an application uses textures in multiple queues, it must program a texture and sampler pool separately in each queue. It is legal to share a single texture or sampler pool between multiple queues, but applications must ensure that all queues are finished using a shared pool before freeing or reusing its memory.</p>
<h2><a class="anchor" id="nvn_guide_sec_5_6"></a>
5.6. Texture and Image Handles</h2>
<p>To use texture and sampler objects for texture lookups in a shader, an application must use texture handles (<a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08" title="GPU handle used to refer to a texture object for texture mapping operations.">nvn::TextureHandle</a> or <a class="el" href="structnvn_1_1_separate_texture_handle.html" title="Structure containing a GPU handle used to refer to a separate texture object for texture mapping oper...">nvn::SeparateTextureHandle</a>). A texture handle is obtained via the command <a class="el" href="classnvn_1_1_device.html#a8d1c52b97f2667307df5e299c637fa41" title="Get a handle for a combined pair of Texture and Sampler objects.">nvn::Device::GetTextureHandle</a> or <a class="el" href="classnvn_1_1_device.html#a7e764abad3e6e33d4cd0c5e352f4bcd9" title="Get a handle for a separate Texture object.">nvn::Device::GetSeparateTextureHandle</a>, passing in one <em>id</em> value previously used to register a texture object in a texture pool. Combined texture/sampler handles (nvn::GetTextureHandle) requires passing in a second <em>id</em> value previously used to register a sampler object in a sampler pool. The returned handle can be used:</p>
<ul>
<li>for bound texture access, via <a class="el" href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901" title="Bind a Texture/Sampler pair to use for texture mapping in shaders.">nvn::CommandBuffer::BindTexture</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a>.</li>
<li>for bindless texture access, by passing the 64-bit texture handle value to the shader through a uniform block, a shader storage block, a vertex attribute, or by any other means.</li>
</ul>
<p>Texture handles are valid if and only if the <em>id</em> values used to construct the handle were registered in the current texture and sampler pools. Additionally, a texture handle becomes invalid if a new texture or sampler object is registered in the same texture or sampler pool using the <em>id</em> values used to construct the handle.</p>
<p>NVN supports independently binding texture and sampler objects to API binding points using <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSampler</a>.</p>
<p>To use a texture object for random-access loads and stores in a shader using GLSL image variables, an application must use image handles (<a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2" title="GPU handle used to refer to a texture object for image load and store operations.">nvn::ImageHandle</a>). An image handle is obtained via the command <a class="el" href="classnvn_1_1_device.html#a9e1c4bf2070f7657bea6caf219556836" title="Get a handle to use for image loads and stores to a Texture object.">nvn::Device::GetImageHandle</a> passing in an <em>id</em> value previously used to register a texture object in a texture pool. The returned handle can be used:</p>
<ul>
<li>for bound image access, via <a class="el" href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab" title="Bind a Texture to use for image loads and stores in shaders.">nvn::CommandBuffer::BindImage</a>;</li>
<li>for bindless image access, by passing the 64-bit image handle value to the shader through a uniform block, a shader storage block, a vertex attribute, or by any other means.</li>
</ul>
<p>Image handles are valid if and only if the <em>id</em> value used to construct the handle were registered in the current texture pool. Additionally, an image handle becomes invalid if a new texture object is registered in the same texture pool using the <em>id</em> value used to construct the handle.</p>
<p>On NX and on first- and second-generation Maxwell GPUs on the Windows reference implementation, descriptors for images are stored in the same texture pool and using the same format as descriptors for textures. On such GPUs, 64-bit texture handles may also be used as image handles and passed to <a class="el" href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab" title="Bind a Texture to use for image loads and stores in shaders.">nvn::CommandBuffer::BindImage</a>. Applications can determine if this feature is supported by checking the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daa6b2134777aed24f8d9dd7968fb8d1f9" title="1 if the NVN implementation supports using texture handles for image accesses, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_IMAGES_USING_TEXTURE_HANDLES</a>. Note that on implementations that generally support using texture handles for image accesses, image loads and stores for cubemap and cubemap array textures require dedicated image handles that treat the textures as two-dimensional array textures.</p>
<p>Unbinding a texture handle in NVN is not directly supported. Instead, texture handles created from texture and sampler <em>id</em> values meeting the following criteria will yield (0, 0, 0, 0) when accessed in a shader:</p>
<blockquote class="doxtable">
<p>texture_pool_max &lt; texture_id &lt; <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae45576034cd4692845ec283c734fe193" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool.">nvn::DeviceInfo::MAX_TEXTURE_POOL_SIZE</a><br  />
 sampler_pool_max &lt; sampler_id &lt; <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6774d774c25a69449531768a6b5e5b56" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool.">nvn::DeviceInfo::MAX_SAMPLER_POOL_SIZE</a><br  />
 </p>
</blockquote>
<p>For the purposes of the above equations, texture_pool_max and sampler_pool_max are the maximum <em>id</em> values possible in the currently bound texture and sampler pools, based on the memory provided to them in <a class="el" href="classnvn_1_1_texture_pool.html#acd9a0e9b98c9c1a8781e649ded11aa1e" title="Initialize a TexturePool object.">nvn::TexturePool::Initialize</a> and <a class="el" href="classnvn_1_1_sampler_pool.html#aa142c9deaf8467d8bbb60d54bce3591f" title="Initialize a SamplerPool object.">nvn::SamplerPool::Initialize</a>. (When these equal <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae45576034cd4692845ec283c734fe193" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool.">nvn::DeviceInfo::MAX_TEXTURE_POOL_SIZE</a> or <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da6774d774c25a69449531768a6b5e5b56" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool.">nvn::DeviceInfo::MAX_SAMPLER_POOL_SIZE</a>, respectively, those pools will not be able to make use of this feature.)</p>
<h2><a class="anchor" id="nvn_guide_sparse_texture"></a>
5.7. Sparse Textures</h2>
<p>When a texture is created with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaff46064359d3393f15aefecc05d52df7" title="This texture is arranged in memory to store as much of the texture as possible as collections of fixe...">nvn::TextureFlags::SPARSE</a> bit set, it is considered to be a <em>sparse texture</em> and is arranged in memory to decompose individual mipmap levels into a set of fixed-size tiles aligned on GPU page boundaries. When a sparse texture is created using memory from a virtual memory pool, individual texture tiles can be made resident or non-resident by mapping or unmapping pages in the virtual memory pool.</p>
<p>Not all mipmap levels of a sparse texture will be decomposed into page-sized tiles; smaller mipmap levels will not be padded out to tile sizes or aligned to page boundaries. On NX and second-generation Maxwell GPUs, if the size of a mipmap level is greater than or equal to the tile size in all dimensions, that image will be decomposed into tiles and padded out to tile boundaries if required. The set of mipmaps with any dimension smaller than the tile size is referred to as the <em>mipmap tail</em>. Because the memory used in the mipmap tail will not be aligned on page boundaries, applications will not be able to map or unmap tile-sized regions of those mipmap levels without affecting other tiles or mipmap levels. Applications should treat all the mipmap levels of the tail as a unit and make the entire tail resident or non-resident as needed.</p>
<p>For any given sparse texture, applications can query the tile size and the number of non-tail mipmap levels by calling <a class="el" href="classnvn_1_1_texture_builder.html#aead0012ce620fa7054a0e8c62430942f" title="Returns properties of the sparse memory layout for a texture to be created using the provided Texture...">nvn::TextureBuilder::GetSparseTileLayout</a> or <a class="el" href="classnvn_1_1_texture.html#a5688ae5d36ef97f88c89c5ba9a256dcd" title="Returns properties of the sparse memory layout for a texture.">nvn::Texture::GetSparseTileLayout</a>.</p>
<p>Most NVN implementations, including the NX platform, will have 64KB GPU memory pages. For these implementations, NVN will use a standard tile size based on the target, sample count, and format of the texture, as indicated in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits/texel   </th><th class="markdownTableHeadCenter">3D   </th><th class="markdownTableHeadCenter">2D, no AA   </th><th class="markdownTableHeadCenter">2D, 2xAA   </th><th class="markdownTableHeadCenter">2D, 4xAA   </th><th class="markdownTableHeadCenter">2D, 8xAA    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyCenter">64x32x32   </td><td class="markdownTableBodyCenter">256x256   </td><td class="markdownTableBodyCenter">128x256   </td><td class="markdownTableBodyCenter">128x128   </td><td class="markdownTableBodyCenter">64x128    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">32x32x32   </td><td class="markdownTableBodyCenter">256x128   </td><td class="markdownTableBodyCenter">128x128   </td><td class="markdownTableBodyCenter">128x64   </td><td class="markdownTableBodyCenter">64x64    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">32x32x16   </td><td class="markdownTableBodyCenter">128x128   </td><td class="markdownTableBodyCenter">64x128   </td><td class="markdownTableBodyCenter">64x64   </td><td class="markdownTableBodyCenter">32x64    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">64   </td><td class="markdownTableBodyCenter">32x16x16   </td><td class="markdownTableBodyCenter">128x64   </td><td class="markdownTableBodyCenter">64x64   </td><td class="markdownTableBodyCenter">64x32   </td><td class="markdownTableBodyCenter">32x32    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">128   </td><td class="markdownTableBodyCenter">16x16x16   </td><td class="markdownTableBodyCenter">64x64   </td><td class="markdownTableBodyCenter">32x64   </td><td class="markdownTableBodyCenter">32x32   </td><td class="markdownTableBodyCenter">16x32   </td></tr>
</table>
<p>The "bits/texel" column indicates the number of bits per texel in the texture's format. For three-dimensional textures, the tile size is given by the "3D" column. For non-multisample textures with two-dimensional images, the tile size will be given by the "2D, no AA" column. For multisample textures, the tile size is given in one of the other "2D" columns, depending on the sample count. Sparse tiled textures are not supported for formats using 96 bits per texel (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a821c14e8dec351b783ac10e6b69d47fb" title="Three 32-bit floating-point components.">nvn::Format::RGB32F</a>), textures with one-dimensional images, or linear textures. In such cases, the mipmap tail is considered to begin at texture level zero.</p>
<p>For <a href="#nvn_guide_compressed_formats">compressed texture formats</a>, standard tile sizes are also obtained from the table above, using the number of bits in the compression block for "bits/texel" and interpreting the tile size as being in units of compression blocks instead of texels. For example, the standard tile size for a 2D texture with a format of <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6c4f48f1a34b5c8102664c7c41dd780a" title="DXT1 compressed texture blocks with an RGB format.">nvn::Format::RGB_DXT1</a> (64 bits per 4x4 texel compession block) would be 128x64 compression blocks or 512x256 texels.</p>
<p>To populate or unpopulate an individual sparse texture tile, applications need to determine the tile's offset relative to the base of the texture and then add the texture's offset relative to the beginning of the virtual memory pool containing the texture. The base offset of the texture level and layer can be determined by: </p><pre class="fragment">nvn::TextureView view;
view.SetDefaults().SetLevels(level, 1).SetLayers(layer, 1);
imageOffset = texture-&gt;GetViewOffset(&amp;view);
</pre><p> In all NVN implementations, individual mipmap levels are stored consecutively in memory with addresses increasing by mipmap level. Array and cube map textures are stored as arrays of two-dimensional textures with the set of mipmaps for each layer or face stored as a unit. Array layers and cube faces are stored consecutively in memory with addresses increasing by level or face number. Within a given sparse texture mipmap level, page-sized tiles are arranged in a simple three-dimensional array.</p>
<p>The sparse tile layout, including the tile size and number of non-tail mipmap levels, can be determined by: </p><pre class="fragment">nvn::Texture *texture;
nvn::TextureSparseTileLayout sparseLayout;
texture-&gt;GetSparseTileLayout(&amp;sparseLayout);
</pre><p> Once the offset of the single level and layer is determined, the offset of a tile containing texel (x,y,z) within this level can be determined by: </p><pre class="fragment">int imageWidth, imageHeight, imageDepth;
int x, y, z;
size_t pageSize;

int tileWidth = sparseLayout.tileWidth;
int tileHeight = sparseLayout.tileHeight;

// Translate the image size from texels to tiles.
int tilesInX = (imageWidth  + tileWidth  - 1) / tileWidth;
int tilesInY = (imageHeight + tileHeight - 1) / tileHeight;

// Translate the (x,y,z) texel location to a tile number.
int tileX = x / tileWidth;
int tileY = y / tileHeight;
int tileZ = z / tileDepth;
int tileNum = tileX + tileY * tilesInX + tileZ * tilesInX * tilesInY;

// Compute an offset for that tile, treating the image as a
// three-dimensional array of page-sized tiles in memory.
tileOffset = pageSize * tileNum;
</pre><p> On the Windows reference implementation, GPUs older than second-generation Maxwell GPUs do not include full hardware support for forcibly aligning texture tiles to mipmap boundaries. For such GPUs, additional restrictions apply:</p>
<ul>
<li>The mipmap tail will start at the first mipmap level whose size is not an integer multiple of the tile size.</li>
<li>For array and cube map textures, the tail will start at mipmap level zero (i.e., no tiled levels) if any mipmap level is not an integer multiple of the tile size.</li>
<li>Images produced by the NVN texture packager for NX using the <em>sparse</em> option can not be used on these older GPUs because the implementation will use a different memory layout than on the NX target GPU.</li>
</ul>
<blockquote class="doxtable">
<p><b>NOTE</b>: While not a hardware requirement, in order to align sparse texture texel blocks to page boundaries, the virtual pool offset of the sparse texture should be aligned to NVN_DEVICE_INFO_MEMORY_POOL_PAGE_SIZE ( 64Kb on both Windows and NX platforms ). If this requirement is not met, the texture may still be rendered to or fetched from, but texel blocks may mis-align with page boundaries. In this case, texel blocks may not be cleanly mapped in and out of sparse pool memory and thus defeats the purpose of having a sparse texture. </p>
</blockquote>
<h1><a class="anchor" id="nvn_guide_samplers"></a>
6. Sampler Objects</h1>
<p>The <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> object, together with the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object, is used by programmable shaders to access the contents of images stored in memory and use the image data when rendering primitives.</p>
<p>To create a new sampler object, applications should specify the parameters describing the sampling state using the <a class="el" href="classnvn_1_1_sampler_builder.html" title="Object specifying state used to construct new sampler objects.">nvn::SamplerBuilder</a> class and then use the sampler builder to initialize the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a> object using <a class="el" href="classnvn_1_1_sampler.html#add1cc02bf252e30007775cef77e01c20" title="Initialize a Sampler object using the specified SamplerBuilder object.">nvn::Sampler::Initialize</a>.</p>
<p>The state of the sampler builder can be programmed with a variety of <a class="el" href="classnvn_1_1_sampler_builder.html" title="Object specifying state used to construct new sampler objects.">nvn::SamplerBuilder</a> class methods, including:</p>
<ul>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#ad7d9f27a76f7ba6c368ee81d3e9c2b05" title="Set the minification and magnification filters for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetMinMagFilter</a> specifies the minification and magnification filters. The GPU computes a level of detail and determines whether the texture is being magnified (where each texel takes up multiple pixels on screen) or minified (where each pixel takes up multiple texels on screen). Based the level of detail, the GPU selects a filter that determines if the texture will be accessed using a single sample (point filtering), average multiple samples in a small footprint (linear filtering), and whether the samples come from one mipmap level or multiple levels. A description of the supported minification and magnification filters can be found in the documentation of <a class="el" href="structnvn_1_1_min_filter.html" title="Specifies a minification filter used for texture sampling.">nvn::MinFilter</a> and <a class="el" href="structnvn_1_1_mag_filter.html" title="Specifies a magnification filter used for texture sampling.">nvn::MagFilter</a>.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#ac116834a55e326957abc0d5c07fb237a" title="Set the maximum level of anisotropy used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetMaxAnisotropy</a> specifies a floating-point value controlling anisotoropic filtering, which is used when the footprint of a pixel in the texture is long and narrow. Legal values are in the range [1.0, 16.0], where a value of <em>N</em> specifies the maximum number of extra samples taken for pixels with a non-square footprint. There is no separate minification and magnification filter enabling anisotropic filtering; it is enabled automatically when a value greater than 1.0 is specified.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#ad6be43a45337fe162520ed94e16d756f" title="Set the coordinate wrap modes for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetWrapMode</a> specifies how interpolated texture coordinates are mapped to texels in the original textures. Wrap mode options are explained in the documentation of <a class="el" href="structnvn_1_1_wrap_mode.html" title="Specifies a wrap mode when mapping a normalized texture coordinate to texels in a texture map.">nvn::WrapMode</a>, and include choices where coordinates wrap around to the opposite edge of the texture, are clamped to edges of the texture, and are mirrored around the origin of the texture.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#ac8e01ff7a4f6d501c08a0241c9336644" title="Set the minimum and maximum level of detail used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetLodClamp</a> specifies floating-point level of detail values <em>min</em> and <em>max</em>, where the computed level of detail is clamped to [<em>min</em>, <em>max</em>].</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#af23ebdff147f36027f8d9b1495896b51" title="Set the level-of-detail bias used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetLodBias</a> specifies a floating-point level of detail bias that is added into the computed level of detail.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#a4ac3a9caaa16596ade1748d677af8e18" title="Set the depth comparison mode used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetCompare</a> is used to enable shadow mapping for depth textures. When enabled, shadow mapping compares a reference depth value against the depth value stored in the texture, and produces values of 0.0 or 1.0 based on whether the comparison passes or fails. In this method, the <em>mode</em> parameter indicates whether comparisons are enabled and the <em>func</em> parameter (of type <a class="el" href="structnvn_1_1_compare_func.html" title="Specifies a function used to compare &#39;texture&#39; and &#39;reference&#39; values.">nvn::CompareFunc</a>) specifies the type of comparison to use. The compare mode has no effect on textures not storing depth values.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#ad77c10911853ab5de3f9a40bf2609540" title="Set floating-point border color values used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetBorderColor</a>, <a class="el" href="classnvn_1_1_sampler_builder.html#aea915d09cfde7c320bf44ba0bad1349c" title="Set signed integer border color values used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetBorderColori</a>, and <a class="el" href="classnvn_1_1_sampler_builder.html#a3cf01d6b66fdcf11b3e3daf47470ac63" title="Set unsigned integer border color values used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetBorderColorui</a> specify a floating-point, signed integer, or unsigned integer border color that is used in place of texel values when texture coordinates are outside the normal [0.0, 1.0] range and the wrap mode indicates clamping to border values. All three methods update the same border color state. If the border color is sampled when doing a lookup that accesses the border color, the sampler used should be programmed using a type compatible with the type of the shader sampler variable. For example, sampler objects used for lookups using <code>sampler2D</code>, <code>isampler2D</code>, and <code>usampler2D</code> variable types should be programmed with SetBorderColor, SetBorderColori, or SetBorderColorui, respectively. In case of mismatch, the raw bits of the border color will be re-interpreted according to the type of the texture used with the sampler. The default border color (all zero) will be correctly interpreted as zero for all sampler variable types.</li>
<li><a class="el" href="classnvn_1_1_sampler_builder.html#a8313d8dd772ebf6e41a6314983012518" title="Set LOD snap used for Sampler objects created from the SamplerBuilder.">nvn::SamplerBuilder::SetLodSnap</a> sets the LOD snap for an optimization that reduces texture bandwidth consumption with minification filters that average samples in multiple texture LODs. When performing texture lookups, hardware will round (snap) the computed texture LOD to the nearest integer if the difference between the computed LOD and the integer value is less than the snap value in the sampler. LOD values that are not snapped are adjusted so that the function adjusting the LOD value is continuous. When snapping occurs, hardware will save bandwidth by sampling from only one mipmap level instead of two. Valid values for the LOD snap are in the range [0.0, 0.5], where 0.0 will result in no snapping and 0.5 would round most computed LODs to integer values. Not all values are supported by the hardware; the driver will select a supported snap value close to the value provided in the sampler.</li>
</ul>
<p>After a sampler object is created using the state in the sampler builder, it must be registered in a sampler pool and combined with a texture pool entry to form a texture handle, as discussed in detail in the <a href="#nvn_guide_textures">texture section of this guide</a>. Additionally, applications are able to set up sampler pool entries directly from sampler builder state without creating sampler objects.</p>
<h2><a class="anchor" id="nvn_guide_sec_6_1"></a>
6.1. Sampler Interactions with Textures</h2>
<p>In NVN, texture and sampler objects are programmed independently, and the driver has no opportunity to tweak sampler state to match the texture used or vice-versa. Some combinations of texture and sampler state are not supported and behave as follows:</p>
<ul>
<li>When using textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a505a74176236dd724a336accb9fafd3c" title="Two-dimensional texture, accessed with non-normalized coordinates.">nvn::TextureTarget::TARGET_RECTANGLE</a>, repeating or mirroring wrap modes are not supported. The modes <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9caf2325145003e509b5e7aa585c67ddaad" title="When filtering, texels outside the [0,1] range are mapped back to values in [0,1] by using only the f...">nvn::WrapMode::REPEAT</a>, <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca6c0157be29aafa4d8be8180b81d3c3e7" title="Texture coordinates are mirrored around zero and then treated like CLAMP.">nvn::WrapMode::MIRROR_CLAMP</a>, <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca375c585bdd10051ec10040f9a813bfaa" title="Texture coordinates are mirrored around zero and then treated like CLAMP_TO_EDGE.">nvn::WrapMode::MIRROR_CLAMP_TO_EDGE</a>, <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9cade0d5b48c2f41cb31f2a08d6635b53a0" title="Texture coordinates are mirrored around zero and then treated like CLAMP_TO_BORDER.">nvn::WrapMode::MIRROR_CLAMP_TO_BORDER</a>, and <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca8dfc80108fa495057306c9b16da46414" title="Texture coordinates are mirrored around zero and then treated like REPEAT.">nvn::WrapMode::MIRRORED_REPEAT</a> will be remapped by hardware to <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca95d06bd7f46540878b60b1db0f1d234d" title="Texture coordinates are clamped to the range [0,1] before filtering.">nvn::WrapMode::CLAMP</a>.</li>
<li>When doing a lookup from a depth or stencil texture using wrap modes that involve the border color, the border value (a depth or stencil value) used for filtering will be taken from either the R or G component of the border color depending on the texture format. We recommending programming the same component in all four components of the border color.</li>
<li>When using depth textures, shadow mapping is programmed separately in GLSL shader code (using the <code>sampler*Shadow</code> variable types) and in sampler objects. As in OpenGL, results of texture mapping are undefined if these are programmed inconsistently.</li>
<li>When using depth/stencil textures in stencil mode (<a class="el" href="structnvn_1_1_texture_depth_stencil_mode.html#a9e5440037111eb2ffbf759ec9db9f1d6aa61144ff54cf3ea7cb280f15db8a26b2" title="Return stencil data as unsigned integer values.">nvn::TextureDepthStencilMode::STENCIL</a>), hardware will perform a comparison of the stencil values if used with a sampler with depth comparisons enabled. Depth comparisons should be disabled in the sampler in this case.</li>
<li>When textures with signed or unsigned integer components use a sampler with linear or anisotropic filtering enabled, hardware will compute a weighted average of the integer values, and return a rounded integer value. If an averaged value is not desired, disable anisotropic filtering and use only the <code>NEAREST</code> or <code>NEAREST_MIPMAP_NEAREST</code> filters.</li>
<li>When using sRGB-encoded textures with border color components other than 0.0 or 1.0, applications must avoid using texture swizzles mapping the original alpha component into a non-alpha component of the final output vector. Failing to do so could result in an improperly encoded border value.</li>
</ul>
<h1><a class="anchor" id="nvn_guide_programs"></a>
7. Program Objects</h1>
<p>The <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> object represents a collection of programmable shaders that can be bound as a unit for rendering or compute operations. A program can contain or one or multiple vertex, tessellation control, tessellation evaluation, geometry, and fragment shaders, which are referred to collectively as graphics shaders. Alternately, the program can hold a single compute shader used to process compute dispatches. Graphics and compute shaders operate completely independently, and a single program object can not contain both graphics and compute shaders.</p>
<p>To create a new program, applications should call <a class="el" href="classnvn_1_1_program.html#a2bf86820737ab112fcc993736f8bfe3c" title="Initialize a Program object for the specified device.">nvn::Program::Initialize</a> to initialize the object and then load shaders into the program using <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>. When an application is done using a program, it should be released using <a class="el" href="classnvn_1_1_program.html#a365787d302b9b33508787046ab18d083" title="Finalize a Program object.">nvn::Program::Finalize</a>.</p>
<p>NVN does not support compiling shaders from source as part of the API. Shaders loaded into a program object with <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a> use the output of the GLSLC compiler library. These shaders may be compiled for the NX platform using an off-line version of the compiler library (built for Windows on x86 and x64 CPUs) when the shader assets for the application are being compiled, or using an on-line version of the compiler library (built for ARM CPUs) when the application is being executed.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Shader code produced for the NX platform will not run directly on the Windows NVN reference implementation, which supports a number of different NVIDIA GPUs with different instruction encodings. When using the reference implementation, applications must generate "fat" shader binaries. These binaries will store extra information in the control section of the shader binary so that the NVN driver can generate appropriate executable code for the discrete GPU used by the reference implementation. </p>
</blockquote>
<p>Program objects are set up for use by graphics primitives or compute dispatches using <a class="el" href="classnvn_1_1_command_buffer.html#a533458762741e1851a0d64a766593b5d" title="Bind or unbind shaders in a Program object for subsequent rendering commands.">nvn::CommandBuffer::BindProgram</a>. Each queue has an active shader for each programmable shader stage (vertex, tessellation control, tessellation evaluation, geometry, fragment, and compute), and BindProgram can be used to set the active shader for one or multiple stages. The argument <em>program</em> identifies a program object containing one or more shaders or can be NULL to indicate no program object. The argument <em>stages</em> is a bitfield of type <a class="el" href="structnvn_1_1_shader_stage_bits.html" title="Specifies a set of programmable shader stages.">nvn::ShaderStageBits</a> identifying the set of shader stages to update. For each shader stage enabled in <em>stages</em>:</p>
<ul>
<li>the shader stage is enabled and uses the appropriate shader from <em>program</em>, if <em>program</em> is non-NULL and contains a shader for the stage; or</li>
<li>the shader stage is disabled if <em>program</em> is NULL or <em>program</em> does not contain a shader for the stage.</li>
</ul>
<p>BindProgram does not support binding only a subset of shaders present in a program object; binding a non-NULL program will always activate all its shaders, regardless of the value of <em>stages</em>. When <em>program</em> is non-NULL, the bitfield <em>stages</em> must include bits for all stages present in <em>program</em>.</p>
<h2><a class="anchor" id="nvn_guide_sec_7_1"></a>
7.1. Compiled Shader Code</h2>
<p>The output data produced by the GLSLC shader compiler library include two sections used by <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>:</p>
<ul>
<li>The <em>data</em> section includes the shader binary code required to execute the shader, additional information about the shader code that is consumed by the GPU, and data values (e.g., constants) used by the executable shader code.</li>
<li>The <em>control</em> section provides additional information about the shader that will be required by the driver to program the hardware to execute the shader. On the Windows reference implementation, the control section of "fat" shader binaries will also include enough information for the driver to produce shader code that can be used on the GPU used by the reference implementation.</li>
</ul>
<p>Both sections must be passed to the driver when the shader is loaded into a program.</p>
<p>Before setting up a program object, applications should load the data section of a shader into a GPU-accessible <a href="#nvn_guide_memory_pools">memory pool</a> that has the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1ffdc01c00bf57c8a42913d7600f9233" title="Indicates that the memory pool may be used to store shader code for execution.">nvn::MemoryPoolFlags::SHADER_CODE</a> flag set. The application must load the data section at a 256B-aligned offset in the pool and obtain or compute an <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a> value pointing at the pool memory where the shader is loaded. When the program is bound, the shader code will be executed directly by the GPU at the provided address. Applications must also avoid loading shader code in the last 1KB of any memory pool. This last 1KB of a pool should not be used because the GPU shader cores may pre-fetch from instruction memory beyond the last byte of actual shader code, which could fault if the GPU virtual address space beyond the end of the pool is unpopulated. For graphics developer tools to be able to access the shader program at run-time, memory pools holding shader code should not have the flag <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384" title="Indicates that the memory pool will not be accessed by the CPU.">nvn::MemoryPoolFlags::CPU_NO_ACCESS</a>. Failure to adhere to this may prevent developer tools from working properly.</p>
<p>When loading shaders into the program, <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a> takes two arguments: a <em>count</em> parameter indicating the number of shaders to load into the program and a <em>stageData</em> parameter providing an array of <em>count</em> <a class="el" href="structnvn_1_1_shader_data.html" title="Data structure representing the shader data.">nvn::ShaderData</a> structures holding the code and control sections for each shader being loaded. Each shader data structure holds the buffer address where the code code section of the shader is stored, as well as a CPU pointer to the control section of the shader. Because <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a> does no shader compilation on the NX platform, loading will typically succeed. However, shader loading will fail and return <code>NVN_FALSE</code> if:</p>
<ul>
<li>The array of shaders include multiple shaders from the same stage. There is no separate <em>stage</em> argument provided to SetShaders because the shader stage is identified as part of the control section of the shader.</li>
<li>The set of shaders includes both a compute shader and one or more graphics shaders; a single program can include only graphics shaders or only compute shaders.</li>
</ul>
<p>On the Windows reference implementation, where NX shader code is not executed directly, the shader code address provided in <a class="el" href="structnvn_1_1_shader_data.html" title="Data structure representing the shader data.">nvn::ShaderData</a> is ignored. Instead, shader code is generated using information stored in the control section of the shader output. If the reference implementation is unable to generate valid shader code for the target GPU (e.g., if the shader uses a feature not supported by the target), <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a> will fail and return <code>NVN_FALSE</code>.</p>
<p>When loading shaders, applications must provide valid data and control sections produced by the GLSLC shader compiler for each shader. If a program object is set up with invalid shader data or control sections, application crashes, hangs, or corruption may occur. Additionally, if the provided buffer address for the shader code is not properly aligned, or is freed or overwritten during the lifetime of the program object, attempts to execute the shader code can result in application crashes, hangs, or corruption.</p>
<h2><a class="anchor" id="nvn_guide_sec_7_2"></a>
7.2. Shader Scratch Memory</h2>
<p>Some shaders require the use of additional GPU memory in order to run on the hardware. Shaders that have complex flow control, require a lot of memory, or need to use arrays of temporary values may need to store values in off-chip per-device shader scratch memory.</p>
<p>To run such shaders, applications must provide a block of scratch memory to the GPU using <a class="el" href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6" title="Specify scratch memory required for shader execution.">nvn::CommandBuffer::SetShaderScratchMemory</a>. Each queue has a single block of scratch memory. Applications can change the scratch memory used by the queue at any time by submitting a command set containing a SetShaderScratchMemory command. However, changing scratch memory frequently may result in poor performance because the GPU will wait for all previously submitted rendering commands to complete before setting up the new scratch memory.</p>
<p>If an application uses shaders in multiple queues, it must program scratch memory separately for each queue. It is legal to share a single block of scratch memory between multiple queues, but applications must ensure that all queues are finished using a shared scratch memory allocation before freeing or reusing the memory.</p>
<p>The amount of memory that the driver needs to provide is a function of the requirements of the shaders used by the application. The output produced by the GLSLC library for each compiled shader includes a recommended amount of memory needed on the NX device as well as a minimum amount of memory required for each shader "warp" (collection of 32 SIMD shader threads). If the amount of scratch memory provided by the application is less than the required amount of memory needed, the GPU will automatically "throttle" shader execution by running only as many shader threads as will fit with the available scratch memory. Throttling can result in decreased overall performance. Failure to provide sufficient scratch memory to execute on all threads of a single warp will result in GPU errors for graphics shaders and skipped dispatches for compute shaders.</p>
<p>When running on an NX device, we recommend that applications provide the recommended amount of memory for the most demanding shader it uses. If the currently bound programs require scratch memory in multiple shader stages, it is not necessary to add the recommended sizes for each stage. For this case, it is sufficient to provide only enough memory to satisfy the requirements of the most demanding shader.</p>
<p>The debug layer can help catch issues when applications provide incorrect scratch memory for bound programs. These checks will happen only during a draw or compute dispatch, and the debug layer will only report scratch memory issues if <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a2b3504a7e2b60355fa60a9e6896269ef" title="Enable (TRUE) or disable (FALSE) level 4 debug layer for the device.">nvn::DeviceFlagBits::DEBUG_ENABLE_LEVEL_4</a> is enabled. If the application does not provide enough scratch memory for the shader to even execute (i.e. less than the minimum required amount), a debug layer error will be emitted. If the application provides enough memory to execute, but not enough memory to run the shader "un-throttled", a debug layer warning will be emitted.</p>
<p>On the Windows reference implementation, the driver manages its own internal scratch memory pool. For convenience, the Windows reference implementation will emit debug layer warnings and errors for throttling/insufficient memory based on the NX memory requirements, but the input memory pool to <a class="el" href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6" title="Specify scratch memory required for shader execution.">nvn::CommandBuffer::SetShaderScratchMemory</a> is not actually used on Windows. The Windows driver will always internally allocate enough scratch memory to run shaders unthrottled. Since pool memory is neither copied nor used in the Windows reference implementation, Windows applications may pass in NULL for the <em>pool</em> parameter of <a class="el" href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6" title="Specify scratch memory required for shader execution.">nvn::CommandBuffer::SetShaderScratchMemory</a>. This will still generate a debug layer warning only once per lifetime of the device which will indicate that NULL pools are only allowed on the Windows reference implementation but not on NX.</p>
<p>Applications can compute the amount of memory needed using the per-warp requirements for individual shaders and the following device properties:</p>
<ul>
<li><a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5823bffb01b209fcc2a7ae41bcb386d7" title="Scale factor for the recommended amount of memory.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_SCALE_FACTOR_RECOMMENDED</a> provides a scale factor that can be multiplied by per-warp memory requirement to determine the amount of scratch memory needed in order to run the shader without throttling.</li>
<li><a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da9876dab7aec2bc4f56784f210f84cd50" title="Minimum scale factor for providing scratch memory for non-compute shaders.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_SCALE_FACTOR_MINIMUM</a> and <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab68b27f061f6d566500ce4b985d7446c" title="Minimum scale factor for providing scratch memory for compute shaders.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_COMPUTE_SCALE_FACTOR_MINIMUM</a> provides scaling factors that can be multiplied by per-warp memory requirement to determine the amount of scratch memory needed in order to run the shader at all (with maximum throttling and low performance). The former factor applies to non-compute shaders; the latter applies to compute shaders.</li>
<li><a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da8b8ab4e85b70b3f1308efc8693a6291f" title="Required granularity for shader scratch memory provided to NVN.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_GRANULARITY</a> provides the minimum granularity of the per-device scratch memory allocation; scratch memory amounts must be padded to the next largest multiple of the granularity; and</li>
<li><a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da680a0b084aacbf2e3ee8cf18b72e60f6" title="Alignment required (in bytes) for the shader scratch memory.">nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_ALIGNMENT</a> provides the minimum alignment of the global scratch memory allocation provided to the device.</li>
</ul>
<p>The recommended total amount of memory for a shader can be computed with code like the following: </p><pre class="fragment">nvn::Device device;
size_t computeScratchSize(nvn::Device &amp;device, struct MyShaderInfo *shaderInfo)
{
  int scale, granularity;
  size_t bytes_per_warp = shaderInfo-&gt;bytes_per_warp;
  device.GetInteger(nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_SCALE_FACTOR_RECOMMENDED, &amp;scale);
  device.GetInteger(nvn::DeviceInfo::SHADER_SCRATCH_MEMORY_GRANULARITY, &amp;granularity);
  return granularity * ((bytes_per_warp * scale + granularity - 1) / granularity);
}
</pre><p> The minimum total amount of memory can be computed the same way, but using the minimum scale factors instead of the recommended scale factor.</p>
<p>When a target amount of scratch memory has been established, we recommend that applications allocate the scratch memory when initializing the NVN device and use <a class="el" href="classnvn_1_1_command_buffer.html#a2a65c1f2c4f9cde0395aa082526d52f6" title="Specify scratch memory required for shader execution.">nvn::CommandBuffer::SetShaderScratchMemory</a> when initializing each queue to set up the scratch memory for the queue. If an application can't establish a maximum scratch memory size when the application is built, it can pick an initial size and set up devices and queues using that size. If the a shader requiring more memory is discovered after initialization, the application can allocate a new block of scratch memory, program the scratch memory in its queues, and then free the old scratch memory when previously submitted GPU commands have completed.</p>
<p>For convenience, the offline compiler's output for each shader stage contains a flag <a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62" title="The total amount of local memory recommended for this program on a NX device.">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a> which has the output value for the <em>total</em> recommended amount of scratch memory the shader would need to be run on an NX device. <a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62" title="The total amount of local memory recommended for this program on a NX device.">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a> is computed using the same formula listed in this chapter, using device property values of an NX device. <a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62" title="The total amount of local memory recommended for this program on a NX device.">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a> can be used on both NX devices and the Windows reference implementation (though Windows will manage its own internal scratch memory).</p>
<p>If applications wish to calculate scratch memory scaling factors without using device properties, they can use the definitions in the header file <a class="el" href="nvn___device_constants_n_x_8h.html" title="Constants holding values that would be returned for queries of various NVN DeviceInfo properties on t...">nvn_DeviceConstantsNX.h</a>. These scaling factors can also be used on the Windows reference implementation.</p>
<h2><a class="anchor" id="nvn_guide_sec_7_3"></a>
7.3. Shader Resources</h2>
<p>In NVN, each GLSL shaders can access a variety of different buffer and texture binding points during shader execution, as indicated in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Resource   </th><th class="markdownTableHeadNone">Count   </th><th class="markdownTableHeadNone">Binding API    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uniform blocks   </td><td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081" title="Bind a range of a Buffer object to use for fetching shader uniform values.">nvn::CommandBuffer::BindUniformBuffer</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">shader storage blocks   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a1e8f4df985fe6d64ede82ae19a5ee9d7" title="Bind a range of a Buffer object to use for random-access reads and writes in shaders.">nvn::CommandBuffer::BindStorageBuffer</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">texture handles   </td><td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901" title="Bind a Texture/Sampler pair to use for texture mapping in shaders.">nvn::CommandBuffer::BindTexture</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">image handles   </td><td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab" title="Bind a Texture to use for image loads and stores in shaders.">nvn::CommandBuffer::BindImage</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sampler-only handles   </td><td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSampler</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">texture-only handles   </td><td class="markdownTableBodyNone">128   </td><td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a>   </td></tr>
</table>
<p>Each shader stage supports up to 14 uniform blocks, 16 shader storage blocks, 32 bound texture handles, 8 bound image handles, 32 bound separate sampler-only handles, and 128 bound separate texture-only handles. Unlike OpenGL, NVN provides a separate set of bindings for each shader stage; all of the binding APIs for these resources have a <em>stage</em> parameter indicating which stage's bindings should be updated. All of these resources can be associated with a specific per-stage binding number using the <code>binding</code> layout qualifier. For example: </p><pre class="fragment">layout(binding = 4) uniform UBO4  { vec4 value1; };
layout(binding = 0) buffer SSBO0  { vec4 value2; };
layout(binding = 3) uniform sampler2D sampler3;
</pre><p> declares a uniform block with storage provided by uniform buffer binding point 4, a shader storage block with storage provided by shader storage buffer binding point 0, and a sampler using the texture handle bound to texture binding point 3. Shader resources not explicitly assigned a binding point in shader text will have a binding point assigned by the GLSLC compiler during compilation that is returned in the reflection section of the compiler output.</p>
<p>The commands <a class="el" href="classnvn_1_1_command_buffer.html#a486ff1b4cd3e5dc02263c20e65e23081" title="Bind a range of a Buffer object to use for fetching shader uniform values.">nvn::CommandBuffer::BindUniformBuffer</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a1e8f4df985fe6d64ede82ae19a5ee9d7" title="Bind a range of a Buffer object to use for random-access reads and writes in shaders.">nvn::CommandBuffer::BindStorageBuffer</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901" title="Bind a Texture/Sampler pair to use for texture mapping in shaders.">nvn::CommandBuffer::BindTexture</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSampler</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#aa4748cba765d583a25c409e57645c7ab" title="Bind a Texture to use for image loads and stores in shaders.">nvn::CommandBuffer::BindImage</a> all bind a single resource to single binding point. The commands <a class="el" href="classnvn_1_1_command_buffer.html#aeb9743dc0cc5c7fbf449053aca7cb562" title="Bind one or more Buffer object ranges to use for fetching shader uniform values.">nvn::CommandBuffer::BindUniformBuffers</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a23714ab975ced5fe2a5502504e34a59c" title="Bind one or more Buffer object ranges to use for random-access reads and writes in shaders.">nvn::CommandBuffer::BindStorageBuffers</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a3256b8853627d7b5cf003c2e4e807f2d" title="Bind one or more Texture/Sampler pairs to use for texture mapping in shaders.">nvn::CommandBuffer::BindTextures</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a9e12db39b6d1672fee21a7915219c621" title="Bind one or more separate textures to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTextures</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a80cb59e7b9cf2c3722d5b9f90815f57c" title="Bind one or more Samplers to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSamplers</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a419c6e03d540096c3cc4ddf1ec04183b" title="Bind one or more Textures to use for image loads and stores in shaders.">nvn::CommandBuffer::BindImages</a> can be used to bind multiple resources to consecutive binding points in a single call.</p>
<h3><a class="anchor" id="autotoc_md70"></a>
Uniforms</h3>
<p>Unlike OpenGL and OpenGL ES, NVN does not support GLSL uniform variables outside blocks, except for sampler, image, and separate sampler/texture uniforms associated with the binding points discussed above. These "default" uniforms are not supported because NVN allocates no per-shader uniform storage and provides no API like OpenGL's <code>glUniform1i</code> to load individual uniform values into memory. When compiling for NVN, the GLSLC compiler will reject any shader that declares uniforms other than the above specified bound resource types outside uniform blocks.</p>
<p>The contents of uniform buffers can be updated in a number of different ways: using a CPU mapping of the buffer, using copy commands, or using the dedicated command <a class="el" href="classnvn_1_1_command_buffer.html#a2a0c771367c9d655052cfc1657aa70ca" title="Update the contents of a uniform buffer.">nvn::CommandBuffer::UpdateUniformBuffer</a>. When updating uniform buffers with the CPU, applications must wait on the completion of any previously submitted commands needing to use the old memory contents and must invalidate the shader caches using <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">nvn::CommandBuffer::Barrier</a> before using the new contents. When updating uniform buffers using UpdateUniformBuffer, no waiting or cache invalidation is required. Any shaders spawned by commands prior to the uniform update will see the old contents of the buffer and any shaders for commands after the update will see the new contents. Note that when using UpdateUniformBuffer, the <em>buffer</em> and <em>bufferSize</em> parameters identifying the buffer to update need to exactly match the address and size of a bound uniform buffer. If the memory updated by this command overlaps with a bound uniform buffer with a different address or size, the update is not guaranteed to be visible to new shader threads using the unmatched binding.</p>
<h3><a class="anchor" id="autotoc_md71"></a>
Bindless Resources</h3>
<p>In addition to accessing buffers and textures through the binding points described above, shaders can also access these resources directly by using <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a>, <a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08" title="GPU handle used to refer to a texture object for texture mapping operations.">nvn::TextureHandle</a>, <a class="el" href="structnvn_1_1_separate_texture_handle.html" title="Structure containing a GPU handle used to refer to a separate texture object for texture mapping oper...">nvn::SeparateTextureHandle</a>, <a class="el" href="structnvn_1_1_separate_sampler_handle.html" title="Structure containing a GPU handle used to refer to a separate sampler object for texture mapping oper...">nvn::SeparateSamplerHandle</a>, and <a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2" title="GPU handle used to refer to a texture object for image load and store operations.">nvn::ImageHandle</a> values in shaders without making any API binding calls, using the following "bindless graphics" shading language extensions:</p>
<ul>
<li><a href="https://www.opengl.org/registry/specs/NV/bindless_texture.txt">NV_bindless_texture</a></li>
<li><a href="https://www.opengl.org/registry/specs/NV/shader_buffer_load.txt">NV_shader_buffer_load</a></li>
<li><a href="https://www.opengl.org/registry/specs/NV/shader_buffer_store.txt">NV_shader_buffer_store</a></li>
</ul>
<p>To use buffer addresses and handles without bindings, the values may be passed as 64-bit data values to shaders using uniform buffers, vertex attributes, or using any other means. For example, this shader </p><pre class="fragment">#extension GL_NV_bindless_texture : require
#extension GL_NV_gpu_shader5 : require
...
struct Struct {
    vec4 member1;
    int member2;
};
uniform UBO {
    sampler2D tex0;
    Struct *s1;
};
...
vec4 value = texture(tex0, vec2(0,0)) + s1-&gt;member1;
</pre><p> will use the texture handle stored in the <code>tex0</code> member of the uniform block <code>UBO</code> to perform a texture lookup, and use the buffer address stored in the <code>s1</code> block member as a pointer to access the value of <code>member1</code> stored in memory.</p>
<p>64-bit integer types can also be used in place of the named "sampler" types in uniform buffers. The shader must create a sampler object from an appropriate constructor (ex. sampler2D(uint64_t) constructor) before making a texture lookup. For example, the following shader could be used in functionally the same way as the above shader: </p><pre class="fragment">#extension GL_NV_bindless_texture : require
#extension GL_NV_gpu_shader5 : require
...
struct Struct {
    vec4 member1;
    int member2;
};
uniform UBO {
    uint64_t tex0;
    Struct *s1;
};
...
vec4 value = texture(sampler2D(tex0), vec2(0,0)) + s1-&gt;member1;
</pre><p> Applications can also interface with shaders that use bindless sampler-only and texture-only handles. The handles can be combined within the shader to create a combined handle compatible with the sampler constructors. The value <a class="el" href="structnvn_1_1_separate_texture_handle.html#a5b3ee5c40a146c3d92ff4f8a87615bdb" title="GPU handle used to refer to a separate texture object for texture mapping operations.">nvn::SeparateTextureHandle::value</a> and <a class="el" href="structnvn_1_1_separate_sampler_handle.html#aa0967c62c6c257373d564316a670460e" title="GPU handle used to refer to a separate sampler object for texture mapping operations.">nvn::SeparateSamplerHandle::value</a> should be used when filling uniform buffer memory. For example, the following shader performs a texture lookup by combining a texture-only and sampler-only handle together: </p><pre class="fragment">#extension GL_NV_bindless_texture : require
#extension GL_NV_gpu_shader5 : require
...
struct Struct {
    vec4 member1;
    int member2;
};
uniform UBO {
    uint64_t sampOnlyHandle;
    uint64_t texOnlyHandle;
    Struct *s1;
};
...
uint64_t sampCombinedHandle = sampOnlyHandle | texOnlyHandle;
vec4 value = texture(sampler2D(sampCombinedHandle), vec2(0,0)) + s1-&gt;member1;
</pre><p> The separate sampler/texture handles themselves should be obtained by applications using the function nvn::GetSeparateTextureHandle and nvn::GetSeparateSamplerHandle instead of nvn::GetTextureHandle.</p>
<h3><a class="anchor" id="autotoc_md72"></a>
Separate Samplers and Textures</h3>
<p>In addition to the bindless mode described previously it is also possible to use the <code>GL_NV_separate_texture_types</code> extension to define separate samplers and textures in GLSL shaders.</p>
<p>For example the standard GLSL code for fetching a texture: </p><pre class="fragment">layout(binding = 0) uniform sampler2D myTexture;
...
vec4 value = texture(myTexture, vec2(0,0));
</pre><p> can be re-written as: </p><pre class="fragment">#extension GL_NV_separate_texture_types : enable
...
layout(binding = 0) uniform texture2D myTexture;
layout(binding = 0) uniform sampler mySampler;
...
vec4 value = texture(sampler2D(myTexture, mySampler), vec2(0,0));
</pre><p> Binding textures application-side needs to be modified, with each call to <a class="el" href="classnvn_1_1_command_buffer.html#a4f1b66c1660d5692b9e337db1262f901" title="Bind a Texture/Sampler pair to use for texture mapping in shaders.">nvn::CommandBuffer::BindTexture</a> replaced by a call to <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a> and a call to <a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSampler</a>.</p>
<p>Note that it is also necessary to pass the <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999ab7f10346fa515d311b19a8669f2bdb87" title="Enable (TRUE) or disable (FALSE) separate sampler/texture support.">nvn::DeviceFlagBits::ENABLE_SEPARATE_SAMPLER_TEXTURE_SUPPORT</a> flag at device creation time to enable support for separate samplers and textures.</p>
<blockquote class="doxtable">
<p>SPIR-V shaders, which natively support sampler-only and texture-only types, are also supported in the same way, with application code relying on the same <a class="el" href="classnvn_1_1_command_buffer.html#a3c573173dbcfeda3576f8bf6ed55407e" title="Bind a separate Texture to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a32a0cf86766888156ef4f1b50f2095e1" title="Bind a separate Sampler to use for texture mapping in shaders.">nvn::CommandBuffer::BindSeparateSampler</a> calls to perform the bindings. If the SPIR-V shader is generated from GLSL code, separate textures and samplers can be declared in a similar fashion as described above since the GLSL syntax is compatible with both the <code>GL_NV_separate_texture_types</code> extension and the <a href="https://www.khronos.org/registry/vulkan/specs/misc/GL_KHR_vulkan_glsl.txt">GL_KHR_vulkan_glsl</a> extension. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md73"></a>
Shader Subroutines</h3>
<p>Shader subroutine support in the NVN API as well as the GLSLC offline compiler matches subroutine support defined in the GLSL 4.00 specification and has similar API-level functionality to <a href="https://www.opengl.org/registry/specs/ARB/shader_subroutine.txt">the ARB_shader_subroutine OpenGL extension</a>.</p>
<p>Shader subroutine functionality allows an application to dynamically alter the code paths executed by a shader at run-time through the NVN API. Shaders can declare subroutine types that can be used by subroutine calls. Subroutine types are conceptually similar to C/C++ function pointer types. Shaders can also declare shader subroutine uniforms using one of the declared subroutine types. Subroutine uniforms are used by shader code similarly to a normal function call. Shader functions that can be assigned to subroutine uniforms are declared using the "subroutine" qualifier and one or more subroutine types. A call using a subroutine uniform in a shader will execute the subroutine function assigned to that uniform by the application.</p>
<p>One possible use of subroutines would have an application shader implement a variety of different lighting algorithms where the color of an object is evaluated based on different object or light properties. In this approach, each algorithm is implemented in a separate subroutine function, and all subroutine functions take the same parameters and return the same values. The shader makes lighting function calls using a subroutine uniform whose value is selected in the NVN API based on the properties of the objects being rendered.</p>
<p>When GLSL shaders with subroutines are compiled, each subroutine function in a shader stage will get assigned a unique <em>index</em> value, and each subroutine uniform will get assigned a unique <em>location</em> value by the compiler. Explicit layout qualifiers can be used to explicitly control the assignment of index and locations in the shader, otherwise it is the application's responsibility to read the compiler-assigned index and location values from the compiler's reflection information.</p>
<p>For an overview of subroutine syntax and offline compiler reflection output, please see the GLSLC programming guide. The rest of this section will focus on how to use subroutines via the NVN API.</p>
<p>Two functions must be used in NVN applications using programs compiled with subroutines: <a class="el" href="classnvn_1_1_program.html#a7329f858542939f8b7a72123c3c71a5d" title="Sets the program&#39;s subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines.">nvn::Program::SetSubroutineLinkage</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a>.</p>
<p><a class="el" href="classnvn_1_1_program.html#a7329f858542939f8b7a72123c3c71a5d" title="Sets the program&#39;s subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines.">nvn::Program::SetSubroutineLinkage</a> is used to provide the NVN driver with a block of data called a <em>linkage map</em>. The linkage map is an opaque data structure which is obtained directly from the GLSLC offline compiler as part of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure.">GLSLCoutput</a> for each program stage containing subroutines. The driver will internally use the linkage map to configure the shader code to execute the subroutine functions assigned to the uniforms. The memory holding the linkage map used with <a class="el" href="classnvn_1_1_program.html#a7329f858542939f8b7a72123c3c71a5d" title="Sets the program&#39;s subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines.">nvn::Program::SetSubroutineLinkage</a> must be writeable since the driver will use portions of the linkage map's data as scratch space to record bindings between subroutines and subroutine uniforms, as well as other meta-information needed to program the hardware for the shader program execution. The linkage map only needs to be set once for a <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> which contains subroutines in at least one of its shader stages and should typically be done immediately after (but not before) a call to <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>. Because the both the program's linkage map and the shader code are updated by calls to <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a>, sharing a single program containing subroutines between two queues is not practical. An application that wishes to use the same program in multiple queues should make multiple copies of the program code and the linkage map so that subroutine updates to one program do not affect the other instances of the same program.</p>
<p><a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a> is a function which lets the application specify which subroutines to bind to each subroutine uniform location. This function is similar to OpenGL's UniformSubroutinesuiv function, with the exception that NVN allows the application to specify a range of uniform locations to be updated instead of requiring that all uniforms need to be updated at the same time. A program with subroutines does not need to be bound at the time of the function call, and in fact other programs that are bound will not be affected by calls to <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a>.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a> is not a thread-safe call. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: Since <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a> updates the shader code and the linkage map, all calls must be completed by the GPU before the memory can be freed. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: <a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a> will only be evaluated at command buffer submit time, but the program used as input needs to be set up before a call to this function is made. </p>
</blockquote>
<p>As an example to illustrate how to use NVN with a program containing subroutines, consider a program containing the following fragment shader:</p>
<pre class="fragment">#version 440

// Define a subroutine type
subroutine vec4 subroutineType0 (vec4, float);

// Define 2 subroutine functions of type subroutineType0.  The first function
// performs a scaling operation on the input vec4.  The second function performs
// an additive operation.

layout (index = 0) subroutine(subroutineType0)
vec4 scaleSubroutine (vec4 input, float scaleAmt) {
    return input * scaleAmt;
}

layout (index = 1) subroutine(subroutineType0)
vec4 additionSubroutine (vec4 input, float additionAmt) {
    return input + vec4(additionAmt);
}

// Define a subroutine uniform of type subroutineType0
layout (location = 0) subroutine uniform subroutineType0 performOperation0;

// Define a subroutine uniform of type subroutineType0
layout (location = 1) subroutine uniform subroutineType0 performOperation1;

uniform Block {
    float operationAmt;
};

in vec4 inColor;
out vec4 outColor;

void main() {
    // Call the subroutine uniforms.  This will either call either
    // scaleSubroutine or additionSbroutine depending on how the
    // application binds the two subroutine uniforms.
    outColor = performOperation0(inColor, operationAmt) +
               performOperation1(inColor, operationAmt);
}
</pre><p> After calling <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>, the application needs to bind the linkage map produced by offline compiler to the <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> it corresponds to.</p>
<p>In an NVN application, the sequence would look similar to: </p><pre class="fragment">// Assume subroutineProgram is a previously initialized nvn::Program object with a vertex and fragment stage,
// and the fragment stage is the only stage which uses subroutine uniforms.
// Assume shaderData is an array of NVNshaderData blocks obtained from the offline compiler.
// Assume fragmentLinkageMap is the linkage map for the fragment stage obtained by the offline compiler for this
// program.

// Create an array to hold linkage maps for all potential stages which uses subroutines.
int numberOfLinkageMaps = 0;
NVNsubroutineLinkageMapPtr linkageMaps[6];

// In this example, only the fragment stage uses subroutines and requires a
// linkage map, but if any other stage uses subroutines then their linkage
// maps would also need to set in the input array.  Each linkage map also
// contains information about which shader stage it corresponds to, so the
// application does not need to provide the stage information to the
// driver.
linkageMaps[numberOfLinkageMaps++] = fragmentLinkageMap;

// Set the shaders, and if successful, set the linkage map for this program.
if (subroutineProgram.SetShaders(2, shaderData)) {
    // Set the linkage maps from the offline compiler.
    subroutineProgram.SetSubroutineLinkage(numberOfLinkageMaps, linkageMaps);
}

// ...
</pre><p> Note that in the above code, the shader stages for the linkage map was not specified. Each linkage map has meta-data describing which stage it came from, so the driver can determine this from the input linkage maps.</p>
<p>Before executing the above <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> using the above shader code, the NVN application would need to associate the subroutine uniforms performOperation0 and performOperation1 at locations 0 and 1, repsectively, with one of the 2 subroutines defined with the same type of subroutineType0 at either index value 0 or 1. </p><pre class="fragment">// Assume cb is an nvn::CommandBuffer object.

// We select subroutine with index 1 to be assigned to the uniform at location 0, and set subroutine with index 0 to the
// subroutine uniform at location 1.
// This binds performOperation0 to the subroutine "additionSubroutine", and
// binds performOperation1 to the subroutine "scaleSubroutine".
int uniformIndexValue[2] = {1, 0};
int numSubroutineUniformLocations = 2;

cb.SetProgramSubroutines(subroutineProgram, NVN_SHADER_STAGE_FRAGMENT, 0, numSubroutineUniformLocations, uniformIndexValue);

// At this point, all stages with subroutines have been updated, so use the program to draw.
// ...
</pre><p> After this first update, the application could update just one of the selected uniforms if it wishes instead of specifying all subroutine uniforms. </p><pre class="fragment">// Update only the subroutine at location 1.
cb.SetProgramSubroutines(subroutineProgram, NVN_SHADER_STAGE_FRAGMENT, 1, 1, &amp;uniformIndexValue[1]);
</pre> <blockquote class="doxtable">
<p><b>NOTE</b>: Applications should initially set all subroutine uniform locations. An arbitarily chosen default value will be used for any subroutine uniform not initialized. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: Only use the linkage map with the program that it was generated with from the offline compiler. Attempting to use linkage maps with programs that the data was not generated with will result in errors and possibly crashes. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: There is no debug layer support yet for validating correct usage of subroutines. This is expected in the next NVN release. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: Programs with subroutines must be compiled with GLSLC implementing code version 1.7 or later. </p>
</blockquote>
<h1><a class="anchor" id="nvn_guide_command_buffers"></a>
8. Command Buffer Objects</h1>
<p>The <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> object is used to assemble collections of commands (called <em>command sets</em>) in memory, which will later be submitted to <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a> objects for processing by the GPU. Command sets can be built in parallel and independently from queues used to submit them. For example, an application may use a parallel job system where each "worker" CPU thread builds its own command sets to render a portion of a larger scene, and a single "master" CPU thread submits command buffers built by worker threads when command set construction completes.</p>
<h2><a class="anchor" id="nvn_guide_sec_8_1"></a>
8.1. Command Set Recording and Submission</h2>
<p>A command set is constructed by accumulating a list of commands into CPU- and GPU-accessible memory. When a command set is submitted for processing to an <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a> object, the commands in the command set will be played back on the GPU in the order that they were added to the command set. The commands in a command set are used to update GPU state and to render primitives. A new command set is assembled by:</p>
<ul>
<li>Calling <a class="el" href="classnvn_1_1_command_buffer.html#a569698f00f43c1074330c137b97f9e81" title="Begin recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::BeginRecording</a> to begin recording the new command set.</li>
<li>Calling other <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> methods to add new commands to the command set under construction.</li>
<li>Calling <a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording</a> to complete recording the new command set. This method returns an <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb" title="GPU handle used to refer to a command buffer object.">nvn::CommandHandle</a> that refers to the command set and can be used to submit the command set for processing by the GPU or to include the contents of the command set in other command sets.</li>
</ul>
<p>Each command buffer may only record one command set at a time. Command buffer recording is not thread-safe; NVN performs no locking (and thus incurs no locking overhead) when accessing command buffers. Multiple threads attempting to record commands to the same command buffer at the same time may result in memory corruption or crashes. Applications are free to record command sets on multiple threads concurrently, but should do so with separate command buffer objects with separate command buffer memory.</p>
<p>A single command buffer object may be used to record multiple command sets sequentially. The first command set recorded in the command buffer will be recorded at the beginning of the memory provided by the application for command set recording. Once this command set is fully recorded, recording a second command set will use the memory immediately following the memory consumed by the first command set.</p>
<p>The command buffer handle returned by <a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording</a> may be passed to <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> to send the contents of the recorded command set to the GPU. State change commands in the command set will update the current state of the queue, and will affect rendering for subsequent commands in the command set. State changes from one command set will also affect rendering for future command sets until the state in question is changed again. <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> can accept multiple <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb" title="GPU handle used to refer to a command buffer object.">nvn::CommandHandle</a> values. In this case, the command sets are processed according to the order of the handles provided in the <em>handles</em> array.</p>
<p>Most commands recorded in a command set are submitted directly to the GPU. However, certain commands require additional processing when <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> is called. The following commands may record pointers to NVN objects that are dereferenced by SubmitCommands:</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a533458762741e1851a0d64a766593b5d" title="Bind or unbind shaders in a Program object for subsequent rendering commands.">nvn::CommandBuffer::BindProgram</a> (holds an <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> object, but only when using compute shaders)</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a7e968d43bfc4919804bf951101a17b65" title="Sets the subroutine uniform parameters.">nvn::CommandBuffer::SetProgramSubroutines</a> (holds an <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a> object, when using any shader type)</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a> (holds an <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> object)</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> (holds an <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> object)</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#ad36725731839793d678ce0243df56f94" title="Specify a new sampler pool used for subsequent rendering operations.">nvn::CommandBuffer::SetSamplerPool</a> (holds an <a class="el" href="classnvn_1_1_sampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects.">nvn::SamplerPool</a> object)</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a25f10e3257fe549de368e842e61ee8ee" title="Specify a new texture pool used for subsequent rendering operations.">nvn::CommandBuffer::SetTexturePool</a> (holds an <a class="el" href="classnvn_1_1_texture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects.">nvn::TexturePool</a> object)</li>
</ul>
<p>Submitting a command set containing references to NVN objects that have been finalized or overwritten may result in fatal CPU or GPU exceptions.</p>
<h2><a class="anchor" id="nvn_guide_command_buffer_memory_management"></a>
8.2. Command Buffer Memory Management</h2>
<p>To record the command sets, command buffer object will manage two types of memory blocks:</p>
<ul>
<li><b>command memory</b><br  />
 Used to record the commands to be submitted directly to the GPU.</li>
<li><b>control memory</b><br  />
 Used to record additional information needed to process command sets when submitting them to a queue.</li>
</ul>
<h3><a class="anchor" id="autotoc_md74"></a>
Initial Memory Allocations</h3>
<p>When the command buffer object gets initialized using nvn::ComamndBuffer::Initialize, the command buffer object does not hold command memory nor control memory. To build command sets, an application must provide command memory and control memory to the command buffer object using one of the following two ways.</p>
<ul>
<li>Explicitly adding the command memory and control memory</li>
<li>Expect the out of memory callback routine to assing the command memory and control memory as needed. For the detail of callback routine please refer to <a href="#nvn_guide_command_buffer_memory_callbacks">Command Buffer Memory Callbacks</a></li>
</ul>
<p>In ether case, use <a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d" title="Add command data memory for a CommandBuffer object.">nvn::CommandBuffer::AddCommandMemory</a> for adding command memory, and <a class="el" href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a" title="Add control memory for a CommandBuffer object.">nvn::CommandBuffer::AddControlMemory</a> for adding control memory.</p>
<h3><a class="anchor" id="autotoc_md75"></a>
Characteristics of memory to assign to command memory and control memory</h3>
<p>Memory blocks added to the command or control memory must meet the following characteristics.</p>
<ul>
<li><b>command memory</b><br  />
 The memory should come from a <a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a> object with CPU-accessible memory (either using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> or <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a>). Command buffers whose contents are submitted directly to the GPU must use <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> memory, <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> is not supported.<br  />
 <br  />
 <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356afb36e42ea7fdd4da445f195ccd641c58" title="Indicates that the memory pool will be accessed by the GPU without caching.">nvn::MemoryPoolFlags::GPU_UNCACHED</a> is strongly recommended for the GPU cache flag. This is especially so when the command memory is read once per frame since command memory is typically fetched sequentially by the GPU.<br  />
 If command memory is read many times in the same frame without changing the contents (for example, using <a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a>), using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b" title="Indicates that the memory pool will be accessed by the GPU with caching.">nvn::MemoryPoolFlags::GPU_CACHED</a> may have better performance. However, on NX, there is no hardware mechanism to ensure the GPU L2 cache coherency when the command memory is updated by the CPU. Therefore, when using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b" title="Indicates that the memory pool will be accessed by the GPU with caching.">nvn::MemoryPoolFlags::GPU_CACHED</a> command memory, it will be the developer's responsibility to keep the coherency of the GPU cache by flushing and/or invalidating the GPU cache on appropriate timing. The developer must refer to the section <a href="#nvn_guide_memory_pool_aliasing">Memory Pool Aliasing</a> and understand the restrictions of the GPU cache in detail prior to choosing <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b" title="Indicates that the memory pool will be accessed by the GPU with caching.">nvn::MemoryPoolFlags::GPU_CACHED</a>.</li>
<li><b>control memory</b><br  />
 The block of memory is provided using a plain CPU pointer, and should be CPU-cacheable.</li>
</ul>
<h3><a class="anchor" id="autotoc_md76"></a>
Recording to the command memory and the control memory</h3>
<p>Once the application has provided both command and control memory to the command buffer, command sets are recorded in the provided memory, starting at the first byte provided.</p>
<h3><a class="anchor" id="nvn_guide_command_buffer_memory_callbacks"></a>
Command Buffer Memory Callbacks</h3>
<p>When adding commands to command buffer memory, the NVN implementation will check for available space. If a <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> method requires more command or control memory than is available in the command buffer's current allocations, NVN will call an application-registered callback function:</p>
<ul>
<li>Each command buffer has its own callback function, which is registered using <a class="el" href="classnvn_1_1_command_buffer.html#a0aab9ff6d4872bd1bc75feb264dc5734" title="Set a callback function for a CommandBuffer object that will be called if it runs out of memory.">nvn::CommandBuffer::SetMemoryCallback</a>.</li>
<li>The callback function will be provided with three parameters:<ul>
<li>A pointer to the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> object that has run out of memory.</li>
<li>An <a class="el" href="structnvn_1_1_command_buffer_memory_event.html" title="Specifies the event type in a command buffer memory callback.">nvn::CommandBufferMemoryEvent</a> enum indicating whether the command buffer ran out of command memory or control memory.</li>
<li>An application-provided pointer registered in the command buffer using <a class="el" href="classnvn_1_1_command_buffer.html#a89bf59fb5a193439c2289387f33fb196" title="Specify a generic pointer that will be passed to a callback function if the command buffer runs out o...">nvn::CommandBuffer::SetMemoryCallbackData</a>. This pointer can be used to reference an application data structure with additional app-specific information on the command buffer.</li>
</ul>
</li>
</ul>
<p>When a command buffer memory callback receives an <a class="el" href="structnvn_1_1_command_buffer_memory_event.html#ae205102e87335273e0529a0747921686aebaaeb4238a35d6bc6a94b3e9800792d" title="The command buffer has run out of command memory.">nvn::CommandBufferMemoryEvent::OUT_OF_COMMAND_MEMORY</a> event, the application must provide the calling command buffer with new memory using <a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d" title="Add command data memory for a CommandBuffer object.">nvn::CommandBuffer::AddCommandMemory</a>. When a command buffer memory callback receives an <a class="el" href="structnvn_1_1_command_buffer_memory_event.html#ae205102e87335273e0529a0747921686a318b543d61439a5ce486ebf4761c4196" title="The command buffer has run out of control memory.">nvn::CommandBufferMemoryEvent::OUT_OF_CONTROL_MEMORY</a> event, the application must provide the command buffer with new memory using <a class="el" href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a" title="Add control memory for a CommandBuffer object.">nvn::CommandBuffer::AddControlMemory</a>.</p>
<p>Command buffer memory callbacks may occur while the driver is in the middle of writing to the command buffer. Out-of-memory callbacks should make no NVN calls other than adding new memory of the appropriate type or querying available memory. Adding memory of the "wrong" type or making other NVN calls in a command buffer memory callback could lead to memory corruption or program termination.</p>
<p>If a command buffer runs out of command or control memory, failing to register a callback for the command buffer or failing to provide new memory in the registered callback could lead to memory corruption or program termination.</p>
<p>A command buffer's out of memory callback may be explicitly toggled for command memory via <a class="el" href="classnvn_1_1_command_buffer.html#aec6f7480a9f868cffe1d348b8f076dc9" title="Enable or disable the memory callback when out of command memory.">nvn::CommandBuffer::SetCommandMemoryCallbackEnabled</a>. By default, the NVN implementation will conservatively invoke the callback when there is a risk of overrunning available command memory capacity. However, if an application has previously measured the amount of memory consumed by a sequence of commands (e.g., via <a class="el" href="classnvn_1_1_command_buffer.html#a93a4a7e4e8a7da91a1627d836548f788" title="Get the used size in bytes of the command memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetCommandMemoryUsed</a>), it can allocate precisely enough command memory for the command sequence. In such cases, an invocation of the memory callback near the end of the command sequence is undesireable and unnecessary.</p>
<p>Regardless of whether the callback is enabled or disabled for command memory, applications should always keep a non-NULL memory callback set for a command buffer that will receive commands. Disabling the memory callback is <em>not</em> equivalent to setting a NULL memory callback:</p>
<ul>
<li>The implementation may still invoke the memory callback to request additional control memory, even if the callback is disabled for command memory.</li>
<li>Exhausting command buffer memory with a NULL callback enabled may result in memory corruption or program termination.</li>
</ul>
<h3><a class="anchor" id="autotoc_md77"></a>
How command memory and/or the control memory is used</h3>
<p>When a new block of command or control memory is added, explicitly or via callback routine, subsequent command sets will be recorded to the new block of memory, regardless of the amount of memory you have left free on old blocks.</p>
<p>The following code will add a total of 3072 bytes of command memory but only the 2048 bytes chunk can be used since it was assigned by the second call to <a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d" title="Add command data memory for a CommandBuffer object.">nvn::CommandBuffer::AddCommandMemory</a>. The first chunk of 1024 bytes will be left unused: </p><pre class="fragment">// 'mp'     is pointer to memory pool created with necessary characteristics,
// 'ofs'    is offset from mp top where the chunk we wan to assign starts, and
// 'cmdBuf' is pointer to nvn::CommandBuffer object.
cmdBuf-&gt;AddCommandMemory(mp, ofs, 1024);
ofs += 1024;
cmdBuf-&gt;AddCommandMemory(mp, ofs, 2048);
</pre><p> Single command sets will be recoded within single block of command memory and control memory. Adding small memory blocks to command memory and/or control memory will likely cause waste of memory, plus require extra cycles. But assigning too big memory compare to total amount of command sets to be recorded, will also cause wasted unused memory.</p>
<p>Also, the amount of memory being used for each <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> method may vary based on methods being called prior to that call.</p>
<p>If you want to maximize the memory utilization of command memory and control memory, you should measure the exact amount of command memory and control memory necessary for specific path, and assign large block of memory enough to fulfill the needs, but not too large as to have too much unused memory.</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Measuring the command memory and the control memory usage</h3>
<p>Applications can track usage of command buffer memory using the following six commands:</p>
<ul>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#a29294f5d9eb53ec74c59e2ed6df4afd9" title="Get the total size in bytes of the command memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetCommandMemorySize</a></b><br  />
 returns the size in bytes of the currently used command memory.</li>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#a19c8fa0255e9e0845c46e7d5162de17c" title="Get the total size in bytes of the control memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetControlMemorySize</a></b><br  />
 returns the size in bytes of the currently used control memory.</li>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#a93a4a7e4e8a7da91a1627d836548f788" title="Get the used size in bytes of the command memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetCommandMemoryUsed</a></b><br  />
 returns the used size in bytes of the currently used command memory.</li>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#abec66e4ec6d42caca35de9f3fcfbf638" title="Get the used size in bytes of the control memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetControlMemoryUsed</a></b><br  />
 returns the used size in bytes of the currently used control memory.</li>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#aac49f0ab25fa651a0f4913a1b962c34f" title="Get the unused size in bytes of the command memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetCommandMemoryFree</a></b><br  />
 returns the unused size in bytes of the currently used command memory.</li>
<li><b><a class="el" href="classnvn_1_1_command_buffer.html#ad6c494a15150ea651feb87e44aeb0f67" title="Get the unused size in bytes of the control memory block that was lastly added to the CommandBuffer.">nvn::CommandBuffer::GetControlMemoryFree</a></b><br  />
 returns the unused size in bytes of the currently used control memory.</li>
</ul>
<p>As you can see, all six commands only returns information about the <em>current</em> memory block, not the total amount of blocks we add, nor memory block <em>previous</em> to the one being added.</p>
<p>To measure the total amount of memory being used for specific path of command sets, you must measure the status of memory before recording, every time before a new memory block is added (explicitly or via callbacks do not matter), and after recoding have ended. When <a class="el" href="classnvn_1_1_command_buffer.html#a7ce9763420147218acf41e01380c84bf" title="Complete recording a new set of commands in this CommandBuffer object.">nvn::CommandBuffer::EndRecording</a> was called, Command Buffer Object still have valid information about the command memory and control memory assigned last time.</p>
<p>Sum up the amount of memory being used for command memory and control memory. The total amount should equal for any number of times you have added the blocks of memory, as long as you've runned exactly same path with exactly same data and parameters.</p>
<h2><a class="anchor" id="nvn_guide_sec_8_3"></a>
8.3. Command Buffer Calls and Copies</h2>
<p>When recording a command set, an application can include the contents of other previously recorded command sets by copy or reference.</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a> accepts one or more command handles and adds their command sets (by reference) to the command set being recorded. When adding to a command set via CallCommands, control memory will be consumed by the new command set to store information needed to process the call when the command set being recorded is submitted to the queue. No new command memory will be consumed by the call.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CopyCommands</a> accepts one or more command handles and adds their command sets (by copy) to the command set being recorded. When adding to a command set via CopyCommands, command and control memory will be consumed, as the contents of the previously recorded command sets will be copied into the new command set.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_sec_8_4"></a>
8.4. Command Buffer Memory Usage</h2>
<p>Applications must manage memory provided to command buffers carefully. In particular, the command and control memory provided to a command buffer may not be freed or reused until processing of all previous uses of the memory have completed. The command memory used for a command set is not available for reuse until the GPU has finished processing all <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> calls that reference the command set. In addition to explicitly writing to the memory region, other examples of reuse include passing the memory region as a parameter to AddControlMemory, AddCommandMemory or SetStorage, which prepare the memory region for other uses. Applications can determine that a queue submission has been completed on the GPU by:</p>
<ol type="1">
<li>Calling <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> to insert a fence in the same queue where the command set was submitted, and then waiting on the fence's completion via <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a>.</li>
<li>Calling <a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">nvn::Queue::Finish</a> to wait for all commands previously submitted to the queue to complete.</li>
</ol>
<p>If a command set has been submitted to multiple queues, it is necessary to wait for completion on all queues. If a command set has been included by reference in another command set via <a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a>, it is also necessary to wait on the completion of any submissions referencing the command set. If a command set has not been submitted directly to a queue, but has only been included by copy in other command sets via <a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CopyCommands</a>, the command memory for the command set may be reused as soon as the last CopyCommands call has returned.</p>
<p>Applications do not need to wait GPU completion of command sets in order to reuse control memory. Control memory used for a command set is available for immediate reuse after all calls to <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a>, <a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a>, or <a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CopyCommands</a> that reference the command set's handle have returned.</p>
<p>When an application provides memory to a command buffer, there is no requirement that it be new memory. An application can reuse portions of command and control memory as long as it ensures that all command sets in the reused memory have completed execution. One sample use of this feature is a ring buffer for one-time command set submission:</p>
<ul>
<li>Provide the command buffer with fixed-size blocks of command and control memory at initialization time.</li>
<li>For each frame, use the command buffer to construct new command sets.</li>
<li>At the end of each frame, insert a new fence via <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> and record the memory usage in the command buffer using <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> query APIs. When the <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> object has completed, we know that all command sets for the frame have completed.</li>
<li>Continue using the command buffer to generate new command sets until the command buffer runs out of memory.</li>
<li>When an out-of-memory event occurs, determine the portions of the ring buffer that may be reused by checking the completion of previous frames using <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a>. When sufficient memory is available, provide the command buffer with new memory from the portion of the ring buffer that can be safely reused.</li>
</ul>
<p>The type of memory pool used for command buffers will affect the performance and possibly correctness of command buffer processing submission.</p>
<ul>
<li>For command sets submitted directly to queues or added by reference into other command sets (<a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a>), command memory should use pools allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> and <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356afb36e42ea7fdd4da445f195ccd641c58" title="Indicates that the memory pool will be accessed by the GPU without caching.">nvn::MemoryPoolFlags::GPU_UNCACHED</a>. Memory from CPU_CACHED pools will be cached by the CPU, and accesses by the GPU to fetch command memory may not see all the values written during command set construction unless <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> is called to flush the relevant portions of the CPU caches.</li>
<li>For command sets added by copy into other command sets (<a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CopyCommands</a>), command memory should use pools allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a>. Memory from CPU_UNCACHED pools will not be cached on the CPU, and copies from uncached memory in CopyCommands will be slow.</li>
<li>Control memory should use regular CPU-cached memory since it will be read by the CPU when command sets are submitted.</li>
</ul>
<blockquote class="doxtable">
<p><b>NOTE</b>: In the current NVN implementation, submitting command sets using memory from pools allocated with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> is not supported. </p>
</blockquote>
<h1><a class="anchor" id="nvn_guide_formats"></a>
9. Formats</h1>
<p>Data stored in textures and vertex buffers has an associated format that indicates how the underlying memory should be interpreted by the GPU. The format of data elements stored in texture or buffer memory is given by one of the enums in the <a class="el" href="structnvn_1_1_format.html" title="Identifies how data elements stored in texture or buffer objects are encoded.">nvn::Format</a> class. Each data element holds 1 to 4 components of data, whose bits represent floating-point, unsigned integer, or signed integer values. Formats beginning with "R", "RG", "RGB", and "RGBA" hold 1, 2, 3, or 4 component values, respectively. For simple formats, this prefix is followed by an integer holding the number of bits used to store each component, and then an optional suffix describing how the bits are interpreted.</p>
<p>When data elements are read or written by a shader, they are converted to or from four-component vectors with floating-point, unsigned integer, or signed integer components. If the format has fewer than four components, the 2nd (G) and 3rd (B) components will be treated as holding zero if not present, and the 4th (A) component will be treated as +1.0 if the format represents floating-point values and +1 if it represents integers.</p>
<p>When data elements are read or written by a shader, such operations will involve a GLSL variable whose data type indicates whether components are expected to be floating-point (e.g., sampler2D, vec3), unsigned integer (e.g., usampler1D, uvec2), or signed integer (e.g., isampler2D, ivec4). If the variable used to access a data element has a component type that doesn't match the component type of the data element, the results of reading or writing the data element are undefined.</p>
<h2><a class="anchor" id="nvn_guide_format_encodings"></a>
9.1. Component Encodings</h2>
<p>Each component is stored with a specified number of bits, and is converted to a floating-point or integer value using the encoding described by the optional suffix in the format name. Supported encodings are:</p>
<p>Unsigned normalized (no suffix) : Values are stored as unsigned integers and converted to floating-point values in the range [0.0, 1.0]. For <em>n</em>-bit components, input values are treated as unsigned integers and divided by 2<sup>n</sup> - 1. For example, 8-bit component values of 0 and 255 are converted to 0.0 and 1.0, respectively.</p>
<p>Signed normalized (suffix: SN) : Values are stored as signed integers and converted to floating-point values in the range [-1.0, +1.0]. For <em>n</em>-bit components, input values are treated as signed integers, divided by 2<sup>n-1</sup> - 1, and then clamped to the range [-1.0, +1.0]. For example, 8-bit component values of -128, -127, 0, and +127 are converted to -1.0, -1.0, 0.0, and 1.0, respectively.</p>
<p>Floating-point (suffix: F) : Values are stored and returned as floating-point values. 32-bit floating-point values are represented according to the IEEE 754 standard. 16-bit floating-point values are represented using the encoding described in the OpenGL and OpenGL ES Specifications or the <a href="https://www.opengl.org/registry/specs/ARB/half_float_pixel.txt">the ARB_half_float_pixel OpenGL extension</a>.</p>
<p>Unsigned integer (suffix: UI) : Values are stored and returned as unsigned integer values, and will not be converted to floating-point.</p>
<p>Signed integer (suffix: I) : Values are stored and returned as signed integer values, and will not be converted to floating-point.</p>
<p>Unsigned integer-to-float (suffix: _UI2F) : Values are stored as unsigned integers, but are converted to floating-point by a type cast. For 8-bit components, input values of 0 and 255 are converted to 0.0 and 255.0, respectively.</p>
<p>Signed integer-to-float (suffix: _I2F) : Values are stored as signed integers, but are converted to floating-point by a type cast. For 8-bit components, input values of -128, -127, 0, and +127 are converted to -128.0, -127.0, 0.0, and +127.0, respectively.</p>
<p>All component values are stored using "little-endian" representations, where multi-byte components store the least significant 8 bits in the first byte and the most significant 8 bits in the last byte.</p>
<h2><a class="anchor" id="nvn_guide_sec_9_2"></a>
9.2. Depth/Stencil Formats</h2>
<p>A number of formats are used to represent depth/stencil values, which are handled differently from the "RGBA" color or generic data types described above.</p>
<ul>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a> stores each data element as a single 8-bit unsigned stencil value. On the Windows reference implementation, this format is only supported on second-generation Maxwell GPUs (GeForce GTX 960 and above).</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component.">nvn::Format::DEPTH16</a> stores each data element as a 16-bit unsigned normalized depth value.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a74df5a03a4702521794089f23c4f364b" title="A 24-bit unsigned normalized depth component in the LSBs of a 32-bit word.">nvn::Format::DEPTH24</a> stores each data element with a 32-bit word, where the 24 most significant bits hold an unsigned normalized depth value.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a> stores each data element as a 32-bit floating-point depth value.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9745a145c841e60ff50d7a0fe0469e1f" title="A 24-bit unsigned normalized depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH24_STENCIL8</a> stores each data element as a 32-bit word, where the 24 most significant bits hold an unsigned normalized depth value and the 8 least signficant bits hold an unsigned integer stencil value.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57b3319d5b05a91d1599dfbbf4edc924" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH32F_STENCIL8</a> stores each data element as two 32-bit words, where the first word holds a 32-bit floating-point value, and the second word holds an 8-bit unsigned integer stencil value in the least significant bits. The 24 most significant bits of the second word are unused.</li>
</ul>
<p>When used as a texture, the depth/stencil formats will return either a floating-point depth value or an unsigned integer stencil value, depending on the value of <a class="el" href="structnvn_1_1_texture_depth_stencil_mode.html" title="For textures containing depth and stencil data, identifies whether texture lookups will return depth ...">nvn::TextureDepthStencilMode</a> used to create the texture.</p>
<h2><a class="anchor" id="nvn_guide_sec_9_3"></a>
9.3. Packed Formats</h2>
<p>A number of formats are used to represent color or generic data values where multiple components are packed into a single word. The general pattern followed by these packed formats is the first component is stored in the least significant bits of a data word and the last component is stored in the most significant bits.</p>
<p>The following table describes the bits used by each component of each packed format. All components are stored in a single little-endian word with a number of bits indicated by the "Word Size" column. The columns "R Bits", "G Bits", "B Bits", and "A Bits" indicate the bits of the packed word occupied by each component. A value of "*N*:*M*" indicates that the component occupies bits <em>M</em> through <em>N</em> of the word, where the least significant bit is numbered 0. The components are <a href="#nvn_guide_format_encodings">encoded</a> according to the suffix of the format name.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Word Size   </th><th class="markdownTableHeadCenter">R Bits   </th><th class="markdownTableHeadCenter">G Bits   </th><th class="markdownTableHeadCenter">B Bits   </th><th class="markdownTableHeadCenter">A Bits    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac702393fafb03f99aab0ac98252f7691" title="Four 4-bit unsigned normalized components.">nvn::Format::RGBA4</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">3:0   </td><td class="markdownTableBodyCenter">7:4   </td><td class="markdownTableBodyCenter">11:8   </td><td class="markdownTableBodyCenter">15:12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3c85c14fcedc14e03dacf495a4850315" title="Three 5-bit unsigned normalized components.">nvn::Format::RGB5</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">9:5   </td><td class="markdownTableBodyCenter">14:10   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042afa48a3adf10a03e972e0a64c9fcea78d" title="Three 5-bit unsigned normalized RGB components with a 1-bit A component.">nvn::Format::RGB5A1</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">9:5   </td><td class="markdownTableBodyCenter">14:10   </td><td class="markdownTableBodyCenter">15:15    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af6644e27b50738986601c71aec396cdf" title="Three 5-bit (R,B) and 6-bit (G) unsigned normalized components.">nvn::Format::RGB565</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">10:5   </td><td class="markdownTableBodyCenter">15:11   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab86089210f8f2e06937095228db5fc61" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned normalized components.">nvn::Format::RGB10A2</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a594216b5def609bbf896e5116858fade" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned integer components.">nvn::Format::RGB10A2UI</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad47b7f1050825944ee936ca24b24c169" title="Three 10-bit (R,G,B) and 2-bit (A) signed normalized components.">nvn::Format::RGB10A2SN</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6da29dae167cd2bf055b079109ab8c2e" title="Three 10-bit (R,G,B) and 2-bit (A) signed integer components.">nvn::Format::RGB10A2I</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a62bf9314fce19c7248b7148e9cda360e" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned integer components, cast to floating-point.">nvn::Format::RGB10A2_UI2F</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2edf0a885741d5b152ea553936cac744" title="Three 10-bit (R,G,B) and 2-bit (A) signed integer components, cast to floating-point.">nvn::Format::RGB10A2_I2F</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">9:0   </td><td class="markdownTableBodyCenter">19:10   </td><td class="markdownTableBodyCenter">29:20   </td><td class="markdownTableBodyCenter">31:30    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9957bf4a5edcdc1e2f9155ecb229f743" title="Three 10-bit (B) and 11-bit (R,G) floating-point components.">nvn::Format::R11G11B10F</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">10:0   </td><td class="markdownTableBodyCenter">21:11   </td><td class="markdownTableBodyCenter">31:22   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042add9ce02d7adcbe7d7e0ba2275cd25da8" title="Three floating-point components with separate 9-bit mantissas and a shared 5-bit exponent.">nvn::Format::RGB9E5F</a>   </td><td class="markdownTableBodyCenter">32   </td><td class="markdownTableBodyCenter">8:0   </td><td class="markdownTableBodyCenter">17:9   </td><td class="markdownTableBodyCenter">26:18   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae557cb1382bab91de2536e92674fe805" title="Three 5-bit unsigned normalized components.">nvn::Format::BGR5</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">14:10   </td><td class="markdownTableBodyCenter">9:5   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a19622313fef63da8f7ae4fb1f8b5b318" title="Three 5-bit unsigned normalized RGB components with a 1-bit A component.">nvn::Format::BGR5A1</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">14:10   </td><td class="markdownTableBodyCenter">9:5   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">15:15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6a9c8118b9d97a1a2f61d7f339d51e3a" title="Three 5-bit (R,B) and 6-bit (G) unsigned normalized components.">nvn::Format::BGR565</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">15:11   </td><td class="markdownTableBodyCenter">10:5   </td><td class="markdownTableBodyCenter">4:0   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a575225680f5005807dc2ced814a98dfd" title="One 1-bit A component with three 5-bit unsigned normalized RGB components.">nvn::Format::A1BGR5</a>   </td><td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">15:11   </td><td class="markdownTableBodyCenter">10:6   </td><td class="markdownTableBodyCenter">5:1   </td><td class="markdownTableBodyCenter">0:0   </td></tr>
</table>
<p>Notes:</p>
<ul>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9957bf4a5edcdc1e2f9155ecb229f743" title="Three 10-bit (B) and 11-bit (R,G) floating-point components.">nvn::Format::R11G11B10F</a> encodes three packed floating-point values, as described in the <a href="https://www.opengl.org/registry/specs/EXT/packed_float.txt">EXT_packed_float OpenGL extension</a>.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042add9ce02d7adcbe7d7e0ba2275cd25da8" title="Three floating-point components with separate 9-bit mantissas and a shared 5-bit exponent.">nvn::Format::RGB9E5F</a> encodes three floating-point mantissa values in bits 26:0 and a 5-bit shared exponent in bits 31:27, and is decoded as described in the <a href="https://www.opengl.org/registry/specs/EXT/texture_shared_exponent.txt">EXT_texture_shared_exponent OpenGL extension</a>.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_compressed_formats"></a>
9.4. Compressed Formats</h2>
<p>Several compressed texture formats are supported by NVN, using compressed blocks storing multiple texels in a single 64- or 128-bit data element. For ASTC formats, each compressed block stores fixed Width x Height texels defined by the ASTC format name (e.g. <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042abc0cac3a53cf15ea37b0ac735d89a7f7" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 10x8 texel block footprint.">nvn::Format::RGBA_ASTC_10x8_SRGB</a> has a block size of 10 x 8 texels). Other compressed formats store 4x4 texels in each compressed block. Note that compressed formats are not supported for 1D or 1D array textures. Supported formats include:</p>
<ul>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6c4f48f1a34b5c8102664c7c41dd780a" title="DXT1 compressed texture blocks with an RGB format.">nvn::Format::RGB_DXT1</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0d18f9e939905dd7bc3b74510f5d2576" title="DXT1 compressed texture blocks with an RGBA format.">nvn::Format::RGBA_DXT1</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa74c41f904ef4aa1c91a0455b26d38b8" title="DXT3 compressed texture blocks.">nvn::Format::RGBA_DXT3</a>, and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6adfb7f59df9c813743c2b542de8b495" title="DXT5 compressed texture blocks.">nvn::Format::RGBA_DXT5</a> are encoded as described in the <a href="https://www.opengl.org/registry/specs/EXT/texture_compression_s3tc.txt">EXT_texture_compression_s3tc OpenGL extension</a>.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4dd043c274dd645b2d62fa58f6bf9e0d" title="DXT1 compressed texture blocks with an sRGB-encoded RGB format.">nvn::Format::RGB_DXT1_SRGB</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a16dc557324a9dc9ae13122d0839983e9" title="DXT1 compressed texture blocks with an sRGB-encoded RGBA format.">nvn::Format::RGBA_DXT1_SRGB</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ade07933601ff6e06bac8bcc159862626" title="DXT3 compressed texture blocks with an sRGB color encoding.">nvn::Format::RGBA_DXT3_SRGB</a>, and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3fd8398705a8efa407b2314cc997b6f7" title="DXT5 compressed texture blocks with an sRGB color encoding.">nvn::Format::RGBA_DXT5_SRGB</a>, are encoded in the same manner as the equivalent formats without an "_SRGB" suffix, but decompressed values are treated as sRGB-encoded and are decoded to a linear representation.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8278c521fea5355ad0eb1af170953fed" title="RGTC compressed 1-component unsigned normalized blocks.">nvn::Format::RGTC1_UNORM</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa55989e827a77ce3505baff9a9962f5e" title="RGTC compressed 1-component signed normalized blocks.">nvn::Format::RGTC1_SNORM</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4c784ac8efa41f88281723e40beba7eb" title="RGTC compressed 2-component unsigned normalized blocks.">nvn::Format::RGTC2_UNORM</a>, and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042acc41d0863c02194d257ac96d1762e859" title="RGTC compressed 2-component signed normalized blocks.">nvn::Format::RGTC2_SNORM</a> are encoded as described in the <a href="https://www.opengl.org/registry/specs/ARB/texture_compression_rgtc.txt">ARB_texture_compression_rgtc OpenGL extension</a>.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a93db80e4884ea1aa7c776cd0667dc342" title="BPTC compressed 4-component unsigned normalized blocks.">nvn::Format::BPTC_UNORM</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af02f4bbf42bb1bfc2246f06e2dd67c77" title="BPTC compressed 4-component unsigned normalized blocks with an sRGB color encoding.">nvn::Format::BPTC_UNORM_SRGB</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa43bfdd239fe5816f4f2ad19a8c45e15" title="BPTC compressed 3-component signed floating-point blocks.">nvn::Format::BPTC_SFLOAT</a>, and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a18a215c79c3be991643388457adc91ea" title="BPTC compressed 3-component unsigned floating-point blocks.">nvn::Format::BPTC_UFLOAT</a> are encoded as described in the <a href="https://www.opengl.org/registry/specs/ARB/texture_compression_bptc.txt">ARB_texture_compression_bptc OpenGL extension</a></li>
<li>The various ASTC formats (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac063a7c41528b74cac18df50e41d9b04" title="ASTC compressed texture blocks with an RGBA format and 4x4 texel block footprint.">nvn::Format::RGBA_ASTC_4x4</a>) are encoded as described in the <a href="https://www.opengl.org/registry/specs/KHR/texture_compression_astc_hdr.txt">KHR_texture_compression_astc OpenGL extension</a>. RGB color components for formats with a suffix of "_SRGB" are considered to be encoded in the sRGB color space, while components for formats without such a suffix are considered to be encoded in a linear color space.</li>
</ul>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: ASTC texture formats are not natively supported on the NVN Windows reference implementation, although emulation is possible with pre-packaged texture data. Native support for ASTC texture formats can be determined at run-time by querying the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dacb5167de8c6a4d9779a32e6a7fc99c8a" title="1 if ASTC texture formats are supported by the NVN implementation; 0 otherwise.">nvn::DeviceInfo::SUPPORTS_ASTC_FORMATS</a>. For more detail, please refer to the section '<a href="#nvn_guide_formats_restrictions_on_Windows">Formats Restrictions on the NVN Windows Reference Implementation</a>'. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_srgb"></a>
9.5. sRGB Formats</h2>
<p>Formats with a suffix of "SRGB" are treated as being encoded in the sRGB color space. When reading from textures with such formats, the R, G, and B components of the data element are converted from the sRGB color space (cs) to the linear color space (cl) using the following equation: </p><pre class="fragment">        {  cs / 12.92,                 cs &lt;= 0.04045
   cl = {
        {  ((cs + 0.055)/1.055)^2.4,   cs &gt;  0.04045
</pre><p> When rendering to textures with such formats, each stored component is converted from sRGB to linear prior to blending. Blending (if enabled) is performed in the linear color space. The R, G, and B components of the final blended values, or the color output if blending is disabled, is converted back to the sRGB color space using the following equation: </p><pre class="fragment">        {  0.0,                          0         &lt;= cl
        {  12.92 * c,                    0         &lt;  cl &lt; 0.0031308
   cs = {  1.055 * cl^0.41666 - 0.055,   0.0031308 &lt;= cl &lt; 1
        {  1.0,                                       cl &gt;= 1
</pre><p> No conversion is performed on the A component of data elements with sRGB formats.</p>
<p>sRGB color conversions are always performed when using a texture with an sRGB format for texturing or rendering. Applications can use texture views to disable conversion for sRGB textures or enable conversion for non-sRGB textures.</p>
<p>sRGB color conversions are <b>not</b> performed when copying texel values between images or between images and buffers; such copies support no conversions and only copy the raw bits.</p>
<h2><a class="anchor" id="nvn_guide_formats_table"></a>
9.6. Formats Table</h2>
<p>The following table lists all formats supported by NVN, and various properties of each format.</p>
<ul>
<li>The column "Texture" indicates whether the format is supported for texels stored in a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object. "-" indicates the format is not supported for texturing. Other entries identify the format class for the texture.</li>
<li>The column "Render" indicates whether the format is supported for render target textures used with <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>.</li>
<li>The column "Vertex" indicates whether the format is supported for vertex attributes stored in an <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a> object.</li>
<li>The column "Image" indicates whether the format is supported for textures used in image load/store operations.</li>
<li>The column "Copy2D" indicates whether the format is supported for textures used with <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>.</li>
<li>The column "Linear2D" indicates whether linear filtering of the format is supported for textures used with <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>. Additionally, when both the source and destination of a texture-to-texture copy support linear filtering, copy commands may also be used to convert images from the source format to the destination format. When supported, conversion between formats will be performed irrespective of whether or not the copy requests linear filtering. Conversions using this API are not completely orthogonal; see below for a list of caveats regarding converting between formats with <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>.</li>
<li>The column "Format class" indicates whether the format is supported for lossy color reduction optimization and the format class to use with <a class="el" href="classnvn_1_1_command_buffer.html#a372c68297e7725dd87f78278078c7755" title="Specify new lossy color reduction thresholds for a format class.">nvn::CommandBuffer::SetColorReductionThresholds</a>.</li>
<li>The column "Fast clear format" indicates the fast clear equivalent format as described in <a class="el" href="nvn_index.html#nvn_guide_framebuffer_clears">framebuffer clears</a>. "-" indicates that no fast clear equivalent format is applicable. This is the case for formats that cannot be used as render targets, are not framebuffer compressible, or are non-color formats (depth and/or stencil).</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aecf603ba72eafffa746f230c20cc707d" title="Placeholder enum indicating no defined format; never valid.">nvn::Format::NONE</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af1b26ee6122f78ff0ab4b2b092052ce0" title="One 8-bit unsigned normalized component.">nvn::Format::R8</a>   </td><td class="markdownTableBodyCenter">C8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2eb8e1239bdbbe9d1d9f7de1c7355a76" title="One 8-bit signed normalized component.">nvn::Format::R8SN</a>   </td><td class="markdownTableBodyCenter">C8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad3f4d7b6d46bca92e69233c7ea32eed7" title="One 8-bit unsigned integer component.">nvn::Format::R8UI</a>   </td><td class="markdownTableBodyCenter">C8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a93b92d968395ec21e164517920671618" title="One 8-bit signed integer component.">nvn::Format::R8I</a>   </td><td class="markdownTableBodyCenter">C8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a69b98168968a3314cea20b98491068fc" title="One 16-bit floating-point component.">nvn::Format::R16F</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">FP16   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aff5b9bf5b960aee16bf2bf4bb0cc59c2" title="One 16-bit unsigned normalized component.">nvn::Format::R16</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM16   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac60f44ae937b0d436f7b97389987cb15" title="One 16-bit signed normalized component.">nvn::Format::R16SN</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aedbb5ee583ca8512400aa94ae340fd42" title="One 16-bit unsigned integer component.">nvn::Format::R16UI</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a75b0569ea9ff2e1ee01077ee08b01e06" title="One 16-bit signed integer component.">nvn::Format::R16I</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1143a610156272c1a1e91e5026455510" title="One 32-bit floating-point component.">nvn::Format::R32F</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32F    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fccc2332c5bb0a200b4df7b2912212d" title="One 32-bit unsigned integer component.">nvn::Format::R32UI</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a638b1c971e45dc06a1daf1f9ed5b28ed" title="One 32-bit signed integer component.">nvn::Format::R32I</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8dccd3d843efd92785a1de10c92f1ac9" title="Two 8-bit unsigned normalized components.">nvn::Format::RG8</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a48bd7bf4e91670214a6419018d2e64bc" title="Two 8-bit signed normalized components.">nvn::Format::RG8SN</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8d45ca059c2cf3542ee4db5df988d0c8" title="Two 8-bit unsigned integer components.">nvn::Format::RG8UI</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5089b01550a91889a2a9beb235195343" title="Two 8-bit signed integer components.">nvn::Format::RG8I</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042adb8cb6dae0bfb06c99ea4e5f951c2276" title="Two 16-bit floating-point components.">nvn::Format::RG16F</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">FP16   </td><td class="markdownTableBodyCenter">RGBA16F    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0bf96d5590e1ca6faac60b433cd26074" title="Two 16-bit unsigned normalized components.">nvn::Format::RG16</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM16   </td><td class="markdownTableBodyCenter">RGBA16    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a71082763cf37e7e954c01c6831900b70" title="Two 16-bit signed normalized components.">nvn::Format::RG16SN</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16SN   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a824b132f31942c5d69bc0a7e1cb4c01b" title="Two 16-bit unsigned integer components.">nvn::Format::RG16UI</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2e083cfce847d58cd80aea09866a69de" title="Two 16-bit signed integer components.">nvn::Format::RG16I</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16I    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a555e49e9a741f7fee1c0da77814f57ba" title="Two 32-bit floating-point components.">nvn::Format::RG32F</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32F    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae7243c1d911ba24a1d4d8a7afe0f8e0f" title="Two 32-bit unsigned integer components.">nvn::Format::RG32UI</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a876ede717b4e8de33271a70912f281a5" title="Two 32-bit signed integer components.">nvn::Format::RG32I</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a31c037e4242a231fd8b0e187d2698f14" title="Three 8-bit unsigned normalized components.">nvn::Format::RGB8</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac2ba89d936700845bb06b22e0c806f54" title="Three 8-bit signed normalized components.">nvn::Format::RGB8SN</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5e5e1d47748a270e596eaf26f27cddab" title="Three 8-bit unsigned integer components.">nvn::Format::RGB8UI</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa6ad44d4f3ba548fb39778e09c7e3a06" title="Three 8-bit signed integer components.">nvn::Format::RGB8I</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0d5338286e780b37ac2ee275c1f6524d" title="Three 16-bit floating-point components.">nvn::Format::RGB16F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad47acb4869c360786ae6f4a7479e597b" title="Three 16-bit unsigned normalized components.">nvn::Format::RGB16</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a03eb724f7bca437776a9a82a5b07ad6b" title="Three 16-bit signed normalized components.">nvn::Format::RGB16SN</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aebed131b4f3d91c628793fb21a34823c" title="Three 16-bit unsigned integer components.">nvn::Format::RGB16UI</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a155dc5f04fd528e9de064f086f376fc5" title="Three 16-bit signed integer components.">nvn::Format::RGB16I</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a821c14e8dec351b783ac10e6b69d47fb" title="Three 32-bit floating-point components.">nvn::Format::RGB32F</a>   </td><td class="markdownTableBodyCenter">C96   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2557ddb79e33e7b2b07d571dba77248e" title="Three 32-bit unsigned integer components.">nvn::Format::RGB32UI</a>   </td><td class="markdownTableBodyCenter">C96   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae60ee022a675ec9f866de4b56c78e1fd" title="Three 32-bit signed integer components.">nvn::Format::RGB32I</a>   </td><td class="markdownTableBodyCenter">C96   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">RGBA8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aac217c744a68ea92c11e896b8066f712" title="Four 8-bit signed normalized components.">nvn::Format::RGBA8SN</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8SN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a7c2fcc451790705492d9cd508365ae3d" title="Four 8-bit unsigned integer components.">nvn::Format::RGBA8UI</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8UI   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af01b43d03e0263677c063a53fbd6bd82" title="Four 8-bit signed integer components.">nvn::Format::RGBA8I</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8I    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae2aaaa12b447e79ac04575ef289ef278" title="Four 16-bit floating-point components.">nvn::Format::RGBA16F</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">FP16   </td><td class="markdownTableBodyCenter">RGBA16F    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5ad1c608d6f07ab75953d09a933e132a" title="Four 16-bit unsigned normalized components.">nvn::Format::RGBA16</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM16   </td><td class="markdownTableBodyCenter">RGBA16    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa39ecfe09f5d423cee6cb96c3cd92362" title="Four 16-bit signed normalized components.">nvn::Format::RGBA16SN</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16SN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac3eca5fd1c211a2f09bb6ecd0adf65fb" title="Four 16-bit unsigned integer components.">nvn::Format::RGBA16UI</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af6bf44655541657e29c4b9d7fc819977" title="Four 16-bit signed integer components.">nvn::Format::RGBA16I</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16I    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a147b77eb15f0ed8ffda34c97d562e5cb" title="Four 32-bit floating-point components.">nvn::Format::RGBA32F</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32F    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a7972e8232f67991f737c2055eb09215b" title="Four 32-bit unsigned integer components.">nvn::Format::RGBA32UI</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8278caf46289b19fe659e46a758daf6b" title="Four 32-bit signed integer components.">nvn::Format::RGBA32I</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a>   </td><td class="markdownTableBodyCenter">S8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component.">nvn::Format::DEPTH16</a>   </td><td class="markdownTableBodyCenter">Z16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a74df5a03a4702521794089f23c4f364b" title="A 24-bit unsigned normalized depth component in the LSBs of a 32-bit word.">nvn::Format::DEPTH24</a>   </td><td class="markdownTableBodyCenter">Z24S8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a>   </td><td class="markdownTableBodyCenter">Z32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9745a145c841e60ff50d7a0fe0469e1f" title="A 24-bit unsigned normalized depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH24_STENCIL8</a>   </td><td class="markdownTableBodyCenter">Z24S8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57b3319d5b05a91d1599dfbbf4edc924" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH32F_STENCIL8</a>   </td><td class="markdownTableBodyCenter">Z32S8   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab573a06bd66be668656a86f505b717e4" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel and encoded in the sRGB color...">nvn::Format::RGBX8_SRGB</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">SRGB8   </td><td class="markdownTableBodyCenter">RGBA8_SRGB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab96de31169c48cc156158e685aa55e93" title="Four 8-bit unsigned normalized components, encoded in the sRGB color space.">nvn::Format::RGBA8_SRGB</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">SRGB8   </td><td class="markdownTableBodyCenter">RGBA8_SRGB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac702393fafb03f99aab0ac98252f7691" title="Four 4-bit unsigned normalized components.">nvn::Format::RGBA4</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3c85c14fcedc14e03dacf495a4850315" title="Three 5-bit unsigned normalized components.">nvn::Format::RGB5</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042afa48a3adf10a03e972e0a64c9fcea78d" title="Three 5-bit unsigned normalized RGB components with a 1-bit A component.">nvn::Format::RGB5A1</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af6644e27b50738986601c71aec396cdf" title="Three 5-bit (R,B) and 6-bit (G) unsigned normalized components.">nvn::Format::RGB565</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab86089210f8f2e06937095228db5fc61" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned normalized components.">nvn::Format::RGB10A2</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM10   </td><td class="markdownTableBodyCenter">RGB10A2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a594216b5def609bbf896e5116858fade" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned integer components.">nvn::Format::RGB10A2UI</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGB10A2UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a9957bf4a5edcdc1e2f9155ecb229f743" title="Three 10-bit (B) and 11-bit (R,G) floating-point components.">nvn::Format::R11G11B10F</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">FP10   </td><td class="markdownTableBodyCenter">R11G11B10F    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042add9ce02d7adcbe7d7e0ba2275cd25da8" title="Three floating-point components with separate 9-bit mantissas and a shared 5-bit exponent.">nvn::Format::RGB9E5F</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6c4f48f1a34b5c8102664c7c41dd780a" title="DXT1 compressed texture blocks with an RGB format.">nvn::Format::RGB_DXT1</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0d18f9e939905dd7bc3b74510f5d2576" title="DXT1 compressed texture blocks with an RGBA format.">nvn::Format::RGBA_DXT1</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa74c41f904ef4aa1c91a0455b26d38b8" title="DXT3 compressed texture blocks.">nvn::Format::RGBA_DXT3</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6adfb7f59df9c813743c2b542de8b495" title="DXT5 compressed texture blocks.">nvn::Format::RGBA_DXT5</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4dd043c274dd645b2d62fa58f6bf9e0d" title="DXT1 compressed texture blocks with an sRGB-encoded RGB format.">nvn::Format::RGB_DXT1_SRGB</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a16dc557324a9dc9ae13122d0839983e9" title="DXT1 compressed texture blocks with an sRGB-encoded RGBA format.">nvn::Format::RGBA_DXT1_SRGB</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ade07933601ff6e06bac8bcc159862626" title="DXT3 compressed texture blocks with an sRGB color encoding.">nvn::Format::RGBA_DXT3_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3fd8398705a8efa407b2314cc997b6f7" title="DXT5 compressed texture blocks with an sRGB color encoding.">nvn::Format::RGBA_DXT5_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8278c521fea5355ad0eb1af170953fed" title="RGTC compressed 1-component unsigned normalized blocks.">nvn::Format::RGTC1_UNORM</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa55989e827a77ce3505baff9a9962f5e" title="RGTC compressed 1-component signed normalized blocks.">nvn::Format::RGTC1_SNORM</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4c784ac8efa41f88281723e40beba7eb" title="RGTC compressed 2-component unsigned normalized blocks.">nvn::Format::RGTC2_UNORM</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042acc41d0863c02194d257ac96d1762e859" title="RGTC compressed 2-component signed normalized blocks.">nvn::Format::RGTC2_SNORM</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a93db80e4884ea1aa7c776cd0667dc342" title="BPTC compressed 4-component unsigned normalized blocks.">nvn::Format::BPTC_UNORM</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af02f4bbf42bb1bfc2246f06e2dd67c77" title="BPTC compressed 4-component unsigned normalized blocks with an sRGB color encoding.">nvn::Format::BPTC_UNORM_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa43bfdd239fe5816f4f2ad19a8c45e15" title="BPTC compressed 3-component signed floating-point blocks.">nvn::Format::BPTC_SFLOAT</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a18a215c79c3be991643388457adc91ea" title="BPTC compressed 3-component unsigned floating-point blocks.">nvn::Format::BPTC_UFLOAT</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a19e0d2fe218cac7b7eb191f4df12be2a" title="One 8-bit unsigned integer component, cast to float.">nvn::Format::R8_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a56ad8aef47ddbbbec72cfeac143c101c" title="One 8-bit signed integer component, cast to float.">nvn::Format::R8_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3fcb17a1c480ca3bdcc31c6e885a4467" title="One 16-bit unsigned integer component, cast to float.">nvn::Format::R16_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac9904f72043dd645aa75d73043ed65bc" title="One 16-bit signed integer component, cast to float.">nvn::Format::R16_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a55733af9eb1b6d8874fc603485501eae" title="One 32-bit unsigned integer component, cast to float.">nvn::Format::R32_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a16b904b0124e79c9fe1ae41e039abbfa" title="One 32-bit signed integer component, cast to float.">nvn::Format::R32_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a09e77cb3d13035389a3eb1e1fd8c6abe" title="Two 8-bit unsigned integer components, cast to float.">nvn::Format::RG8_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a66985087234171737d3de6b1d5d69fba" title="Two 8-bit signed integer components, cast to float.">nvn::Format::RG8_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1b3f4f9add0cf3281f74f5a92f3f2554" title="Two 16-bit unsigned integer components, cast to float.">nvn::Format::RG16_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6079ec55344f9a7b1ab1563ea407958e" title="Two 16-bit signed integer components, cast to float.">nvn::Format::RG16_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042acc9b679fd9f16e5d226a3c898bdcba4e" title="Two 32-bit unsigned integer components, cast to float.">nvn::Format::RG32_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6386f8c9b8fa06f0b289b5ad4ba14a73" title="Two 32-bit signed integer components, cast to float.">nvn::Format::RG32_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042abd8b5cf2feb8bd6a177e7593ba650df2" title="Three 8-bit unsigned integer components, cast to float.">nvn::Format::RGB8_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2ccb11fd3cdb51f1fa3bec4f3f789910" title="Three 8-bit signed integer components, cast to float.">nvn::Format::RGB8_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a10462bf1042be83c141630d112272373" title="Three 16-bit unsigned integer components, cast to float.">nvn::Format::RGB16_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad49bb53aee55f61a684738547f3434f2" title="Three 16-bit signed integer components, cast to float.">nvn::Format::RGB16_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a94932f56ea63281a033bc7f8978b51d2" title="Three 32-bit unsigned integer components, cast to float.">nvn::Format::RGB32_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab5f4f5d876fbac6ed54f907d2e5bbafa" title="Three 32-bit signed integer components, cast to float.">nvn::Format::RGB32_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a30bad965bbcec5b8ac4b38bbde910b75" title="Four 8-bit unsigned integer components, cast to float.">nvn::Format::RGBA8_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad05e5d7ab6b5034bc05a3e37d5c4bb67" title="Four 8-bit signed integer components, cast to float.">nvn::Format::RGBA8_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a15112852f1078eda33acddd2c5db54d3" title="Four 16-bit unsigned integer components, cast to float.">nvn::Format::RGBA16_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6f542dd33fed0b620dc72f24e53f4de6" title="Four 16-bit signed integer components, cast to float.">nvn::Format::RGBA16_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae0e7f82063dad2da8966e3154a7e6981" title="Four 32-bit unsigned integer components, cast to float.">nvn::Format::RGBA32_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042acd8f9d8f7b8c84ee444de00e60f680e8" title="Four 32-bit signed integer components, cast to float.">nvn::Format::RGBA32_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad47b7f1050825944ee936ca24b24c169" title="Three 10-bit (R,G,B) and 2-bit (A) signed normalized components.">nvn::Format::RGB10A2SN</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6da29dae167cd2bf055b079109ab8c2e" title="Three 10-bit (R,G,B) and 2-bit (A) signed integer components.">nvn::Format::RGB10A2I</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a62bf9314fce19c7248b7148e9cda360e" title="Three 10-bit (R,G,B) and 2-bit (A) unsigned integer components, cast to floating-point.">nvn::Format::RGB10A2_UI2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2edf0a885741d5b152ea553936cac744" title="Three 10-bit (R,G,B) and 2-bit (A) signed integer components, cast to floating-point.">nvn::Format::RGB10A2_I2F</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac256c39495bd9849f1c94b801fde588d" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">RGBA8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8ecf341cfbeeeb1288b56e16366a26b2" title="Three 8-bit signed normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8SN</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8SN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1048798a772bf9634c04c6fccc4f6e2f" title="Three 8-bit unsigned integer components, padded to 32 bits per pixel.">nvn::Format::RGBX8UI</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8UI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa43b219f768496cff9403526bce3bff5" title="Three 8-bit signed integer components, padded to 32 bits per pixel.">nvn::Format::RGBX8I</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA8I    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad1334593aff31f75f45a13228fd7943e" title="Three 16-bit floating-point components, padded to 64 bits per pixel.">nvn::Format::RGBX16F</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">FP16   </td><td class="markdownTableBodyCenter">RGBA16F    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a08a1e26923758a2a542aca6c8e84df3c" title="Three 16-bit unsigned normalized components, padded to 64 bits per pixel.">nvn::Format::RGBX16</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM16   </td><td class="markdownTableBodyCenter">RGBA16    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa999740227c4a93e255274d879b570a2" title="Three 16-bit signed normalized components, padded to 64 bits per pixel.">nvn::Format::RGBX16SN</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16SN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a812e8781bdf60810e450d0a39355a1da" title="Three 16-bit unsigned integer components, padded to 64 bits per pixel.">nvn::Format::RGBX16UI</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a93ad1d4808c98db7b7e3c34b10e0e9cd" title="Three 16-bit signed integer components, padded to 64 bits per pixel.">nvn::Format::RGBX16I</a>   </td><td class="markdownTableBodyCenter">C64   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA16I    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2f76bc92bfc22fdd31f98e90ffb59e63" title="Three 32-bit floating-point components, padded to 128 bits per pixel.">nvn::Format::RGBX32F</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32F    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a292706a49d760b04dcf7830cace088ae" title="Three 32-bit unsigned integer components, padded to 128 bits per pixel.">nvn::Format::RGBX32UI</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a479f62cf00aca4c4c2d23dd032a37a2d" title="Three 32-bit signed integer components, padded to 128 bits per pixel.">nvn::Format::RGBX32I</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">RGBA32UI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac063a7c41528b74cac18df50e41d9b04" title="ASTC compressed texture blocks with an RGBA format and 4x4 texel block footprint.">nvn::Format::RGBA_ASTC_4x4</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1241f132aad2423297a563ab0825e9e2" title="ASTC compressed texture blocks with an RGBA format and 5x4 texel block footprint.">nvn::Format::RGBA_ASTC_5x4</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a665c4124ede77e7bcd27c71ccd7b2a9a" title="ASTC compressed texture blocks with an RGBA format and 5x5 texel block footprint.">nvn::Format::RGBA_ASTC_5x5</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae1d19b005932f1bd1b4a9f04150fb3c7" title="ASTC compressed texture blocks with an RGBA format and 6x5 texel block footprint.">nvn::Format::RGBA_ASTC_6x5</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8e4644066d12b1c74f0d818e987eaccd" title="ASTC compressed texture blocks with an RGBA format and 6x6 texel block footprint.">nvn::Format::RGBA_ASTC_6x6</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042afdc5eef88bd406367b1957eebc5d47ba" title="ASTC compressed texture blocks with an RGBA format and 8x5 texel block footprint.">nvn::Format::RGBA_ASTC_8x5</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57d338c0b242a976fd530eda780cb529" title="ASTC compressed texture blocks with an RGBA format and 8x6 texel block footprint.">nvn::Format::RGBA_ASTC_8x6</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1e806902e549ad6c22ee22592ab74898" title="ASTC compressed texture blocks with an RGBA format and 8x8 texel block footprint.">nvn::Format::RGBA_ASTC_8x8</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2c6f73a437c6713a1d31802ab9026fb0" title="ASTC compressed texture blocks with an RGBA format and 10x5 texel block footprint.">nvn::Format::RGBA_ASTC_10x5</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a15c018f37ed34f8466e1131bd72bd03a" title="ASTC compressed texture blocks with an RGBA format and 10x6 texel block footprint.">nvn::Format::RGBA_ASTC_10x6</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3a9129b8d2d60bce76e0e75466fa35a3" title="ASTC compressed texture blocks with an RGBA format and 10x8 texel block footprint.">nvn::Format::RGBA_ASTC_10x8</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab3a9ae8ec7eef4292eb468f3380c1985" title="ASTC compressed texture blocks with an RGBA format and 10x10 texel block footprint.">nvn::Format::RGBA_ASTC_10x10</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4ee90e3435b463da5bbf0c88821cdc97" title="ASTC compressed texture blocks with an RGBA format and 12x10 texel block footprint.">nvn::Format::RGBA_ASTC_12x10</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a31b984f50e550751e7bf6368141a91a9" title="ASTC compressed texture blocks with an RGBA format and 12x12 texel block footprint.">nvn::Format::RGBA_ASTC_12x12</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ad4a5a0de79b10ec3207f41ca3c923aa0" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 4x4 texel block footprint.">nvn::Format::RGBA_ASTC_4x4_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1283b6832835aa8f2d5ca620b15b863b" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 5x4 texel block footprint.">nvn::Format::RGBA_ASTC_5x4_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac7de83ad2c0d5e0616e53f1b959ca513" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 5x5 texel block footprint.">nvn::Format::RGBA_ASTC_5x5_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042abff6f91b17de80284cc13fe5da6d40a7" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 6x5 texel block footprint.">nvn::Format::RGBA_ASTC_6x5_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3024f19983f45ac751eb51ef9d9ff90a" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 6x6 texel block footprint.">nvn::Format::RGBA_ASTC_6x6_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadCenter">Texture   </th><th class="markdownTableHeadCenter">Render   </th><th class="markdownTableHeadCenter">Vertex   </th><th class="markdownTableHeadCenter">Image   </th><th class="markdownTableHeadCenter">Copy2D   </th><th class="markdownTableHeadCenter">Linear2D   </th><th class="markdownTableHeadCenter">Format class   </th><th class="markdownTableHeadCenter">Fast clear format    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ade59f430d5185606bcb32087a5087fd9" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 8x5 texel block footprint.">nvn::Format::RGBA_ASTC_8x5_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a4686aa84bf83e8539e312b2d71730173" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 8x6 texel block footprint.">nvn::Format::RGBA_ASTC_8x6_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a235eb8a820443297062f9cf8b0e3f456" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 8x8 texel block footprint.">nvn::Format::RGBA_ASTC_8x8_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a23dfc04e8939045e982bbce59bc58734" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 10x5 texel block footprint.">nvn::Format::RGBA_ASTC_10x5_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a001614179e3f4743443f04ae5cbf6fc6" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 10x6 texel block footprint.">nvn::Format::RGBA_ASTC_10x6_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042abc0cac3a53cf15ea37b0ac735d89a7f7" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 10x8 texel block footprint.">nvn::Format::RGBA_ASTC_10x8_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a602af9c2e3d668eb10b7529400f9cd04" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 10x10 texel block footprint.">nvn::Format::RGBA_ASTC_10x10_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa6e194b13b3e76addeedd673898f22fd" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 12x10 texel block footprint.">nvn::Format::RGBA_ASTC_12x10_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aca429a56b6b5e6df3aa0643125c42216" title="ASTC compressed texture blocks with an sRGB plus Alpha format and 12x12 texel block footprint.">nvn::Format::RGBA_ASTC_12x12_SRGB</a>   </td><td class="markdownTableBodyCenter">C128   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a6a9c8118b9d97a1a2f61d7f339d51e3a" title="Three 5-bit (R,B) and 6-bit (G) unsigned normalized components.">nvn::Format::BGR565</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ae557cb1382bab91de2536e92674fe805" title="Three 5-bit unsigned normalized components.">nvn::Format::BGR5</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a19622313fef63da8f7ae4fb1f8b5b318" title="Three 5-bit unsigned normalized RGB components with a 1-bit A component.">nvn::Format::BGR5A1</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a575225680f5005807dc2ced814a98dfd" title="One 1-bit A component with three 5-bit unsigned normalized RGB components.">nvn::Format::A1BGR5</a>   </td><td class="markdownTableBodyCenter">C16   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5ac7f90a22a691a9f4490d58e5fac7e2" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::BGRX8</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">BGRA8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5a4987929e799fd8542efb45dc4b5d09" title="Four 8-bit unsigned normalized components.">nvn::Format::BGRA8</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">UNORM8   </td><td class="markdownTableBodyCenter">BGRA8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a66d17b56553dd552f24b573596455e77" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel and encoded in the sRGB color...">nvn::Format::BGRX8_SRGB</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">SRGB8   </td><td class="markdownTableBodyCenter">BGRA8_SRGB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab11b472c9859f8b0d2eac170f8d26753" title="Four 8-bit unsigned normalized components, encoded in the sRGB color space.">nvn::Format::BGRA8_SRGB</a>   </td><td class="markdownTableBodyCenter">C32   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">Y   </td><td class="markdownTableBodyCenter">SRGB8   </td><td class="markdownTableBodyCenter">BGRA8_SRGB   </td></tr>
</table>
<p>Notes:</p>
<ul>
<li>RGB formats are stored as three tightly-packed components. RGBA formats are are stored as four densely-packed components. RGBX formats have the same memory layout as RGBA formats, but the fourth component is ignored padding. RGB8 formats and RGB16 formats can only be used to store vertex data. RGB32 formats can be used for textures or vertex data, but not for render targets. RGBX formats can only be used for textures or render targets.</li>
<li>BGR, BGRA, and BGRX formats are treated identically to RGB, RGBA, and RGBX formats, except that the first component in memory holds a blue (B) component, instead of the red (R) component in the RGB formats.</li>
<li>The format STENCIL8 is not supported on discrete GPUs older than the GeForce GTX 970/980 series.</li>
<li>The set of formats supported for image load/store operations is a subset of the full set of textures supported for texture mapping.</li>
<li>Refer to <a href="#nvn_guide_presentation">nvn::Window</a> documentation for formats supported by the display pipeline.</li>
</ul>
<p><a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> notes:</p>
<ul>
<li>A conversion copy is defined as a copy using <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> where the source and destination formats of the textures differ.</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af1b26ee6122f78ff0ab4b2b092052ce0" title="One 8-bit unsigned normalized component.">nvn::Format::R8</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aff5b9bf5b960aee16bf2bf4bb0cc59c2" title="One 16-bit unsigned normalized component.">nvn::Format::R16</a> cannot be used as a destination for a conversion copy.</li>
<li>If the source and destination formats differ in precision<ul>
<li>Each value is preserved. For example, (0.1, 0.2) represented by RG8 will be converted to (0.1, 0.2) represented by RG16.</li>
</ul>
</li>
<li>If the source and destination formats differ in the number of components<ul>
<li>When used as a source, a single-component (red) texture will be treated as a luminance image, with the single component replicated to the red, green, and blue channels of the destination, if present.</li>
<li>If the destination texture format contains alpha and the source does not, the destination's alpha component will be set to 1.0. (e.g., RG16 to RGBA16, RG16 to RGBA32F)</li>
<li>If the destination texture format contains color components not present in the source, e.g., RG to RGB, such components will be set to 0.0.</li>
<li>If the source format has components not present in the destination format, the components present in both formats will be copied, and the components not present in the destination will be ignored.</li>
</ul>
</li>
<li>If the source and destination formats differ in type (e.g., RGB8 to RGB8SN)<ul>
<li>Each value will be converted to the corresponding destination component's precision, but its value is preserved. For example, 0.4 represented as unsigned normalized will be converted to 0.4 represented as float in an R8-to-R32 conversion. When source value is outside of destination value range, it will be clamped to that range as it is copied.</li>
<li>Integer texture formats cannot be converted in a copy operation.</li>
</ul>
</li>
<li>Texture-to-texture copies do not natively support <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3c85c14fcedc14e03dacf495a4850315" title="Three 5-bit unsigned normalized components.">nvn::Format::RGB5</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042afa48a3adf10a03e972e0a64c9fcea78d" title="Three 5-bit unsigned normalized RGB components with a 1-bit A component.">nvn::Format::RGB5A1</a>, and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042af6644e27b50738986601c71aec396cdf" title="Three 5-bit (R,B) and 6-bit (G) unsigned normalized components.">nvn::Format::RGB565</a>, and these formats will be programmed using their "BGR" equivalents. As a result, conversions between any of these formats and any other multi-component format would effectively swap red and blue components. Conversion copies involving these formats are only allowed if both source and destination use these formats, or if the source is single-component (lumiance). (It is recommended that applications avoid these formats and use the BGR versions instead where possible.)</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a8ecf341cfbeeeb1288b56e16366a26b2" title="Three 8-bit signed normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8SN</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a08a1e26923758a2a542aca6c8e84df3c" title="Three 16-bit unsigned normalized components, padded to 64 bits per pixel.">nvn::Format::RGBX16</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa999740227c4a93e255274d879b570a2" title="Three 16-bit signed normalized components, padded to 64 bits per pixel.">nvn::Format::RGBX16SN</a> will be treated as <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aac217c744a68ea92c11e896b8066f712" title="Four 8-bit signed normalized components.">nvn::Format::RGBA8SN</a>, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a5ad1c608d6f07ab75953d09a933e132a" title="Four 16-bit unsigned normalized components.">nvn::Format::RGBA16</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aa39ecfe09f5d423cee6cb96c3cd92362" title="Four 16-bit signed normalized components.">nvn::Format::RGBA16SN</a> respectively. (i.e., treated as if they had alpha)</li>
<li><a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab573a06bd66be668656a86f505b717e4" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel and encoded in the sRGB color...">nvn::Format::RGBX8_SRGB</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ab96de31169c48cc156158e685aa55e93" title="Four 8-bit unsigned normalized components, encoded in the sRGB color space.">nvn::Format::RGBA8_SRGB</a> will be converted from SRGB to linear and back as necessary when copied using this API. To copy texture data between sRGB and non-sRGB textures without performing sRGB conversion, applications can specify a texture view of the sRGB texture using an equivalent non-sRGB format.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_formats_restrictions_on_Windows"></a>
9.7. Formats Restriction on the NVN Windows Reference Implementation</h2>
<p>ASTC texture formats are not natively supported on the NVN Windows Reference Implementation.</p>
<p>A texture with an ASTC format is treated as follows:</p>
<ol type="1">
<li>Native support for ASTC texture formats can be determined at run-time by querying the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dacb5167de8c6a4d9779a32e6a7fc99c8a" title="1 if ASTC texture formats are supported by the NVN implementation; 0 otherwise.">nvn::DeviceInfo::SUPPORTS_ASTC_FORMATS</a>.</li>
<li>If an application initializes a texture with an ASTC format, and has also provided texels using <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a>, the driver will make a separate copy of the texture in a format native to the GPU. The driver will use this separate copy.</li>
<li>If an application initializes a texture with an ASTC format, but has not called <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a>, no separate copy is created.</li>
<li>If an application changes the memory contents associated with the texture after calling <a class="el" href="classnvn_1_1_texture.html#ac369f6845c5776de5dbedc84b9191e4c" title="Initialize a texture object from a texture builder using storage provided by a memory pool.">nvn::Texture::Initialize</a>, such changes have no effect on the separate copy.</li>
<li>When an application registers a texture initialized with an ASTC format, but has not called <a class="el" href="classnvn_1_1_texture_builder.html#a0960d36e2de68129e623b19db344c77b" title="Specify optional packaged texture data used to initialize texture storage.">nvn::TextureBuilder::SetPackagedTextureData</a> as described in (3), the texture will be created using the actual memory the application has set up for the texture. Since NVIDIA desktop-class GPUs do not support ASTC formats, this will not render correctly, and may cause GPU errors.</li>
<li>If <a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">nvn::TexturePool::RegisterTexture</a> is called with an ASTC texture and a texture view, any format specified in the texture view will be ignored.</li>
<li>When the <a class="el" href="classnvn_1_1_texture.html#a8c7b46637959e0e244c50a75f87b6bb6" title="Finalize a Texture object.">nvn::Texture::Finalize</a> operation has been completed on the GPU, the separate copy area described on (2) will be freed.</li>
</ol>
<p>For the other restrictions related to the NVN Windows Reference Implementation, please see <a href="#nvn_guide_Windows_Reference_Implementation">Windows Reference Implementation Details</a>.</p>
<h1><a class="anchor" id="nvn_guide_rendering"></a>
10. Graphics Primitive Processing</h1>
<p>Graphics primitives in NVN are processed similarly to primitives in other 3D graphics APIs, such as OpenGL and Direct3D. The following sections include high-level descriptions of the operation of the GPU pipeline stages involved in processing graphics primitives. This section assumes that readers have some familiarity with these pipeline stages from other 3D graphics APIs and will concentrate on differences between NVN and other APIs.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_1"></a>
10.1. Draw Calls</h2>
<p>Graphics primitives are initially inserted into command buffers using draw calls such as <a class="el" href="classnvn_1_1_command_buffer.html#a9da364199d8c432151e8c18234ddde61" title="Render a primitive with consecutive vertex indices.">nvn::CommandBuffer::DrawArrays</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a471babeb6b1971ba35fd006ecee180e8" title="Render a primitive with vertex indices fetched from an index buffer.">nvn::CommandBuffer::DrawElements</a>. Each draw call specifies a collection of vertices arranged into sets of point, line segment, polygon, or patch primitives according to primitive mode specified by the <em>mode</em> parameter of the draw call. The set of primitive types supported by NVN is described by the enumerated type <a class="el" href="structnvn_1_1_draw_primitive.html" title="Specifies the type of primitive to render in draw calls.">nvn::DrawPrimitive</a>, and is identical to that of the OpenGL compatibility profile. This set includes some primitives (such as quadrilaterals) not supported by Direct3D, OpenGL ES, and the OpenGL core profile.</p>
<p>Each vertex in a primitive has an associated vertex index. For DrawArrays calls, vertex indices are assigned consecutively from the range of values [<em>first</em>, <em>first</em>+*count*-1]. For DrawElements calls, vertex indices are fetched from an index buffer in GPU-accessible memory. The vertex index is used for fetching vertex attributes and can be read directly in vertex shaders using the built-in GLSL variable <code>gl_VertexID</code>.</p>
<p>Draw calls may be <em>instanced</em> (<a class="el" href="classnvn_1_1_command_buffer.html#aff1d89da478af0af62b725f3acb2a03d" title="Render multiple copies (instances) of a primitive with consecutive vertex indices.">nvn::CommandBuffer::DrawArraysInstanced</a>, <a class="el" href="classnvn_1_1_command_buffer.html#ad006e85876e24f910ca224279ef15e56" title="Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer.">nvn::CommandBuffer::DrawElementsInstanced</a>), where the set of primitives is drawn multiple times, each with a different instance ID. The instance ID can be used for fetching vertex attributes from an instanced vertex stream, and can also be read directly in shaders using the built-in variable <code>gl_InstanceID</code>.</p>
<p>Draw calls may be <em>indirect</em> (<a class="el" href="classnvn_1_1_command_buffer.html#ae646d84699c45f2fbb8f19228d09c552" title="Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect dat...">nvn::CommandBuffer::DrawArraysIndirect</a>, <a class="el" href="classnvn_1_1_command_buffer.html#ae01f121b63f5ad2e555acd587f7837bf" title="Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched fro...">nvn::CommandBuffer::DrawElementsIndirect</a>), where the properties of the draw call are fetched from a buffer address provided by the application. Additionally, multiple indirect draws may be performed in a single call using <a class="el" href="classnvn_1_1_command_buffer.html#a8bb65434a9927e837c8824130ea71de1" title="Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched ...">nvn::CommandBuffer::MultiDrawArraysIndirectCount</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a8572e7834fcaff511baf47464075f172" title="Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fe...">nvn::CommandBuffer::MultiDrawElementsIndirectCount</a>. In those commands, the parameters of each draw operation as well as the total number of draw operations are fetched from buffer memory.</p>
<p>In addition to geometric primitives, axis-aligned rectangles containing texture data can be rendered into the framebuffer using <a class="el" href="classnvn_1_1_command_buffer.html#a4c0ab209349d35ddaa3166571bc66039" title="Draws an on-screen rectangle displaying the contents of a provided texture.">nvn::CommandBuffer::DrawTexture</a>. The DrawTexture command is discussed in more detail in a <a href="#nvn_guide_draw_texture">separate sub-section below</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_2"></a>
10.2. Vertex Shaders</h2>
<p>When a primitive is specified, its vertices are first processed by programmable vertex shaders. Vertex shaders transform each vertex provided by the a draw call, reading the values of input variables fetched by the GPU and computing new vertex attributes (including position) that will be used by subsequent programmable stages and fixed-function pipeline units.</p>
<p>A vertex shader is required for processing all graphics primitives. Executing a draw call without an active vertex shader will have undefined behavior and may result in program termination.</p>
<h3><a class="anchor" id="nvn_guide_vertex"></a>
Vertex Attributes</h3>
<p>When executing GLSL vertex shaders, the values for each input variable in the original GLSL source is fetched by fixed-function <em>vertex pulling</em> hardware. Vertex attributes are fetched from buffer object memory using vertex buffers programmed via <a class="el" href="classnvn_1_1_command_buffer.html#ad5187aa77bf5509c1a02bae33ea3b17c" title="Bind a range of a Buffer object to use for fetching vertex attributes.">nvn::CommandBuffer::BindVertexBuffer</a> and vertex attribute and stream state programmed via <a class="el" href="classnvn_1_1_command_buffer.html#aa57223468c54a870cd07cee18752a1a9" title="Specify a vertex attribute layout for subsequent commands.">nvn::CommandBuffer::BindVertexAttribState</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a5c5c1896e8850f177606530b2599226f" title="Specify a vertex stream layout for subsequent commands.">nvn::CommandBuffer::BindVertexStreamState</a>. Multiple vertex buffers may be bound in a single call using nvn::CommmandBuffer::BindVertexBuffer.</p>
<p>Each vertex shader input variable is associated with a numbered vertex attribute, either using the "location" layout qualifier: </p><pre class="fragment">layout(location=4) in vec4 vertexAttribute;
</pre><p> or using a vertex attribute number assigned by the GLSL compiler. The values fetched for a vertex shader input associated with vertex attribute <em>n</em> are determined using the following process:</p>
<ul>
<li><b>Vertex attribute</b> <em>n</em> is enabled or disabled in the vertex attribute state object. If the <em>numAttribs</em> parameter passed in the last call to <a class="el" href="classnvn_1_1_command_buffer.html#aa57223468c54a870cd07cee18752a1a9" title="Specify a vertex attribute layout for subsequent commands.">nvn::CommandBuffer::BindVertexAttribState</a> is less than <em>n</em>, or if vertex attribute state object <em>n</em> in the array passed in <em>attribs</em> parameter does not have a format programmed by <a class="el" href="classnvn_1_1_vertex_attrib_state.html#ab142ebc5f4667047e40d26754aee83bf" title="Specifies the format (in memory) for values for a single vertex attribute.">nvn::VertexAttribState::SetFormat</a>, the attribute is disabled. Otherwise, the attribute is enabled. If attribute <em>n</em> is disabled, a value of (0,0,0,1) is returned for the vertex attribute.</li>
<li>If vertex attribute <em>n</em> is enabled, its values will be fetched from the the <b>vertex stream</b> associated with that attribute. The stream used by a vertex attribute is programmed by <a class="el" href="classnvn_1_1_vertex_attrib_state.html#a99d3b3ec8a8b6f2fa6b0054c9277132c" title="Specifies the vertex attribute stream binding index.">nvn::VertexAttribState::SetStreamIndex</a>, whose value we will refer to as <em>b</em>. If the programmed stream number <em>b</em> is greater than or equal to the <em>numStreams</em> parameter passed in the last call to <a class="el" href="classnvn_1_1_command_buffer.html#a5c5c1896e8850f177606530b2599226f" title="Specify a vertex stream layout for subsequent commands.">nvn::CommandBuffer::BindVertexStreamState</a>, attribute <em>n</em> is considered disabled.</li>
<li>When fetching attributes from vertex stream <em>b</em> for a given vertex, the base address used in the binding for that vertex is given by <em>buffer_address</em> + <em>index</em> * <em>stride</em>. The address <em>buffer_address</em> is programmed by calling <a class="el" href="classnvn_1_1_command_buffer.html#ad5187aa77bf5509c1a02bae33ea3b17c" title="Bind a range of a Buffer object to use for fetching vertex attributes.">nvn::CommandBuffer::BindVertexBuffer</a> with an <em>index</em> value of <em>b</em>. Vertex buffer binding <em>b</em> is always associated with vertex stream <em>b</em>. The stride <em>stride</em> is programmed in stream <em>b</em> using <a class="el" href="classnvn_1_1_vertex_stream_state.html#a726a6b8669b08eb9775088041209fb9e" title="Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding poi...">nvn::VertexStreamState::SetStride</a>. If the value programmed in <a class="el" href="classnvn_1_1_vertex_stream_state.html#a98e2f5bb12bc9465739d5de542a9b08a" title="Specifies the frequency divisor for vertices in vertex binding N.">nvn::VertexStreamState::SetDivisor</a> for stream <em>b</em> is zero (default), attributes using stream <em>b</em> are considered to be per-vertex, and <em>index</em> is set to vertex number. If the divisor is set to a non-zero value, attributes using stream <em>b</em> are considered per-instance, and <em>index</em> is set to the instance number divided by the divisor.</li>
<li>Once the base address for the vertex in stream <em>b</em> is established, an additional offset (in bytes) programmed by the <em>relativeOffset</em> parameter in <a class="el" href="classnvn_1_1_vertex_attrib_state.html#ab142ebc5f4667047e40d26754aee83bf" title="Specifies the format (in memory) for values for a single vertex attribute.">nvn::VertexAttribState::SetFormat</a> for attribute <em>n</em> is added to the base address for stream <em>b</em>.</li>
<li>The values for the attribute are fetched from the post-offset address according to the format given by the <em>format</em> parameter in <a class="el" href="classnvn_1_1_vertex_attrib_state.html#ab142ebc5f4667047e40d26754aee83bf" title="Specifies the format (in memory) for values for a single vertex attribute.">nvn::VertexAttribState::SetFormat</a>. More information on formats can be found in the <a href="#nvn_guide_formats">formats section of this guide</a>. Not all formats are supported for use as vertex attributes.</li>
</ul>
<p>Unlike OpenGL, NVN does not support constant vertex attribute values (<code>glVertexAttrib4f</code>) that are used when vertex attributes are disabled. To use a non-zero constant value for all vertices in a primitive, applications should store the constant value in a vertex buffer and program a binding stride of zero using <a class="el" href="classnvn_1_1_vertex_stream_state.html#a726a6b8669b08eb9775088041209fb9e" title="Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding poi...">nvn::VertexStreamState::SetStride</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_3"></a>
10.3. Tessellation Control Shaders</h2>
<p>After primitives are processed by the vertex shader, patch primitives (of type <a class="el" href="structnvn_1_1_draw_primitive.html#affab27b6c3b0c110d7871663e75887b3a639a1bb6deb14ff2cf17eaf8687384c8" title="Renders a collection of independent patches.">nvn::DrawPrimitive::PATCHES</a>) may be processed by the optional tessellation control shader. Each patch primitive is a fixed-size array of 1 to 32 vertices, where the size is specified by <a class="el" href="classnvn_1_1_command_buffer.html#a580ce64d255d8aa9a7f0bfbda34ae995" title="Specify the number of vertices in each patch when rendering patch primitives.">nvn::CommandBuffer::SetPatchSize</a>. Tessellation control shaders consume each patch provided by the application and produce a new fixed-size patch. These shaders compute attributes for each vertex in the output patch, additional attributes for the entire output patch, and levels of detail that will be used by the fixed-function tessellator. A separate tessellation control shader thread is run for each vertex of the output patch and is assigned to produce the attributes of a specific vertex in the output patch.</p>
<p>The tessellation control shader is optional; if no tessellation control shader is enabled, this pipeline stage is disabled. Tessellation control shaders only support processing primitives of type <a class="el" href="structnvn_1_1_draw_primitive.html#affab27b6c3b0c110d7871663e75887b3a639a1bb6deb14ff2cf17eaf8687384c8" title="Renders a collection of independent patches.">nvn::DrawPrimitive::PATCHES</a>. Providing graphics primitives of any other type when a tessellation control shader is active has undefined behavior and can result in program termination.</p>
<p>Tessellation control programs that were compiled from SPIR-V may also contain tessellation parameters ("execution mode" in SPIR-V terms; see the SPIR-V reference <a href="https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#Execution_Mode">here</a>). See <a href="#nvn_tessellation_execution_modes">this section</a> for more information about tessellation execution mode parameters.</p>
<p>The tessellation control shader is referred to as the <em>hull shader</em> in the Direct3D API.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_4"></a>
10.4. Tessellation Evaluation Shaders</h2>
<p>After primitives are processed or passed through by the tessellation control shader stage, patch primitives (of type <a class="el" href="structnvn_1_1_draw_primitive.html#affab27b6c3b0c110d7871663e75887b3a639a1bb6deb14ff2cf17eaf8687384c8" title="Renders a collection of independent patches.">nvn::DrawPrimitive::PATCHES</a>) may be processed by the optional tessellator and tessellation evaluation shader. When a tessellation evaluation shader is active, patch primitives are subdivided by a fixed-function tessellator according to inner and outer levels of detail associated with the patch. If a tessellation control shader is active, the levels of detail used are those written by the tessellation control shader. Tessellation in NVN does not require the use of a tessellation control shader. If no such shader is active, fixed outer and inner levels provided by the commands <a class="el" href="classnvn_1_1_command_buffer.html#a953c968a32947a0bfd7cf38ccf89d925" title="Specify default outer tessellation levels when rendering patch primitives.">nvn::CommandBuffer::SetOuterTessellationLevels</a> and <a class="el" href="classnvn_1_1_command_buffer.html#ae4491406f044f024bcca908a1a6f9b27" title="Specify default inner tessellation levels when rendering patch primitives.">nvn::CommandBuffer::SetInnerTessellationLevels</a> will be used to control tessellation.</p>
<p>The tessellator produces a collection of points, lines, or triangles, depending on layout qualifiers specified in the GLSL tessellation evaluation shader source. Other layout qualifiers in the tessellation evaluation shader control the operation of the tessellator itself. In SPIR-V, these parameters are derived from the tessellation "execution modes" specified in the source binaries (see <a href="https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#Execution_Mode">https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#Execution_Mode</a>). If both the tessellation control and tessellation evaluation shaders contain tessellation execution mode parameters, the parameters are processed by NVN according to the rules in <a href="#nvn_tessellation_execution_modes">this section</a>.</p>
<p>After a patch is subdivided by the tessellator, tessellation evaluation shaders are used to compute the position and attributes of new vertices produced by the tessellator. A separate thread is run for each vertex produced by the tessellator and is used to calculate the position and other attributes of the vertex.</p>
<p>The tessellation evaluation shader is optional; if no tessellation evaluation shader is enabled, this pipeline stage is disabled. Tessellation evaluation shaders only support processing primitives of type <a class="el" href="structnvn_1_1_draw_primitive.html#affab27b6c3b0c110d7871663e75887b3a639a1bb6deb14ff2cf17eaf8687384c8" title="Renders a collection of independent patches.">nvn::DrawPrimitive::PATCHES</a>. Providing graphics primitives of any other type when a tessellation evaluation shader is active has undefined behavior and can result in program termination.</p>
<p>The tessellation evaluation shader is referred to as the <em>domain shader</em> in the Direct3D API.</p>
<h3><a class="anchor" id="nvn_tessellation_execution_modes"></a>
Tessellation execution mode parameters</h3>
<p>Tessellation control and evaluation shaders can specify different parameters to dictate how NVN sets up the tessellator unit. These are set by using either layout qualifiers (GLSL) in the evaluation shader, or by specifying execution modes (SPIR-V) in the control and/or the evaluation shaders. In the SPIR-V case, control shaders are only allowed to contain these paramters if the NVN driver supports binaries from GLSLC GPU code version 1.16 or later. The four different tessellation parameters that can be specified in the control and/or evaluation shaders are: primitive mode, point mode, vertex spacing mode, and primitive ordering. For full details about each of these parameters, see either the <a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.pdf">GLSL</a> specification or the <a href="https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.pdf">SPIR-V</a> specification.</p>
<p>NVN will only use one set of tessellation parameters for each draw call, not for each stage or program individually. NVN follows a set of rules to determine how to set up the hardware tessellator unit based on the programs that are bound for drawing and the primitive mode that is declared in the shaders. NVN also handles programs containing both a tessellation control and a tessellation evaluation shader differently from programs containing only one of the two stages. One of the following two sets of rules are used:</p>
<p>1: When both tessellation control and tessellation evaluation stages are present in the same program, NVN will merge the tessellation state from each stage in the following way for each parameter:</p>
<ul>
<li>If both stages specify the parameter identically, then NVN will set that parameter.</li>
<li>If the stages specify the parameter differently, then NVN will send the tessellation evaluation shader's parameter value and will emit a debug layer warning.</li>
<li>If only one stage specifies the parameter, then NVN will use that parameter.</li>
<li>If no stage specifies the parameter, then NVN will set the default value for the parameter. If the parameter is the non-optional primitive mode parameter, NVN will still set a default value but a debug layer warning will also be emitted.</li>
</ul>
<p>2: When a program contains only one of the two tessellation shader types, it may need to be combined with another program that contains the other shader type at run-time. When this happens, NVN will set up the hardware to use the tessellation state from one program and will ignore any state from the other. NVN uses the primitive mode parameter to determine whether an individual program's state should be ignored. In this case, the following rules apply:</p>
<ul>
<li>If a program with only one tessellation shader stage declares a primitive mode, NVN will treat it as fully declaring all tessellation state, using defaults for undeclared parameters.</li>
<li>If a program with only one tessellation shader stage does not declare a primitive mode, NVN will treat it as not declaring any tessellation state. This means binding this program will not overwrite any state that could have been set from a previously bound tessellation program.</li>
<li>When using tessellation, a draw-time error occurs if there is an active tessellation control or tessellation evaluation shader, but the program(s) containing those shaders have no tessellation state (which will also happen if neither shader specifies primitive mode).</li>
<li>When using tessellation, a draw-time error occurs if there are active tessellation control and tessellation evaluation shaders in separate programs and those programs have the same parameter with different values in each stage.</li>
</ul>
<p>The following are the default values for these parameters in cases where NVN requires setting the default value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Parameter   </th><th class="markdownTableHeadNone">Default Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">primitive mode   </td><td class="markdownTableBodyNone">triangles    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">point mode   </td><td class="markdownTableBodyNone">no    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">primitive ordering   </td><td class="markdownTableBodyNone">counter-clockwise    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">vertex spacing mode   </td><td class="markdownTableBodyNone">equal spacing   </td></tr>
</table>
<p>These match the OpenGL default values for the same parameters. If not specified, then point mode, vertex spacing mode, primitive ordering, and primitive mode parameters will default to values listed above. However, note that the default values will only be sent to the hardware according to the rules listed above. If no commands are sent to the hardware to set up tessellation parameters, then issuing a draw call while tessellation programs are bound will result in undefined tessellation behavior.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Tessellated primitive orientation</h3>
<p>When the tessellation primitive generator produces triangles (in the "triangles" or "quads" modes), the orientation of all triangles can be specified by an input layout declaration in the tessellation evaluation or control shader using the identifiers "cw" and "ccw". If the order is "cw", the vertices of all generated triangles will have a clockwise ordering in (u,v) or (u,v,w) space, as illustrated in <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_tessellation_shader.txt">figure X.2 of the ARB_tessellation_shader OpenGL specification</a>. If the order is "ccw", the vertices will be specified in counter-clockwise order. If no layout is specified, "ccw" will be used.</p>
<p>The orientation is only meaningful in (u,v,w) parameter space space. The triangulation happens before the tessellation evaluation shader computes the output tessellated vertex position (gl_Position), and before any transformations are applied get into final screen-space coordinates. The tessellation in (u,v,w) space is similar to the OpenGL model where the (u,v,w) space's origin is defined to be in the lower-left in (u,v,w) parameter space (this is separate from window origin mode).</p>
<p>Subsequent position transformations and projections may flip the primitive relative to the (u,v,w) coordinate space which would in turn flip the orientation. Additionally, the window origin mode will affect how vertex position values are interpreted as either clockwise or counter-clockwise in the final output coordinates and will also contribute to the orientation of the triangles.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_5"></a>
10.5. Geometry Shaders</h2>
<p>After primitives are processed or passed through by the tessellation evaluation shader, primitives may be processed by the optional geometry shader. Geometry shaders are used to process point, line, triangle, or patch primitives produced by the application. The geometry shader consumes each input primitive and emits new vertices that are arranged into output primitives used by subsequent pipeline stages.</p>
<p>The geometry shader is optional; if no geometry shader is enabled, this pipeline stage is disabled. The type of input primitive consumed by a geometry shader and the type of output primitive produced by a geometry shader are specified by layout qualifiers in the GLSL geometry shader source. If a primitive reaching the geometry shader stage has a type incompatible with the input primitive type expected by the geometry shader, the behavior of the geometry shader stage is undefined and can result in program termination.</p>
<p>While geometry shaders can emit a variable number of vertices, there are implementation-dependent limits on the number of vertices and the total number of output variable components that can be emitted by a geometry shader. The geometry shader must declare the maximum number of vertices it can emit using the <code>max_vertices</code> layout qualifier. Geometry shader compilation will fail if the declared maximum vertex count exceeds the hardware limit (1024), or if the product of the maximum vertex count and the number of components of per-vertex output exceeds the maximum total component output count (also 1024).</p>
<h3><a class="anchor" id="autotoc_md80"></a>
Passthrough Geometry Shaders</h3>
<p>NVN supports <em>passthrough</em> geometry shaders, as described in the <a href="https://www.opengl.org/registry/specs/NV/geometry_shader_passthrough.txt">NV_geometry_shader_passthrough OpenGL extension</a>. Unlike ordinary geometry shaders, passthrough geometry shaders do not emit vertices and can not modify the topology of the input primitive. The original input primitive is passed through, where all input variables qualified with the <code>passthrough</code> layout qualifier are effectively copied to equivalent output variables and used by later pipeline stages. The passthrough geometry shader has access to all vertices of the input primitive and can be used to compute values for per-primitive output variables that are available to later pipeline stages.</p>
<p>For example, a passthrough geometry shader can be used to perform triangle culling computations by evaluating the position of the three input vertices and determining if the primitive should be drawn. If the shader decides to cull the input primitive, it writes zero to the <code>gl_ViewportMask[0]</code> built-in provided by the <a href="https://www.opengl.org/registry/specs/NV/viewport_array2.txt">NV_viewport_array2 OpenGL extension</a>. In other use cases, passthrough geometry shaders can select a set of viewports to use in a multi-resolution multi-viewport renderer, select a set of cube faces to project the primitive onto for single-pass cube map rendering, or to compute per-primitive attributes such as facet normals.</p>
<p>There are a number of restrictions on the use of passthrough geometry shaders:</p>
<ul>
<li>The input variable <code>gl_Position</code> must be qualified with the <code>passthrough</code> layout qualifier; per-primitive positions are not supported.</li>
<li>The passthrough geometry shader may not write per-primitive clip distances (using the output <code>gl_ClipDistance[]</code>) or point sizes (<code>gl_PointSize</code>).</li>
<li>Any per-primitive outputs produced by the passthrough geometry shader that are read by the fragment shader must be qualified by <code>flat</code> in the fragment shader. Reading per-primitive outputs in a fragment shader without the <code>flat</code> qualifier will return undefined values.</li>
<li>Transform feedback must be disabled when passthrough geometry shaders are enabled.</li>
<li>If a passthrough geometry shader is used together with a tessellation evaluation shader, both shaders must be compiled using the <code>tessellationAndPassthroughGS</code> option set in the GLSLC compiler options. Additionally, the tessellation evaluation shader must not write to the <code>gl_PointSize</code> or <code>gl_Layer</code> output.</li>
</ul>
<p>If any of these restrictions is violated, the results of rendering are undefined and could result in GPU errors.</p>
<p>Passthrough geometry shaders are only available on NX and second-generation Maxwell GPUs.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_6"></a>
10.6. Transform Feedback</h2>
<p>After graphics primitives have been processed or passed through by all stages of the programmable vertex processing pipeline, the contents of the primitives' vertices may be captured to buffer memory using <em>transform feedback</em>. When transform feedback is active, attributes of each vertex of each primitive entering this pipeline stage can be written to buffer memory. Applications can bind up to four different buffer ranges to receive attributes of the captured vertices. For each buffer, the first vertex captured writes attributes starting at the first byte of the range, and each subsequent vertex begins writing at a fixed offset relative to the previous captured vertex. If capturing a primitive would write off the end of the bound buffer range for any transform feedback buffer, that primitive and all subsequent primitives will not be captured.</p>
<p>Transform feedback is started with <a class="el" href="classnvn_1_1_command_buffer.html#a6e05f90c241cb01ffe07862ae2afaad5" title="Start a transform feedback (stream output) operation.">nvn::CommandBuffer::BeginTransformFeedback</a> and completed with <a class="el" href="classnvn_1_1_command_buffer.html#ab6086eb5893574fe192d08454c246972" title="Complete a transform feedback (stream output) operation.">nvn::CommandBuffer::EndTransformFeedback</a>. Transform feedback can also be temporarily paused with <a class="el" href="classnvn_1_1_command_buffer.html#acf2263122bab5991d4a99212493657b7" title="Pause a transform feedback (stream output) operation.">nvn::CommandBuffer::PauseTransformFeedback</a> and resumed with <a class="el" href="classnvn_1_1_command_buffer.html#ae69b628752585094f50ff22cbba8ab69" title="Resume a transform feedback (stream output) operation.">nvn::CommandBuffer::ResumeTransformFeedback</a>. All of these transform feedback commands use a 32-byte control structure in memory pointed to by the <em>buffer</em> parameter that capture the state of the transform feedback operation. For BeginTransformFeedback and EndTransformFeedback, a non-zero buffer address is required. For PauseTransformFeedback and ResumeTransformFeedback, an address of zero is allowed, in which case ResumeTransformFeedback will continue using the previous transform feedback state. When pausing and resuming, a non-zero buffer is required only if the application switches to another transform feedback operation while the first operation is paused. The control structure may also be used to render primitives captured in a previous transform feedback operation by passing it to <a class="el" href="classnvn_1_1_command_buffer.html#a9ab04f8a0370eb42f81c9d307016f7cb" title="Draw primitives captured in a previous transform feedback (stream output) operation.">nvn::CommandBuffer::DrawTransformFeedback</a>.</p>
<p>To specify the buffer ranges to capture attributes, a single range may be bound to capture attributes using <a class="el" href="classnvn_1_1_command_buffer.html#a6d2ad7d6b0e29930b13d8590026a074c" title="Bind a range of a Buffer object to use for capturing transformed vertex data.">nvn::CommandBuffer::BindTransformFeedbackBuffer</a>, and multiple ranges may be bound in a single call to <a class="el" href="classnvn_1_1_command_buffer.html#a9594fd76317f902d6c3dc6f74e71e8a4" title="Bind one or more Buffer object ranges to use for capturing transformed vertex data.">nvn::CommandBuffer::BindTransformFeedbackBuffers</a>.</p>
<p>The set of attributes to capture during transform feedback is established when shaders are compiled by the GLSLC shader compiler. Attributes may be selected for capture using the <code>xfb_buffer</code>, <code>xfb_stride</code>, and <code>xfb_offset</code> layout qualifiers or using the <code><a class="el" href="struct_g_l_s_l_cxfb_varying_info.html" title="An information data section corresponding to an individual transform feedback varying.">GLSLCxfbVaryingInfo</a></code> structure to identify attributes by name. Each attribute to capture is associated with one of the four transform feedback binding points. Using the transform feedback information established at shader compilaton time, each binding point is assigned a <em>stride</em>, indicating the number of bytes used to record each vertex. Each attribute captured is assigned an offset relative to the first byte of its binding point used for each captured vertex, and attribute values will be written at that offset. The transform feedback state used for capture will come from the last enabled shader (vertex, tessellation control, tessellation evaluation, or geometry), whose primitives will be sent to subsequent pipeline stages.</p>
<p>The number of primitives captured during transform feedback is counted by the counter <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ac6bf904cc36a49dbd95419a3b75d7fde" title="Reports the number of primitives captured during transform feedback.">nvn::CounterType::TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</a>. The total number of primitives processed by the fragment shader stage, whether or not transform feedback is active, is counted by the counter <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29a3d3de6262236b76b5c07dbde90d4db7a" title="Reports the number of primitives produced for clipping and rasterization.">nvn::CounterType::PRIMITIVES_GENERATED</a>. If transform feedback capture overflows any buffer binding ranges, the overflowing primitive and all subsequent ones will be counted only by PRIMITIVES_GENERATED.</p>
<p>If an application wants to capture primitives using transform feedback without rasterizing or running fragment shaders, <a class="el" href="classnvn_1_1_command_buffer.html#a20400dc9d0edb9f7069d83c3b6106b38" title="Enable or disable rasterizer discard.">nvn::CommandBuffer::SetRasterizerDiscard</a> can be used to discard all primitives after the transform feedback stage.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_7"></a>
10.7. Viewport Selection</h2>
<p>After graphics primitives have been processed or passed through by all stages of the programmable vertex processing pipeline, they are sent to one or multiple <em>viewports</em>. NVN supports up to 16 separate viewports, where each viewport identifies a rectangular region of the render target and a range of the depth buffer that each primitive is projected onto.</p>
<p>The viewport used when mapping a vertex to window coordinates depends on the programmable shaders used prior to the viewport transformation:</p>
<ul>
<li>If the last enabled shader in the vertex processing pipeline writes to the built-in output <code>gl_ViewportIndex</code>, the value of <code>gl_ViewportIndex</code> identifies a single viewport used for the primitive.</li>
<li>If the last enabled shader in the vertex processing pipeline writes to the built-in output <code>gl_ViewportMask[]</code>, the value in <code>gl_ViewportMask[0]</code> is treated as a bitfield identifying a set of viewports used for the primitive. If viewport mask bit <em>N</em> is set, the primitive will be sent to viewport <em>N</em>; otherwise, it will not be sent to viewport <em>N</em>. A mask with multiple bits set will broadcast the primitive to multiple viewports and a mask of zero will cause the primitive to be discarded.</li>
<li>If the last enabled shader does not write to either <code>gl_ViewportIndex</code> or <code>gl_ViewportMask[]</code>, the primitive will be sent to viewport zero.</li>
</ul>
<p>The built in <code>gl_ViewportMask[]</code> is not currently part of the core OpenGL or OpenGL ES shading languages, and is provided by the <a href="https://www.opengl.org/registry/specs/NV/viewport_array2.txt">NV_viewport_array2</a> extension. The viewport mask is only supported on NX and second-generation Maxwell GPUs.</p>
<p>When the viewport index or viewport mask is used for line and triangle primitives, there will be a separate value for each vertex. The value used for viewport selection will be taken from the <em>provoking vertex</em> of the primitive. In NVN, the provoking vertex of a primitive follows OpenGL conventions and is typically the last vertex specified. For example, a triangle strip primitive with vertex index values of 0, 1, 2, 3, 4, and 5, will produce four triangle primitives, with provoking vertices of 2, 3, 4, and 5, respectively. The provoking vertex is also used when selecting values for flat-shaded vertex attributes during rasterization.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_8"></a>
10.8. Viewport Swizzle</h2>
<p>For each primitive sent to a viewport, the <em>viewport swizzle</em> operation can be used to modify the components of each vertex's position. The original position is specified by as a four-component vector of <em>clip coordinates</em> (x<sub>c</sub>, y<sub>c</sub>, z<sub>c</sub>, w<sub>c</sub>) taken from the value of <code>gl_Position</code>. The viewport swizzle assembles a new clip coordinate vector, where each of the four components of the vector can be taken from the +x<sub>c</sub>, -x<sub>c</sub>, +y<sub>c</sub>, -y<sub>c</sub>, +z<sub>c</sub>, -z<sub>c</sub>, +w<sub>c</sub>, or -w<sub>c</sub> values from the original clip coordinates. While no arithmetic is supported by this transformation, the component selection allows applications to rotate and mirror a scene around the axes in the clip coordinate space. This transformation is useful for projecting a primitive onto all six faces of a cube map or for orienting a primitive in the appropriate direction for voxel rasterization.</p>
<p>The viewport swizzle can be specified for one or multiple viewports using the command nvn::CommandBuffer::SetViewportSwizzle. For each viewport, the application should specify four swizzle selectors of the type <a class="el" href="structnvn_1_1_viewport_swizzle.html" title="Specifies an input value to use for one component of the position vector produced by the viewport swi...">nvn::ViewportSwizzle</a>. By default, the swizzle for each viewport selects (+x<sub>c</sub>, +y<sub>c</sub>, +z<sub>c</sub>, +w<sub>c</sub>), which passes through <code>gl_Position</code> without modification.</p>
<p>The viewport swizzle operation is only supported on NX and second-generation Maxwell GPUs.</p>
<h2><a class="anchor" id="nvn_guide_clipping"></a>
10.9. Primitive Clipping</h2>
<p>After primitives are processed by the viewport swizzle operation, they are clipped to a fixed <em>view volume</em>. By default, clipping in NVN follows OpenGL conventions, where primitives are clipped to satisfy the following inequalities:</p>
<blockquote class="doxtable">
<p>-w<sub>c</sub> &lt;= x<sub>c</sub> &lt;= +w<sub>c</sub> <br  />
 -w<sub>c</sub> &lt;= y<sub>c</sub> &lt;= +w<sub>c</sub> <br  />
 -w<sub>c</sub> &lt;= z<sub>c</sub> &lt;= +w<sub>c</sub> </p>
</blockquote>
<p>However, NVN applications can instead use Direct3D view volume conventions by calling <a class="el" href="classnvn_1_1_device.html#a11a7a578db399ec77a9ecccc24fd4695" title="Set the global clipping range for normalized depth in clip space.">nvn::Device::SetDepthMode</a>, passing a value of <a class="el" href="structnvn_1_1_depth_mode.html#ae6e12f0c14c4a32b63642f28bfbf9d16ad4b6ca05a32e614d2d42ca26da594bcf" title="The near clip plane is located at zero, following Direct3D conventions.">nvn::DepthMode::NEAR_IS_ZERO</a>, in which case primitives are clipped to instead satisfy the following inequalities:</p>
<blockquote class="doxtable">
<p>-w<sub>c</sub> &lt;= x<sub>c</sub> &lt;= +w<sub>c</sub> <br  />
 -w<sub>c</sub> &lt;= y<sub>c</sub> &lt;= +w<sub>c</sub> <br  />
 0 &lt;= z<sub>c</sub> &lt;= +w<sub>c</sub> </p>
</blockquote>
<p>The OpenGL-compatible mode described above corresponds to the depth mode <a class="el" href="structnvn_1_1_depth_mode.html#ae6e12f0c14c4a32b63642f28bfbf9d16a3cc4f7e4dc0037c067bbca1bbef7bc69" title="The near clip plane is located at -W (i.e., -1 when depth is normalized as z/w), following default Op...">nvn::DepthMode::NEAR_IS_MINUS_W</a>.</p>
<p>The depth mode state belongs to the device object and is inherited by queue and command buffer objects created from the device. The results of clipping are undefined unless the depth mode state in the device, queue, and command buffer objects used to submit primitives are identical. We recommend that applications needing to set the depth mode do so once immediately after creating a device, and before creating any queues or command buffers.</p>
<p>While the above inequalities describe the basic operation of clipping in NVN, the implementation supports <em>guard-band clipping</em> for improved performance. When performing guard-band clipping, NVN does not clip primitives that extend beyond the left, right, top, and bottom clip planes, as long as they don't extend too far beyond those clip planes. Instead, these primitives will be passed through the clipper stage unmodified, and the portions of the primitive that would fall outside the clip volume are discarded during rasterization.</p>
<p>In addition to clipping primitives to the view volume, primitives may be clipped to one or more programmable clip planes using <em>clip distances</em> written to the GLSL built-in output <code>gl_ClipDistance[]</code>. For each element <em>i</em> in the array <code>gl_ClipDistance[]</code>, the primitive is clipped to satisfy the following inequality:</p>
<blockquote class="doxtable">
<p><em>gl_ClipDistance</em>[<em>i</em>] &gt;= 0 </p>
</blockquote>
<p>Unlike OpenGL, NVN has no controls to enable or disable clip planes. All clip planes are enabled by default and cannot be disabled in the API. Shaders that contain a statement assigning to <code>gl_ClipDistance</code> with a non-constant array index must re-declare <code>gl_ClipDistance[]</code> with an explicit size, and clip planes for indices greater than or equal to the declared size are ignored and treated as disabled. For all other shaders, a clip plane is ignored and treated as disabled if the shader does not include a statement assigning to the corresponding element of the <code>gl_ClipDistance</code> array. Each shader invocation must write to all clip distances that are not ignored as described above. If a shader invocation fails to assign a value to a non-ignored clip distance, its value is undefined and the results of clipping to the corresponding clip plane is also undefined.</p>
<h2><a class="anchor" id="nvn_guide_viewport"></a>
10.10. Viewport Transformation</h2>
<p>After clipping, primitives are projected onto the screen. First, each vertex in the primitive is transformed to normalized device coordinates (x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>) via the following equations:</p>
<blockquote class="doxtable">
<p>x<sub>d</sub> = x<sub>c</sub> / w<sub>c</sub> <br  />
 y<sub>d</sub> = y<sub>c</sub> / w<sub>c</sub> <br  />
 z<sub>d</sub> = z<sub>c</sub> / w<sub>c</sub> </p>
</blockquote>
<p>Then, the vertex is mapped to window coordinates (x<sub>w</sub>, y<sub>w</sub>, z<sub>w</sub>) using one of the 16 viewports.</p>
<p>Each viewport includes a rectangle on the screen with an origin (x<sub>v</sub>, y<sub>v</sub>), a width w<sub>v</sub>, and a height h<sub>v</sub>. Viewport rectangles are specified by the commands <a class="el" href="classnvn_1_1_command_buffer.html#a0c7f8f6b72d99364f85dbe0e5ebdcaa4" title="Specify the rectangle for viewport 0.">nvn::CommandBuffer::SetViewport</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a373958d6d0ef429a0b66c37c92abf7b2" title="Specify one or more viewport rectangles.">nvn::CommandBuffer::SetViewports</a>. SetViewport sets the extents of viewport zero using integer values; SetViewports sets the extents of multiple viewports using an array of floating-point values.</p>
<p>Each viewport also includes a depth range with near and far depth values, which we will call n<sub>v</sub> and f<sub>v</sub>. Depth ranges are specified by the commands <a class="el" href="classnvn_1_1_command_buffer.html#a8271958565ab72d7a3dc216a5bcf13c7" title="Set the range of depth values for rendered primitives.">nvn::CommandBuffer::SetDepthRange</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a64e4979f26c85f912363be9b5f1ab121" title="Sets multiple ranges of depth values for rendered primitives.">nvn::CommandBuffer::SetDepthRanges</a>. SetDepthRange sets the near and far values for viewport zero using two floating-point values; SetDepthRanges sets the near and far values of multiple viewports using an array of floating-point values.</p>
<p>By default, window coordinates are computed using the following equations:</p>
<blockquote class="doxtable">
<p>x<sub>w</sub> = (x<sub>v</sub> + w<sub>v</sub>/2) + x<sub>d</sub> * (w<sub>v</sub>/2) <br  />
 y<sub>w</sub> = (y<sub>v</sub> + h<sub>v</sub>/2) + y<sub>d</sub> * (h<sub>v</sub>/2) <br  />
 z<sub>w</sub> = (n<sub>v</sub> + f<sub>v</sub>)/2 + z<sub>d</sub> * ((f<sub>v</sub>-n<sub>v</sub>)/2) </p>
</blockquote>
<p>If the depth mode is set to <a class="el" href="structnvn_1_1_depth_mode.html#ae6e12f0c14c4a32b63642f28bfbf9d16ad4b6ca05a32e614d2d42ca26da594bcf" title="The near clip plane is located at zero, following Direct3D conventions.">nvn::DepthMode::NEAR_IS_ZERO</a>, the z window coordinate is instead computed using:</p>
<blockquote class="doxtable">
<p>z<sub>w</sub> = n<sub>v</sub> + z<sub>d</sub> * (f<sub>v</sub>-n<sub>v</sub>) </p>
</blockquote>
<p>By default, window coordinates in NVN match the conventions of OpenGL, where the pixel with coordinates (0,0) is considered to be the in the lower left corner of the screen, and where a window coordinate (x<sub>w</sub>,y<sub>w</sub>) of (0.0, 0.0) is considered to represent the lower left corner of pixel (0,0). However, NVN applications can instead use Direct3D conventions by calling <a class="el" href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497" title="Set the global location for window coordinates (0,0).">nvn::Device::SetWindowOriginMode</a>, passing a value of <a class="el" href="structnvn_1_1_window_origin_mode.html#ac732445c1220d5718064a49032d292b5a1d7d7a47b208c3688d48678a86b2043f" title="The origin is located at the upper-left corner of the window, following Direct3D conventions.">nvn::WindowOriginMode::UPPER_LEFT</a>. In UPPER_LEFT mode, the pixel with coordinates (0,0) is considered to be the in the upper left corner of the screen, where a window coordinate (x<sub>w</sub>,y<sub>w</sub>) of (0.0, 0.0) is considered to represent the upper left corner of pixel (0,0). Additionally, the y window coordinate is instead computed using:</p>
<blockquote class="doxtable">
<p>y<sub>w</sub> = (y<sub>v</sub> + h<sub>v</sub>/2) - y<sub>d</sub> * (h<sub>v</sub>/2) </p>
</blockquote>
<p>The OpenGL-compatible mode described above corresponds to the window origin mode <a class="el" href="structnvn_1_1_window_origin_mode.html#ac732445c1220d5718064a49032d292b5ad774de71b1ccbc1669f6a7c0e03182ff" title="The origin is located at the lower-left corner of the window, following default OpenGL conventions.">nvn::WindowOriginMode::LOWER_LEFT</a>.</p>
<p>As with the depth mode, the window origin mode state belongs to the device object and is inherited by queue, command buffer, and window objects created from the device. The results of the viewport transformation and subsequent rasterization are undefined unless the window origin mode state in the device, queue and command buffer objects used to submit primitives are identical. If the window origin mode state in the device and window objects are not consistent, rendered frames may be presented incorrectly. We recommend that applications needing to set the window origin mode do so once immediately after creating a device, and before creating any queues, command buffers, or windows.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_11"></a>
10.11. Rasterization</h2>
<p>After graphics primitives are clipped and transformed to screen coordinates, the rasterizer pipeline stage computes the set of pixels on the screen covered by the primitive and generates a <em>fragment</em> for each such pixel. Each fragment produced by the rasterizer has an associated (x,y) coordinate and a collection of interpolated fragment attributes (including a depth value) produced by computing weighted averages of the attributes of the vertices in the primitive being rasterized. Note that the fragment attributes produced by interpolation can be slightly outside the range of the primitive's per-vertex attributes. This can happen due to limited floating-point precision, or due to sampling outside the primitive when using multisample rasterization.</p>
<p>When primitives are rasterized, fragments outside the left, right, top, or bottom edges of the view volume are discarded as part of the implementation of <a href="#nvn_guide_clipping">guardband clipping</a>.</p>
<p>Additionally, each of the <a href="#nvn_guide_viewport">16 viewports</a> has a <em>scissor rectangle</em> with an origin, (x<sub>s</sub>, y<sub>s</sub>), a width w<sub>s</sub>, and a height h<sub>s</sub>. Scissor rectangles are specified by the commands <a class="el" href="classnvn_1_1_command_buffer.html#a5f511de71b6bec1603e68bb8fd5ba424" title="Specify the scissor rectangle used for clipping primitives and clears.">nvn::CommandBuffer::SetScissor</a> and <a class="el" href="classnvn_1_1_command_buffer.html#af379c72c350eeb7623d498d10067b8f3" title="Specify one or more scissor rectangles.">nvn::CommandBuffer::SetScissors</a>. SetScissor sets the extents of scissor rectangle for viewport zero using integer values; SetScissors sets the scissor rectangles for multiple viewports using an array of integer values. The rasterizer will only produce fragments for pixels with coordinates (x,y) satisfying</p>
<blockquote class="doxtable">
<p>x<sub>s</sub> &lt;= x &lt; x<sub>s</sub> + w<sub>s</sub> <br  />
 y<sub>s</sub> &lt;= y &lt; y<sub>s</sub> + h<sub>s</sub> </p>
</blockquote>
<p>where x<sub>s</sub>, y<sub>s</sub>, w<sub>s</sub>, and h<sub>s</sub> identify the extents of the scissor rectangle for the viewport used by the rasterized primitive. The scissor test is always enabled in NVN. To effectively disable the scissor test, program a scissor rectangle with (x<sub>s</sub>, y<sub>s</sub>) set to (0,0) and with w<sub>s</sub> and h<sub>s</sub> set to values greater than or equal to the size of the render targets.</p>
<p>NVN supports single-sample and multisample rasterization, depending on the current value of the multisample rasterization enable in the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing.">nvn::MultisampleState</a> object. Multisample rasterization is enabled or disabled by calling <a class="el" href="classnvn_1_1_multisample_state.html#a703b817993977fd7e5f01771d0a7b0c1" title="Enable or disable multisample rasterization.">nvn::MultisampleState::SetMultisampleEnable</a>. The number of samples for each pixel must be programmed using <a class="el" href="classnvn_1_1_multisample_state.html#a166d9ef3f583a7901a5046e1169204b0" title="Specify the number of samples in the framebuffer.">nvn::MultisampleState::SetSamples</a>.</p>
<p>Point primitives are rasterized as square point sprites, whether multisample or conservative rasterization is enabled or disabled. The size of each point rasterized is given by:</p>
<ul>
<li>the value of the built-in GLSL output variable <code>gl_PointSize</code> for the vertex being rasterized, if <code>gl_PointSize</code> was written by the last enabled stage of the programmable vertex processing pipeline; or</li>
<li>the fixed point size specified via <a class="el" href="classnvn_1_1_command_buffer.html#a5dca4b84f62fb292de2ec41305209c55" title="Specifies the size (in pixels) of point primitives to render.">nvn::CommandBuffer::SetPointSize</a>, if <code>gl_PointSize</code> was not written by the last enabled stage of the programmable vertex processing pipeline.</li>
</ul>
<p>Line primitives are rasterized using Bresenham-style lines if multisample and conservative rasterization is disabled. Otherwise, line primitives are rasterized like rectangles using the multisample line rasterization algorithm described in the OpenGL specification.</p>
<p>Polygon primitives are rasterized as aliased triangles if multisample rasterization is disabled, or using the multisample triangle rasterization algorithm described in the OpenGL specification if multisample rasterization is enabled. Additionally, polygon primitive rasterization is affected by the controls in the <a class="el" href="classnvn_1_1_polygon_state.html" title="API state object controlling rasterization of polygons.">nvn::PolygonState</a> state object:</p>
<ul>
<li><a class="el" href="classnvn_1_1_polygon_state.html#a08f870982db1a2c614fdec62b423874e" title="Specify whether clockwise or counter-clockwise polygons are considered front-facing.">nvn::PolygonState::SetFrontFace</a> specifies whether a polygon is considered front-facing if it has a clockwise (<a class="el" href="structnvn_1_1_front_face.html#a2db0005f74a1f335fca9e73140c5dad6a64c714a922c3f82a8029afb67025336b" title="Clockwise primitives are considered front-facing.">nvn::FrontFace::CW</a>) or counter-clockwise (<a class="el" href="structnvn_1_1_front_face.html#a2db0005f74a1f335fca9e73140c5dad6ab2624a9dd5332161a83fae15a62c46f4" title="Counter-clockwise primitives are considered front-facing.">nvn::FrontFace::CCW</a>) orientation on the screen.</li>
<li><a class="el" href="classnvn_1_1_polygon_state.html#a987ea331981b36613f7c3523b24eb3d4" title="Specify controls for culling of front- and back-facing polygons.">nvn::PolygonState::SetCullFace</a> specifies whether front-facing and/or back-facing primitives are <em>culled</em> (discarded) without generating any fragments. Front-facing polygons are culled if the SetCullFace is called with <a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9aa7fc81b16a75e5ccf9ad5fad8476f9fd" title="Specifies that an operation applies to front-facing primitives only.">nvn::Face::FRONT</a> or <a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9a478d90f185c20906774cfad3337190ce" title="Specifies that an operation applies to both front- and back-facing primitives.">nvn::Face::FRONT_AND_BACK</a>. Back-facing polygons are culled if SetCullFace is called with <a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9acecad020721ad0de3b0224bd45c9bc88" title="Specifies that an operation applies to back-facing primitives only.">nvn::Face::BACK</a> or <a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9a478d90f185c20906774cfad3337190ce" title="Specifies that an operation applies to both front- and back-facing primitives.">nvn::Face::FRONT_AND_BACK</a>.</li>
<li><a class="el" href="classnvn_1_1_polygon_state.html#ad155a6b956b83e4661f6d1ee5e00ba83" title="Specifies whether polygons are rendered as points, lines, or triangles.">nvn::PolygonState::SetPolygonMode</a> allows applications to render polygon primitives as points (<a class="el" href="structnvn_1_1_polygon_mode.html#a8033f48cedebff6e36013da30e2e22c7a04a0669a4bd04399fdeec32911eef142" title="Polygon primitives should be rasterized as points.">nvn::PolygonMode::POINT</a>), lines (<a class="el" href="structnvn_1_1_polygon_mode.html#a8033f48cedebff6e36013da30e2e22c7a51b19f018173fce7eed872e6da7d6da6" title="Polygon primitives should be rasterized as outlines.">nvn::PolygonMode::LINE</a>), or filled triangles (<a class="el" href="structnvn_1_1_polygon_mode.html#a8033f48cedebff6e36013da30e2e22c7ac7fc7df0783f490eb7e25306616f2ab4" title="Polygon primitives should be rasterized as filled polygons.">nvn::PolygonMode::FILL</a>). Unlike the OpenGL compatibility profile, NVN provides no support for using a different polygon mode for front- and back-facing primitives.</li>
<li><a class="el" href="classnvn_1_1_polygon_state.html#a8ed608bd9faab39baadf8437f8f88e9a" title="Specify whether polygon offset is applied for point-mode, line-mode, and filled polygons.">nvn::PolygonState::SetPolygonOffsetEnables</a> allows applications to specify that the rasterizer add an additional offset to depth values associated with each fragment. The <em>enables</em> parameter is a bitfield, where the bits <a class="el" href="structnvn_1_1_polygon_offset_enable.html#aff98f1f495ad5b25ea6670f6529f7db1a851be6c9103e828bde1de91d1adb7b08" title="Polygon primitives rendered in POINT mode should be offset.">nvn::PolygonOffsetEnable::POINT</a>, <a class="el" href="structnvn_1_1_polygon_offset_enable.html#aff98f1f495ad5b25ea6670f6529f7db1aedf5c189f9020073880b2c7afbf42e48" title="Polygon primitives rendered in LINE mode should be offset.">nvn::PolygonOffsetEnable::LINE</a>, and <a class="el" href="structnvn_1_1_polygon_offset_enable.html#aff98f1f495ad5b25ea6670f6529f7db1aa4c5ddee82e96b8bcbdb36bcc426b8b0" title="Polygon primitives rendered in FILL mode should be offset.">nvn::PolygonOffsetEnable::FILL</a> enable polygon offset for polygon primitives drawn as points, lines, and filled triangles, respectively.</li>
</ul>
<p>When polygon offset is enabled for a primitive, the values specified by <a class="el" href="classnvn_1_1_command_buffer.html#a720e42e18e9818a05cc73ed7fa04a748" title="Specifies values used to compute a depth offset value when polygon offset is enabled.">nvn::CommandBuffer::SetPolygonOffsetClamp</a> are used to compute and clamp an offset that will be added to the interpolated depth value associated with each fragment.</p>
<h3><a class="anchor" id="nvn_guide_conservative_rasterization"></a>
Conservative Rasterization</h3>
<p>NVN supports <em>conservative rasterization</em>, where individual pixels are treated as covered if any portion of the pixel is covered by the rasterized point, line, or triangle. Conservative rasterization is enabled and disabled using <a class="el" href="classnvn_1_1_command_buffer.html#aa91972f2ddf79b233d4abf26838c82f5" title="Enable/disable conservative rasterization of rendered primitives.">nvn::CommandBuffer::SetConservativeRasterEnable</a>. When conservative rasterization is enabled, <a class="el" href="classnvn_1_1_command_buffer.html#a7c86df94525318a4cb2116b4f9194c03" title="Specifies the degree of primitive dilation when conservative rasterization is enabled.">nvn::CommandBuffer::SetConservativeRasterDilate</a> can be used to expand each primitive drawn slightly (up to 3/4 of a pixel). Also, <a class="el" href="classnvn_1_1_command_buffer.html#aea06553acf05d4707402343486a0125c" title="Specifies the number of additional bits of subpixel precision to be used for primitive rasterization ...">nvn::CommandBuffer::SetSubpixelPrecisionBias</a> can be used to avoid artifacts in applications rendering the same geometry to viewports of different sizes due to hardware snapping of post-viewport vertex coordinates. For example, one additional bit of subpixel precision will cause hardware to make the same rounding decisions when rendering to a 960x540 viewport as it would make when rendering to a 1920x1080 viewport with no extra precision. Further information on conservative rasterization functionality supported by NVN can be found in the <a href="https://www.opengl.org/registry/specs/NV/conservative_raster.txt">NV_conservative_raster</a> and <a href="https://www.opengl.org/registry/specs/NV/conservative_raster_dilate.txt">NV_conservative_raster_dilate</a> OpenGL extension specifications. Conservative rasterization is only supported on NX and second-generation Maxwell GPUs on Windows. Applications can determine if conservative rasterization is supported by checking the <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da0e897cd76b3ad7353e80e5bf397af455" title="1 if conservative rasterization is supported supported by the NVN implementation; 0 otherwise.">nvn::DeviceInfo::SUPPORTS_CONSERVATIVE_RASTER</a> device property.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
Target-Independent Rasterization</h3>
<p>NVN supports <em>target-independent rasterization</em>, where rasterization uses a raster sample count that is programmed independently from the number of samples in the render targets. The multisample state object supports two separate sample counts:</p>
<ul>
<li><a class="el" href="classnvn_1_1_multisample_state.html#adb4ca475a2fca7835b9a516b3195f140" title="Specify the raster sample count for target-independent rasterization.">nvn::MultisampleState::SetRasterSamples</a> specifies the number of samples used to evaluate coverage for multisample rasterization that is independent from the number of stored color samples.</li>
<li><a class="el" href="classnvn_1_1_multisample_state.html#a166d9ef3f583a7901a5046e1169204b0" title="Specify the number of samples in the framebuffer.">nvn::MultisampleState::SetSamples</a> specifies the number of samples stored in framebuffer color attachments.</li>
</ul>
<p>If the raster sample count specified by SetRasterSamples is non-zero, the rasterizer will use the provided value as the effective raster sample count. If the raster sample count specified by SetRasterSamples is zero, the rasterizer will use the number of color samples specified by SetSamples. If both sample counts are zero, the rasterizer evaluates coverage only at the pixel center. When multisample rasterization is disabled, the rasterizer also evaluates coverage for all samples at the pixel center.</p>
<p>There are several restrictions on the sample counts in the multisample state:</p>
<ul>
<li>In NVN, target-independent rasterization can be used together with depth or stencil tests. However, the effective raster sample count must equal the number of samples in the depth/stencil buffer.</li>
<li>In NVN, target-independent rasterization can be supported with a multisample color buffer. However, the raster sample count must be greater than or equal to the color sample count specified by SetSamples.</li>
<li>The color sample count specified by SetSamples must be equal to the number of samples stored in the framebuffer color attachments.</li>
</ul>
<p>The results of rasterization are undefined, and may result in GPU errors, if any of these restrictions is violated.</p>
<p>When the raster sample count is not equal to the number of color samples in the framebuffer, each color sample will be associated with multiple raster samples. A sample (if render targets are multisample) or pixel in each color target will be updated if any of its associated raster samples are considered covered. For color samples with partial raster sample coverage, applications can use the sample mask in the fragment shader to adjust the output color to account for the partial coverage. Additionally, NVN supports <em>color modulation</em>, where components of the output color can be automatically multiplied by a factor that reflects the fraction of the associated raster samples that are covered. Applications can call <a class="el" href="classnvn_1_1_multisample_state.html#af70c6c171586265cafedf41af820f68a" title="Set the coverage modulation mode for target-independent rasterization.">nvn::MultisampleState::SetCoverageModulationMode</a> to enable color modulation on color (RGB) components, alpha components, neither, or both. Additionally, applications can specify a non-linear mapping from the raster sample coverage ratio to the scaling factor used for color modulation using <a class="el" href="classnvn_1_1_command_buffer.html#a590a471152f386345e26f39e98890d60" title="Binds or unbinds a coverage modulation table used for target-independent rasterization.">nvn::CommandBuffer::BindCoverageModulationTable</a>.</p>
<p>Target-independent rasterization (including color modulation) is supported on NX and second-generation Maxwell GPUs for the Windows reference implementation, but not on older GPUs. Support for these features can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da5fd79160d3916db7416b66ee8d91dc68" title="1 if the NVN implementation supports target-independent rasterization, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_TARGET_INDEPENDENT_RASTERIZATION</a>.</p>
<h3><a class="anchor" id="autotoc_md82"></a>
Programmable Sample Locations</h3>
<p>By default, rasterization will evaluate coverage at a set of fixed locations determined by the effective raster sample count. However, the command <a class="el" href="classnvn_1_1_multisample_state.html#acebe4fe4e01912a3cebc7bf5ad768cf6" title="Enable or disable programmable sample locations.">nvn::MultisampleState::SetSampleLocationsEnable</a> allows applications to instead use a set of locations stored in the multisample state object. When enabled, the rasterizer uses a set of sixteen sample locations stored in the multisample state object. Sample locations may be specified using the command <a class="el" href="classnvn_1_1_multisample_state.html#a89fc9ae077d2a7d0594850c077566258" title="Specifies programmable sample locations for rasterization.">nvn::MultisampleState::SetSampleLocations</a>. Each sample location is specified using a pair of floating-point values (x,y) with both values in the range [0.0, 1.0), where the pair (0.5, 0.5) specifies the center of a pixel. The origin (0.0, 0.0) location follows the window origin mode, which is set by <a class="el" href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497" title="Set the global location for window coordinates (0,0).">nvn::Device::SetWindowOriginMode</a>. When the window origin mode is NVN_WINDOW_ORIGIN_MODE_LOWER_LEFT, a sample location of (0.0, 0.0) identifies the lower-left corner of each pixel. Likewise, when the window origin mode is NVN_WINDOW_ORIGIN_MODE_UPPER_LEFT, a sample location of (0.0, 0.0) identifies the upper-left corner of each pixel. These floating-point values are converted to four-bit fixed-point values when stored in the multisample state object.</p>
<p>When using programmable sample locations, the rasterizer can use the same locations for each pixel, or it can use a different set of locations for each pixel in a repeating <em>pixel grid</em>. The mode used is determined using the command <a class="el" href="classnvn_1_1_multisample_state.html#a5d819818314c0091f6c571f17b442c4f" title="Set the programmable sample locations grid enable.">nvn::MultisampleState::SetSampleLocationsGridEnable</a>. When enabled, the sixteen sample locations in the multisample state object are spread across a group of 16 / <em>n</em> pixels, where <em>n</em> is the effective raster sample count. When disabled, the rasterizer uses sample locations 0 through <em>n</em> - 1 to evaluate coverage for each pixel. When using the pixel grid, the dimensions of the grid can be determined using <a class="el" href="classnvn_1_1_multisample_state.html#ae6f53817de7e5705af51acf0c74f4520" title="Query the size of a pixel grid used for programmable sample locations.">nvn::MultisampleState::GetSampleLocationsGrid</a>. For the location of sample <em>s</em> of pixel (<em>x</em>, <em>y</em>) using a grid size of (<em>gw</em>, <em>gh</em>), the rasterizer uses sample <em>s</em> if the pixel grid is disabled or sample <em>s</em> + (<em>y</em> % <em>gh</em>) * <em>gw</em> + (<em>x</em> % <em>gw</em>) if the pixel grid is enabled.</p>
<p>Programmable sample locations interact with framebuffer compression for depth render targets. Framebuffer compression may store depth buffer values in a manner where depth values for individual samples will be reconstructed from compressed data based on the current sample locations. As a result, changing the sample locations used with a compressible depth buffer would modify the depth values that would be reconstructed by the GPU's decompression logic. In the event that an application needs to change sample locations but wants to use per-sample depth values based on previous sample locations, the command <a class="el" href="classnvn_1_1_command_buffer.html#a0ac239d2cc3ff8bc71004e3eeccac58e" title="Resolve depth values in a compressible depth render target.">nvn::CommandBuffer::ResolveDepthBuffer</a> can be used to decompress the depth buffer prior to changing sample locations.</p>
<p>Programmable sample locations are supported on NX and second-generation Maxwell GPUs for the Windows reference implementation, but not on older GPUs. Support for this feature can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da759155616d670544a7472f3cf267aa17" title="1 if the NVN implementation supports programmable sample locations, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_SAMPLE_LOCATIONS</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_12"></a>
10.12. Early Per-Fragment Tests</h2>
<p>By default, the per-fragment tests described in the <a href="#nvn_guide_per_fragment">per-fragment operations section of this guide</a> behave as though they are performed after fragment shader execution. However, hardware will automatically enable early depth tests when conditions are favorable (the "Maxwell Best Practices" guide provides further details). Fragment shaders can also specify that early per-fragment tests should be be enabled using the layout qualifier: </p><pre class="fragment">layout(early_fragment_tests) in;
</pre><p> When early_fragment_tests are enabled, writes to gl_FragDepth are discarded, since the depth test and depth buffer updates have already happened. If "discard" is used in the shader, the color buffer will not be updated, but the depth and stencil buffers will have already been updated by the early depth test. Using ARB_conservative_depth with early_fragment_tests enabled has no effect since gl_FragDepth would be ignored. When early fragment tests are enabled, the depth bounds, depth, and stencil tests are performed prior to fragment shader execution instead of being performed after fragment shader execution. Additionally, sample counts for occlusion queries (<a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29a3869757943a2dcb6ff193bcd12370ace" title="Reports the number of samples passing the depth and stencil test in the framebuffer.">nvn::CounterType::SAMPLES_PASSED</a>) will be updated during the early fragment tests stage.</p>
<p>By default, the sample mask provided to the fragment shader will come from the set of raster samples covered during rasterization. However, when early fragment tests are enabled, applications can specify that samples failing any of the early fragment tests should not be considered covered in the sample mask, using the layout qualifier: </p><pre class="fragment">layout(post_depth_coverage) in;
</pre><p> Early fragment tests are supported on NX and all GPUs supported by the Windows reference implementation. Post-depth coverage is supported on NX and second-generation Maxwell GPUs for the Windows reference implementation, but not on older GPUs. Support for this feature can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da53b35c7c55326f94c5d45afb2d516155" title="1 if the NVN implementation supports post-depth coverage, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_POST_DEPTH_COVERAGE</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_10_13"></a>
10.13. Fragment Shaders</h2>
<p>After fragments are generated by primitive rasterization, each fragment is processed by a programmable fragment shader. The fragment shader reads the interpolated attributes of the fragment as inputs and produces output colors (and optionally, an output depth value) that will be sent to the fixed-function fragment processing stages to be written into the render targets of the framebuffer.</p>
<p>The fragment shader is optional; if no fragment shader is enabled, fragments will be passed through the fixed-function fragment processing stage.</p>
<p>The fragment shader is referred to as the <em>pixel shader</em> in the Direct3D API.</p>
<h2><a class="anchor" id="nvn_guide_per_fragment"></a>
10.14. Per-Fragment Operations</h2>
<p>After fragments are processed or passed through by the fragment shader stage, a set of additional fixed-function operations are performed on the fragment, as described in the following sub-sections.</p>
<p>These fixed-function fragment operations use the values associated with each fragment to update the textures attached as <em>render targets</em> in the framebuffer. Render targets are programmed using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>. The framebuffer has up to 8 color texture attachments and a single optional depth/stencil texture attachment that can be updated by these per-fragment operations. More information on render targets can be found in a <a href="#nvn_guide_render_targets">separate section of this guide</a>.</p>
<h3><a class="anchor" id="autotoc_md83"></a>
Multisample Fragment Operations</h3>
<p>When the framebuffer contains multisample textures with <em>n</em> samples, each texel in the render targets has <em>n</em> separate sets of color or depth and stencil samples. The set of samples updated by the per-fragment operations is controlled by an <em>n</em>-bit sample mask, where sample <em>i</em> of a pixel is updated if and only if bit <em>i</em> is in the sample mask is set to one. The sample mask is produced by computing the logical AND of the following masks:</p>
<ul>
<li>If multisample rasterization is enabled, bit <em>i</em> in the rasterizer sample mask is initially set to one if and only if sample <em>i</em> in the pixel is covered by the primitive being rasterized, and set to zero otherwise. If multisample rasterization is disabled, all bits of the rasterizer sample mask are set to one.</li>
<li>The NVN API sample mask is set to all ones in the default state, but can be updated using <a class="el" href="classnvn_1_1_command_buffer.html#a4aecd213fbf83199c53b4ce455fab481" title="Specifies a mask of samples that may be covered by rendered primitives.">nvn::CommandBuffer::SetSampleMask</a>.</li>
<li>The fragment shader sample mask is the value of the built-in output variable <code>gl_SampleMask[]</code>. If the fragment shader doesn't write to <code>gl_SampleMask[]</code>, the fragment shader sample mask is set to all ones.</li>
<li>If alpha-to-coverage is enabled in the current multisample state object, the alpha-to-coverage sample mask is generated by the GPU based on the value of the alpha component of color output zero. The fraction of bits enabled in this generated mask is roughly proportional to the floating-point alpha value, where all bits are set to zero if the alpha value is 0.0 and all bits are set to one if the alpha value is 1.0. Alpha-to-coverage is enabled or disabled in the multisample state by calling <a class="el" href="classnvn_1_1_multisample_state.html#a7d18e24578866a64c9d74a4abbd25df9" title="Enable or disable alpha-to-coverage operation.">nvn::MultisampleState::SetAlphaToCoverageEnable</a>. If alpha-to-coverage is disabled, the corresponding mask is set to all ones.</li>
</ul>
<p>Unlike OpenGL, alpha-to-coverage in NVN is supported for both single-sample and multisample-render targets, and is also supported when multisample rasterization is enabled. The command <a class="el" href="classnvn_1_1_multisample_state.html#a202f114e6e48f7adc4916494c4451977" title="Enable or disable dithering in the alpha-to-coverage operation.">nvn::MultisampleState::SetAlphaToCoverageDither</a> can be used to enable or disable <em>dithering</em> in the computation of the sample mask for alpha to coverage. When disabled, a constant alpha value will produce the same mask for each pixel. When enabled, a constant alpha value may produce different masks for different pixels, where the fraction of enabled mask bits averaged over a small neighborhood of pixels should roughly equal the alpha value used to generate the masks.</p>
<h3><a class="anchor" id="autotoc_md84"></a>
Alpha Test</h3>
<p>The alpha test compares the value of the alpha component of color output zero against a reference value and discards the fragment if the comparison fails. The alpha test is specified in the currently bound <a class="el" href="classnvn_1_1_color_state.html" title="API state object controlling processing of color values.">nvn::ColorState</a> object using <a class="el" href="classnvn_1_1_color_state.html#ad5f32755733d08204a70950de477c036" title="Specifies a comparison function to use for alpha testing.">nvn::ColorState::SetAlphaTest</a>. The reference value used for the comparison is programmed using <a class="el" href="classnvn_1_1_command_buffer.html#a7edd6a2e5bceb5db2ab83cbc9724221e" title="Specifies a reference value to use for alpha testing.">nvn::CommandBuffer::SetAlphaRef</a>.</p>
<p>In NVN there is no separate function to explicitly enable or disable alpha testing. Instead, alpha testing is enabled unless at least one of the following conditions are true:</p>
<ul>
<li>The alpha test function is set to <a class="el" href="structnvn_1_1_alpha_func.html#a3f024a5c9b4054f7247dc9528f9cde62ac7374ebb7619d11e39be0843be53e184" title="Comparison always passes.">nvn::AlphaFunc::ALWAYS</a>. Note that this is the value set by <a class="el" href="classnvn_1_1_color_state.html#ab8d5f91dd7768c1cb99bd5a1a1255d94" title="Set default state for the ColorState object.">nvn::ColorState::SetDefaults()</a>, which means that alpha testing is disabled by default unless explicitly changed by the application.</li>
<li>The count of color render target bound is zero.</li>
<li>The format of color render target zero is not alpha testable.</li>
<li>The fragment shader does not output alpha value.</li>
</ul>
<p>Note that passing a null pointer as color render target zero does not disable alpha testing if the number of color render targets is greater than 0, where those are programmed using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>. In this case the render target is treated as disabled and a disabled target is considered alpha testable.</p>
<p>For example, in the code fragment below alpha testing is disabled for the first draw call because the count of color render target is explicitly set to 0. However, alpha testing is enabled for the second draw call because the count of color render target is 1 although a null pointer surface is bound. </p><pre class="fragment">nvn::CommandBuffer cmdBuf;    // command buffer used for rendering
nvn::Texture *texDepth;       // the depth texture
nvn::ColorState alphaTest;    // color state for alpha test

alphaTest.SetDefaults();
alphaTest.SetAlphaTest(nvn::AlphaFunc::NEVER);
cmdBuf.BindColorState(&amp;alphaTest);

cmdBuf.SetRenderTargets(0, NULL, NULL, texDepth, NULL);
/* the depth buffer will be updated by the next draw call
   since _numColors_ is 0, the alpha test is ignored and skipped  */
/* first draw call */

nvn::Texture* texColors[] = {NULL};
cmdBuf.SetRenderTargets(1, texColors, NULL, texDepth, NULL);
/* the depth buffer won't be updated by the next  draw call
   since the alpha test func is NEVER, _numColors_ is not 0
   and the format of color target zero is alpha testable  */
/* second draw call */
</pre><p> When the framebuffer has multiple samples, the alpha test will be applied independently for each sample enabled in the sample mask.</p>
<h3><a class="anchor" id="autotoc_md85"></a>
Depth Bounds Test</h3>
<p>If the framebuffer has a depth/stencil texture attachment, the depth bounds test will be performed as specified via <a class="el" href="classnvn_1_1_command_buffer.html#ac89b302622bedfbe4d1efe8f6c070f5a" title="Control the operation of the depth bounds test.">nvn::CommandBuffer::SetDepthBounds</a>. If the depth bounds test is disabled, all fragments will be passed to the next pipeline stage. If the depth bounds test is enabled, the current depth value in the depth attachment will be read. The depth bounds test passes if and only if the value in the depth buffer is in the range [ <em>n</em>, <em>f</em> ], where <em>n</em> and <em>f</em> are the values specified in SetDepthBounds. If the depth bounds test fails, the fragment will be discarded. If there is no depth/stencil render target or the format of the depth/stencil render target has no depth component (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a>), the depth bounds test is ignored. By default, the depth bounds test is disabled.</p>
<p>When the depth/stencil attachment has multiple samples, the depth bounds test will be applied independently for each sample enabled in the sample mask.</p>
<h3><a class="anchor" id="autotoc_md86"></a>
Depth and Stencil Test</h3>
<p>If the framebuffer has a depth/stencil texture attachment, depth and stencil tests will be performed according to the current <a class="el" href="classnvn_1_1_depth_stencil_state.html" title="API state object controlling depth and stencil testing operations.">nvn::DepthStencilState</a> object.</p>
<p>Depth testing compares the depth value associated with the fragment to the depth value stored in the depth/stencil render target, producing a pass or fail result. Depth testing is enabled or disabled via <a class="el" href="classnvn_1_1_depth_stencil_state.html#a1b050202f9f0c17f6e69e92a973bd91d" title="Specify whether depth testing is enabled or disabled.">nvn::DepthStencilState::SetDepthTestEnable</a>. The function used to compare the two depth values is specified by calling <a class="el" href="classnvn_1_1_depth_stencil_state.html#a2143610886c1715fcfbe2e3ead98900c" title="Specifies the comparison function used when depth testing is enabled.">nvn::DepthStencilState::SetDepthFunc</a>. If the depth test passes, the depth value stored in the depth buffer is replaced with the fragment's depth value if depth writes are enabled via <a class="el" href="classnvn_1_1_depth_stencil_state.html#a05bf999a1c4ceef5e052ea6e6e4a15a4" title="Specify whether the depth buffer should be updated by the depth test.">nvn::DepthStencilState::SetDepthWriteEnable</a>. If there is no depth/stencil render target or the format of the depth/stencil render target has no depth component (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a2fe58a20f37245def07f58311383dfe8" title="An 8-bit unsigned integer stencil component.">nvn::Format::STENCIL8</a>), the depth test is ignored.</p>
<p>Stencil testing compares a stencil reference value to the stencil value stored in the depth/stencil render target, producing a pass or fail result. Stencil testing is enabled or disabled via <a class="el" href="classnvn_1_1_depth_stencil_state.html#acdec184fc4488625d9e5773220b152f8" title="Specify whether the stencil testing is enabled or disabled.">nvn::DepthStencilState::SetStencilTestEnable</a>. The function used to compare the two stencil values is specified via <a class="el" href="classnvn_1_1_depth_stencil_state.html#a5fb3f5aaba6cc1d6ac479f5e92f5c26b" title="Specifies the comparison function used when stencil testing is enabled.">nvn::DepthStencilState::SetStencilFunc</a>. The reference value used by the stencil test is programmed directly in command sets using <a class="el" href="classnvn_1_1_command_buffer.html#a33326a59db6cab792fd729fbbd223512" title="Specify a stencil reference value used by the stencil test.">nvn::CommandBuffer::SetStencilRef</a>. Before performing the stencil test, the reference stencil value and the stored stencil value are both ANDed with the stencil value mask programmed using <a class="el" href="classnvn_1_1_command_buffer.html#a719b4e44b46242d14ff81d3af76af169" title="Set a mask that will be applied to the stencil index and reference values prior to performing the ste...">nvn::CommandBuffer::SetStencilValueMask</a>. If there is no depth/stencil render target or the format of the depth/stencil render target has no stencil component (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a>), the stencil test is ignored.</p>
<p>When the stencil test is enabled, the stencil buffer will be updated whether the test passes or fails. A new stencil value will be computed according to one of the three stencil operations programmed via <a class="el" href="classnvn_1_1_depth_stencil_state.html#ac45bd97de2cf21700b8b0325e2dcc3df" title="Specifies operations performed on stored stencil values by the stencil test.">nvn::DepthStencilState::SetStencilOp</a>. If the stencil test failed, the operation specified by <em>fail</em> should be used. If the stencil test passed but the depth test failed, the operation specified by <em>depthFail</em> should be used. If both the stencil and depth tests passed, the operation specified by <em>depthPass</em> should be used. The new value will be written to the stencil bits of the depth/stencil render target under the control of a mask specified by <a class="el" href="classnvn_1_1_command_buffer.html#a5c6ae23a1825ecc510d9e9ec06c743ee" title="Specify a mask to apply to stencil values written by the stencil test.">nvn::CommandBuffer::SetStencilMask</a>. If bit <em>i</em> in the stencil mask is set to one, bit <em>i</em> in the render target will be updated to the value of bit <em>i</em> in the new computed stencil value. If bit <em>i</em> in the stencil mask is set to zero, bit <em>i</em> in the render target will be unchanged.</p>
<p>NVN supports two-sided stencil testing, where a separate set of stencil functions, operations, and masks are maintained for front- and back-facing primitives. When updating stencil-related state, the functions above take a parameter <em>faces</em>, where</p>
<ul>
<li><a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9aa7fc81b16a75e5ccf9ad5fad8476f9fd" title="Specifies that an operation applies to front-facing primitives only.">nvn::Face::FRONT</a> indicates that only the front-facing stencil state should be updated;</li>
<li><a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9acecad020721ad0de3b0224bd45c9bc88" title="Specifies that an operation applies to back-facing primitives only.">nvn::Face::BACK</a> indicates that only the back-facing stencil state should be updated; and</li>
<li><a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9a478d90f185c20906774cfad3337190ce" title="Specifies that an operation applies to both front- and back-facing primitives.">nvn::Face::FRONT_AND_BACK</a> indicates both front- and back-facing stencil state should be updated.</li>
</ul>
<p>Two-sided stencil testing is always enabled in NVN. Applications wanting to use the sample stencil state for both front- and back-facing primitives should use a <em>faces</em> value of <a class="el" href="structnvn_1_1_face.html#a6cd1a78a4e2706369e91a29ee2438ef9a478d90f185c20906774cfad3337190ce" title="Specifies that an operation applies to both front- and back-facing primitives.">nvn::Face::FRONT_AND_BACK</a> when updating stencil state.</p>
<p>When the depth/stencil attachment has multiple samples, the depth and stencil tests will be applied independently for each sample enabled in the sample mask.</p>
<h3><a class="anchor" id="autotoc_md87"></a>
Coverage-to-Color</h3>
<p>NVN supports a <em>coverage-to-color</em> mode, where a coverage mask can be written to the framebuffer as a color output. Coverage-to-color can be enabled using <a class="el" href="classnvn_1_1_multisample_state.html#a095f794f39df5a3ef790b787ce0c17e6" title="Enable or disable the fragment coverage-to-color feature.">nvn::MultisampleState::SetCoverageToColorEnable</a>. When enabled, the coverage mask is written to the red component of the color output specified using <a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8" title="Specify the color output updated by the fragment coverage-to-color feature.">nvn::MultisampleState::SetCoverageToColorOutput</a>.</p>
<p>The coverage mask used as a color output includes the results of all per-fragment operations affecting coverage, including all sample masks, alpha-to-coverage, the alpha test, the depth bounds test, the depth test, and the stencil test.</p>
<p>When using coverage-to-color, the color render target receiving the color output mask must use a single-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if the format of the color render target does not meet these requirements.</p>
<p>The coverage color output <em>N</em> must be enabled in the fragment program in order for the hardware to write the coverage value to output <em>N</em>. For the color output to be considered enabled, developers can use one of these two options:</p>
<p>1) Define and write a dummy color value in the fragment shader to the same output that will be used with <a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8" title="Specify the color output updated by the fragment coverage-to-color feature.">nvn::MultisampleState::SetCoverageToColorOutput</a>. The actual fragment color value will be overwritten by the hardware with the coverage value during execution. Note that it is insufficient to just define the color output; the fragment shader must write <em>some</em> value to the output.</p>
<p>2) Specify _#pragma coverageToColorTarget N_ in the fragment shader. <em>N</em> must be a number between 0 and 7 inclusive, and should be the same value used with <a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8" title="Specify the color output updated by the fragment coverage-to-color feature.">nvn::MultisampleState::SetCoverageToColorOutput</a>. This will force the compiler to enable color output <em>N</em> in the compiled fragment program, even if it is not defined or used in the shader source code.</p>
<blockquote class="doxtable">
<p>Note: For performance reasons, it is advisable to use the pragma to enable the coverage output color instead of writing a dummy color value. Writing a dummy color value will enable the coverage color output, but it could also lead to an increased number of instructions in the compiled program. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: It is also advisable to use the pragma only if the coverage-to-color feature is required. Using the pragma without enabling coverage-to-color could lead to undefined results being written any render targets that happened to be attached to the color output specified by the pragma. It may also lead to the usage of more registers which could hurt performance when not using coverage-to-color. </p>
</blockquote>
<p>Coverage-to-color is supported on NX and second-generation Maxwell GPUs for the Windows reference implementation, but not on older GPUs. Support for this feature can be determined by querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daeffeb8dc90cf6efd5404df0b273f0a52" title="1 if the NVN implementation supports fragment coverage to color, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_FRAGMENT_COVERAGE_TO_COLOR</a>.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Blending and Logical Operations</h3>
<p>If the fragment survives the depth and stencil tests, a new color value will be computed for each color render target in the framebuffer.</p>
<p>The command <a class="el" href="classnvn_1_1_color_state.html#a26d2e4452520467a75be6f45e0a0e2fb" title="Specifies the logical operation to perform for all color targets.">nvn::ColorState::SetLogicOp</a> programs a bitwise logical operation that applies to all color targets. If the logical operation is anything other than <a class="el" href="structnvn_1_1_logic_op.html#acce95074b081e6b87e56363a9a9ee5a1ae0c1f7be2834108072dc08def6ae15a5" title="Compute C = Cs.">nvn::LogicOp::COPY</a>, the fragment color value for each color target is combined with the color value stored in the corresponding color target to produce a new value to store into the color target. Logical operations are not supported for render targets with sRGB or floating-point components. For such render targets, the logical operation is disabled. When a non-COPY logical operation is specified in color state (including for sRGB and floating-point formats), blending enables for all color targets are ignored and treated as disabled.</p>
<p>Each color target has a separate blending enable specified using the command <a class="el" href="classnvn_1_1_color_state.html#a1d19d6348e520bc8c5c3493b0413c0fc" title="Specifies the blending enable for a single color target.">nvn::ColorState::SetBlendEnable</a>, where the parameter <em>index</em> indicates which color target's enable to update. When blending is enabled for a color target, a blending function is used to compute the new color value for that target. If blending is disabled, the fragment color value for the target is used directly as the new color value.</p>
<p>If enabled, the blending function for a color target is controlled by the state in the <a class="el" href="classnvn_1_1_blend_state.html" title="API state object controlling blending for one color target.">nvn::BlendState</a> object. The current blending state for a single color target is updated by calling <a class="el" href="classnvn_1_1_command_buffer.html#a328628b7afb78c07dc84fed234782b6d" title="Specify a new BlendState object to bind for subsequent commands.">nvn::CommandBuffer::BindBlendState</a>, where the number of the color target to update is programmed in the blend state using <a class="el" href="classnvn_1_1_blend_state.html#ac78956e39668ffe168f5765bc97844e5" title="Specify the number of the color target to update via the BlendState object.">nvn::BlendState::SetBlendTarget</a>. The equations used for blending are specified via <a class="el" href="classnvn_1_1_blend_state.html#a9f5462a4606d4ed56085cea03d646ffb" title="Specify blend equations for color and alpha channels.">nvn::BlendState::SetBlendEquation</a>, where separate equations can be used for RGB components and alpha components using the <em>modeRGB</em> and <em>modeAlpha</em> equations, respectively. When evaluating the blend equation, the RGB and alpha components of the source color (from the fragment) and destination color (from the stored color values) are multiplied by blend factors specified via <a class="el" href="classnvn_1_1_blend_state.html#a0b5b51a4f98b242ea3772bfd409f5d1b" title="Specify blend functions for source and destination color and alpha channels.">nvn::BlendState::SetBlendFunc</a>. The set of blend factors supported by SetBlendFunc include several that select a constant blend color, which is programmed via <a class="el" href="classnvn_1_1_command_buffer.html#a89a986e1674a5b2182666efb95538c89" title="Specifies a constant color that may be used by blending functions.">nvn::CommandBuffer::SetBlendColor</a>.</p>
<p>If a color target used for blending has an sRGB format, the sRGB-encoded components are <a href="#nvn_guide_srgb">coverted</a> to a linear color space prior to blending.</p>
<p>When the color render target has multiple samples, a separate color value will be computed by the logical operation or blending equation for each sample enabled in the sample mask.</p>
<p>NVN provides a set of advanced blending modes with functionality similar to that provided by the <a href="https://www.opengl.org/registry/specs/NV/blend_equation_advanced.txt">NV_blend_equation_advanced</a> OpenGL extension. The set of blending modes supported is given by the enumerant <a class="el" href="structnvn_1_1_blend_advanced_mode.html" title="Specifies an advanced blending mode to combine source and destination colors.">nvn::BlendAdvancedMode</a> and can be specified using <a class="el" href="classnvn_1_1_blend_state.html#acc23f0770032689ca9e74d826ae3ceb2" title="Specify a mode for advanced blending equations.">nvn::BlendState::SetAdvancedMode</a>. Advanced blending is disabled by default and can be disabled manually using nvn::BlendAdvancedMode::NONE. Additional entry points are provided to further control advanced blending:</p>
<ul>
<li><a class="el" href="classnvn_1_1_blend_state.html#a0a0978e760fe46134345825de578a579" title="Specify blend overlap mode for advanced blending equations.">nvn::BlendState::SetAdvancedOverlap</a> controls the overlap of partially transparent source and destination colors, affecting how blending computations are peformed.</li>
<li><a class="el" href="classnvn_1_1_blend_state.html#a6d3d9b1bfdd3cf2d17ea1bda8708cce0" title="Specify whether the source color is considered premultiplied for advanced blending equations.">nvn::BlendState::SetAdvancedPremultipliedSrc</a> controls whether the source color is considered pre-multiplied. For pre-multiplied colors, a white pixel with 50% coverage has an (R,G,B,A) value of (0.5, 0.5, 0.5, 0.5). For non-pre-multiplied colors, it has a value of (1.0, 1.0, 1.0, 0.5). Advanced blending assumes that destination colors are always pre-multiplied, and produces a pre-multiplied result.</li>
<li><a class="el" href="classnvn_1_1_blend_state.html#a68f419344c9ce16790a25407a4ddc437" title="Specify whether the destination color target has unsigned normalized components (values in [0,...">nvn::BlendState::SetAdvancedNormalizedDst</a> specifies whether the destination is stored using unsigned normalized components (e.g., using the format <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a>). Some blending equations involve clamping values to the range [0,1] and can be evaluated more efficiently if the destination and result are assumed to be clamped to [0,1].</li>
</ul>
<p>Advanced blending modes are only supported when there is a single color target. Using advanced blending with multiple color targets bound produces undefined results, including possible GPU errors. When binding blend state using advanced blending, the NVN driver needs to do some computation to optimally configure the GPU to perform the blend operation. If such bind operations are performed frequently, this overhead can be reduced by saving the results in a command set that could be passed to <a class="el" href="classnvn_1_1_command_buffer.html#a5d1d30a924b48b7691a509f28783ae55" title="Insert copies of previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CopyCommands</a> or <a class="el" href="classnvn_1_1_command_buffer.html#ac26cc174e1b801e022cff2c5405726b0" title="Insert calls to previously recorded command sets into the command set under construction.">nvn::CommandBuffer::CallCommands</a>.</p>
<p>Advanced blending in NVN is supported on NX. On the Windows reference implementation, it is supported on first-generation Maxwell and newer GPUs. The device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da50ed6ebd174c356ab757d6f98347f367" title="1 if advanced blending modes (other than BlendAdvancedMode::NONE) are supported by the NVN implementa...">nvn::DeviceInfo::SUPPORTS_ADVANCED_BLEND_MODES</a> indicates if this feature is supported. In NVN, all advanced blending operations are considered "coherent" and do not require a blending barrier if the same pixel is touched multiple times in a rendering pass.</p>
<h3><a class="anchor" id="autotoc_md89"></a>
Framebuffer Color Writes</h3>
<p>If the fragment survives the depth and stencil tests, the new color value for each color target will be stored into the textures programmed as color render targets using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>. Color target <code>n</code> will be updated only if all of the following are true:</p>
<ul>
<li>it is one of the <code>numColors</code> textures passed to SetRenderTargets;</li>
<li>the value of <code>colors[n]</code> passed to SetRenderTargets is non-NULL;</li>
<li>the color mask state for output <code>n</code> does not disable writes; and</li>
<li>there is an active fragment shader output assigned to location <code>n</code>.</li>
</ul>
<p>If a fragment shader output assigned to location <code>n</code> is written conditionally, the values written to the texture are undefined for any fragments where the fragment shader did not execute code writing to the output.</p>
<p>For each color target, the RGBA components of the color value will be converted to match the <a href="#nvn_guide_formats">format of the color target</a>. For each component in the color target, a corresponding write mask can be found in the <a class="el" href="classnvn_1_1_channel_mask_state.html" title="API state object holding per-channel write masks for all color buffers.">nvn::ChannelMaskState</a> object. If the write mask for a component is enabled (<code>NVN_TRUE</code>), that component will be updated to hold the new value; if the write mask is disabled, the old value of the component will be retained. The channel writemasks for a single color target are programmed using <a class="el" href="classnvn_1_1_channel_mask_state.html#a302a5ec73f71347aed44d2622714976a" title="Program RGBA channel masks for a single color target.">nvn::ChannelMaskState::SetChannelMask</a>, where the color target number to update is specified by the <em>index</em> parameter.</p>
<p>If a color target has an sRGB format, new color value is <a href="#nvn_guide_srgb">converted</a> from a linear color space to the sRGB color space prior to storing the color value in the color target.</p>
<p>When the color target has multiple samples, separate color values will be stored for each sample enabled in the sample mask.</p>
<h2><a class="anchor" id="nvn_guide_draw_texture"></a>
10.15. DrawTexture Primitives</h2>
<p>In addition to regular graphics primitives, the command <a class="el" href="classnvn_1_1_command_buffer.html#a4c0ab209349d35ddaa3166571bc66039" title="Draws an on-screen rectangle displaying the contents of a provided texture.">nvn::CommandBuffer::DrawTexture</a> allows applications to render an axis-aligned rectangle into the color target zero of the framebuffer, displaying the contents of a two-dimensional texture. DrawTexture primitives bypass most of the graphics primitive processing pipeline, but do support many of the per-fragment operations. This functionality is similar to that provided by the OpenGL extension <a href="https://www.opengl.org/registry/specs/NV/draw_texture.txt">GL_NV_draw_texture</a>. While applications can obtain similar results by rendering a geometric primitive with a vertex shader used to position the primitive on screen and a fragment shader to perform a texture lookup, DrawTexture has built-in hardware support that is more power-efficient than using 3D primitives.</p>
<p>The parameter <em>dstRegion</em> contains a set of floating-point texel coordinates identifying the corners of the portion of the texture attached to color target zero, which will be updated. The parameter <em>srcRegion</em> identifies the corners of a portion of the source texture (identified by the handle <em>texture</em>) holding the texels to display on the destination. Both regions are programmed using the type <a class="el" href="structnvn_1_1_draw_texture_region.html" title="Data structure describing a region used by the DrawTexture command.">nvn::DrawTextureRegion</a>. For a two-dimensional texture of size <em>w</em> x <em>h</em>, the corners of the full texture will be given by (x,y) values of (0,0) and (w,h), and the centers of the texels adjacent to those corners will be given by (x,y) values of (0.5,0.5) and (w-0.5,h-0.5). For each pixel covered by <em>dstRegion</em>, a fragment will be generated by computing an interpolated source coordinate from <em>srcRegion</em>, performing a texture lookup using that (non-normalized) value as a texture coordinate, and then using the value returned as the fragment color. Fragments for pixels outside scissor rectangle zero will be discarded, but per-fragment operations will be performed on all remaining fragments.</p>
<p><a class="el" href="classnvn_1_1_command_buffer.html#a4c0ab209349d35ddaa3166571bc66039" title="Draws an on-screen rectangle displaying the contents of a provided texture.">nvn::CommandBuffer::DrawTexture</a> has a number of limitations:</p>
<ul>
<li>Conservative rasterization is ignored when determining what pixels are covered by <em>dstRegion</em>.</li>
<li>The source texture must be two-dimensional (<a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8c499dff06e2171624572ec97051b75c" title="Two-dimensional texture.">nvn::TextureTarget::TARGET_2D</a> or <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a505a74176236dd724a336accb9fafd3c" title="Two-dimensional texture, accessed with non-normalized coordinates.">nvn::TextureTarget::TARGET_RECTANGLE</a>).</li>
<li>Level of detail selection is not supported; level zero of the original texture is always used, even if <em>texture</em> is a handle for a texture view with a non-zero base level.</li>
<li>Anisotropic texture filtering is not supported.</li>
<li>The only supported wrap modes are <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca21135ca1e9cad1a9ceb4941f724d7f38" title="When filtering, texels outside the [0,1] range are treated as sampling the texel on the nearest edge ...">nvn::WrapMode::CLAMP_TO_EDGE</a>, <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca757cb8b85c9dba77037d5f919c382d1f" title="When filtering, texels outside the [0,1] range are treated as sampling the border color.">nvn::WrapMode::CLAMP_TO_BORDER</a>, and <a class="el" href="structnvn_1_1_wrap_mode.html#ae1d9d47785db6cc73a66928bb7963b9ca95d06bd7f46540878b60b1db0f1d234d" title="Texture coordinates are clamped to the range [0,1] before filtering.">nvn::WrapMode::CLAMP</a>.</li>
<li>Depth, depth bounds, and stencil tests are ignored and treated as disabled.</li>
<li>Blending is supported, but "dual source" blending modes that require a second fragment color, such as <a class="el" href="structnvn_1_1_blend_func.html#aa60e9f414a5609000e83d316c3985840a36edc47cbbe9a2baf044bac9377c9376" title="Use the corresponding component of the second source color.">nvn::BlendFunc::SRC1_COLOR</a>, are not allowed.</li>
<li>Multiple render targets (<a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> with <em>numColors</em> &gt;= 2) are not supported.</li>
</ul>
<p>Violating any of these rules will result in undefined behavior. Using multiple color targets or dual-source blending may result in GPU errors.</p>
<h2><a class="anchor" id="nvn_guide_framebuffer_clears"></a>
10.16. Framebuffer Clears</h2>
<p>NVN provides dedicated commands to clear the render targets programmed via <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>. Color render targets can be cleared using one of several commands:</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f" title="Clear a color buffer using floating-point clear color values.">nvn::CommandBuffer::ClearColor</a> clears a color texture using floating-point clear values. This command supports clearing textures with unsigned normalized components (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a>), signed normalized components with format names ending in "SN" (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042aac217c744a68ea92c11e896b8066f712" title="Four 8-bit signed normalized components.">nvn::Format::RGBA8SN</a>), and floating-point components ending in "F" (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a1143a610156272c1a1e91e5026455510" title="One 32-bit floating-point component.">nvn::Format::R32F</a>).</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#ae2279d44a44fd246ef9f9392b8f9e8bf" title="Clear a color buffer using signed integer clear color values.">nvn::CommandBuffer::ClearColori</a> clears a color texture using signed integer clear values. This command supports clearing textures with signed integer components with format names ending in "I" (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a876ede717b4e8de33271a70912f281a5" title="Two 32-bit signed integer components.">nvn::Format::RG32I</a>).</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a4b88ad85195c8749ebe41a3c4e9ee250" title="Clear a color buffer using unsigned integer clear color values.">nvn::CommandBuffer::ClearColorui</a> clears a color texture using unsigned integer clear values. This command supports clearing textures with unsigned integer components with format names ending in "UI" (e.g., <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac3eca5fd1c211a2f09bb6ecd0adf65fb" title="Four 16-bit unsigned integer components.">nvn::Format::RGBA16UI</a>).</li>
</ul>
<p>Color textures can also be directly cleared using one of <a class="el" href="classnvn_1_1_command_buffer.html#acba967469608c76841e41d2b4546f8bd" title="Clear a color buffer using floating point clear color values.">nvn::CommandBuffer::ClearTexture</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a7c37d217f9cdcc5dd083986aa785d17b" title="Clear a color buffer using signed integer clear color values.">nvn::CommandBuffer::ClearTexturei</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a4313e5838e0b2528870bb3437a18bf5d" title="Clear a color buffer using unsigned integer clear color values.">nvn::CommandBuffer::ClearTextureui</a>. These commands do not require the use of <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> to set the destination of the clear. Instead they will will internally change the current render target to the destination texture, perform a clear, and restore the previously set render target. These commands support only texture formats marked as renderable in the 'Render' column of the <a href="#nvn_guide_formats_table">formats table in this guide</a>. When clearing a linear texture, the texture must have been created with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a> flag set to make sure all alignment requirements are met. The region of the texture to be cleared is identified using the <em>textureView</em> and <em>copyRegion</em> arguments of the clear commands. The semantics of these arguments are as described in <a href="#nvn_guide_copy_commands">Data Copy Commands</a>.</p>
<p>If the format of the color render target is not supported by the command used to perform a clear, the values provided to the command will be re-interpreted using a data type compatible with a render target. For example, a floating-point clear color of 1.0 used by <a class="el" href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f" title="Clear a color buffer using floating-point clear color values.">nvn::CommandBuffer::ClearColor</a> will be interpreted as specifying an unsigned integer value of 0x3F800000 (the IEEE-754 representation of 1.0) if the color texture uses the unsigned integer format <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a7972e8232f67991f737c2055eb09215b" title="Four 32-bit unsigned integer components.">nvn::Format::RGBA32UI</a>.</p>
<p>In all of these commands, the parameter <em>index</em> selects a single color render target. NVN does not support clearing multiple color render targets with a single command. Color clear values are always specified as four-component vectors. When clearing a color render target with a format that has fewer than four components, extra component values are ignored.</p>
<p>To clear the single depth/stencil render target, the command <a class="el" href="classnvn_1_1_command_buffer.html#a9a0f6d9771cdf2c4d2ec99fcbc366640" title="Clear a depth/stencil buffer.">nvn::CommandBuffer::ClearDepthStencil</a> should be used. This command can be used to clear only depth values, only stencil values, or both depth and stencil values. The parameters <em>depthValue</em> and <em>stencilValue</em> specify clear values for the depth and stencil components of the render target, respectively. The parameter <em>depthMask</em> is an <code>NVNboolean</code> value indicating whether the depth values of the render target should be cleared. The parameter <em>stencilMask</em> is an integer bitfield specifying which bits of the stencil values should be cleared. A mask of 0xFF indicates that all 8 bits of the stencil value should be cleared. A mask of 0x01 indicates indicates that only the least significant bit of each stencil value should be cleared. A mask of 0x00 disables updates to the stencil buffer.</p>
<p>All color and depth/stencil clears are scissored using scissor rectangle zero (programmed via <a class="el" href="classnvn_1_1_command_buffer.html#a5f511de71b6bec1603e68bb8fd5ba424" title="Specify the scissor rectangle used for clipping primitives and clears.">nvn::CommandBuffer::SetScissor</a>). Portions of render targets outside the scissor rectangle will not be updated by clears.</p>
<p>The clear commands provided by NVN will clear render targets faster and with better power efficiency than using geometric primitives to write clear values. However, NVN supports an additional "fast" clear optimization where clears may be accelerated further when applications identify commonly used clear values and formats. More detail can be found in the <a href="#nvn_guide_fast_clear">Fast Clear section of this guide</a>.</p>
<h1><a class="anchor" id="nvn_guide_sec_11"></a>
11. Compute Shader Dispatch</h1>
<p>Programmable shaders in NVN can be used not just to process graphics primitives, but also to perform generic computations on arrays of data. Compute shaders in NVN are processed similarly to compute shaders in other 3D graphics APIs, such as OpenGL and Direct3D, and use the same shading langauge (GLSL) as used by OpenGL.</p>
<p>Each compute shader specifies the dimensions of an array of compute shader threads called a <em>workgroup</em>. For each workgroup executed, an array of parallel shader threads is created. For example, if compute shader has a workgroup size of 8x8x1, 64 compute shader threads are launched for each workgroup. The threads of the workgroup run independently, but GLSL built-in functions are provided to synchronize the execution of these threads. Additionally, compute shaders can access per-workgroup shared memory that can be used to communicate values between compute shader threads.</p>
<p>GLSL compute shaders are launched via command buffers using the command <a class="el" href="classnvn_1_1_command_buffer.html#a0bbd3065ed66e5d9060d0b996a08f427" title="Dispatch a new grid of compute shader work groups for processing.">nvn::CommandBuffer::DispatchCompute</a>. The <em>groupsX</em>, <em>groupsY</em>, and <em>groupsZ</em> parameters of DispatchCompute specify an array of workgroups to launch as part of the dispatch operation. Compute shader workgroups and dispatches are specified as three-dimensional arrays of threads and workgroups, respectively. However, one- and two-dimensional arrays can be easily specified by setting the size of the "extra" dimensions to one. GLSL compute shaders may also be launched with workgroup counts taken from GPU-accessible memory using the command <a class="el" href="classnvn_1_1_command_buffer.html#a007a24940c8df5f378f27832ef65424f" title="Dispatch a new grid of compute shader work groups for processing.">nvn::CommandBuffer::DispatchComputeIndirect</a>.</p>
<p>Unlike graphics shaders, compute shaders do not have built-in input or output variables that can be used to obtain inputs from or pass outputs to other GPU pipeline stages. Instead, compute shaders are expected to fetch their inputs from and write their outputs to buffer or texture memory using shader storage buffers, texel fetches, or image loads and stores. GLSL compute shaders do include built-in variables to identify properties of an individual shader thread, such as its location within its workgroup and the location of its workgroup relative to the full dispatch. Such variables can be used to determine where the shader's inputs should be read from and where its outputs should be written. More information on these variables can be found in the OpenGL Shading Language Specification (for versions 4.30 and higher).</p>
<p>Compute shader workgroups execute in parallel. Individual workgroups execute in an undefined order relative to other workgroups in the same compute dispatch. Compute shader workgroups also execute in an undefined order relative to workgroups in other compute dispatches. To ensure that the outputs written to memory by one compute shader dispatch are available to be read by subsequent compute shader dispatches or graphics primitives, applications must use <a href="#nvn_guide_barriers">barriers</a> and/or <a href="#nvn_guide_sync">synchronization objects</a>.</p>
<h1><a class="anchor" id="nvn_guide_copy_commands"></a>
12. Data Copy Commands</h1>
<p>NVN provides four commands allowing applications to schedule GPU operations copying data from one buffer object or texture to another buffer object or texture:</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> copies data from an array of pixels stored in buffer memory into texture storage.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a> copies data from texture storage into an array of pixels stored in buffer memory.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924" title="Schedule a copy of data from one Buffer object into another Buffer object.">nvn::CommandBuffer::CopyBufferToBuffer</a> copies <em>size</em> bytes from one range of buffer memory to another range of buffer memory.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> copies texture data from a region of one texture to another region of the same texture or a different texture.</li>
</ul>
<p>When reading from or writing to a buffer, the first byte of the buffer memory used by the copy is identified by a GPU address of type <a class="el" href="group__nvn__cpp__handle.html#gaf71f72cf8daaaaef74f71375981b95dd" title="GPU address of memory inside a buffer object.">nvn::BufferAddress</a>.</p>
<p>When reading from or writing to a texture, the region of the texture read from or written to is identified using three parameters:</p>
<ul>
<li>A pointer to an <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object identifies the texture being read or written.</li>
<li>An optional pointer to an <a class="el" href="classnvn_1_1_texture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations.">nvn::TextureView</a> structure identifies a specific mipmap level or set of layers in the texture involved in the copy. The texture view can also be used to identify an alternate format for the texel data. Other fields of this parameter, such as swizzle, are ignored. If NULL is provided, the copy will use all layers of the base mipmap level of the texture.</li>
<li>A pointer to an <a class="el" href="structnvn_1_1_copy_region.html" title="Data structure describing a region of a texture used in copy commands.">nvn::CopyRegion</a> structure identifies a subset of the texels in the selected mipmap level or layers that are involved in the copy.</li>
</ul>
<p>When copying to and from textures, texture levels are treated as three-dimensional images.</p>
<ul>
<li>Textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a2df223e19709155c2986ab25c341e01a" title="One-dimensional texture.">nvn::TextureTarget::TARGET_1D</a> and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a> are treated as having a height and depth of 1.</li>
<li>Textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86af8292b0591c18d9b82cd66ed06d6e34c" title="Array of one-dimensional textures.">nvn::TextureTarget::TARGET_1D_ARRAY</a> are treated as having a height equal to the number of layers in the texture and a depth of 1.</li>
<li>Textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8c499dff06e2171624572ec97051b75c" title="Two-dimensional texture.">nvn::TextureTarget::TARGET_2D</a> and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a505a74176236dd724a336accb9fafd3c" title="Two-dimensional texture, accessed with non-normalized coordinates.">nvn::TextureTarget::TARGET_RECTANGLE</a> are treated as having a depth of 1.</li>
<li>Textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86ab30b71fec0699e9a966e3c06a42b6487" title="Array of two-dimensional textures.">nvn::TextureTarget::TARGET_2D_ARRAY</a>, <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a17c2bd47992f9b52df6d0bbd30579e69" title="Cube map texture, with six two-dimensional cube faces.">nvn::TextureTarget::TARGET_CUBEMAP</a>, and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86afc724c2360384d08d04ac183015edcf2" title="Array of cube map textures, each with six two-dimensional cube faces.">nvn::TextureTarget::TARGET_CUBEMAP_ARRAY</a> are treated as having a depth equal to the number of layers in the image (6 for cube maps and 6N for cube map arrays).</li>
</ul>
<p>Copies between buffers and multisample textures (with targets of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8fca32f85ac2fdb4850903b5f5f9078d" title="Two-dimensional texture, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE</a> and <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86adae55e7e5918dcaf98121d6cc5816003" title="Array of two-dimensional textures, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE_ARRAY</a>) are not supported.</p>
<p>The copy region used when reading from or writing to textures is also treated as three-dimensional, where <em>xoffset</em>, <em>yoffset</em>, and <em>zoffset</em> identify the first texel in the region, and <em>width</em>, <em>height</em>, and <em>depth</em> identify the size of the region. For one- and two-dimensional textures, applications should program a <em>zoffset</em> of zero and a <em>depth</em> of one. For one-dimensional textures, applications should also program a <em>yoffset</em> of zero and a <em>height</em> of one. The copy region must be fully contained within the texture view used for the copy; otherwise, results of the copy are undefined. If the texture view specifies a layer range, <em>zoffset</em> (for 2D array, cubemap, or cubemap array textures) or <em>yoffset</em> (for 1D array textures) is treated as offsets from the minimum layer index of the texture view.</p>
<p>For copies between texture and buffer memory, the buffer memory is read or written using raw texel data using the memory layout described in the <a href="#nvn_guide_formats">formats section of this guide</a>. By default, if the size of the copy region is <em>w</em> x <em>h</em> x <em>d</em> and each texel uses <em>b</em> bytes, then <em>w</em> * <em>h</em> * <em>d</em> * <em>b</em> bytes are read from or written to the buffer object. The difference (in bytes) between addresses of adjacent rows and image layers are referred to as the <em>row stride</em> and <em>image stride</em>, respectively. With the default row and image strides, a texel with an offset of (x,y,z) relative to the origin of the copy region is stored in buffer memory at a byte offset of <em>x</em> * <em>b</em> + <em>y</em> * <em>rowStride</em> + <em>z</em> * <em>imageStride</em> relative to the buffer address used for the copy.</p>
<p>For copies between texture and buffer memory, applications can override the default row and image strides for a copy using the commands <a class="el" href="classnvn_1_1_command_buffer.html#a0207cc2151b50b8b0fd1957612482e67" title="Set the row stride used for copies between buffer and texture memory.">nvn::CommandBuffer::SetCopyRowStride</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a9ed848d8f9360fa17c44e9570a6d8bc4" title="Set the image stride used for copies between buffer and texture memory.">nvn::CommandBuffer::SetCopyImageStride</a>. Programming non-default strides allows applications to read from or write to a sub-region of a larger image stored in buffer memory. When SetCopyRowStride or SetCopyImageStride are called, the new strides are stored in the command buffer and affect future calls to <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a> sent to the same command buffer object. The row strides are not stored in command or control memory and do not affect previously recorded copy commands or copy commands recorded using other command buffers. When the row stride is zero (default), the row stride for new copies will be computed as <em>w</em> * <em>b</em> bytes. When the image stride is zero, the image stride for new copies will be computed as <em>h</em> * <em>rowStride</em> bytes.</p>
<p>Copy commands also accept a bitfield of type <a class="el" href="structnvn_1_1_copy_flags.html" title="Flags controlling the operation of copy commands.">nvn::CopyFlags</a> specifying special operations applicable to the copy. For copies involving textures, the following flags are supported:</p>
<ul>
<li><a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2af6f7c3a32fa4f4fb75acb0ec66d1c527" title="Enable linear filtering for texture-to-texture copies.">nvn::CopyFlags::LINEAR_FILTER</a> controls the behavior of <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> when the size of the source and destination copy regions differ. Whether or not this bit is set, copies will stretch the source region to fit in the destination region. If the LINEAR_FILTER bit is set, the value for each texel of the destination will be computed using a weighted average of nearby texels in the source. If the bit is not set, each texel in the destination will be taken from the closest texel in the source with no averaging. The LINEAR_FILTER flag is not supported in buffer-to-texture, texture-to-buffer, and buffer-to-buffer copies and should not be set.</li>
<li><a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2ae0dd7765dc7c7a35d5efce67f6ed1683" title="Enable use of the 2D engine copy path.">nvn::CopyFlags::ENGINE_2D</a> controls how <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> transfers texels from a buffer to a texture. In order for the destination to be compressed by <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a>, this bit must be present, the texture format for the destination must be a compressible texture format, and the destination must be allocated in a compressible memory pool. This bit can be used with all of the color texture formats supported by <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> that aren't block-based compressed formats, but is only beneficial to texture data in a compressible color format. When using this flag, the source data must be aligned to the data element size, and the row and image strides must be aligned to the value given by <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab372d74472a67ab624b370707234a0bf" title="Minimum alignment required for stride in linear textures, in bytes.">nvn::DeviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT</a> (32B). If the destination is a linear texture, it must be aligned to the value given by <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da61c146cbc11a83d809d4235911070188" title="Minimum alignment required for stride in linear render targets, in bytes.">nvn::DeviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT</a> (128B). 2D Engine uses Texture pipes and parts of the pixel pipeline, and it restricts the destination texture to the same as a render target.</li>
<li><a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2ad31bbe72d1c53a455f32e86a69cc04e3" title="Mirrors data in the X direction while copying.">nvn::CopyFlags::MIRROR_X</a> reverses the direction that texels are copied in relative to the X axis whenever <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> is used. This flag can only be used with <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> in conjunction with the <a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2ae0dd7765dc7c7a35d5efce67f6ed1683" title="Enable use of the 2D engine copy path.">nvn::CopyFlags::ENGINE_2D</a> flag. It is not supported with block-based compressed formats or multisample textures, and it is not supported in any other copy functions.</li>
<li><a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2aa7044d3503b71478688fe3a063315a9d" title="Mirrors data in the Y direction while copying.">nvn::CopyFlags::MIRROR_Y</a> reverses the direction that texels are copied in relative to the Y axis. This flag is not supported with block-based compressed formats or multisample textures, and it is not supported in buffer-to-buffer copies.</li>
<li><a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2a0bfe4ff82f6183e1b060bcc799a33d23" title="Mirrors data in the Z direction while copying.">nvn::CopyFlags::MIRROR_Z</a> reverses the direction that texels are copied in relative to the Z axis. This flag is not supported with block-based compressed formats or multisample textures, and it is not supported in buffer-to-buffer copies.</li>
</ul>
<p>Additional flags controlling all types of copy operations may be added in the future.</p>
<p>Texture-to-texture copies have a number of restrictions, some permanent and some temporary:</p>
<ul>
<li>The texture format must be one of the formats permitted for texture-to-texture copies. Support for point-sampled copies is indicated in the 'Copy2D' column of the <a href="#nvn_guide_formats_table">formats table in this guide</a>. Support for linear-filtered copies is indicated in the 'Linear2D' column of the formats table. Linear filtering may be supported for more formats in a future update.</li>
<li>Linear filtering is not supported for copies involving a source or destination target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86ab113a9348993bfbcc81eaf36dad73ae6" title="Three-dimensional texture.">nvn::TextureTarget::TARGET_3D</a> because the copy commands do not support averaging texels between layers of a 3D texture.</li>
<li>The number of layers in the <em>srcRegion</em> and the <em>dstRegion</em> must match. (For <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86af8292b0591c18d9b82cd66ed06d6e34c" title="Array of one-dimensional textures.">nvn::TextureTarget::TARGET_1D_ARRAY</a> textures, this is the <em>y</em> component; for all other targets, this is the <em>z</em> component.)</li>
<li>Textures with a target of <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8fca32f85ac2fdb4850903b5f5f9078d" title="Two-dimensional texture, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE</a> or <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86adae55e7e5918dcaf98121d6cc5816003" title="Array of two-dimensional textures, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE_ARRAY</a> may only be used when copying from one multisample texture to another multisample texture with the same number of samples, and the copy region for the source must have the same dimensions as the destination.</li>
<li>For compressed formats, the dimensions of the source and destination regions must match. In addition, the <em>x</em> coordinates must be aligned to units of the block width, and the <em>y</em> coordinates must be aligned to units of the block height.</li>
<li>Copies between overlapping regions of a single texture are not supported and will have undefined results.</li>
<li>If the destination is a linear texture, it must be aligned to the value given by <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da61c146cbc11a83d809d4235911070188" title="Minimum alignment required for stride in linear render targets, in bytes.">nvn::DeviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT</a> (128B).</li>
</ul>
<p>For supported formats, the <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a> function can be used with linear filtering to generate mipmap levels. For unsupported but renderable formats, a custom shader can be used in conjunction with the 3D pipeline to generate mipmaps.</p>
<p>When copy commands are submitted to a queue (via a command set), they are executed in order relative to commands before and after the copy. The source data used by the copy will reflect any GPU writes from commands submitted prior to the copy. Copies submitted to one queue are not executed in any particular order relative to commands submitted to other queues, except as enforced using sync objects. In most cases, data written to the destination buffer or texture by a copy command should be immediately visible to subsequent commands without requiring manual execution ordering controls or cache invalidation <a href="#nvn_guide_barriers">in nvn::CommandBuffer::Barrier</a>. One exception is that copies updating depth textures might require invalidation of ZCull data using <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5ac8720bba76d8ece30ef1e222564e7085" title="Invalidate GPU ZCull storage after direct depth texture updates.">nvn::BarrierBits::INVALIDATE_ZCULL</a>.</p>
<p>In addition to scheduling copies via command buffer, applications can directly load texel data into texture memory using the following commands:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a> writes the texel data from the memory pointed to by the <em>data</em> parameter into the portion of a texture selected by the provided copy region and texture view.</li>
<li><a class="el" href="classnvn_1_1_texture.html#a64eba11aec0921442aece995dcb5e8e9" title="Read texture data from a region of a Texture object into memory.">nvn::Texture::ReadTexels</a> reads texel data from the portion of a texture selected by the provided copy region and texture view into the memory pointed to by the <em>data</em> parameter.</li>
</ul>
<p>These commands behave identically to <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a>, except that the copies are performed immediately by the CPU.</p>
<p>On the NX device, if the texture is stored in a memory pool with the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a> bit set, CPU texture copies will use the CPU cache. To ensure that CPU-cached texels written by <a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a> are visible to subsequent GPU texture accesses, applications must call <a class="el" href="classnvn_1_1_texture.html#ad55e1f7ba304186df7a99ef2f92e3c14" title="Flush CPU cache lines holding portions of a texture.">nvn::Texture::FlushTexels</a> to flush relevant portions of the CPU cache. If a texture read by <a class="el" href="classnvn_1_1_texture.html#a64eba11aec0921442aece995dcb5e8e9" title="Read texture data from a region of a Texture object into memory.">nvn::Texture::ReadTexels</a> was previously written by the GPU, applications must call <a class="el" href="classnvn_1_1_texture.html#a0d476c0d6f25b8aeb19ebfd3cff7d2b2" title="Invalidate CPU cache lines holding portions of a texture.">nvn::Texture::InvalidateTexels</a> to invalidate relevant portions of the CPU cache to ensure that the CPU doesn't access stale texel data from the CPU cache. Flushing and invalidating CPU caches is not necessary for textures stored in pools with the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching.">nvn::MemoryPoolFlags::CPU_UNCACHED</a> bit set. Flushing and invalidating CPU caches after <a class="el" href="classnvn_1_1_texture.html#a64eba11aec0921442aece995dcb5e8e9" title="Read texture data from a region of a Texture object into memory.">nvn::Texture::ReadTexels</a> or <a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a> is also not necessary on Windows.</p>
<p>When operating on textures using <a class="el" href="classnvn_1_1_texture.html#a64eba11aec0921442aece995dcb5e8e9" title="Read texture data from a region of a Texture object into memory.">nvn::Texture::ReadTexels</a> or <a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a>, the CPU has access to the underlying texture memory but not to framebuffer compression meta-information. When portions of a texture are compressed by the GPU, the actual texel values are reconstructed using both the texture memory and compression meta-information. Because the compression information is unavailable, ReadTexels is unable to reconstruct proper decompressed texture data when reading compressed portions of textures, and WriteTexels is unable to merge new uncompressed data into compressed portions of the texture. Because these commands won't work properly for GPU-compressed textures, it is illegal to call ReadTexels and WriteTexels on textures with either the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> or the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> flags set.</p>
<p>To maximize the performance of <a class="el" href="classnvn_1_1_texture.html#a64eba11aec0921442aece995dcb5e8e9" title="Read texture data from a region of a Texture object into memory.">nvn::Texture::ReadTexels</a> and <a class="el" href="classnvn_1_1_texture.html#a8d31fd3dc28103627f80e5dfa3284ccd" title="Copy texture data from memory into a region of a Texture object.">nvn::Texture::WriteTexels</a>, fast-path optimizations are automatically used if:</p>
<ul>
<li>copy regions are aligned to <a href="#nvn_guide_native_texture_format">group-of-bytes (GOB)</a> boundaries (i.e., 64 bytes horizontally and 8 rows vertically), and</li>
<li>each row of texels (or blocks for compressed texture formats) in <em>data</em> begins at a memory address that is aligned to 16 bytes.</li>
</ul>
<p>Data copy commands are executed either on the 2D Engine or Copy Engine as follows:</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a>: 2D Engine (if <a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2ae0dd7765dc7c7a35d5efce67f6ed1683" title="Enable use of the 2D engine copy path.">nvn::CopyFlags::ENGINE_2D</a> is set), or Copy Engine.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a776e2215df7bf908253d82689ead67b5" title="Copy texture data from a region of a Texture object into buffer memory.">nvn::CommandBuffer::CopyTextureToBuffer</a>: Copy Engine</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#aa6785390e813c50f1394d8f3e44de924" title="Schedule a copy of data from one Buffer object into another Buffer object.">nvn::CommandBuffer::CopyBufferToBuffer</a>: Copy Engine</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>: 2D Engine</li>
</ul>
<p>The "Maxwell Best Practices" guide provides further details on the performance characteristics of the 2D Engine (RSTR2D) and Copy Engine (CE).</p>
<h1><a class="anchor" id="nvn_guide_barriers"></a>
13. Barriers</h1>
<p>In the NVN API, the driver is not responsible for tracking the use of buffer and texture objects and evaluating dependencies between passes of a rendering algorithm. This lack of tracking significantly reduces the CPU overhead of the API, but makes the application responsible for controlling execution ordering between passes and cache invalidation. One common example requiring application intervention is where a first rendering pass uses a texture as a render target and a second rendering pass accesses the same texture using texture mapping. Without any application intervention in NVN, GPU work on the second pass might begin before completing work on the first pass and might also read stale cached values for texels that were updated in the first pass, resulting in corruption.</p>
<p>The command <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">nvn::CommandBuffer::Barrier</a> is used to insert a barrier into the command stream, which can be used to order the processing of rendering commands submitted before and after the barrier, and can also invalidate GPU caches before processing commands after the barrier. To control execution order and cache invalidation, applications pass a bitfield value of the type <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">nvn::BarrierBits</a>.</p>
<p>Several barrier bits control execution order, and can ensure that the some or all portions of the work submitted before the barrier completes before starting work after the barrier. For the purposes of execution ordering, "work" refers to graphics primitives from commands such as <a class="el" href="classnvn_1_1_command_buffer.html#a471babeb6b1971ba35fd006ecee180e8" title="Render a primitive with vertex indices fetched from an index buffer.">nvn::CommandBuffer::DrawElements</a> and compute dispatches from commands such as <a class="el" href="classnvn_1_1_command_buffer.html#a0bbd3065ed66e5d9060d0b996a08f427" title="Dispatch a new grid of compute shader work groups for processing.">nvn::CommandBuffer::DispatchCompute</a>. <a href="#nvn_guide_copy_commands">Copy commands</a> are automatically ordered relative to previous and subsequent commands in the same queue, without requiring any barriers. The following barrier bits control execution order:</p>
<ul>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee" title="Ensure that primitives and compute dispatches from after the barrier don&#39;t start until all such work ...">nvn::BarrierBits::ORDER_PRIMITIVES</a> ensures that all work from before the barrier completes before starting any work after the barrier.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">nvn::BarrierBits::ORDER_INDIRECT_DATA</a> behaves like ORDER_PRIMITIVES, except that it also ensures that the GPU will wait on the completion of all work from before the barrier before fetching any data required by an indirect draw or compute dispatch from after the barrier. Without using ORDER_INDIRECT_DATA, the GPU might prematurely fetch indirect draw or dispatch data, even if the application uses ORDER_PRIMITIVES or waits on the completion of previous commands with <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a>. Using ORDER_INDIRECT_DATA or waiting on completion of the previous commands with the CPU is sufficient to ensure that correct indirect data are fetched.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS</a> ensures that the processing of all fragments from before the barrier completes before starting the processing of any fragments after the barrier. However, ORDER_FRAGMENTS does allow the GPU to begin processing of vertices from after the barrier before completing all fragment work from before the barrier. For the purposes of this barrier, processing of fragments includes fragment shader execution, subsequent per-fragment operations such as the depth and stencil tests, and updates of the framebuffer's render targets. There are a few exceptions to the ordering guarantee for ORDER_FRAGMENTS. On the Windows reference implementation for Turing and older GPUs, the GPU may begin processing depth/stencil clears or depth/stencil testing (including buffer updates) for fragments after the barrier before completing all processing of fragments before the barrier. When fragments from after the barrier perform such updates to a texture read by fragments from before the barrier, a heavier barrier like ORDER_PRIMITIVES is necessary to ensure the "new" fragments don't overwrite values read by "old" ones.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aebc5d0a824a75a2c8656b6be18403692" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS_TILED</a> behaves like ORDER_FRAGMENTS except that it only orders fragment processing within individual screen-space tiles. The GPU may begin processing one fragment from after the barrier before completing work on another fragment from after the barrier if the two fragments land in different screen-space tiles. This mode is useful for render-to-texture operations where the second texturing pass accesses texels written during the first pass with the same (x,y) coordinates.</li>
</ul>
<p>When dependencies requiring a barrier involve only fragment shaders and framebuffer stores, applications should use <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS</a> or <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aebc5d0a824a75a2c8656b6be18403692" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS_TILED</a>, which are less expensive than <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee" title="Ensure that primitives and compute dispatches from after the barrier don&#39;t start until all such work ...">nvn::BarrierBits::ORDER_PRIMITIVES</a> and <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">nvn::BarrierBits::ORDER_INDIRECT_DATA</a>. ORDER_INDIRECT_DATA is more expensive than ORDER_PRIMITIVES and should only be used if commands after the barrier require indirect draw or dispatch data written by the GPU from commands before the barrier.</p>
<p>When using <a href="#nvn_guide_tiled_caching">tiled caching</a>, applications should use ORDER_FRAGMENTS_TILED when possible. If commands after the barrier access textures written before the barrier using only their own (x,y) coordinates, ORDER_FRAGMENTS_TILED doesn't have to wait for completion of fragments from other screen-space tiles and can thus perform better then ORDER_FRAGMENTS. However, if fragments after the barrier access texels written by other pixels before the barrier &ndash; even their immediate neighbors &ndash; ORDER_FRAGMENTS_TILED can not be safely used because those pixels may belong to other tiles that the barrier will not wait on.</p>
<p>In addition to controlling shader execution, barrier bits allow applications to invalidate internal GPU caches before executing commands after the barrier. When processing commands prior to a barrier, the GPU may fetch data from textures or buffers into internal caches that might not be updated when the cached memory is updated by the CPU, by buffer or image stores performed by shader code, or by stores to render targets. To ensure that commands after the barrier do not use stale cached data, manual cache invalidation is required.</p>
<ul>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a9e69c1611d60167aabe53bc267ead1a9" title="Invalidate caches used to hold texture data fetched via sampler or image variables.">nvn::BarrierBits::INVALIDATE_TEXTURE</a> is used to invalidate caches that hold texture data fetched by sampler or image variables.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af1c1a082ea6e170974efc753d8e04db3" title="Invalidate caches used to hold shader code and data from uniform or shader storage blocks.">nvn::BarrierBits::INVALIDATE_SHADER</a> is used to invalidate caches that hold shader code and data fetched from uniform or shader storage blocks.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a6b577811b7e71491b735c2540bad6e0a" title="Invalidate caches used to hold texture and sampler descriptors.">nvn::BarrierBits::INVALIDATE_TEXTURE_DESCRIPTOR</a> is used to invalidate caches that hold texture and sampler descriptors registered by commands such as <a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">nvn::TexturePool::RegisterTexture</a> and <a class="el" href="classnvn_1_1_sampler_pool.html#af39ae66ac172ee0c4804ff4b95fc94e7" title="Register a sampler descriptor in a sampler pool for use via texture handles, using a Sampler object.">nvn::SamplerPool::RegisterSampler</a>. This cache is invalidated automatically whenever commands are flushed to the hardware, or whenever a new sampler or texture pool is bound. However, if the sampler or texture pool constants are updated as the result of a Draw, compute, or some other rendering operation, the cache must be invalidated manually.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5ac8720bba76d8ece30ef1e222564e7085" title="Invalidate GPU ZCull storage after direct depth texture updates.">nvn::BarrierBits::INVALIDATE_ZCULL</a> is used to invalidate an on-chip cache that tracks the contents of the current depth/stencil render target and is used to accelerate depth and stencil testing. This cache is updated automatically when depth buffers are cleared and when depth and stencil values are updated by normal rendering. However, if the current depth/stencil render target is updated by copy commands or some other non-rendering operation, the cache must be invalidated manually.</li>
<li><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aa9b1e43aeb830c6a60bfdca764d8ac5f" title="Invalidates the L2 cache.">nvn::BarrierBits::INVALIDATE_L2_CACHE</a> is used to invalidate the L2 cache which is a unified cache between all clients on the GPU and the DRAM. For more information on use cases for this barrier, check the section <a href="#nvn_guide_memory_pool_aliasing">MemoryPool aliasing</a>.</li>
</ul>
<p>Except for updates to depth textures requiring the use of INVALIDATE_ZCULL, data written <a href="#nvn_guide_copy_commands">by copy commands</a> will automatically invalidate internal GPU caches and require cache no barrier.</p>
<p>When commands after the barrier need to read values that the GPU writes when processing commands prior to the barrier, applications must not only invalidate relevant caches but also ensure that the previous commands producing the data have completed. This can be done by either using one of the execution barrier bits above or waiting on the completion of a Sync object using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a>.</p>
<p>When commands after the barrier need to read values written by the CPU, cache invalidation is required but no execution barrier is needed. Additionally, if the data written by the CPU come from a memory pool using the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching.">nvn::MemoryPoolFlags::CPU_CACHED</a>, the CPU caches must be flushed using <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a> or <a class="el" href="classnvn_1_1_buffer.html#a33d9a879a34a17e9328d4c593d817fdd" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU.">nvn::Buffer::FlushMappedRange</a> to ensure that the newly-written data are not stuck in CPU caches and invisible to the GPU.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
Examples</h3>
<ul>
<li>If an application has one pass where it uses a depth texture as a render target and then a second pass where it reads from the depth texture as a shadow map, a barrier is needed with the bits <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS</a> and <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a9e69c1611d60167aabe53bc267ead1a9" title="Invalidate caches used to hold texture data fetched via sampler or image variables.">nvn::BarrierBits::INVALIDATE_TEXTURE</a>.</li>
<li>If an application has one pass where it renders to a multisample color texture and then a second pass where it performs a resolve operation where each pixel averages the color values for its samples, a barrier is needed with the bits <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aebc5d0a824a75a2c8656b6be18403692" title="Ensure that fragments from after the barrier don&#39;t start until all fragments from before the barrier ...">nvn::BarrierBits::ORDER_FRAGMENTS_TILED</a> and BarrierBits::INVALIDATE_TEXTURE. If the resolve operation also accesses samples from neighboring pixels, ORDER_FRAGMENTS must be used instead of ORDER_FRAGMENTS_TILED.</li>
<li>If the application has one pass where it renders to a color texture and a second pass where it reads from the texture in a vertex shader, a barrier is needed with the bits <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee" title="Ensure that primitives and compute dispatches from after the barrier don&#39;t start until all such work ...">nvn::BarrierBits::ORDER_PRIMITIVES</a> and <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a9e69c1611d60167aabe53bc267ead1a9" title="Invalidate caches used to hold texture data fetched via sampler or image variables.">nvn::BarrierBits::INVALIDATE_TEXTURE</a>.</li>
<li>If the application writes to a uniform buffer with the CPU, a barrier must be inserted before rendering commands needing the new data with the bit <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af1c1a082ea6e170974efc753d8e04db3" title="Invalidate caches used to hold shader code and data from uniform or shader storage blocks.">nvn::BarrierBits::INVALIDATE_SHADER</a> set. No execution barrier is required.</li>
<li>If the application has one pass where a compute shader generates data for draw calls, including vertex buffer, index buffer, uniform buffer, and indirect draw data, and a second pass that uses indirect draw calls to render the generated primitives, a barrier is needed with <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">nvn::BarrierBits::ORDER_INDIRECT_DATA</a> and <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af1c1a082ea6e170974efc753d8e04db3" title="Invalidate caches used to hold shader code and data from uniform or shader storage blocks.">nvn::BarrierBits::INVALIDATE_SHADER</a>.</li>
<li>If the application has one pass capturing primitives using transform feedback and then a second pass rendering those primitives using <a class="el" href="classnvn_1_1_command_buffer.html#a9ab04f8a0370eb42f81c9d307016f7cb" title="Draw primitives captured in a previous transform feedback (stream output) operation.">nvn::CommandBuffer::DrawTransformFeedback</a>, a barrier using <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">nvn::BarrierBits::ORDER_INDIRECT_DATA</a> is required. DrawTransformFeedback is considered an indirect draw call (fetching primitive information from the results of a previous transform feedback operation). No cache invalidations are required if the generated data are only fetched from vertex buffers.</li>
</ul>
<h1><a class="anchor" id="nvn_guide_sync"></a>
14. Sync Objects</h1>
<p>Sync objects are a coarse synchronization primitive that can be used to synchronize between queues or between a queue and the CPU.</p>
<p>Sync objects begin in an "initialized" state when <a class="el" href="classnvn_1_1_sync.html#a2a560c21696b35e39f5aa18dc5c382d4" title="Initialize a Sync object for the specified device.">nvn::Sync::Initialize</a> is called. Sync objects enter an "unsignaled" state when <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> is called or a command set containing an <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> command is submitted to a queue. Sync objects transition to a "signaled" state upon completion of all work submitted to the queue prior to the most recently submitted <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> or <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> command. The set of work that needs to be completed before signaling is specified by the <code>condition</code> parameter, which can be:</p>
<ul>
<li><a class="el" href="structnvn_1_1_sync_condition.html#a04db14358fc989497815bdf3773519cca63b434d23a8f0b4a40b4271b97371b3b" title="The sync object should be signaled when all previous commands have fully completed on the GPU.">nvn::SyncCondition::ALL_GPU_COMMANDS_COMPLETE</a>: Signal when all preceding commands have been fully executed, and all memory transactions for those commands will be visible to all units of the GPU.</li>
<li><a class="el" href="structnvn_1_1_sync_condition.html#a04db14358fc989497815bdf3773519cca59cc33e71a276a351779704fe1f7683f" title="The sync object should be signaled when the vertices of previous commands have been fully processed b...">nvn::SyncCondition::GRAPHICS_WORLD_SPACE_COMPLETE</a>: Signal when all preceding graphics commands have completed through vertex, tessellation, and geometry shader, and transform feedback pipeline stages, and all memory transactions for those commands and stages will be visible to all units of the GPU. GRAPHICS_WORLD_SPACE_COMPLETE does not wait on rasterization, fragment shader processing, or stores to render targets.</li>
</ul>
<p>The <code>flags</code> parameter is a bitfield specifying additional conditions that must apply before a sync object is signaled.</p>
<ul>
<li>If <a class="el" href="structnvn_1_1_sync_flag_bits.html#ac1ec0d9eacc08a459d9780280227013ca2fccff48d70ff398363e997420ee7fa5" title="Ensures that all GPU memory transactions performed for commands prior to the fence will be visible to...">nvn::SyncFlagBits::FLUSH_FOR_CPU</a> is set in <code>flags</code>, the sync object will not be signaled until all memory transactions for previous commands will be visible to the CPU. If FLUSH_FOR_CPU is not set, CPU accesses to memory written by previous commmands may see old values even when the sync object is signaled.</li>
</ul>
<p>Applications may wait on sync objects in multiple ways. First, the CPU can wait on a sync object using <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait()</a>. The <code>timeout</code> parameter specifies the minimum time (in nanoseconds) to wait for the sync object to enter the signaled state. If a timeout value of zero is specified, NVN checks the state of the sync object and immediately returns whether or not it is signaled. This command returns one of four conditions, depending on the state of the sync object when the command returns:</p>
<ul>
<li><a class="el" href="structnvn_1_1_sync_wait_result.html#a41766f39f04f537a5d09af744600b572a2ea427099c26bfa28b97b31d2ff8029b" title="The sync object was already signaled when the wait was requested.">nvn::SyncWaitResult::ALREADY_SIGNALED</a> is returned if the sync object was already in the signaled state at the time the command was issued.</li>
<li><a class="el" href="structnvn_1_1_sync_wait_result.html#a41766f39f04f537a5d09af744600b572a6cd75adc659c6436259a9b0c4768662c" title="The sync object not signaled when the wait was requested, but was signaled prior to the end of the wa...">nvn::SyncWaitResult::CONDITION_SATISFIED</a> is returned if the sync object was not in the signaled state at the time the command was issued, but reached the signaled state before the specified timeout interval completed.</li>
<li><a class="el" href="structnvn_1_1_sync_wait_result.html#a41766f39f04f537a5d09af744600b572a25e2e5fd9ba5654d2d2473385690f1e0" title="The condition was not satisfied before the wait period expired.">nvn::SyncWaitResult::TIMEOUT_EXPIRED</a> is returned if the sync object did not reach the signaled state before the specified timeout interval expired.</li>
<li><a class="el" href="structnvn_1_1_sync_wait_result.html#a41766f39f04f537a5d09af744600b572a366893276197eda110b68703b4770534" title="An error occured while waiting on the sync object.">nvn::SyncWaitResult::FAILED</a> is returned when an error occurred. This can happen if an application waits on a sync object in the initialized state, or if an error prevented the GPU from completing the associated FenceSync command, or if an application waits on too many (&gt;64) sync objects concurrently.</li>
</ul>
<p>Additionally, an application can cause NVN commands submitted to a queue to wait on a sync object using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a>. If the sync object has been used by a previous FenceSync command, work on commands submitted to the queue after WaitSync command will not begin until the sync object is signaled. If the sync object has not been used by a previous FenceSync command, WaitSync will have no effect. <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a> returns <code>NVN_TRUE</code> is the sync object has been used by a previous FenceSync command and <code>NVN_FALSE</code> otherwise.</p>
<p>The commands <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> and <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> are not automatically flushed to the GPU for processing. Before waiting on a FenceSync call with the CPU using Sync::Wait or from another Queue using Queue::WaitSync, applications must ensure that the previous FenceSync call was flushed using Queue::Flush. Waiting on a FenceSync call using Queue::WaitSync in the same queue requires no manual flush.</p>
<p>It is legal to call <a class="el" href="classnvn_1_1_sync.html#ab87eb51b8df4843608d0e78adaa304fe" title="Finalize a Sync object.">nvn::Sync::Finalize</a> on a sync object regardless of its state.</p>
<p>Sync objects may be reused by applications without being finalized and re-initialized. When a FenceSync command is submitted to a queue using a sync object not in the initialized state, the sync object will enter the unsignaled state and will transition to to signaled state when that FenceSync command and all prior commands submitted to the queue complete execution on the GPU.</p>
<p>We recommend that applications wait for the completion of previously submitted commands using the sync object before reusing the sync object. If there are uncompleted commands using an existing Sync object at the time a sync object is reused, the following behavior occurs:</p>
<ul>
<li>Uncompleted <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> commands will not wait for the new FenceSync command. Each call will wait only for the completion of the FenceSync command that was most recently submitted at the time <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> was called.</li>
<li>Uncompleted <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a> commands previously submitted to queues will not wait for the new FenceSync command. Each call will wait only for the completion of the FenceSync command that was most recently submitted at the time the WaitSync command was submitted to the queue.</li>
<li>Uncompleted <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a> and <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> commands will complete and may affect previous calls to <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a>, as described above. However, those commands will have no effect on future calls waiting on the reused sync objects, including submissions of previously compiled command sets that contain <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a> commands.</li>
</ul>
<p>If a sync object is reused before previous FenceSync commands have completed on the GPU, new calls waiting on the sync object ignore the previous FenceSync commands. If the previous FenceSync command was submitted to a different queue, succesfully waiting on the new FenceSync command does not guarantee that the previous fence has completed.</p>
<p>Commands using sync objects are not thread-safe. It is not safe for an one application thread to update a sync object by:</p>
<ul>
<li>calling <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a>; or</li>
<li>calling <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> to submit a command set containing a call to <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a></li>
</ul>
<p>while another thread is updating or waiting on the same sync object by:</p>
<ul>
<li>calling <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a>, <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a>, or <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a>; or</li>
<li>calling <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> to submit a command set containing a <a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a> or <a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a> command.</li>
</ul>
<p>Multiple threads may wait on the same sync object concurrently as long as no other thread is updating it at the same time.</p>
<h1><a class="anchor" id="nvn_guide_event_object"></a>
15. Event objects</h1>
<p>Event objects can be used when the application needs to synchronize work between the CPU and the GPU.</p>
<p>Events are different from sync objects:</p><ul>
<li>Each Event object has an associated 32-bit unsigned integer value stored in GPU-accessible memory, while sync objects have binary (signaled or not signaled) state. This means that it is possible to, for example, have multiple outstanding signal commands to the same event, where each signal command, when executed, increments the value of the event by one.</li>
<li>The CPU can be used to signal events, while sync objects cannot be signaled from the CPU.</li>
<li>The CPU can be used to read the value associated with an event, but a blocking CPU wait operation is not supported.</li>
<li>The application is responsible for providing GPU accessible memory storage for events, while the sync object storage is managed by the NVN driver.</li>
<li>Event signal and wait commands are written directly into command memory, and do not require control memory or any extra processing when SubmitCommands is called.</li>
</ul>
<p>An Event object is created using an EventBuilder object that is supplied a memory pool and an offset inside this memory pool. The offset must be 4-byte-aligned.</p>
<p>When an event object is created, its initial value will be the current contents of the associated memory. If an initial value is required for the event, it must be set manually by the application.</p>
<p>The memory pool objects providing storage for events must satisfy several restrictions:</p>
<ul>
<li>If the memory pool is created as CPU_CACHED, applications on the NX platform must perform additional cache operations. Applications must call <a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange()</a> after calling <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal</a> and <a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange()</a> before calling <a class="el" href="classnvn_1_1_event.html#a77023f5b13c1f88c3a884ee3dd3ace2a" title="Get the value associated with an Event object.">nvn::Event::GetValue()</a> to ensure caches in the CPU are flushed. It is an error to use CPU_CACHED memory pools for events on the Windows reference implementation.</li>
<li>If the memory pool is created with CPU_UNCACHED (recommended), no additional CPU cache management is required.</li>
<li>If the memory pool is created with CPU_NO_ACCESS, the event object may not be used with the commands <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal</a> and <a class="el" href="classnvn_1_1_event.html#a77023f5b13c1f88c3a884ee3dd3ace2a" title="Get the value associated with an Event object.">nvn::Event::GetValue</a> that access the event's memory with the CPU.</li>
<li>If the memory pool is created with GPU_CACHED, the memory pool must also use CPU_NO_ACCESS. GPU caching is not supported with CPU-accessible memory because a command like <a class="el" href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5" title="Pause work on the GPU until an event is signaled.">nvn::CommandBuffer::WaitEvent</a> may store an old value of the event in the GPU cache and fail to see the results of a <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal</a> command that writes the needed new value.</li>
<li>If the memory pool is created with GPU_UNCACHED (recommended), use of the pool for events is fully supported.</li>
<li>It is an error to use a memory pool created with GPU_NO_ACCESS, PHYSICAL, or VIRTUAL.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_sec_15_1"></a>
15.1. Creating an event object</h2>
<p>Use the following sequence to create an event builder object from which events can be created. </p><pre class="fragment">MemoryPool *memoryPool = createMemoryPool();
ptrdiff_t offset = /* offset in memoryPool to use */;

EventBuilder builder;
builder.SetDefaults();
builder.SetStorage(memoryPool, offset);
</pre><p> To create an event from the event builder: </p><pre class="fragment">Event *event = allocateStorageForEvent();
event-&gt;Initialize(&amp;builder);
</pre> <h2><a class="anchor" id="nvn_guide_sec_15_2"></a>
15.2. Signaling an event</h2>
<p>Events can be signaled from using either the CPU or GPU. To signal an event from the CPU, use <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal()</a>. To signal from the GPU use <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">nvn::CommandBuffer::SignalEvent()</a>.</p>
<p>There are several options for signaling an event. Both <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal()</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">nvn::CommandBuffer::SignalEvent()</a> support an EventSignalMode parameter that control the signaling semantics.</p>
<p>Currently there are two EventSignal modes available:</p><ul>
<li>WRITE: The 32-bit unsigned value supplied to <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal()</a> will simply be written to the memory pool location specified when the event is created.</li>
<li>ADD: The 32-bit unsigned value supplied to <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal()</a> will be added atomically to the value stored in the memory pool location. The Windows reference implementation does not support the ADD mode in the command <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">nvn::CommandBuffer::SignalEvent</a> on some GPUs. The application needs to query support for this by calling <a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c" title="Query properties of a device.">nvn::Device::GetInteger()</a> with DeviceInfo::EVENTS_SUPPORT_REDUCTION_OPERATIONS. On the NX platform this is always supported.</li>
</ul>
<p>When signaling using <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">nvn::CommandBuffer::SignalEvent</a>, applications can specify the location in the GPU pipeline where the event is signaled. The <a class="el" href="structnvn_1_1_event_signal_location.html" title="Mode determining when CommandBuffer::SignalEvent signals the event.">nvn::EventSignalLocation</a> enum allows applications to specify signaling at the top of the GPU pipeline, at the end of the vertex processing pipeline, or the bottom of the GPU pipeline.</p>
<p>Note that signaling an event from the CPU is a non-atomic operation. Locking is required if <a class="el" href="classnvn_1_1_event.html#ac3e8adab9e905a68ced589b2d8aa172c" title="Use the CPU to signal an NVNevent object.">nvn::Event::Signal</a> could update the same event from multiple threads concurrently.</p>
<h2><a class="anchor" id="nvn_guide_sec_15_3"></a>
15.3. Waiting for an event</h2>
<p>An application can wait for an event on either the GPU or CPU. The command <a class="el" href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5" title="Pause work on the GPU until an event is signaled.">nvn::CommandBuffer::WaitEvent</a> can be used to wait for an event on the GPU. There are different modes that select when a wait is satisfied:</p><ul>
<li>EventWaitMode::EQUAL: The wait is satisfied if the value in event memory is exactly equal to the value provided to nvn:Event::WaitEvent.</li>
<li>EventWaitMode::GEQUAL_WRAP: The wait is satisfied if the value in event memory is greater or equal to the value provided to nvn:Event::WaitEvent.</li>
</ul>
<p>When applications use <a class="el" href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5" title="Pause work on the GPU until an event is signaled.">nvn::CommandBuffer::WaitEvent</a>, they are required to ensure that the memory associated with the event will eventually contain a value that passes the test. If not, a GPU timeout error will occur.</p>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: On the Windows reference implementation, Event objects do not support synchronization between queues. Submitting a command set containing a WaitEvent command on one queue to wait on an event signaled by <a class="el" href="classnvn_1_1_command_buffer.html#a042cb09825770079f08e777509e6d8fe" title="Use the GPU to signal an Event object.">nvn::CommandBuffer::SignalEvent</a> command submitted to another queue may result in GPU timeout errors. Applications can use Sync objects to reliably synchronize between queues on all platforms. </p>
</blockquote>
<p>No dedicated command is provided to wait for an event on the CPU. Applications can implement a CPU-side wait using a polling loop that calls <a class="el" href="classnvn_1_1_event.html#a77023f5b13c1f88c3a884ee3dd3ace2a" title="Get the value associated with an Event object.">nvn::Event::GetValue</a> to read the current value of the event.</p>
<h3><a class="anchor" id="autotoc_md91"></a>
Unblocking the GPU before presenting a texture</h3>
<p>Applications must ensure that the GPU is unblocked when presenting a texture. Failing to do so can produce a deadlock if the application is suspended by the system. Such suspensions can occur as the result of a transition to the Home Menu or Sleep Mode.</p>
<p>The symptoms of this problem can include:</p>
<ul>
<li>Home Menu transition failure.</li>
<li>Device sleep transition failure.</li>
</ul>
<p>Application code that produces this problem might be structured this way: </p><pre class="fragment">nvnCommandBufferBeginRecording(&amp;m_CommandBuffer);
{
    ...
    // This command will block the GPU until the corresponding event is signaled.
    nvnCommandBufferWaitEvent(&amp;m_CommandBuffer, &amp;m_Event, NVN_EVENT_WAIT_MODE_GEQUAL_WRAP, nvnEventGetValue(&amp;m_Event) + 1);
    ...
}
m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_CommandBuffer);

// Submit the commands and the GPU starts processing of the commands.
nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_CommandHandle);
nvnQueueFlush();

// BAD: The texture is presented before the event is signaled.
nvnQueuePresentTexture(&amp;m_Queue, m_pWindow, index);

// If the application is suspended at this point, it will produce a failure.

// Finally unblock the GPU.
nvnEventSignal(&amp;m_Event, NVN_EVENT_SIGNAL_MODE_WRITE, nvnEventGetValue(&amp;m_Event) + 1);
</pre><p> There is another similar possible case with <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress.">NVNsync</a> where GPU processing may be blocked due to synchronization between multiple NVNqueues.</p>
<p>There are three APIs which can block the GPU in NVN:</p><ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a39ce30782d28ebc2f6d97cbc8658cd41" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::CommandBuffer::WaitSync</a></li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a64ada95e92249e9b1f3b1b166dbbf5f5" title="Pause work on the GPU until an event is signaled.">nvn::CommandBuffer::WaitEvent</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a></li>
</ul>
<p>Similar case must be taken with other graphics APIs on the NX platform, such as OpenGL and Vulkan.</p>
<p>The following is the example of the code to make the GPU unblocked before presenting the texture: </p><pre class="fragment">nvnCommandBufferBeginRecording(&amp;m_CommandBuffer);
{
    ...
    // This command will block the GPU until the corresponding event is signaled.
    nvnCommandBufferWaitEvent(&amp;m_CommandBuffer, &amp;m_Event, NVN_EVENT_WAIT_MODE_GEQUAL_WRAP, nvnEventGetValue(&amp;m_Event) + 1);
    ...
}
m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_CommandBuffer);

// Submit the commands and the GPU starts processing of the commands.
nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_CommandHandle);
nvnQueueFlush();

// GOOD: The GPU is unblocked prior to presentation.
nvnEventSignal(&amp;m_Event, NVN_EVENT_SIGNAL_MODE_WRITE, nvnEventGetValue(&amp;m_Event) + 1);

// Present the texture.
nvnQueuePresentTexture(&amp;m_Queue, m_pWindow, index);
</pre> <h1><a class="anchor" id="nvn_guide_render_targets"></a>
16. Render Targets</h1>
<p>The command <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> is used to bind texture objects for rendering. The first <em>numColors</em> color targets (up to 8) are bound to textures programmed using the array <em>colors</em>, using texture views in <em>colorViews</em>. All remaining color targets are unbound. Additionally a single depth, stencil, or combined depth/stencil texture may be programmed using the texture <em>depthStencil</em> with the view <em>depthStencilView</em>.</p>
<p>When using texture views containing multiple mipmap levels as render targets, rendering will always be done to the highest-resolution mipmap level of the view and all other levels will be unaffected. When using texture views with multiple layers, clears will write all layers. Rendered primitives will be sent to layer zero by default, but may be directed to other layers using GLSL shader built-in outputs (e.g., <code>gl_Layer</code>).</p>
<p>When programming a set of render targets, if any texture has a multisample target (<a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8fca32f85ac2fdb4850903b5f5f9078d" title="Two-dimensional texture, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE</a> or <a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86adae55e7e5918dcaf98121d6cc5816003" title="Array of two-dimensional textures, with multiple samples per texel.">nvn::TextureTarget::TARGET_2D_MULTISAMPLE_ARRAY</a>), all populated render targets must be multisample textures with identical sample counts. Mixing multisample and non-multisample render targets is not allowed.</p>
<p>When programming a set of render targets, if the sizes of the views of attached textures (in pixels) doesn't match, rendering will be clipped to the largest rectangle contained in all views. For example, if one render target view is 640x480 pixels and a second is 512x512, rendering will be clipped to a 512x480 rectangle.</p>
<p>Buffer textures (<a class="el" href="structnvn_1_1_texture_target.html#abd128d96eb5fd82395676518c041be86a8723b44f01e96881343ebfa45c50a0fe" title="Buffer texture.">nvn::TextureTarget::TARGET_BUFFER</a>) are not supported as render targets.</p>
<p>When rendering to multisample textures, values for individual samples of a pixel are resolved to single values in a single-sample texture using <a class="el" href="classnvn_1_1_command_buffer.html#af3f0fd0366d48cd3ba8f9c2cfea40e23" title="Computes a filtered version of a multisample source texture to produce a single-sample destination te...">nvn::CommandBuffer::Downsample</a> or <a class="el" href="classnvn_1_1_command_buffer.html#aad675ea33fa4fd4ce4815ed5db5c320a" title="Computes a filtered version of a multisample source texture and texture view to produce a single-samp...">nvn::CommandBuffer::DownsampleTextureView</a>.</p>
<p>After performing a downsample on a multisample texture, the individual sample values are often no longer needed. The contents of color and depth render targets can be discarded using the commands <a class="el" href="classnvn_1_1_command_buffer.html#a51f6b826ef568486e1ec5875663bb980" title="Discard the contents of the specified bound color render target.">nvn::CommandBuffer::DiscardColor</a> and <a class="el" href="classnvn_1_1_command_buffer.html#ae8c508e0b02295d5ac10849239c1499a" title="Discard the contents of the currently bound depth/stencil render target.">nvn::CommandBuffer::DiscardDepthStencil</a>. After discarding the contents of a render target, the values for all texels become undefined. These commands can be used to save memory bandwidth when texels are written to a write-back cache in the GPU and then consumed directly from that cache by operations such as a downsample. In this case, cache lines can be invalidated without writing values to memory.</p>
<h1><a class="anchor" id="nvn_guide_sec_17"></a>
17. Multithreading</h1>
<p>NVN is intended to provide scalable performance when used on multiple CPU threads, but it is important to document what guarantees are provided or not provided by the API.</p>
<p>First, and perhaps most subtle, the API does not provide CPU memory ordering guarantees above and beyond those guaranteed by the CPU architecture. This is particularly noteworthy on the ARM architecture which is more weakly ordered than many developers are accustomed to from x86/x64 programming. For example, on ARM CPUs stores can be reordered with stores to different addresses, and this can affect sharing of NVN objects across CPU threads.</p>
<p>NVN commands that construct or compile objects do simple CPU stores to update software structures representing these objects, and those stores could potentially be reordered against whatever CPU stores the application uses to hand off an object from one thread to another. Therefore, when constructing or modifying an NVN object on one thread, an application must take care to guarantee that the driver's CPU stores are ordered against the application's stores they use for the handoff. This can be accomplished with memory barrier instructions, such as "sfence" on x86 or "dmb" on ARM.</p>
<p>This issue would most commonly affect a "jobs" system that is creating objects in worker threads which are specifically intended to be consumed by a different thread. A natural way to deal with this (which apps ought to be doing already!) is to use a memory barrier immediately before doing the store to indicate that the job is "complete". However, this issue can less commonly affect other objects as well, for example if two threads submit work to the same queue, they should use barriers when handing off the queue between threads.</p>
<p>NVN commands do not do any locking to prevent multiple threads from accessing or modifying a given API object at the same time. If an application needs to modify an object on one thread while accessing or modifying it on another thread, it is required to lock prior to calling NVN functions. The results of calling an NVN function to modify an object on one thread and concurrently calling an NVN function to access or modify an object on a second thread are undefined and may lead to application termination. Applications are not required to lock when accessing an object with multiple threads if none of the accesses modify the object in question.</p>
<p>For objects like <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> that may commonly be written by multiple threads, we recommend that applications generate a separate command buffer (with separate command and control memory) for each thread. This allows each thread to write its own commands without needing to interlock with any other application threads.</p>
<p>Certain operations that might be performed by multiple threads might require the driver to modify "global" per-device internal resources. For these cases, the driver will use a mutex to ensure that multiple threads don't attempt to program these shared resources concurrently. The scope of such mutexing should generally be limited to the memory allocation operations (e.g., setting up new GPU mappings of memory in pools, programming special GPU resources for optimized depth testing) and should be rare. The vast majority of NVN commands will never require a mutex and should thus have no multi-threaded scaling issues.</p>
<h1><a class="anchor" id="nvn_guide_counters"></a>
18. Counters</h1>
<p>The GPU used by NVN maintains a collection of running counters that are incremented on a variety of events. The values of these counters, along with an associated timestamp, can be written to buffer memory using <a class="el" href="classnvn_1_1_command_buffer.html#a97e3b104004b6188f83dfaa755a50936" title="Write a GPU counter and timestamp into buffer object memory.">nvn::CommandBuffer::ReportCounter</a>. The set of counters supported by NVN can be found in the documentation of the type <a class="el" href="structnvn_1_1_counter_type.html" title="Specifies the type of counter value reported in a counter query.">nvn::CounterType</a>. Each counter report writes to 16 bytes of buffer object memory.</p>
<p>Counter reports of all types except <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ab596aefd86769826ce49dc48c92623ef" title="Report zcull counters.">nvn::CounterType::ZCULL_STATS</a> can be read from buffer memory using the data structure <a class="el" href="structnvn_1_1_counter_data.html" title="Data structure describing how counter values are written to buffer memory.">nvn::CounterData</a>. The current value of the counter after the completion of all commands submitted prior to the call to ReportCounter is written to the member <em>counter</em>. The GPU time when the counter value was reported is written to the member <em>timestamp</em>.</p>
<p>The <em>timestamp</em> field is platform dependent. For further details on the resolution of timestamp values for various platforms and how to convert them into units of nanoseconds, please see the section '<a href="#nvn_guide_counter_resolution_of_timestamp">Resolution of timestamp</a>'.</p>
<p>NVN does not provide direct support for querying counter values accrued over a time interval like BeginQuery and EndQuery in OpenGL. However, the values of a given counter can be reset using <a class="el" href="classnvn_1_1_command_buffer.html#a64d15a39c7a1f8391aef376768a37d02" title="Reset a GPU counter to zero.">nvn::CommandBuffer::ResetCounter</a>. To count the number of samples that passed the depth and stencil tests (commonly used for occlusion queries), an application can use code like: </p><pre class="fragment">nvn::CommandBuffer cmdBuf;    // command buffer used for rendering
nvn::BufferAddress bufAddr;   // buffer address used for sample count
...
cmdBuf.ResetCounter(nvn::CounterType::SAMPLES_PASSED);
/* render primitives using cmdBuf */
cmdBuf.ReportCounter(nvn::CounterType::SAMPLES_PASSED, bufferAddress);
</pre><p> The counter types <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29a33db55ee4a8aad66a36527b093fc843e" title="Doesn&#39;t report a counter; zero is written in the counter portion of the report structure.">nvn::CounterType::TIMESTAMP</a> and <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29aa228e64e624b6dd903cbd23ea7cad308" title="Doesn&#39;t report a counter; zero is written in the counter portion of the report structure.">nvn::CounterType::TIMESTAMP_TOP</a> are special report types that only report the current timestamp; the associated counter value is always zero. It is an error to attempt to reset TIMESTAMP or TIMESTAMP_TOP using <a class="el" href="classnvn_1_1_command_buffer.html#a64d15a39c7a1f8391aef376768a37d02" title="Reset a GPU counter to zero.">nvn::CommandBuffer::ResetCounter</a>. TIMESTAMP will report a timestamp when the GPU has finished processing previous primitives (but does not wait for all memory transactions to be committed). TIMESTAMP_TOP does not wait on the completion of previous primitives.</p>
<p>The command <a class="el" href="classnvn_1_1_device.html#afc7eb10400a4c93d173dc280d1e3536f" title="Get timestamp from the device, without queuing like the ReportCounter functions.">nvn::Device::GetCurrentTimestampInNanoseconds</a> can be used to read the current timestamp of the GPU without waiting for the GPU to process previous commands sent to the GPU via NVN queues. However, this command needs to obtain the current timestamp by making a request to the graphics firmware. The time required to service this request will be unpredictable.</p>
<p>The counter type <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ab596aefd86769826ce49dc48c92623ef" title="Report zcull counters.">nvn::CounterType::ZCULL_STATS</a> is a special report type that does not report a timestamp, but instead reports four separate 32-bit counter values related to high-speed depth and stencil testing.</p>
<p>Additionally, the command <a class="el" href="classnvn_1_1_command_buffer.html#a0dc42b659aad608e9e4a976aeb083c7d" title="Write a GPU counter report and timestamp into buffer object memory using an application-provided valu...">nvn::CommandBuffer::ReportValue</a> can be used to write a report of type <a class="el" href="structnvn_1_1_counter_data.html" title="Data structure describing how counter values are written to buffer memory.">nvn::CounterData</a> to GPU memory where the counter value in the report is replaced by a 32-bit value provided when ReportValue was called.</p>
<p>Counter reports can be used for conditional rendering using <a class="el" href="classnvn_1_1_command_buffer.html#ae228acd137da5415f118f5c8268c867a" title="Enables rendering for a queue, depending on the equality of counters.">nvn::CommandBuffer::SetRenderEnableConditional</a>. SetRenderEnableConditional compares the counter values of two reports in consecutive memory and then enables/disables rendering based on whether the counter values are equal or not equal, as requested by the application. To execute a draw call only if the a previous draw call had one or more non-occluded samples, an application can use code like: </p><pre class="fragment">nvn::CommandBuffer cmdBuf;    // command buffer used for rendering
nvn::BufferAddress bufAddr;   // buffer address used for sample count
...
cmdBuf.ReportCounter(nvn::CounterType::SAMPLES_PASSED, bufferAddress);
/* first draw call */
cmdBuf.ReportCounter(nvn::CounterType::SAMPLES_PASSED, bufferAddress + 16);

/* use sync objects to wait for completion of both counter reports */

cmdBuf.SetRenderEnableConditional(nvn::ConditionalRenderMode::RENDER_IF_NOT_EQUAL,
                                  bufferAddress);
/* second draw call */
cmdBuf.SetRenderEnable(NVN_TRUE);  // render unconditionally
</pre> <h2><a class="anchor" id="nvn_guide_counter_resolution_of_timestamp"></a>
18.1. Resolution of timestamp</h2>
<p>The GPU timestamp values are platform dependent, though they are in 8bytes across all platforms.</p>
<p>On the NX platform, the timestamp is reported in units of 625 / 384 (approximately 1.6276) nanoseconds since the NX device was initialized, and has a resolution of 625 / 12 (approximately 52.083) nanoseconds. The timestamp values reported by the NX platform are independent of the programmed GPU clock frequency and will always reflect elapsed time.</p>
<p>On the Windows reference platform, the timestamp is reported in units of 1.0 nanoseconds since 00:00 GMT on January 1, 1970 and has a resolution of 32 nanoseconds.</p>
<p>The utility function <a class="el" href="classnvn_1_1_device.html#ac270fbaf6eb5c0fa2ddea450eb743853" title="Returns the timestamp contained in a counter report, with time values converted from the platform-spe...">nvn::Device::GetTimestampInNanoseconds</a> is available on all platforms for converting the timestamp value to nanosecond units.</p>
<h1><a class="anchor" id="nvn_guide_presentation"></a>
19. Displaying Textures On-Screen</h1>
<p>Presenting textures on-screen requires an <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> object. The window object manages an array of NVN textures, and connects them to a native window. On NX, the native window must be of type <a class="el" href="namespacenn_1_1vi.html#a4d5f9e1b22348c0080755ad26cb980c1" title="Platform-dependent handle to a window.">nn::vi::NativeWindowHandle</a> and it acts as a connection to the platform windowing system and compositor. On the Windows reference implementation, the native window (if provided) must be of type HWND. If the native window is NULL on Windows, present operations require a bound "donor" OpenGL context and will present to the window bound with the OpenGL context.</p>
<p>The maximum number of textures that can be passed to <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> at initialization time is 4 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dabe5e6208b07a54be6fae234730e8610e" title="Maximum value supported by nvn::WindowBuilder::SetTextures.">nvn::DeviceInfo::MAX_TEXTURES_PER_WINDOW</a>). The minimum number of textures that can be passed to <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> at initialization time is 2 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dacf971e5ea3cdc61cdd0a3a8e4a64a5d8" title="Minimum value supported by nvn::WindowBuilder::SetTextures.">nvn::DeviceInfo::MIN_TEXTURES_PER_WINDOW</a>). All textures must be initialized with display access by setting <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea867ccb57db3565319f3d648cfcab1d3e" title="This texture can be displayed on-screen.">nvn::TextureFlags::DISPLAY</a> in the bitfield value passed to <a class="el" href="classnvn_1_1_texture_builder.html#a11f7525e0d1c3c010612c1d9bc1fcbbf" title="Set flags indentifying special properties of Texture objects created from the TextureBuilder.">nvn::TextureBuilder::SetFlags</a>. Linear textures cannot be displayed, so the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea867ccb57db3565319f3d648cfcab1d3e" title="This texture can be displayed on-screen.">nvn::TextureFlags::DISPLAY</a> flag should not be used together with <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> or <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>.</p>
<p>The following texture formats are supported by <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a>:</p>
<ul>
<li>RGBA8</li>
<li>RGBX8</li>
<li>RGBA8_SRGB</li>
<li>RGBX8_SRGB</li>
<li>BGRA8</li>
<li>BGRA8_SRGB</li>
</ul>
<p>The display pipeline does not apply any gamma correction to the textures and treats all texture data as being sRGB encoded - even if the NVN format is not an sRGB format.</p>
<p>The <em>textures</em> pointer passed to <a class="el" href="classnvn_1_1_window_builder.html#a467db53d5d36313074fb40b249772ec2" title="Sets the textures used for presenting to this window.">nvn::WindowBuilder::SetTextures</a> must remain valid until the window is initialized with <a class="el" href="classnvn_1_1_window.html#adaa3ca47e35810048c19b5ed351cda9c" title="Initialize a new window object from a window builder.">nvn::Window::Initialize</a>.</p>
<p>If the size of the textures does not match the size of the native window, the windowing system will scale the texture when presenting it to the display. If the aspect ratio of the textures does not match the aspect ratio of the native window, the scaling policy (letterbox, crop or stretch) is decided by the platform windowing system and/or native window parameters.</p>
<p><a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> manages ownership of the textures: each texture is either owned by the application (when the application is queuing commands that use the texture), or by the platform windowing system (when the windowing system is presenting the texture). When a window object is initialized, all textures assigned to it will be owned by the platform windowing system. The application must acquire textures from the window before using them as render target using <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a>.</p>
<p>If <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> succeeds, <a class="el" href="structnvn_1_1_window_acquire_texture_result.html#a76c981e1553baa7e9a378cc031c33966ad5a680ba7e4563c575a2e8dd41d447e7" title="The texture was acquired successfully.">nvn::WindowAcquireTextureResult::SUCCESS</a> is returned, and the <em>textureIndex</em> parameter is set to identify the index (to the array of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> objects specified when initializing the window) of the texture that was acquired. If <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> encounters an internal error and is unable to acquire a texture, <a class="el" href="structnvn_1_1_window_acquire_texture_result.html#a76c981e1553baa7e9a378cc031c33966a446c75db0cb0f43b7e0d832c889d0f2c" title="Native window system error.">nvn::WindowAcquireTextureResult::NATIVE_ERROR</a> is returned and program termination is recommended.</p>
<p>The caller must provide a valid initialized sync object in the <em>textureAvailableSync</em> parameter to <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a>. After a successful call, the sync object can be used to determine when the acquired texture can be rendered to. Passing <em>textureAvailableSync</em> to <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a> ensures that any subsequent commands sent to the queue are not processed by the GPU until the acquired texture is ready for use.</p>
<p>Applications should also use <em>textureAvailableSync</em> to match their rendering rate to the presentation rate. This can be done by calling <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> on <em>textureAvailableSync</em> before calling <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>.</p>
<p>Waiting for the <em>textureAvailableSync</em> associated with an <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> for a given texture T guarantees that the GPU has completed rendering to the texture that <em>follows</em> T in a window's swap chain. For example, when triple-buffering between textures A, B, and C, when the <em>textureAvailableSync</em> associated with texture A is signaled, the GPU is guaranteed to have completed rendering to texture B.</p>
<p>For foreground applications on NX, <em>textureAvailableSync</em> is signaled when the presented texture is displayed on-screen, which is synchronized with the display vsync signal. This means that <em>textureAvailableSync</em> sync objects associated with subsequent <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> calls will be signaled at 60Hz frequency if the application can maintain a 60 FPS rendering rate. For background applications or applications presenting to an off-screen native window, <em>textureAvailableSync</em> is signaled when the present operation no longer requires the contents of the presented texture, which is not connected to vsync events. Application code should not make any assumptions about the signaling frequency in this case.</p>
<p>If the texture has not been presented before with <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>, <em>textureAvailableSync</em> will be signaled immediately. If <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> returns an error, <em>textureAvailableSync</em> will not be modified.</p>
<p><a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> may block if all textures of the window are being used by the platform windowing system. This can happen if the application is rendering new frames faster than the platform windowing system is able to display them. It is recommended for applications to not rely on this blocking behavior, and instead call <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> on <em>textureAvailableSync</em> to throttle the rate of presentation.</p>
<p>After <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> returns, it is guaranteed that the GPU has completed rendering the previous frame to the acquired texture.</p>
<p>After the application has queued rendering to an acquired texture, it can send it to display using <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>. <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a> transfers the ownership of the texture back to the platform windowing system, and the application must re-acquire it with <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> before using it again.</p>
<p>On NX, <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a> performs the following tasks:</p>
<ul>
<li>Emit a texture decompression command to the queue, if the presented texture was initialized with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> flag.</li>
<li>Emit a GPU L2 flush barrier to the queue so that the previous rendering is seen by the display engine.</li>
<li>Trigger an implicit <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a> call so that the preceding queue commands are guaranteed to complete in finite time.</li>
<li>Release the texture back to the platform windowing system to be displayed.</li>
</ul>
<p>On the Windows reference implementation, the behavior of <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a> depends on whether the window has an associated native window. If the native window is non-NULL, <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a> copies the contents of the acquired texture to the back buffer of the native window set in the <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> object and then calls SwapBuffers to display the contents of the back buffer on screen. When using a non-NULL native window, applications are not required to have a currently bound OpenGL context. If the native window is NULL, the application must have a "donor" OpenGL context bound when the thread calls <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>. In this case, PresentTexture copies the contents of the acquired texture to the back buffer of the window bound to the current OpenGL context. To display the contents of the back buffer on-screen, applications must separately call SwapBuffers.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Current version of NVN API supports only one texture per window to be acquired to the application. In other words, calls to <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a> and <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a> must always come in pairs. This restriction may be lifted in a future version of the API. </p>
</blockquote>
<p>Textures presented to the window may not be displayed on the screen immediately; the behavior depends on the <em>present interval</em> of the <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a> object. The present interval can be set at initialization time using <a class="el" href="classnvn_1_1_window_builder.html#ac9bae5e7ab7566d354ba914a3510cf28" title="Sets the present interval used when presenting to this window.">nvn::WindowBuilder::SetPresentInterval</a>, and changed at any time using <a class="el" href="classnvn_1_1_window.html#aa66e69701eaed3a82c0ebbd5db706682" title="Sets the present interval for a Window object.">nvn::Window::SetPresentInterval</a>.</p>
<p>A present interval of zero will update the display without waiting for the next refresh. This will display frames as fast as possible but will likely result in visual tearing. A present interval of one will update the display on the next refresh. This will limit the frame rate to the display's refresh rate. A present interval of two will also update the display on the next refresh, but no sooner than two refreshes since the previous update. This limits the frame rate to half of the display's refresh rate, but will produce a more regular refresh rate if not all frames complete before the next refresh.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: The NX production environment will not support a present interval of 0. In that environment, setting a present interval of 0 will behave as though 1 were specified. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE</b>: On NX, the display refresh rate will always be 60Hz. On the Windows reference implementation, the refresh rate depend on the capabilities of the connected monitor and might be in some cases different than 60Hz. </p>
</blockquote>
<p>The number of textures buffered by the display can be changed at run-time using <a class="el" href="classnvn_1_1_window.html#a5c9f3512b0e6b1a8081fba688f820ab1" title="Set the number of textures for presenting to this window.">nvn::Window::SetNumActiveTextures</a> or <a class="el" href="classnvn_1_1_window_builder.html#a0e0eda4fb150cd1ca255dbe830d898ec" title="Set the number of textures for presenting to this window.">nvn::WindowBuilder::SetNumActiveTextures</a> at initialization time. For example, developers can set three textures at initialization time as triple buffering to minimize the possibility of the frame drop and then change it to double buffering at such scene that has to prevent one frame longer latency of the display presentation compared to triple buffering. The number of active textures must be less than the number of preallocated textures at <a class="el" href="classnvn_1_1_window_builder.html#a467db53d5d36313074fb40b249772ec2" title="Sets the textures used for presenting to this window.">nvn::WindowBuilder::SetTextures</a>.</p>
<h2><a class="anchor" id="nvn_guide_sec_19_1"></a>
19.1. Presentation sample code</h2>
<p>The following sample code illustrates how to write an efficient rendering loop. </p><pre class="fragment">extern nvn::Device *device;
extern nvn::Window *window;
extern nvn::Queue *queue;
extern nvn::Sync *textureAvailableSync;
extern nvn::CommandHandle RecordCommands(int textureIndex);

while (true)
{
    int textureIndex;

    // Acquire next texture from the window.
    window-&gt;AcquireTexture(textureAvailableSync, &amp;textureIndex);

    // At this point, GPU has completed rendering the previous frame to
    // the acquired texture, but the acquired texture may still be used
    // by the display.

    // Ensure that subsequent rendering commands are not processed by the
    // GPU until the acquired texture is ready for use.
    queue-&gt;WaitSync(textureAvailableSync);

    // Record commands that render to the acquired texture.
    nvn::CommandHandle cmd = RecordCommands(textureIndex);

    // Submit commands to the queue.
    queue-&gt;SubmitCommands(1, &amp;cmd);

    // Present the texture to the window.  This will also flush the queue
    // so that the GPU will see the commands submitted above.  Due to the
    // WaitSync call above, the GPU will remain blocked until
    // "textureAvailableSync" has signaled.
    queue-&gt;PresentTexture(window, textureIndex);

    // Wait for the texture to become available to limit the rendering
    // rate to the display refresh rate (vsync).
    textureAvailableSync-&gt;Wait(NVN_WAIT_TIMEOUT_MAXIMUM);
}
</pre> <h1><a class="anchor" id="nvn_guide_sec_20"></a>
20. Application Debugging</h1>
<p>The NVN API provides a dedicated debug layer as well as additional dedicated entry points to assist in debugging applications. In addition to built-in API support, an external graphics debugger application will be available to assist in application debugging and tuning.</p>
<h2><a class="anchor" id="nvn_guide_debug_layer"></a>
20.1. Debug Layer</h2>
<p>By default, NVN entry points assume the parameters provided by applications are valid and perform requested operations without checking for illegal conditions. This behavior can significantly reduce API overhead, but makes it more difficult for application developers to debug errors in their code. To assist in application debugging, NVN provides a dedicated debug layer. When the debug layer is enabled, NVN provides applications with alternate entry points for NVN functions that wrap the default entry points, check for errors in API usage, and report such errors to the application. Because of the increased CPU overhead of error checking, we recommend that application developers enable the debug layer during development. The debug layer is disabled on Release builds of NX NVN drivers in order to minimize its library size by compiling out the debug layer code. The Windows NVN driver has debug layer enabled unconditionally. If debug layer usage is needed, the application must be linked to either a Debug or Develop build of the NX NVN driver. Support for debug layer usage can be checked by querying the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da984b90d896c67d5f51418b7963cc45db" title="1 if the NVN debug layer is supported by this version of the driver, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_DEBUG_LAYER</a> using <a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c" title="Query properties of a device.">nvn::Device::GetInteger</a> with the NULL value passed in as the device pointer.</p>
<p>For example, to enable the debug layer (level 0), applications should:</p>
<ul>
<li>Initialize an NVN device with debugging enabled by calling <a class="el" href="classnvn_1_1_device_builder.html#abbfbff296b08d528ce8689fdeb617f3c" title="Set flags used for during device initialzation.">nvn::DeviceBuilder::SetFlags</a> with the <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a54b54b6256df52075f686632a73b5ec7" title="Enable (TRUE) or disable (FALSE) level 0 debug layer for the device.">nvn::DeviceFlagBits::DEBUG_ENABLE_LEVEL_0</a> bit set in the provided <code>flags</code> parameter, and then passing that device builder object to <a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a>. In order to enable a higher level debug layer, set the corresponding device flag instead.</li>
<li>Querying the alternate function pointers for NVN driver entry points by using <a class="el" href="classnvn_1_1_device.html#a2e2badd327c2e74493127bc13f004ae6" title="Query a function pointer for a specified C interface entry point for a device.">nvn::Device::GetProcAddress</a>.</li>
</ul>
<blockquote class="doxtable">
<p><b>NOTE</b>: The NVN debug layer does not support a mix of debug and non-debug devices. Whether using a debug or non-debug NVN device, applications should use only the entry points queried for that device. </p>
</blockquote>
<p>Additional error checks in the debug layer levels can be enabled by setting the <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999acbf00c067e70f8223bb03dfb4507af48" title="Enable (TRUE) or disable (FALSE) level 1 debug layer for the device.">nvn::DeviceFlagBits::DEBUG_ENABLE_LEVEL_1</a> to <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a2b3504a7e2b60355fa60a9e6896269ef" title="Enable (TRUE) or disable (FALSE) level 4 debug layer for the device.">nvn::DeviceFlagBits::DEBUG_ENABLE_LEVEL_4</a> bits in the device flags bitfield. A higher debug level will enable more checks and features at higher performance costs. Enabling a debug layer level will also enable all the levels below.</p>
<ul>
<li>Enabling DEBUG_ENABLE_LEVEL_0 will only enable only simple validation; cases where the driver would return FALSE. At level 0, some frequently-used entry points are not validated. This is the fastest and lowest-overhead debug layer level.</li>
<li>Enabling DEBUG_ENABLE_LEVEL_1 will additionally enable object pointer validation and additional checks. This allows the debug layer to detect invalid object pointers.</li>
<li>Enabling DEBUG_ENABLE_LEVEL_2 will additionally enable memory pool object tracking. This allows the debug layer to detect unfinalized buffers, samplers and textures when the underlying memory pool is finalized.</li>
<li>Enabling DEBUG_ENABLE_LEVEL_3 will additionally enable draw-time validations. When draw-time validation is enabled, the debug layer will instrument command sets and track the current values of selected state for each queue. When a command set containing draw calls or compute dispatches is submitted to a queue, draw-time validation will check for invalid state and report any errors.</li>
<li>Enabling DEBUG_ENABLE_LEVEL_4 will additionally enable more intensive draw-time validation checks such as in-flight command buffer command memory checking. NOTE: When command memory ranges are checked at submission time, and attempts to overwrite a memory range that is still being run by the GPU may raise a debug layer error.</li>
</ul>
<p>The follow table describes which features are enabled at each debug layer level: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Level   </th><th class="markdownTableHeadNone">Skipped Functions   </th><th class="markdownTableHeadNone">Simple Handwritten Checks   </th><th class="markdownTableHeadNone">Object Pointer Validation   </th><th class="markdownTableHeadNone">In-depth Handwritten Checks   </th><th class="markdownTableHeadNone">Memory Pool Object Tracking   </th><th class="markdownTableHeadNone">Draw-time Validation   </th><th class="markdownTableHeadNone">In-flight Command Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<blockquote class="doxtable">
<p><b>NOTE</b>: First activation of debug level 1 or higher will initialize internal object tables, using about ~16MB of memory. </p>
</blockquote>
<p>Once a debug device has been initialized, applications can request callbacks from the debug layer by calling <a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77" title="Install or remove a callback function to be called whenever the debug layer generates a message.">nvn::Device::InstallDebugCallback</a>, providing a function pointer in the <em>callback</em> parameter that should be called each time the debug layer detects an issue. Additionally, applications can provide a generic pointer in the <em>callbackData</em> parameter that will be passed to the callback function each time it is called. Applications can install one or multiple callbacks in the debug layer. A specific callback is enabled when the <em>enable</em> parameter passed to InstallDebugCallback is set to <code>NVN_TRUE</code> and removed when <em>enable</em> is set to <code>NVN_FALSE</code>.</p>
<p>The debug callback function should have a prototype that matches the <a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2" title="Function pointer type used to specify a function to call for debug callbacks.">nvn::DebugCallbackFunc</a> function pointer type. Each time a debug callback is made, the NVN debug layer provides the callback function with several parameters:</p>
<ul>
<li><em>source</em> indicates the type of driver code making the callback. For example, <a class="el" href="structnvn_1_1_debug_callback_source.html#acbee107d7c1abfc8169aeb8d96073788aab8adf5cc51b7810d10173e1cfc37a2c" title="A debug callback is being issued while processing an API command.">nvn::DebugCallbackSource::API</a> indicates that the callback came from driver code implementing the NVN API.</li>
<li><em>type</em> indicates the type of condition triggering the callback. For example, <a class="el" href="structnvn_1_1_debug_callback_type.html#a801d0de4144816fffb266672cf30f299a79c2d26da4cd8dc8266e9658ebbd99f2" title="A debug callback is being issued because of an error in API usage.">nvn::DebugCallbackType::API_ERROR</a> indicates the callback came from an error in API usage.</li>
<li><em>id</em> is an implementation-dependent unsigned integer error/warning number. This error number can be used for identifying or ignoring specific errors when debugging.</li>
<li><em>severity</em> indicates the severity of the condition triggering the callback. For example, <a class="el" href="structnvn_1_1_debug_callback_severity.html#af3a776a17511243cd7bcd936df710278ae92fa2b32dcd342a3d3a68792697eb17" title="A debug callback is issued for errors in API usage or conditions that may lead to GPU exceptions.">nvn::DebugCallbackSeverity::HIGH</a> indicates an important error condition.</li>
<li><em>message</em> is a string (in English) with additional details on the condition triggering the callback.</li>
<li><em>userParam</em> is the application-provided callback data pointer provided when the callback was installed.</li>
</ul>
<p>By default, the debug layer does not directly affect the execution of NVN programs. Even if an error is detected in the debug layer, the command triggering the error will still run to completion. Executing such commands can write invalid data to command buffers or trigger CPU or GPU exceptions that will require restarting the program and/or the device. During application development, it can be helpful to set a permanent breakpoint in a registered callback function. This will cause the debugger to break when an error is detected before any faulty data is written to the GPU. When executing a program under development without a debugger attached, it can also be helpful to abort the program in the debug callback after printing out an error message to avoid crashes.</p>
<p>The debug layer can also be configured to skip the processing of NVN commands where errors are detected. This can be done by setting the device flag <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a7b3b695cd8f35cd58454395e6acf364d" title="If non-zero, the debug layer will skip API calls where errors are detected.">nvn::DeviceFlagBits::DEBUG_SKIP_CALLS_ON_ERROR</a> before initializing the debug device. Skipping calls resulting in errors can avoid some CPU or GPU exceptions, but will not avoid all such errors. Skipping one NVN call may avoid immediate errors, but could still trigger errors if future NVN commands depend on state set by the skipped call. This feature can be used by applications, but was added to assist in testing the debug layer by allowing test code to intentionally generate errors without having the main NVN driver execute those commands.</p>
<p>For NVN functions with success/failure return values, setting the device flag <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a7b3b695cd8f35cd58454395e6acf364d" title="If non-zero, the debug layer will skip API calls where errors are detected.">nvn::DeviceFlagBits::DEBUG_SKIP_CALLS_ON_ERROR</a> will cause the driver to return false / zero on debug layer error. When this bit is not set and a debug layer error occurs, the result of the call and the return value may be undefined. The debug layer may introduce additional checks that the implementation do not have; thus a debug layer error message should be treated as failure even when the the call returns success or non-zero.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: When using <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a7b3b695cd8f35cd58454395e6acf364d" title="If non-zero, the debug layer will skip API calls where errors are detected.">nvn::DeviceFlagBits::DEBUG_SKIP_CALLS_ON_ERROR</a>, if a command to be skipped is contained in a command buffer submission, then the entire command buffer submission may be skipped. </p>
</blockquote>
<h3><a class="anchor" id="nvn_guide_global_debug_cb"></a>
Global Debug Callback</h3>
<p>In addition to the callback functions installed via <a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77" title="Install or remove a callback function to be called whenever the debug layer generates a message.">nvn::Device::InstallDebugCallback</a>, a single global debug callback function can be installed by calling the function nvnInstallGlobalDebugCallback. When the NVN debug layer is enabled, the global debug callback function will receive the same callbacks from the debug layer as functions installed via <a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77" title="Install or remove a callback function to be called whenever the debug layer generates a message.">nvn::Device::InstallDebugCallback</a>. However, the global debug callback will additionally receive callbacks for any errors detected while initializing NVN, when normal device callbacks requiring a valid <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">nvn::Device</a> object are not available. The global debug callback use the same interface (<a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2" title="Function pointer type used to specify a function to call for debug callbacks.">nvn::DebugCallbackFunc</a>) as device debug callbacks. In order to catch errors detected during early driver initialization, the global debug callback function should be installed prior to calling nvnDeviceGetProcAddress. The code below shows how to install the global debug callback: </p><pre class="fragment">// Pointer to the application's desired global debug callback function.
extern PFNNVNDEBUGCALLBACKPROC debugCallback = ...;

// Use the NVN bootstrap loader to query a function pointer to nvnInstallGlobalDebugCallback
// and call it if present.  Note that nvnInstallGlobalDebugCallback is not supported for
// API versions less than 55.12.
PFNNVNINSTALLGLOBALDEBUGCALLBACKPROC installDebugCB = (PFNNVNINSTALLGLOBALDEBUGCALLBACKPROC)nvnBootstrapLoader("nvnInstallGlobalDebugCallback");

if (installDebugCB) {
    // Install debug callback to catch errors that occur during the initialization phase.
    installDebugCB(debugCallback, NULL);
}

// Once the global callback is installed, bootstrap NVN.
auto pGetProcAddress = (PFNNVNDEVICEGETPROCADDRESSPROC)((*nvnBootstrapLoader)("nvnDeviceGetProcAddress"));
nvnLoadCProcs(nullptr, pGetProcAddress);
</pre><h2><a class="anchor" id="nvn_guide_sec_20_2"></a>
20.2. Debug Labels, Markers, and Groups</h2>
<p>Debug labels, markers, and groups are provided to allow an application to annotate objects and command sets with strings that may aid in debugging. The entry points for setting labels, markers, and groups are intended for consumption by external NVN debugging tools. Calling these functions has no effect in the NVN API, even when the debug layer is enabled.</p>
<p>Labels, markers, and debug groups are identified using char string parameters (pointers to a null-terminated array of characters). The original pointers provided by the application will be saved by the debugging tool and dereferenced as needed during debugging. If the memory pointed to by the string is freed or reused before the objects annotated by the string, undefined results including crashes or program termination will occur.</p>
<p>Methods such as <a class="el" href="classnvn_1_1_texture.html#a0e06f6970a803509d49dacbd9e8f203a" title="Sets the debug label string for a Texture object.">nvn::Texture::SetDebugLabel</a> are used to associate a char string label with an object. Labels can be associated with <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">nvn::Device</a>, <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a>, <a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system.">nvn::Window</a>, <a class="el" href="classnvn_1_1_program.html" title="Collection of programmable shaders used to process primitives.">nvn::Program</a>, <a class="el" href="classnvn_1_1_memory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects.">nvn::MemoryPool</a>, <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes.">nvn::Buffer</a>, <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a>, <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">nvn::Sampler</a>, <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a>, and <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> objects. The label associated with an object should be valid until the object is finalized. Calling SetDebugLabel with NULL removes the associated label from an object.</p>
<p>Debug markers are strings that have been recorded to a command set to aid in debugging. Debug markers are recorded into a command set using <a class="el" href="classnvn_1_1_command_buffer.html#a0136544d13e04ed57e24ef1571efc4d4" title="Inserts a debug event marker to the command stream.">nvn::CommandBuffer::InsertDebugMarker</a>. The description passed to InsertDebugMarker must be valid as long as the command set can be executed on a queue with <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a>.</p>
<p>Debug groups allow an application to annotate sets of commands with descriptions. Conceptually, each queue maintains a debug group stack. <a class="el" href="classnvn_1_1_command_buffer.html#a8acf5fdb35b068637c19659fde37b92c" title="Pushes a debug group into the command stream.">nvn::CommandBuffer::PushDebugGroup</a> records a command to a command set that pushes a description to the top of the debug group stack when it is submitted to a queue. <a class="el" href="classnvn_1_1_command_buffer.html#aa7c191488de5f8de314d57431bc2ac98" title="Pops the active debug group off the command stream.">nvn::CommandBuffer::PopDebugGroup</a> records a command to a command set that pops the top of the debug group stack when it is submitted to a queue. It is legal to push a debug group in one command set, and pop it in another command set. It is an error to pop an empty debug group stack. As with debug markers, the char string passed to PushDebugGroup as a description must be valid as long as the command set can be executed on a queue. Additionally, the description must be valid as long as it is in the debug group stack of any queue.</p>
<h2><a class="anchor" id="nvn_guide_api_object_tracking"></a>
20.3. API Object Tracking</h2>
<p>The debug layer and related debugging tools may track the set of valid API objects and command handles so it can check the validity of operations performed by the application and so it can display information about each operation performed. Tracking API state may require significant amounts of additional memory. Typically, the debug layer and debug tools will allocate per-object memory when the object is initialized and free the memory when the object is finalized. If objects are used after they are finalized, the debug layer and other debugging tools will have no information about the object and such usage will be considered illegal.</p>
<p>When the debug layer or related tools are not in use, command handles do not need to be finalized. Freeing or reusing the command and control memory used to store the commands recorded in a command set automatically invalidates the command handle and makes future use of the handle illegal.</p>
<p>When the debug layer or related tools are in use, debugging code may retain additional information about each command set for error checking, performance analysis, or other reasons. Those tools will track the memory used by command sets and will invalidate any command handles whose command memory is freed (by <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a>) or reused in a command buffer object (by <a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d" title="Add command data memory for a CommandBuffer object.">nvn::CommandBuffer::AddCommandMemory</a> or <a class="el" href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a" title="Add control memory for a CommandBuffer object.">nvn::CommandBuffer::AddControlMemory</a>).</p>
<p>To reuse the memory immediately after the command finish, but before the implicit memory clean, the application must call <a class="el" href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35" title="Finalize a command handle.">nvn::Device::FinalizeCommandHandle</a> prior to any modification to the memory. Overwriting the memory of command sets without explicit call to <a class="el" href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35" title="Finalize a command handle.">nvn::Device::FinalizeCommandHandle</a> may result in memory leaks because the memory contains a tracking token for implicit clean up by the tools. Overwriting the command set memory may destroy the token, resulting in a memory leak.</p>
<p>Applications can further reduce the memory consumption of these tools by calling <a class="el" href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35" title="Finalize a command handle.">nvn::Device::FinalizeCommandHandle</a> to indicate that a command handle will not be used in any future commands. This allows the debugging tools to free any information it retains on the command set identified by the handle to reduce overall memory consumption.</p>
<p><a class="el" href="classnvn_1_1_device.html#abc4e753408a85ba15e96b4aef57534f6" title="Walk through the debug layer object database.">nvn::Device::WalkDebugDatabase</a> gives you an interface to walk through each live object of a given <a class="el" href="structnvn_1_1_debug_object_type.html" title="Debug layer object type.">nvn::DebugObjectType</a>. Here, live means "Initialized but not Finalized." You can use this to find leaks and dangling objects.</p>
<p><a class="el" href="classnvn_1_1_device.html#abc4e753408a85ba15e96b4aef57534f6" title="Walk through the debug layer object database.">nvn::Device::WalkDebugDatabase</a> has some restrictions:</p><ul>
<li>It requires the debug layer level to be above 1. See <a href="#nvn_guide_debug_layer">Debug Layer</a> for details.</li>
<li>It acquires an internal lock that will block Initializing and Finalizing of any object while scanning. Be careful if your bug is sensitive to timing.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_sec_20_4"></a>
20.4. GPU error reporting</h2>
<p>When the debug layer is enabled, it will validate the parameters of API entry points and perform callbacks into any registered callback functions when it detects errors. In such cases, the thread that produced the error will call into the registered callback functions with a call stack that includes the application code that produced the error. For draw-time error checking, the stack will include the call to <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a> that submitted the command set containing the draw call that triggered the error check. However, errors detected by the GPU will reflect the contents of command sets that have been sent to the GPU by already-completed calls to <a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a>. After such errors are detected by the GPU <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a> goes into faulted state with following behavior:</p>
<ol type="1">
<li>nvnQueueFinish() returns immediately.</li>
<li>Sync objects placed into faulted queue signal completion.</li>
<li>Faulted queue can be finalized to free resources.</li>
<li>Remaining nvnQueue API calls for faulted queue are ignored or return error.</li>
<li>Other device queues are not affected or blocked by faulted queue.</li>
</ol>
<p>To detect GPU errors, applications can call nvn::Queue::getError which returns the error status of the queue.</p>
<p>nvn::Queue::getError recognizes following error conditions:</p>
<h3><a class="anchor" id="autotoc_md92"></a>
Pushbuffer DMA error</h3>
<p>This error is usually reported when GPU encounters corrupted or invalid information from control memory.</p>
<h3><a class="anchor" id="autotoc_md93"></a>
Graphics engine exception.</h3>
<p>This error is usually reported when an invalid command or parameter is encountered in command memory buffer.</p>
<h3><a class="anchor" id="autotoc_md94"></a>
MMU fault</h3>
<p>This error is usually reported when an invalid memory pointer is sent by the application. For this error nvn::Queue::getError provides additional information about address and type of access through errorInfo parameter. This information can be used for debugging.</p>
<h3><a class="anchor" id="autotoc_md95"></a>
Timeout error</h3>
<p>This error is reported when the GPU is stuck in a single draw call for too long and cannot do context switch to another queue. This might be caused by very long shaders or huge amounts of geometry or pixels in draw call.</p>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: Error detection is not yet supported on the Windows reference implementation. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_sec_20_5"></a>
20.5. GPU error recovery</h2>
<p>Once a GPU error is detected, NVN driver automatically disables the queue which caused the error. Application should periodically check error status of the queues using nvn::Queue::getError to catch the error.</p>
<p>Application cannot use faulted queue for rendering. Faulted queue should be finalized. Application can instead use existing queues or create a new queue to replace faulted one.</p>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: GPU error recovery is not yet supported on the Windows reference implementation. </p>
</blockquote>
<h2><a class="anchor" id="nvn_guide_sec_20_6"></a>
20.6. Checkpoint Markers</h2>
<p>When using NVN Aftermath, checkpoint markers can be used to narrow down the command that has caused a GPU error by tracking the progress the GPU has made in executing submitted command sets. In case of a GPU error, the checkpoint marker that was last completed by the GPU, the ones that are currently in-flight, and the first that has not been processed by the GPU front-end will be included in the NVN Aftermath crash dump. If the NVN Aftermath target library is not linked with the application all calls of checkpoint marker functions are ignored by the NVN driver.</p>
<blockquote class="doxtable">
<p><b>WINDOWS NOTE</b>: NVN Aftermath and checkpoint markers are not supported on the Windows reference implementation. </p>
</blockquote>
<p>Checkpoint markers come in two variants: user inserted checkpoint markers and automatically inserted checkpoint markers.</p>
<ul>
<li>User checkpoint markers allow to associate arbitrary user-defined payload data to a checkpoint marker. This allows applications to correlate engine state with GPU execution of the corresponding command set. User checkpoint markers are recorded into a command set using <a class="el" href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointStatic</a> or <a class="el" href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointDynamic</a>. Those two commands differ in how the lifetime of the payload data is managed. In case of <a class="el" href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointStatic</a>, the lifetime of the payload data needs to be managed by the application. The data is not copied and the application must ensure the memory pointed to by the provided payload data buffer is valid at least as long as the currently recorded command set can execute on a queue. In case of <a class="el" href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointDynamic</a>, a copy is made of the checkpoint marker data and the Aftermath library manages the lifetime of the data. While the second variant is more convenient to use it limits the number of checkpoint markers that can be tracked.</li>
<li>Automatic checkpoint markers are automatically inserted into command sets for certain interesting commands, including draw, compute dispatch, copy, or debug group push commands. This allows developers to track GPU progress without the need to manually instrument the command sets with checkpoint markers. It is possible to control the frequency of automatic checkpoint markers, i.e. add only for specific commands, add only for every n-th command, and only for a particular debug group. Automatic checkpoint markers can be enabled and disabled on the NVN device level with <a class="el" href="classnvn_1_1_device.html#a83f953a0c82977cf4a303ef0e22b6a8a" title="Control automatic checkpoint event markers.">nvn::Device::SetAutomaticCheckpointsEnable</a>. The subset of commands for which to add automatic checkpoint markerss can be selected with <a class="el" href="classnvn_1_1_device.html#ac329ed3baeb7ab1e42838a4c1e25d51e" title="Control for which commands automatic checkpoint event markers are added.">nvn::Device::SetAutomaticCheckpointsMask</a>. How frequent they are added can be controlled with <a class="el" href="classnvn_1_1_device.html#ae8329f8ab914685b62660ad6f78edde8" title="Control how frequently automatic checkpoint event markers are inserted.">nvn::Device::SetAutomaticCheckpointsSamplingInterval</a> and they can be restricted only to a certain debug group with <a class="el" href="classnvn_1_1_device.html#a2dce30d998836c084565626acab5d4bf" title="Control automatic checkpoint event markers by debug group.">nvn::Device::SetAutomaticCheckpointsByDebugGroup</a>.</li>
</ul>
<p>In addition to the checkpoint marker data payload, CPU call stacks can optionally be associated with each of the checkpoint markers. This functionality can be enabled with <a class="el" href="classnvn_1_1_device.html#ac86458577a6260fb5fab9f22f2010e0f" title="Control call stack capture for checkpoint event markers.">nvn::Device::SetCheckpointCallStacksEnable</a>. The maximum depth of the call stack that is stored with the checkpoint marker data can be controlled with <a class="el" href="classnvn_1_1_device.html#a78937197f9881c6448e21e314da1141e" title="Control call stack capture depth for checkpoint event markers.">nvn::Device::SetCheckpointMaxCallStacksDepth</a>.</p>
<h3><a class="anchor" id="autotoc_md96"></a>
Checkpoint Marker Memory</h3>
<p>The NVN Aftermath target library provides a fixed amount of memory that can be used to store checkpoint marker data. This memory is shared across all NVN command sets that the application records. Checkpoint marker memory will be reused in a least recently added fashion. That means if the available memory is exhausted the oldest recorded checkpoint markers will be evicted to make room for newly recorded checkpoint markers. Application developers should keep that in mind when deciding on what frequency checkpoint markers are added, and on the amount of memory associated with each user checkpoint marker. Especially if automatic checkpoint markers are used, it is highly encouraged to use the various filtering options to reduce the total number of checkpoint markers being added.</p>
<p>The following tables show the approximate number of active markers which can typically be tracked based on checkpoint marker type, average size of the data payload and the configured maximum CPU call stack capture depth.</p>
<p>User checkpoint markers with <a class="el" href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointDynamic</a></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stack Depth   </th><th class="markdownTableHeadCenter">8B   </th><th class="markdownTableHeadCenter">16B   </th><th class="markdownTableHeadCenter">32B   </th><th class="markdownTableHeadCenter">64B   </th><th class="markdownTableHeadCenter">128B   </th><th class="markdownTableHeadLeft">256B    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">disabled   </td><td class="markdownTableBodyCenter">262,016   </td><td class="markdownTableBodyCenter">209,664   </td><td class="markdownTableBodyCenter">149,760   </td><td class="markdownTableBodyCenter">95,232   </td><td class="markdownTableBodyCenter">55,168   </td><td class="markdownTableBodyLeft">29,952    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyCenter">174,720   </td><td class="markdownTableBodyCenter">149,760   </td><td class="markdownTableBodyCenter">116,480   </td><td class="markdownTableBodyCenter">80,640   </td><td class="markdownTableBodyCenter">49,920   </td><td class="markdownTableBodyLeft">28,288    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyCenter">130,944   </td><td class="markdownTableBodyCenter">116,480   </td><td class="markdownTableBodyCenter">95,232   </td><td class="markdownTableBodyCenter">69,888   </td><td class="markdownTableBodyCenter">45,568   </td><td class="markdownTableBodyLeft">26,880    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyCenter">87,296   </td><td class="markdownTableBodyCenter">80,640   </td><td class="markdownTableBodyCenter">69,888   </td><td class="markdownTableBodyCenter">55,168   </td><td class="markdownTableBodyCenter">38,784   </td><td class="markdownTableBodyLeft">24,320    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyCenter">52,352   </td><td class="markdownTableBodyCenter">49,920   </td><td class="markdownTableBodyCenter">45,568   </td><td class="markdownTableBodyCenter">38,784   </td><td class="markdownTableBodyCenter">29,952   </td><td class="markdownTableBodyLeft">20,480   </td></tr>
</table>
<p>Here, the first column indicates the maximum call stack depth to be captured for each of the rows, while the second till the last column indicate how many checkpoint markers can be typically tracked based on average payload size in bytes.</p>
<p>User checkpoint markers with <a class="el" href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointStatic</a></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stack Depth   </th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">disabled   </td><td class="markdownTableBodyCenter">262,016    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyCenter">174,720    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyCenter">130,944    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyCenter">87,296    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyCenter">52,352   </td></tr>
</table>
<p>Automatic checkpoint markers (draw, dispatch, copy)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stack Depth   </th><th class="markdownTableHeadCenter"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">disabled   </td><td class="markdownTableBodyCenter">262,016    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyCenter">174,720    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyCenter">130,944    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyCenter">87,296    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyCenter">52,352   </td></tr>
</table>
<p>Automatic checkpoint markers (PushDebugGroup)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stack Depth   </th><th class="markdownTableHeadCenter">8   </th><th class="markdownTableHeadCenter">16   </th><th class="markdownTableHeadCenter">32   </th><th class="markdownTableHeadCenter">64   </th><th class="markdownTableHeadCenter">128   </th><th class="markdownTableHeadLeft">256    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">disabled   </td><td class="markdownTableBodyCenter">174,720   </td><td class="markdownTableBodyCenter">149,760   </td><td class="markdownTableBodyCenter">116,480   </td><td class="markdownTableBodyCenter">80,640   </td><td class="markdownTableBodyCenter">49,920   </td><td class="markdownTableBodyLeft">28,288    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyCenter">130,944   </td><td class="markdownTableBodyCenter">116,480   </td><td class="markdownTableBodyCenter">95,232   </td><td class="markdownTableBodyCenter">69,888   </td><td class="markdownTableBodyCenter">45,568   </td><td class="markdownTableBodyLeft">26,880    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyCenter">104,832   </td><td class="markdownTableBodyCenter">95,232   </td><td class="markdownTableBodyCenter">80,640   </td><td class="markdownTableBodyCenter">61,568   </td><td class="markdownTableBodyCenter">41,856   </td><td class="markdownTableBodyLeft">25,472    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyCenter">74,880   </td><td class="markdownTableBodyCenter">69,888   </td><td class="markdownTableBodyCenter">61,568   </td><td class="markdownTableBodyCenter">49,920   </td><td class="markdownTableBodyCenter">36,096   </td><td class="markdownTableBodyLeft">23,296    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyCenter">47,616   </td><td class="markdownTableBodyCenter">45,568   </td><td class="markdownTableBodyCenter">41,856   </td><td class="markdownTableBodyCenter">36,096   </td><td class="markdownTableBodyCenter">28,288   </td><td class="markdownTableBodyLeft">19,712   </td></tr>
</table>
<p>Here, the first column indicates the maximum call stack depth to be captured for each of the rows, while the second till the last column indicate how many checkpoint markers can be typically tracked based on average debug group name string length in bytes.</p>
<h3><a class="anchor" id="autotoc_md97"></a>
Checkpoint Marker Overhead</h3>
<p>Using checkpoint markers introduces both CPU and GPU overhead. The CPU overhead incurred when command sets are recorded depends strongly on the checkpoint marker features being used. For example, the CPU overhead introduced by using <a class="el" href="classnvn_1_1_command_buffer.html#ae1dcfd6c8ea0149c2d399f37b405584e" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointDynamic</a> is higher than that of <a class="el" href="classnvn_1_1_command_buffer.html#ac563deb3fad19e40cc044ead3405da66" title="Insert a checkpoint event marker to the command set.">nvn::CommandBuffer::InsertCheckpointStatic</a> because of the additional copy that is made of the provided data. Additional CPU overhead is incurred if the CPU call stack tracking feature is enabled. This invokes a costly call stack capture for every checkpoint marker that is recorded into the command set.</p>
<p>In addition to the CPU overhead caused by the checkpoint marker data tracking, checkpoint markers also add some GPU overhead for handling the additional GPU semaphores required for tracking the progress the GPU has made in executing the submitted command sets.</p>
<p>Using checkpoint markers also increases the amount of command memory used by the application. For each command set an additional fixed amount of 88 bytes of command memory is used and each individual checkpoint marker consumes 44 bytes of command memory for the GPU semaphore methods.</p>
<p>Developers are therefore encouraged to use user checkpoint markers sparsely and to use the filtering mechanism provided for automatic checkpoint markers to limit the overhead.</p>
<p>Although all checkpoint marker functions are turned into no-ops if the application is not linked with the NVN Aftermath target library, there is still a small amount of CPU overhead incurred when the functions are called. It is therefore best practice to conditionally enable the checkpoint marker related code only if the application is going to be linked with the NVN Aftermath target library.</p>
<h1><a class="anchor" id="nvn_guide_tiled_caching"></a>
21. Tiled Caching</h1>
<p>Tiled caching is a hardware-based performance optimization that captures geometric primitives in one or multiple rendering passes, subdivides the render targets into rectangular tiles, and then replays the set of captured primitives for each tile. This feature can improve performance when rendering to tiles due to increased memory locality that keeps work in on-chip caches. Reduction in required memory bandwidth can both increase rendering throughput and reduce power consumption. In the NVN API, tiled caching is disabled by default. It can be enabled using <a class="el" href="classnvn_1_1_command_buffer.html#a9013640ac6720f99139509a1763df6c1" title="Perform a specified operation related to tiled caching.">nvn::CommandBuffer::SetTiledCacheAction</a>.</p>
<p>Tiled caching is particularly effective in workloads limited by framebuffer bandwidth, where many memory accesses are performed and where the working set exceeds the sizes of the GPU's internal caches. Such cases include rendering algorithms that exercise one or more of: heavy blending, multiple lighting passes, high depth complexity, multisample rendering (including the final resolve step), and user interface compositing.</p>
<p>Tiled caching is not always effective and may decrease performance in rendering algorithms that are not limited by framebuffer bandwidth, because collecting the scene and playing it back multiples times adds new work not required when tiled caching is disabled. Examples of cases where tiled caching may not be effective include scenes with a large number of primitives with high geometric complexity, primitives using a large number of vertex attributes, and scenes with many state changes (which need to be captured and played back).</p>
<p>Since tiled caching is not an unambiguous performance win, and NVN supports rendering with and without tiled caching, we recommend that application developers experiment with the feature to determine if tiled caching can improve application performance.</p>
<p>Tiled caching can be controlled directly by application code using two commands programming tiled caching hardware directly. <a class="el" href="classnvn_1_1_command_buffer.html#a9013640ac6720f99139509a1763df6c1" title="Perform a specified operation related to tiled caching.">nvn::CommandBuffer::SetTiledCacheAction</a> API allows applications to explicitly enable and disable tiled caching, instruct the hardware to flush/replay the primitives it has currently collected, and instruct the hardware whether or not to automatically replay previously collected primitives when render targets change. <a class="el" href="classnvn_1_1_command_buffer.html#a9c0390349017d16e8481942f520fba95" title="Sets the tile size used for tiled caching.">nvn::CommandBuffer::SetTiledCacheTileSize</a> allows applications to directly control the size (in pixels) of the tiles used for tiled caching. An optimal tile size may be determined experimentally, but one useful algorithm is to program the tile size so that the total memory footprint of the tile (the tile size in pixels multiplied by the total number of bytes of color and depth buffer data for each pixel in the framebuffer) consumes a fraction of the GPU's on-chip L2 cache. The total L2 cache size can be determined by querying the device property nvn::DeviceInfo::L2_CACHE_SIZE.</p>
<h4><a class="anchor" id="autotoc_md98"></a>
Temporarily disable tiled caching for tiled caching-unfriendly rendering</h4>
<pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture msColor, msDepth, color;

....

cb.SetRenderTargets(1, &amp;color, NULL, depth, NULL);

// ... Do tiled cache friendly rendering ...

// Disable tiled caching temporarily.
cb.SetTiledCacheAction(nvn::TiledCacheAction::DISABLE);

// Do tiled caching unfriendly work.  For example, when rendering
// highly tessellated primitives, the amount of geometry that needs to be
// captured and replayed for tiled caching may outweigh the benefits of
// improved memory locality during playback.

// Re-enable tiled caching...
cb.SetTiledCacheAction(nvn::TiledCacheAction::ENABLE);
</pre><p> NVN commands that track the completion of previously submitted work will implicitly flush the tiled cache, which will cause the GPU to replay previously captured primitives and start a new capture for subsequent primitives. Commands triggering tiled cache flushes include:</p>
<ul>
<li><a class="el" href="classnvn_1_1_command_buffer.html#adc0a2ade0434ed01f886cd52aeac1a23" title="Mark a Sync object as signaled when all previous commands have completed in the CommandBuffer object.">nvn::CommandBuffer::FenceSync</a>, <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a0dc42b659aad608e9e4a976aeb083c7d" title="Write a GPU counter report and timestamp into buffer object memory using an application-provided valu...">nvn::CommandBuffer::ReportValue</a>, all of which report the completion of all previously submitted commands.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#a97e3b104004b6188f83dfaa755a50936" title="Write a GPU counter and timestamp into buffer object memory.">nvn::CommandBuffer::ReportCounter</a> and <a class="el" href="classnvn_1_1_command_buffer.html#a64d15a39c7a1f8391aef376768a37d02" title="Reset a GPU counter to zero.">nvn::CommandBuffer::ResetCounter</a>, which are used to report statistics that reflect the results of all previously submitted commands.</li>
</ul>
<p>Because these flushes could reduce the effectiveness of tiled caching, applications using tiled caching should avoid inserting fences or counter reports in the middle of a set of primitives that can be collected together in a single rendering pass.</p>
<h4><a class="anchor" id="autotoc_md99"></a>
Custom resolve pass at end of the frame</h4>
<p>Tiled caching often works well with the <a class="el" href="classnvn_1_1_command_buffer.html#a51f6b826ef568486e1ec5875663bb980" title="Discard the contents of the specified bound color render target.">nvn::CommandBuffer::DiscardColor</a> and <a class="el" href="classnvn_1_1_command_buffer.html#ae8c508e0b02295d5ac10849239c1499a" title="Discard the contents of the currently bound depth/stencil render target.">nvn::CommandBuffer::DiscardDepthStencil</a> APIs. If one rendering pass produces a result that is used in a second rendering pass that accesses the same pixels, both passes can be accumulated and played back by the tiled caching hardware, after which the temporary results from the first pass can be discarded without writing pixels back to main memory. One common use case is multisample rendering, where a multisample render target (requiring 2-8x the storage of single-sample targets) is generated and then used in a resolve pass to produce a final single-sample image. </p><pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture msColor, msDepth, color;
....

cb.SetRenderTargets(1, &amp;msColor, NULL, msDepth, NULL);

// Render work as usual

// Use a barrier to ensure that previous rendering completes before
// the resolve operation (reading the render target as a texture in the
// fragment shader) starts.  Use ORDER_FRAGMENTS_TILED to indicate
// that it safe for tiled caching to collect both the normal rendering pass
// and the resolve pass without flushing in between.
tiled cache barrier so the following resolve may be binned
cb.Barrier(nvn::BarrierBits::ORDER_FRAGMENTS_TILED |
           nvn::BarrierBits::INVALIDATE_TEXTURE);

// Set the resolve target
cb.SetRenderTargets(1, &amp;color, NULL, NULL, NULL);

// Bind msColor as a texture, bind a program to perform the downsample,
// and render a full-screen primitive.

// When the resolve is complete, discard any data cached in the multisample
// color and depth targets.  This assumes their contents will not be used
// in the next frame.
cb.SetRenderTargets(1, &amp;msColor, NULL, msDepth, NULL);
cb.DiscardColor(0);
cb.DiscardDepthStencil();
</pre> <h1><a class="anchor" id="nvn_guide_zcull"></a>
22. ZCull</h1>
<p>The <em>ZCull</em> hardware in the GPU tracks updates to the depth buffer when processing clears and depth buffer updates from the depth test, and maintains a low-resolution representation of the depth buffer in internal ZCull storage. This ZCull data can often be used to quickly determine if fragments will pass or fail the depth test, and can substantially improve rendering performance.</p>
<p>While ZCull acceleration is automatically enabled and is intended to be mostly transparent to the application, the NVN API exposes a few ways to control and examine the behavior of the ZCull hardware:</p>
<ul>
<li>The contents of the ZCull storage can be saved to and restored from buffer memory using the commands <a class="el" href="classnvn_1_1_command_buffer.html#a9e8dd92449da43b69fe613e94cd67ade" title="Save the current ZCull state for the current depth render target.">nvn::CommandBuffer::SaveZCullData</a> and <a class="el" href="classnvn_1_1_command_buffer.html#aac2cecb42e2c89078f75da69200e5ada" title="Update the current ZCull state to use saved state from a previous render target.">nvn::CommandBuffer::RestoreZCullData</a>.</li>
<li>Adaptive ZCull can be enabled for a depth texture using <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea08291fbf4df3cf9248d1c0477b75ccae" title="Enable adaptive ZCull for a given depth texture target.">nvn::TextureFlags::ADAPTIVE_ZCULL</a>. When enabled, hardware automatically tunes the assignment of on-chip ZCull resources to portions of the depth texture based on rendering results from previous frames. See the <a href="#nvn_guide_adaptive_zcull">Adaptive ZCull</a> section for more details on this feature.</li>
<li>The contents of ZCull storage can be invalidated using <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">nvn::CommandBuffer::Barrier</a> with the <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5ac8720bba76d8ece30ef1e222564e7085" title="Invalidate GPU ZCull storage after direct depth texture updates.">nvn::BarrierBits::INVALIDATE_ZCULL</a> bit set. ZCull storage normally does not need to be invalidated, but if applications write to a depth/stencil render target using copy commands or other non-rendering operations, the ZCull storage is not updated and will become out-of-date.</li>
<li>Counters tracking the operation of the ZCull hardware can be read back using the counter type <a class="el" href="structnvn_1_1_counter_type.html#af2829028dc9ed7cdb59e5a2d3d3ffe29ab596aefd86769826ce49dc48c92623ef" title="Report zcull counters.">nvn::CounterType::ZCULL_STATS</a>.</li>
<li>ZF32 values of the ZCull buffer are compressed by default. To disable or enable this feature, use <a class="el" href="classnvn_1_1_command_buffer.html#a867ce7911d6dd0a54ed509459ed7d744" title="Enables/Disables the compression for ZF32 values in the ZCull Buffer.">nvn::CommandBuffer::SetZCullZF32CompressionEnable</a> .</li>
</ul>
<h2><a class="anchor" id="nvn_guide_zcull_save_restore"></a>
22.1. ZCull Save and Restore</h2>
<p>The ZCull storage is automatically invalidated when switching to a new depth render target using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>. Any information on the old depth render target that was accumulated in the ZCull storage from prior commands will be discarded.</p>
<p>The loss of this ZCull information can lead to less effective culling when switching between multiple render targets. Consider the following sequence of operations: </p><pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture colorA, colorB, depthA, depthB;
// ....

// Pass #1
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
cb.ClearColor(0, clearColor, ClearColorMask::RGBA);
cb.ClearDepthStencil(...)
// render some primitives

// Pass #2
cb.SetRenderTargets(1, &amp;colorB, NULL, depthB, NULL);
cb.ClearColor(0, clearColor, ClearColorMask::RGBA);
cb.ClearDepthStencil(...)
// render some primitives

// Pass #3
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
// continue rendering to depthA
</pre><p> At the end of pass #1, the ZCull storage holds information on the render target <em>depthA</em> that could be used to quickly cull new primitives using that depth buffer. But since that information is lost when switching to <em>depthB</em> for pass #2, the additional primitives rendered in pass #3 using <em>depthA</em> will not be culled as effectively.</p>
<p>To preserve ZCull information across render target changes, ZCull contents can be saved and restored using <a class="el" href="classnvn_1_1_command_buffer.html#a9e8dd92449da43b69fe613e94cd67ade" title="Save the current ZCull state for the current depth render target.">nvn::CommandBuffer::SaveZCullData</a> and <a class="el" href="classnvn_1_1_command_buffer.html#aac2cecb42e2c89078f75da69200e5ada" title="Update the current ZCull state to use saved state from a previous render target.">nvn::CommandBuffer::RestoreZCullData</a>: </p><pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture colorA, colorB, depthA, depthB;
nvn::BufferAddress depthABackingStore;
....

// Pass #1
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
cb.ClearColor(0, clearColor, ClearColorMask::RGBA);
cb.ClearDepthStencil(...)
// render some primitives
cb.SaveZCullData(depthABackingStore, backingStoreSize);

// Pass #2
cb.SetRenderTargets(1, &amp;colorB, NULL, depthB, NULL);
cb.ClearColor(0, clearColor, ClearColorMask::RGBA);
cb.ClearDepthStencil(...)
// render some primitives

// Pass #3
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
cb.RestoreZCullData(depthABackingStore, backingStoreSize);
// continue rendering to depthA
</pre><p> Here, the ZCull storage is saved at the end of pass #1 and restored before starting pass #3. Restoring the saved ZCull storage allows primitives sent during pass #3 to be culled as effectively as it would have been if pass #2 were removed.</p>
<p>Applications must allocate and manage the buffer memory used for saving ZCull storage. The command <a class="el" href="classnvn_1_1_texture.html#a4ca44a91efd53f8881e902ba7c3aa31c" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvn::Texture::GetZCullStorageSize</a> or <a class="el" href="classnvn_1_1_texture_builder.html#aea5111b082fa47a28ac458c810bf004e" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvn::TextureBuilder::GetZCullStorageSize</a> should be used to determine the number of bytes required to hold saved ZCull storage for a particular depth/stencil buffer. The buffer holding the saved data must be 32-byte aligned (the value returned when querying the device property <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daf4b271b11114e1c43afe1f7006c84059" title="Minimum alignment for ZCull save/restore buffers.">nvn::DeviceInfo::ZCULL_SAVE_RESTORE_ALIGNMENT</a>). As noted in the <a href="#nvn_guide_memory_pool_aliasing">memory pool aliasing</a> section of this guide, the buffer memory used to hold saved ZCull data must not be in the same 4KB-aligned range of a memory pool (64KB on Windows) as the associated depth texture.</p>
<p>When saving ZCull storage, the data should be saved immediately before switching away from the old render target. When restoring, the data should be restored immediately after switching to the new render target. If the contents of a depth texture are updated between saving and restoring associated ZCull storage, the restored ZCull storage will be inconsistent with the depth buffer. This can lead to incorrect rendering.</p>
<p>When not using adaptive ZCull, ZCull storage should only be saved if the application will continue using the depth texture in the same frame. If an application switches away from a depth buffer in one frame and then clears it immediately after switching back in the next frame, there is no reason to save or restore the ZCull storage for that depth buffer.</p>
<p>When using adaptive ZCull, ZCull storage should be saved and restored when switching render targets even if the depth texture will be cleared after the restore. This save and restore operation will preserve ZCull information from the previous frame so that it can be used to optimize ZCull storage allocations for the new frame.</p>
<h3><a class="anchor" id="autotoc_md100"></a>
ZCull Invalidate Optimizations</h3>
<p>While ZCull contents are generally invalidated on <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>, the NVN driver is able to avoid invalidation in the below scenarios:</p>
<ol type="1">
<li><a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> is called multiple times with the same depth texture. The driver does not invalidate ZCull if the GPU address of the new depth texture didn't change from the previously set depth texture.</li>
<li><a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a> is called with a null depth texture.</li>
</ol>
<p>Setting the same depth texture twice: </p><pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture colorA, depthA;
....

cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);

....

// This SetRenderTargets call will not invalidate ZCull because
// the active depth texture does not change.
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
</pre><p> Switching to color-only rendering between depth passes: </p><pre class="fragment">nvn::CommandBuffer cb;
nvn::Texture colorA, colorB, depthA;
....

cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);

....

// Switch to a color only render target
cb.SetRenderTargets(1, &amp;colorB, NULL, NULL, NULL);

....

// No ZCull invalidate here because previous depth rendering
// used the same depth texture.
cb.SetRenderTargets(1, &amp;colorA, NULL, depthA, NULL);
</pre><p> These optimizations only apply to depth textures created without the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea08291fbf4df3cf9248d1c0477b75ccae" title="Enable adaptive ZCull for a given depth texture target.">nvn::TextureFlags::ADAPTIVE_ZCULL</a> flag.</p>
<h2><a class="anchor" id="nvn_guide_adaptive_zcull"></a>
22.2. Adaptive ZCull</h2>
<p>The ZCull hardware also supports an adaptive ZCull mode where ZCull operations can be optimized by assigning different amounts of ZCull storage to different portions of the screen based on previously rendered frames. The hardware maintains counters tracking the frequency and effectiveness of ZCull in different areas of the screen. The hardware can use this counter data to adaptively increase precision in areas of the screen where higher precision will help the most.</p>
<p>An application can enable or disable the use of adaptive ZCull for each depth buffer. To enable adaptive ZCull for a given depth texture, use <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea08291fbf4df3cf9248d1c0477b75ccae" title="Enable adaptive ZCull for a given depth texture target.">nvn::TextureFlags::ADAPTIVE_ZCULL</a> at texture creation time. Adaptive ZCull is automatically enabled when such a texture is bound as the current depth render target with <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>.</p>
<p>This feature can improve performance, but it may potentially also hurt performance if used improperly. Adaptive ZCull differs from the default ZCull behavior in two important ways:</p>
<ol type="1">
<li>When a texture using adaptive ZCull is bound using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">nvn::CommandBuffer::SetRenderTargets</a>, ZCull hardware will be disabled until the depth buffer is cleared or previous ZCull state is restored using <a class="el" href="classnvn_1_1_command_buffer.html#aac2cecb42e2c89078f75da69200e5ada" title="Update the current ZCull state to use saved state from a previous render target.">nvn::CommandBuffer::RestoreZCullData</a>. When a texture not using adaptive ZCull is bound, ZCull hardware will be enabled, even if previous ZCull state is not restored and the depth buffer is not cleared. In this case, ZCull will initially have no information on the contents of the depth buffer, but will track updates to the depth buffer during normal rendering and use this information to accelerate depth testing for subsequent primitives.</li>
<li>Adaptive ZCull precision assignment is based on hardware counter values from previous rendering to the depth buffer. If application code binds another depth texture before re-using a depth texture with adaptive ZCull enabled, these counters will be lost unless they are saved and restored as described in the <a href="#nvn_guide_zcull_save_restore">ZCull Save/Restore</a> section of this guide. If the ZCull counters are lost, adaptive ZCull optimizations based on incorrect counter information may hurt performance.</li>
</ol>
<h2><a class="anchor" id="nvn_zcull_stencil"></a>
22.3. ZCull stencil culling</h2>
<p>In addition to discarding fragments based on their depth value, the ZCull hardware can also perform stencil culling and discard fragments when they are known to fail the stencil test. Stencil culling is not enabled by default. To enable it, the depth texture of the render target needs to be created using the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eabc03b3208e4a8058456472074a77aeee" title="Enables support for stencil culling.">nvn::TextureFlags::ZCULL_SUPPORT_STENCIL</a> flag. Note that when stencil culling is disabled all ZCull memory can be used for depth culling purpose, but when enabled some of the ZCull memory will be used for stencil culling. This will reduce the precision of depth culling and might have a negative impact on the depth culling performance.</p>
<p>When enabled, the ZCull hardware will only perform stencil culling if the stencil criteria match the currently bound stencil state. The criteria can be controlled by calling <a class="el" href="classnvn_1_1_command_buffer.html#a170337752e305883654a1d57a4727672" title="Sets the criteria that is used by the ZCull HW for stencil culling.">nvn::CommandBuffer::SetStencilCullCriteria</a>. Calling this function will set the criteria but will also make the current ZCull region invalid until the next clear. This might have a negative impact on the ZCull performance. Ideally this function should be used only once per frame, even if multiple primitives would benefit from different stencil criteria. To achieve optimal performance, an application might only set stencil cull criteria for the primitives that benefit the most. </p><pre class="fragment">nvn::CommandBuffer cb;
....

// Set criteria to match func, ref and mask of stencil state B
cb.SetStencilCullCriteria(B.func, B.ref, B.mask);
cb.ClearDepthStencil(...);
...

// Primitive set 1 will be rendered without stencil culling
// since A does not match the criteria.
cb.BindDepthStencilState(A);
render primitive set 1

// Primitive set 2 will be rendered with stencil culling.
// This primitive set should be known to benefit from
// stencil culling.
cb.BindDepthStencilState(B);
render primitive set 2

// Primitive set 3 will be rendered without stencil culling
// since C does not match the criteria.
cb.BindDepthStencilState(C);
render primitive set 3
....
</pre> <h2><a class="anchor" id="nvn_zcull_disabling_ZF32_Compression"></a>
22.4. ZF32 Compression Considerations</h2>
<p>By default ZF32 values (i.e., the contents of <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a0cb28bb8f5f7fefa56888fa11c373c81" title="A 32-bit floating-point depth component.">nvn::Format::DEPTH32F</a> or <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a57b3319d5b05a91d1599dfbbf4edc924" title="A 32-bit floating-point depth component packed with an 8-bit unsigned integer stencil component.">nvn::Format::DEPTH32F_STENCIL8</a> depth buffers) are compressed in the ZCull buffer.</p>
<p>Since the compression is lossy, this can significantly reduce the ZCull performance for depth values near 0.0. However, when using GREATER as depth function it is recommended to disable ZF32Compression for the case where precision near 0.0 is required. Use <a class="el" href="classnvn_1_1_command_buffer.html#a867ce7911d6dd0a54ed509459ed7d744" title="Enables/Disables the compression for ZF32 values in the ZCull Buffer.">nvn::CommandBuffer::SetZCullZF32CompressionEnable</a> to disable or enable the ZCull ZF32 compression.</p>
<p>Toggling the ZF32 compression mode is a comparatively slow operation. Frequent toggles may adversely affect performance. After toggling, the result of any ZCull test will be undefined until after a depth buffer is cleared.</p>
<h1><a class="anchor" id="nvn_guide_frame_buffer_compression"></a>
23. Framebuffer Compression</h1>
<p>Framebuffer compression is a hardware optimization that can reduce memory bandwidth usage during writes and reads.</p>
<p>Framebuffer compression is a different type of compression than block-based compressed textures as described in <a href="#nvn_guide_compressed_formats">compressed formats section of this guide</a>. With framebuffer compression, textures are compressed and decompressed internally and transparently by the GPU. All references within this section to the word "compression" should be taken to mean framebuffer compression only.</p>
<p>By default framebuffer compression is a lossless compression, which is guaranteed to have no detrimental affect on image quality. The GPU will not attempt to compress portions of a texture image if compression of those portions can reduce image quality. Because of this, compression efficiency is dependent on the texture content. For further details on the mechanism of framebuffer compression, please refer to section "8.9. Compression" of the "Maxwell Technical Overview" guide. The only exception is the lossy color reduction which is explicitly enabled to potentially further increase compression efficiency at a possible cost of reduced image quality. Please refer to <a href="#nvn_guide_color_reduction">color reduction section of this guide</a> for further details.</p>
<h2><a class="anchor" id="nvn_guide_frame_buffer_compression_requirements"></a>
23.1. Framebuffer Compression Requirements</h2>
<p>Framebuffer compression will be available only if the framebuffer texture is compressible.</p>
<p>The compressible texture must satisfy all of below conditions. Otherwise, the texture falls back to non-compressible texture.</p>
<ul>
<li>The texture is initialized with <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a>.</li>
<li>The memory pool used for texture storage is initialized with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a>.</li>
<li>The texture is renderable.</li>
<li>The texture format class is not one of C8 and C16.</li>
<li>The texture is not initialized with <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873eaee63554164fcaf2b6de0aa5094dce513" title="This texture is stored in linear format.">nvn::TextureFlags::LINEAR</a> or <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea37cfa391c93c19a27a220697b9583d6d" title="This texture is stored in linear format and will be used as a render target.">nvn::TextureFlags::LINEAR_RENDER_TARGET</a>.</li>
<li>The texture is not one of 1D and 1D array textures.</li>
</ul>
<p>Please refer to the following sections for additional details:</p><ul>
<li>For information about textures that can be used as render targets, see the column "Render" of the <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a>.</li>
<li>For information regarding texture format classes see the <a href="#nvn_guide_memory_mappings">format class table in GPU Memory Mappings section</a>.</li>
<li>For information regarding the <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe" title="Indicates that the memory pool supports compressible textures.">nvn::MemoryPoolFlags::COMPRESSIBLE</a> flag see the <a href="#nvn_guide_memory_pools">NVN memory pool section</a>.</li>
<li>For information regarding the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> flag see the <a href="#nvn_guide_texture_initilization">NVN texture initialization section</a>.</li>
</ul>
<h2><a class="anchor" id="nvn_guide_sec_23_2"></a>
23.2. Framebuffer Compression Action</h2>
<p>The content of textures can be GPU compressed through the following actions:</p>
<ul>
<li>Rendering to a framebuffer compressible texture.</li>
<li>Copying from a buffer object to a framebuffer compressible texture using <a class="el" href="classnvn_1_1_command_buffer.html#a3573269dfa045bfc0673173a8f55fb34" title="Copy texture data from buffer memory into a region of a Texture object.">nvn::CommandBuffer::CopyBufferToTexture</a> with <a class="el" href="structnvn_1_1_copy_flags.html#a842a139af223dd08e0db4b17204272b2ae0dd7765dc7c7a35d5efce67f6ed1683" title="Enable use of the 2D engine copy path.">nvn::CopyFlags::ENGINE_2D</a>.</li>
<li>Copying from a texture object to a framebuffer compressible texture using <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">nvn::CommandBuffer::CopyTextureToTexture</a>.</li>
<li>Clearing compressible color render targets using <a class="el" href="classnvn_1_1_command_buffer.html#a61e04c4a4003648f60f65ce05ce8b61f" title="Clear a color buffer using floating-point clear color values.">nvn::CommandBuffer::ClearColor</a>, <a class="el" href="classnvn_1_1_command_buffer.html#ae2279d44a44fd246ef9f9392b8f9e8bf" title="Clear a color buffer using signed integer clear color values.">nvn::CommandBuffer::ClearColori</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a4b88ad85195c8749ebe41a3c4e9ee250" title="Clear a color buffer using unsigned integer clear color values.">nvn::CommandBuffer::ClearColorui</a>.</li>
<li>Clearing compressible depth/stencil render targets using <a class="el" href="classnvn_1_1_command_buffer.html#a9a0f6d9771cdf2c4d2ec99fcbc366640" title="Clear a depth/stencil buffer.">nvn::CommandBuffer::ClearDepthStencil</a>.</li>
<li>Clearing compressible color texture directly using <a class="el" href="classnvn_1_1_command_buffer.html#acba967469608c76841e41d2b4546f8bd" title="Clear a color buffer using floating point clear color values.">nvn::CommandBuffer::ClearTexture</a>.</li>
</ul>
<p>Please note that in the case of rendering to a framebuffer compressible texture, the glsl imageStore() function, which writes values into an image through the texture pipeline, does not support framebuffer compression. Framebuffer compression can only be applied to values written through the ROP units, with the exception that depth values explicitly defined through gl_FragDepth are not framebuffer compressible.</p>
<h2><a class="anchor" id="nvn_guide_fast_clear"></a>
23.3. Fast Clear</h2>
<p>Fast clear (a.k.a. ZBC: Zero Bandwidth Clear) is an optional framebuffer compression mode that can significantly reduce memory bandwidth usage when clearing a texture. For clear operations, fast clear will be performed if all conditions for fast clear explained in the subsequent section are satisfied. Otherwise, color reduction or arithmetic compression may be performed.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
Fast Clear Requirements and API</h3>
<p>Clearing render targets and textures using registered clear values will have significantly higher performance than clearing with unregistered values in most cases. Clears do not benefit from using registered clear values when writing to:</p>
<ul>
<li>non-compressible textures</li>
<li>color textures with 16 or fewer bits per pixel</li>
<li>16-bit depth textures (<a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component.">nvn::Format::DEPTH16</a>) when <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea53256b41d86cf0e10c4aaa29c206a331" title="Favor fast clear over depth compression for DEPTH16 depth textures.">nvn::TextureFlags::DEPTH16_PREFER_FAST_CLEAR</a> is not set</li>
</ul>
<p>Fast color clear values and formats can be registered using the commands <a class="el" href="classnvn_1_1_device.html#a738e79b4293d108d8dc311840bfb3cd8" title="Register a fast clear color value.">nvn::Device::RegisterFastClearColor</a>, <a class="el" href="classnvn_1_1_device.html#a13ad1a88a3be2802f1ff0b91fe681d40" title="Register a signed integer fast clear color value.">nvn::Device::RegisterFastClearColori</a>, and <a class="el" href="classnvn_1_1_device.html#a156ddbeb91f3c434ec521ecee88b7221" title="Register an unsigned integer fast clear color value.">nvn::Device::RegisterFastClearColorui</a>. Fast depth clear values can be registered using <a class="el" href="classnvn_1_1_device.html#aa3c6011bf315852aebffc88f052fee23" title="Register a fast clear depth value.">nvn::Device::RegisterFastClearDepth</a>.</p>
<p>The total number of clear values that can be registered with NVN is limited. NVN can register 12 unique color value/format pairs and 13 depth values. Additionally, the following fast clear values are pre-registered:</p>
<ul>
<li>The color (0.0, 0.0, 0.0, 0.0) or (0,0,0,0), for all color formats.</li>
<li>The color (1.0, 1.0, 1.0, 1.0), for all color formats with unsigned normalized components.</li>
<li>The color (0.0, 0.0, 0.0, 1.0), for <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac256c39495bd9849f1c94b801fde588d" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8</a>.</li>
<li>The depth value 0.0, for all depth buffer formats.</li>
<li>The depth value 1.0, for all depth buffer formats.</li>
</ul>
<p>When clearing color or depth textures to one of these pre-registered fast clear values, fast clear optimizations will be performed even if those colors were not explicitly registered by the application. Attempting to explicitly register one of the pre-registered fast clear values should succeed, but will reuse the existing pre-registered entry in the tables holding registered fast clear values.</p>
<p>All color formats in NVN that support fast clear are associated with a fast clear equivalent format. The condition for 2 or more formats to be associated with the same fast clear equivalent format is that their components' representation in memory is identical. For example, both <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac256c39495bd9849f1c94b801fde588d" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8</a> are associated with the same fast clear equivalent format, <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a>, because both formats' 8-bit components are stored in memory using the same representation.</p>
<p>When a fast clear color is registered, it is actually registered as the fast clear color for the given format's corresponding fast clear equivalent format instead. Similarly, the GPU determines if a fast clear color has been registered for a particular color format by checking if any has been registered for its equivalent fast clear color format.</p>
<p>The following describes the logical process for determining if fast clear can be executed for a particular color format:</p><ol type="1">
<li>Convert the texture's format to its fast clear equivalent format.</li>
<li>Check if a fast clear color for the equivalent format has been registered which matches the requested clear color, ignoring any unused component in the destination texture's format.</li>
<li>If a matching fast clear color has been registered, then execute the fast clear by clearing the texture content's valid color components to the corresponding registered fast clear color value components.</li>
</ol>
<p>Returning to the <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a> and <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac256c39495bd9849f1c94b801fde588d" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8</a> example above, if a fast clear value of (1.0, 0.0, 1.0, 1.0) has been registered for <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac0ad1e6b0a054c8f2ef5dfeec21a6a14" title="Four 8-bit unsigned normalized components.">nvn::Format::RGBA8</a>, clearing an nvn:Format::RGBX8 texture to (1.0, 0.0, 1.0, 0.0) will result in a fast clear being executed regardless of the mismatch in the alpha component. This is because the alpha component for <a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042ac256c39495bd9849f1c94b801fde588d" title="Three 8-bit unsigned normalized components, padded to 32 bits per pixel.">nvn::Format::RGBX8</a> will not be modified by a clear operation and is ignored for the purpose of matching the clear color to a previously registered fast clear color.</p>
<p>Please refer to the <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> to determine the fast clear equivalent format for all supported color formats. It is only necessary to register a particular fast clear color once for a particular fast clear equivalent format group. Registering the same fast clear color for multiple formats with the same equivalent format will not take up additional GPU resources.</p>
<p>The pre-registered fast clear colors (0.0, 0.0, 0.0, 0.0), (0, 0, 0, 0, 0) and (1.0, 1.0, 1.0, 1.0) listed above are special in that they are applicable to all color formats that support the fast clear operation. Clearing textures with fast clear supported formats to these values will always result in a fast clear being executed.</p>
<p>Registered fast clear values are global GPU resources. If multiple applications running at the same time register fast clear values, any single application may not be able to register a full set of formats. The NVN API provides no way of recycling fast clear value slots. On NX, registered fast clear values will be released when applications terminate. On the Windows reference implementation, clear values may remain registered even after application termination. All of these commands will return <code>NVN_TRUE</code> if registration succeeds and <code>NVN_FALSE</code> if registration fails. If registration fails, clears using the provided values will still work properly and perform better than regular rendering, but will not benefit from the extra fast clear optimization.</p>
<p>When working with textures overlapping in memory, please refer to <a href="#nvn_guide_memory_pool_aliasing">memory pool aliasing section</a> for instructions on clearing and reading.</p>
<h2><a class="anchor" id="nvn_guide_color_reduction"></a>
23.4. Color Reduction</h2>
<p>Color Reduction is a framebuffer compression mode and it has 2 modes: lossless color reduction and lossy color reduction. Lossless color reduction is by default.</p>
<p>Lossy color reduction is an optional framebuffer compression mode that can further reduce memory bandwidth usage at the expense of color accuracy. As the GPU performs raster operations and writes the color results to L2 cache, it can apply a lossy color compression scheme. Applications are able to toggle the optimization and can select thresholds to adjust the tradeoff between memory bandwidth and color accuracy.</p>
<h3><a class="anchor" id="autotoc_md102"></a>
Description of lossy color reduction</h3>
<p>The decision of whether to "reduce" sample values depends on whether they lie within a specified threshold of their average. NVN supports two distinct thresholds. The "aggressive" threshold is used if it is not likely that silhouette (high contrast) edges intersect the tile. Otherwise, the "conservative" threshold is used for sample comparison. Support for both thresholds improves compression for interior pixels while preserving high quality anti-aliased edges.</p>
<p>Tiles where all samples have been touched are considered fully covered. Only samples that lie within a fully covered tile are considered for reduction since the samples must be present in the internal ROP cache to be compared or averaged. Samples may be present due to earlier primitive rasterization or as the result of an L2 cache read.</p>
<p>A fully covered tile where each sample of each pixel is touched exactly once by primitives is not likely to have silhouette (high contrast) edges and will therefore be "aggressively" reduced.</p>
<p>A fully covered tile where any sample of any pixel is touched more than once (or not at all) is more likely to contain a silhouette (high contrast) edge and therefore will only be "conservatively" reduced.</p>
<p>Color reduction is further limited to compressed memory allocations and specific format classes listed below.</p>
<p>To achieve compression each channel of neighboring samples is compared against the threshold. If the difference of each channel in the color format is smaller than the threshold, and all other restrictions (compressible, fully covered tile etc.) apply, one average color value is stored instead of the multiple original color values.</p>
<h3><a class="anchor" id="autotoc_md103"></a>
Color Reduction Requirements</h3>
<p>In order for lossless color reduction framebuffer compression to be enabled, <a href="#nvn_guide_frame_buffer_compression_requirements">all requirements for framebuffer compression above</a> must be satisfied. In addition, 2x MSAA mode is not supported although all other MSAA modes are.</p>
<p>In order for lossy color reduction framebuffer compression to be enabled, all of below conditions must be satisfied.</p>
<ul>
<li>Lossless color reduction requirement is satisfied.</li>
<li>The "format class" must be lossy reducible explained in the subsequent section.</li>
<li>Lossy reduction is enabled by <a class="el" href="classnvn_1_1_command_buffer.html#ad3e75447a4581e7722183ecd0a96e79d" title="Enable or disable lossy color reduction.">nvn::CommandBuffer::SetColorReductionEnable</a>.</li>
<li>non-zero thresholds are used for <a class="el" href="classnvn_1_1_command_buffer.html#a372c68297e7725dd87f78278078c7755" title="Specify new lossy color reduction thresholds for a format class.">nvn::CommandBuffer::SetColorReductionThresholds</a>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md104"></a>
Lossy reducible format classes and thresholds</h3>
<p>Thresholds apply to format classes and not to individual color formats.</p>
<p>Lossy reducible color formats each belong to a "format class". Format classes group color formats with similar precision characteristics together. The supported format classes are UNORM8, UNORM10, UNORM16, FP11, FP16 and SRGB8. The <a href="#nvn_guide_formats_table">NVN formats table</a> lists support for this feature in column "Format class" that indicates the format class to which a format belongs.</p>
<p>Different format classes have different ranges of threshold values, values outside these ranges will be clamped to legal values as listed here:</p>
<ul>
<li>UNORM8/SRGB8: all bits of 8bit components</li>
<li>UNORM10: 8 LSBs of 10bit components</li>
<li>UNORM16: 8 LSBs of 16bit components</li>
<li>FP11: all bits of 6bit mantissa of R and G channel, 5bit mantissa of B channel which is a 10bit floating point number</li>
<li>FP16: 8 bits of 10bit mantissa</li>
</ul>
<p>Thresholds for UNORM and SRGB classes are expressed as non-normalized integers, and are clamped to 255. At this maximum value, UNORM8-class render targets can be reduced regardless of color values, while UNORM10-class render targets can only be reduced within a threshold of 0.25.</p>
<p>For floating point formats, values with different exponents are always considered as exceeding the threshold. For UNORM10 formats, 2bit alpha channel must match exactly.</p>
<h3><a class="anchor" id="autotoc_md105"></a>
Color reduction API</h3>
<p>To enable or disable lossy color reduction, the applications can call <a class="el" href="classnvn_1_1_command_buffer.html#ad3e75447a4581e7722183ecd0a96e79d" title="Enable or disable lossy color reduction.">nvn::CommandBuffer::SetColorReductionEnable</a>. This allows the application to quickly switch between states for all lossy reducible format classes without changing the applied thresholds.</p>
<p>To control threshold values, <a class="el" href="classnvn_1_1_command_buffer.html#a372c68297e7725dd87f78278078c7755" title="Specify new lossy color reduction thresholds for a format class.">nvn::CommandBuffer::SetColorReductionThresholds</a> is used. Setting thresholds to zero effectively disables lossy color reduction for the format class even if <a class="el" href="classnvn_1_1_command_buffer.html#ad3e75447a4581e7722183ecd0a96e79d" title="Enable or disable lossy color reduction.">nvn::CommandBuffer::SetColorReductionEnable</a> is enabled.</p>
<h1><a class="anchor" id="nvn_guide_platforms"></a>
24. Platform Details</h1>
<h2><a class="anchor" id="nvn_guide_sec_24_1"></a>
24.1. API Headers</h2>
<p>The C interface for NVN is defined in the header file <code>"nvn/nvn.h"</code> and includes basic type definitions and prototypes for C API entry points. In the C interface, applications call into the functions defined in the C headers and typically pass pointers to NVN API objects operated on by the functions.</p>
<p>The C++ interface for NVN is defined in the header file <code>"nvn/nvn_Cpp.h"</code> and includes basic type definitions as well as C++ class definitions for the API objects described in this guide. In the C++ interface, NVN entry points are called using C++ class methods.</p>
<p>Applications using the C++ interface for NVN do not need to include headers for the C interface, and vice versa.</p>
<p>The implementation of the entry points in the C and C++ interfaces is provided by the NVN driver. These entry points are not exported directly by the NVN library, but are instead obtained by querying function pointers using the NVN bootstrap loader. The process for obtaining function pointers from the NVN driver for the native NX platform and for the Windows reference implementation is described in the sections below. Note that the function pointers returned by the NVN driver depend on other state set by the application. In particular, a different set of function pointers will be returned if the <a href="#nvn_guide_debug_layer">NVN debug layer</a> is enabled.</p>
<p>Applications using the C interface should include <code>"nvn/nvn.h"</code> plus one of the two following headers:</p>
<ul>
<li><code>"nvn/nvn_FuncPtrGlobal.h"</code> includes #defines that redefine the names of NVN entry points in the C interface (e.g., <code>nvnDeviceInitialize</code>) to the names of global variables holding the values of queried function pointers.</li>
<li><code>"nvn/nvn_FuncPtrInline.h"</code> includes definitions of inline functions that implement all of the entry points in the C interface (e.g., <code>nvnDeviceInitialize</code>) by calling function pointers queried from the NVN driver.</li>
</ul>
<p>Since both of these headers define the same identifiers, applications should only include one of the two headers.</p>
<p>Applications using the C++ interface should include <code>"nvn/nvn_Cpp.h"</code> plus the following header:</p>
<ul>
<li><code>"nvn/nvn_CppMethods.h"</code> includes an implementation of the C++ interface's class methods (e.g., <code><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a></code>) by calling function pointers queried from the NVN driver.</li>
</ul>
<p>The following headers provide function pointer infrastructure for the previous headers:</p>
<ul>
<li><code>"nvn/nvn_FuncPtr.h"</code> and <code>"nvn/nvn_CppFuncPtr.h"</code> declare global variables to hold queried function pointer values for the C and C++ interfaces, respectively. They also declare prototypes for utility functions <code>nvnLoadCProcs()</code> or <code>nvnLoadCPPProcs()</code> that can be used to query those function pointers from the driver. These headers will be included automatically via the C and C++ headers above and need not be included directly by application code.</li>
<li><code>"nvn/nvn_FuncPtrImpl.h"</code> and <code>"nvn/nvn_CppFuncPtrImpl.h"</code> provide definitions for the global variables and utility functions for the C and C++ interfaces declared in the previous files.</li>
</ul>
<p>Applications using the C interface should include <code>"nvn/nvn_FuncPtrImpl.h"</code> in exactly one source file linked into the application so that the globals and utility function will be available when the application is linked. Applications using the C++ interface should similarly include <code>"nvn/nvn_CppFuncPtrImpl.h"</code> in exactly one source file linked into the application.</p>
<h2><a class="anchor" id="nvn_guide_sec_24_2"></a>
24.2. Fastpath Functions</h2>
<p>All API entry points are invocable through function pointers (see <a href="#nvn_guide_bootstrapping">Bootstrapping NVN</a>). However, some functions may be called frequently enough that the overhead of calling through a function pointer noticeably impacts performance. To avoid this performance impact, some API entry points have inline "fastpath" variants that are implemented as inline functions. These functions have the same semantics as as their function pointer equivalents, and they have the same names, but with a <code>_fastpath</code> suffix appended to the name. Fastpath functions may be freely used in combination with the default function pointers.</p>
<p>To avoid excessive code modification when using fastpath functions, applications may define the <code>NVN_FORCE_FASTPATH</code> preprocessor macro prior to including NVN headers. This will redirect all NVN API functions and function-like macros defined in <code>"nvn/nvn_FuncPtrGlobal.h"</code>, <code>"nvn/nvn_FuncPtrInline.h"</code>, and <code>"nvn/nvn_CppFuncPtr.h"</code> to their fastpath equivalents when available.</p>
<p>Fastpath function implementations may not fully include all functionality in their function pointer equivalents. In such cases, the fastpath functions will call their corresponding function pointers.</p>
<p>Because these are inline functions, they cannot vary based on runtime state, and are therefore not compatible with the debug layer or any other mechanism that affects the function pointers when bootstrapping. The result of using fastpath functions in combination with the debug layer is not defined.</p>
<p>Fastpath function implementations are specific to NVN drivers releases and may change. Applications should only use fastpath implementations that correspond to the driver with which they were released. Copied or modified functions are not supported.</p>
<h2><a class="anchor" id="nvn_guide_API_Versions"></a>
24.3. API Versions</h2>
<p>The NVN API is defined with a major and minor version number, given by the defines <code>NVN_API_MAJOR_VERSION</code> and <code>NVN_API_MINOR_VERSION</code>. If the defines for the major and minor versions are 52 and 9, respectively, the API headers are considered to be for API version 52.9. The API version number is incremented whenever new features are added or existing features are changed or removed:</p>
<ul>
<li>The major version is incremented when the API is changed in a way that would break binary compatibility for existing applications, such as the removal of a feature or an increase in the amount of memory required for API data structures.</li>
<li>The minor version is incremented when a new feature is added to the API that will not affect the operation of applications written for previous API versions.</li>
</ul>
<p>Applications can query the major and minor version number supported by the shared library containing the NVN driver by calling <a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c" title="Query properties of a device.">nvn::Device::GetInteger</a> using the properties <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab822c8062d854af9b1a078b6dd55d36e" title="Identifies the major version of the API.">nvn::DeviceInfo::API_MAJOR_VERSION</a> and <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dab822c8062d854af9b1a078b6dd55d36e" title="Identifies the major version of the API.">nvn::DeviceInfo::API_MAJOR_VERSION</a>. The NVN driver is considered to be compatible with the application if both of the following are true:</p>
<ul>
<li>The major version returned by the driver is equal to the major version from the NVN headers used to build the driver.</li>
<li>The minor version returned by the driver is greater than or equal to the minor version from the NVN headers used to build the application.</li>
</ul>
<p>If the API version returned by the driver is incompatible with the application, running the application with the mismatched driver can result in undefined behavior or application crashes. Applications should check the API version during NVN initialization to ensure compatibility. The API version can be queried before creating an NVN device by passing a NULL device pointer to <a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c" title="Query properties of a device.">nvn::Device::GetInteger</a>.</p>
<h2><a class="anchor" id="nvn_guide_bootstrapping"></a>
24.4. Bootstrapping NVN</h2>
<p>Initializing the NVN API and creating a device object can be accomplished on all platforms using code similar to the following: </p><pre class="fragment">extern "C" PFNNVNGENERICFUNCPTRPROC NVNAPIENTRY nvnBootstrapLoader(const char *name);

// Initialize the NVN C entry points.
auto pGetProcAddress = (PFNNVNDEVICEGETPROCADDRESSPROC)((*nvnBootstrapLoader)("nvnDeviceGetProcAddress"));
nvnLoadCProcs(nullptr, pGetProcAddress);

// Optional: Verify the NVN API version.
int major, minor;
nvnDeviceGetInteger(nullptr, NVN_DEVICE_INFO_API_MAJOR_VERSION, &amp;major);
nvnDeviceGetInteger(nullptr, NVN_DEVICE_INFO_API_MINOR_VERSION, &amp;minor);
assert(major == NVN_API_MAJOR_VERSION &amp;&amp; minor &gt;= NVN_API_MINOR_VERSION);

// Initialize the device object.
NVNdeviceBuilder deviceBuilder;
nvnDeviceBuilderSetDefaults(&amp;deviceBuilder);
nvnDeviceBuilderSetFlags(&amp;deviceBuilder, myFlags); // Optional. E.g., NVN_DEVICE_FLAG_ENABLE_BIT, etc.
nvnDeviceInitialize(&amp;myDevice, deviceBuilder);

// Re-initialize the NVN entry points for use with the device.
nvnLoadCProcs(&amp;myDevice, pGetProcAddress);
</pre><p>Note that <code>nvnBootstrapLoader</code> performs some global driver initialization, and <code>nvnDeviceGetProcAddress</code> can also affect internal driver state. Additionally, the return values of <code>nvnDeviceGetProcAddress</code> can vary based on the device state (such as any enabled debug levels). Therefore, it is recommended that applications do NOT call <code>nvnBootstrapLoader</code> or <code>nvnDeviceGetProcAddress</code> with a NULL <code>device</code> parameter while any device object is initialized.</p>
<h3><a class="anchor" id="nvn_guide_bootstrapping_nvn_on_windows"></a>
Bootstrapping NVN on Windows</h3>
<p>On Windows NVN is delivered as library (nvn.dll). In addition to the dll, a static import library (nvn.lib) is provided. Applications can link against the NVN library which exports the <code>nvnBootstrapLoader</code> function. The nvn.dll is loaded at runtime and needs to be available in one of the folders that are searched by the loader. The loader follows the <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order#search-order-for-desktop-applications">standard search order for desktop applications</a>. The default location of the nvn.dll is: </p><pre class="fragment">\%NINTENDO_SDK_ROOT\%\\Tools\\Graphics\\NvnLoader\\nvn.dll
</pre><p> In previous versions of NVN applications had to create an OpenGL "donor" context to load the <code>nvnBootstrapLoader</code>. This is no longer required, but to keep compatibility this mode of bootstrapping is still supported. Application can continue to use code similar to the following: </p><pre class="fragment">// Windows compatibility bootstrapping mode
auto nvnBootstrapLoader = (PFNNVNBOOTSTRAPLOADERPROC)wglGetProcAddress("rq34nd2ffz");

// Initialize the NVN C entry points.
auto pGetProcAddress = (PFNNVNDEVICEGETPROCADDRESSPROC)((*nvnBootstrapLoader)("nvnDeviceGetProcAddress"));
nvnLoadCProcs(nullptr, pGetProcAddress);
</pre><p> Even if NVN applications use compatibility mode of bootstrapping, it requires nvn.dll to be available in the search path noted above since NVN driver is contained within nvn.dll.</p>
<p>In order to run NVN applications on Windows, an NVIDIA display driver (distributed with the NintendoSDK) must be installed on the system running the application. Windows display drivers distributed by Microsoft or on NVIDIA's website do not include any support for NVN. The interface between the NVN library and the Windows display driver may change over time, where shared libraries distributed with one version of the SDK might not be compatible with NVIDIA display drivers provided with a different version of the SDK. We will try to support backwards compatibility where an NVN library from an older SDK should work with a display driver from a newer SDK, but compatibility breaks in this case are possible. When an NVN application runs with an incompatible display driver, NVN initialization will fail.</p>
<p>If a <a href="#nvn_guide_global_debug_cb">global debug callback</a> is installed prior to calling nvnDeviceGetProcAddress, the callback will report any errors that occur during NVN initialization.</p>
<h2><a class="anchor" id="nvn_guide_native_NX_platform"></a>
24.5. Native NX Platform</h2>
<p>On NX, applications can link against the NVN library, which directly exports the <code>nvnBootstrapLoader</code> function, which can be used to load the remaining NVN functions. The use of this function is documented <a href="#nvn_guide_bootstrapping">above</a>. To use NVN on NX, applications should link the application against libnvn.a or nnSdk.nso depending on whether dynamic linking is used or not.</p>
<h3><a class="anchor" id="autotoc_md106"></a>
Memory Usage</h3>
<p>On the NX platform, applications can configure a per-thread stack size. For threads calling into the NVN API, a minimum stack size of 1MB is recommended.</p>
<p>Most NVN functions don't need to allocate memory beyond what is provided to them in the form of NVN API objects. For example, <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> member functions use the memory provided within the <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues.">nvn::CommandBuffer</a> structure, as well as the memory provided explicitly through <a class="el" href="classnvn_1_1_command_buffer.html#aa4fd1a23d42725f00f814de03270d17a" title="Add control memory for a CommandBuffer object.">nvn::CommandBuffer::AddControlMemory</a> and <a class="el" href="classnvn_1_1_command_buffer.html#ab6b7a5a37fd5f91e4b50fb22498a992d" title="Add command data memory for a CommandBuffer object.">nvn::CommandBuffer::AddCommandMemory</a>. However, there are three types of global memory resources that are needed by certain NVN functions:</p>
<ul>
<li><em>Firmware memory</em> is privileged memory used by the graphics firmware for things like GPU virtual memory page tables. This memory needs to be provided up front at page granularity and it will be unmapped from the CPU virtual address space of the calling process.</li>
<li><em>Driver memory</em> is memory used by the NVN driver for extra dynamic memory allocations needed for internal purposes. When the driver needs to dynamically allocate or free a block of memory, it calls the application-provided callback function.</li>
<li><em>Graphics developer tools memory</em> is memory used by the NVN debug layer and other developer tools for extra dynamic memory allocations needed for debugging purposes. NVN API objects do not include storage to hold information that would only be useful to the debug layer, because doing so would would waste memory for applications not using debug layer support. When the debug layer and other developer tools need to keep extra information on NVN API objects, they will dynamically allocate memory as needed using callback functions provided by the application. If an application doesn't use the debug layer or other developer tools, it does not need to provide developer tools memory callback functions. For applications using developer tools, we recommend using a separate memory heap for developer tools memory to ensure that the layout of the driver memory heap is not affected by developer tools memory allocations. Sharing a single heap with driver memory is allowed, but could impact the reproducibility of issues needing to be debugged.</li>
</ul>
<p>On the NX platform, the application developer is responsible for providing memory for all three types of memory explicitly using <a class="el" href="namespacenv.html#aacadc57952b370f2286108f5835ce726" title="Specify the address and size of memory that is donated to graphics firmware.">nv::InitializeGraphics</a> (firmware memory), <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a> (driver memory), and <a class="el" href="namespacenv.html#a5ef00427dfc2493551bb66b37731bb35" title="Set memory allocator for graphics developer tools and NVN debug layer.">nv::SetGraphicsDevtoolsAllocator</a> (graphics developer tools memory). The application has to provide at least 32KB for the firmware memory, otherwise it will be aborted with an error message when calling <a class="el" href="namespacenv.html#aacadc57952b370f2286108f5835ce726" title="Specify the address and size of memory that is donated to graphics firmware.">nv::InitializeGraphics</a>. When calling <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a> or <a class="el" href="namespacenv.html#a5ef00427dfc2493551bb66b37731bb35" title="Set memory allocator for graphics developer tools and NVN debug layer.">nv::SetGraphicsDevtoolsAllocator</a>, the application need to provide the following callback functions:</p>
<ul>
<li><em>void* Allocate(size_t size, size_t alignment, void *userPtr)</em>: This function must allocate a memory block of the requested size with a starting address that is aligned to the requested alignment. Only alignments that are a power of 2 need to be accepted. Unlike std::aligned_alloc, this function may accept a size that is not an integral multiple of the alignment.</li>
<li><em>void Free(void *addr, void *userPtr)</em>: The function frees a memory block that was previously allocated by calling into the allocation or reallocation callback function.</li>
<li><em>void* Reallocate(void* addr, size_t newSize, void *userPtr)</em>: This function changes the size of an already allocated memory block. The function does not need to guarantee that the starting address of the new memory block has the same alignment as the address of the original block. The only alignment guarantee is that the returned address is aligned to alignof(std::max_align_t).</li>
</ul>
<p>The sample code below illustrates the usage of <a class="el" href="namespacenv.html#aacadc57952b370f2286108f5835ce726" title="Specify the address and size of memory that is donated to graphics firmware.">nv::InitializeGraphics</a>, <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a> and <a class="el" href="namespacenv.html#a5ef00427dfc2493551bb66b37731bb35" title="Set memory allocator for graphics developer tools and NVN debug layer.">nv::SetGraphicsDevtoolsAllocator</a>: </p><pre class="fragment">#include &lt;nv/nv_MemoryManagement.h&gt;
#include &lt;nn/mem/mem_StandardAllocator.h&gt;

namespace {
    // Page-aligned block of memory for graphics firmware usage.
    char GraphicsFirmwareMemory[8 * 1024 * 1024] __attribute__((aligned(4096)));

    // Block of memory and allocator functions for graphics driver memory.
    char GraphicsDriverMemory[32 * 1024 * 1024];
    nn::mem::StandardAllocator GraphicsAllocator(GraphicsDriverMemory,
                                                 sizeof(GraphicsDriverMemory));

    void* GraphicsAllocate(size_t size, size_t alignment, void *userPtr)
    {
        return GraphicsAllocator.Allocate(size, alignment);
    }

    void GraphicsFree(void *addr, void *userPtr)
    {
        GraphicsAllocator.Free(addr);
    }

    void *GraphicsReallocate(void* addr, size_t newSize, void *userPtr)
    {
        return GraphicsAllocator.Reallocate(addr, newSize);
    }

    // Block of memory and allocator functions for graphics developer
    // tools memory.
    char DevtoolsMemory[32 * 1024 * 1024];
    nn::mem::StandardAllocator DevtoolsAllocator(DevtoolsMemory,
                                                 sizeof(DevtoolsMemory));
    void* DevtoolsAllocate(size_t size, size_t alignment, void *userPtr);
    void DevtoolsFree(void *addr, void *userPtr);
    void *DevtoolsReallocate(void* addr, size_t newSize, void *userPtr);
}

void nnMain()
{
    // Provide firmware memory.
    nv::InitializeGraphics(GraphicsFirmwareMemory, sizeof(GraphicsFirmwareMemory));

    // Provide driver memory.
    nv::SetGraphicsAllocator(GraphicsAllocate, GraphicsFree, GraphicsReallocate, NULL);

    // Provide developer tools memory if required.  If the application doesn't
    // require a separate developer tools memory heap, it can use the same
    // callback functions used by the graphics allocator.
    nv::SetGraphicsDevtoolsAllocator(DevtoolsAllocate, DevtoolsFree, DevtoolsReallocate, NULL);

    // ...

    // Release resources from graphics subsystem after finalizing NVN objects.
    nv::FinalizeGraphics();
}
</pre><p> The firmware, driver, and developer tools memory resources are shared with other graphics subsystems such as CUDA, OpenGL and Multimedia drivers, and the NVN graphics debugger. The application developer is responsible for providing enough memory to satisfy the combined needs of all graphics subsystems used by the application.</p>
<p>The allocator callbacks provided by the user must be thread-safe. In the sample code above, explicit locking is not needed because <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="Class for managing memory.">nn::mem::StandardAllocator</a> is thread-safe.</p>
<p>Applications must provide graphics firmware memory and specify allocator callback functions before performing any NVN operations, such as initializing an NVN device. Once applications set up allocation callback functions, they must not be changed, since this may result in the driver using a new callback function to free a block of memory allocated from an old callback function.</p>
<p>The relative order of <a class="el" href="namespacenv.html#aacadc57952b370f2286108f5835ce726" title="Specify the address and size of memory that is donated to graphics firmware.">nv::InitializeGraphics</a>, <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a> and <a class="el" href="namespacenv.html#a5ef00427dfc2493551bb66b37731bb35" title="Set memory allocator for graphics developer tools and NVN debug layer.">nv::SetGraphicsDevtoolsAllocator</a> calls does not matter, as long as the application makes its all calls before calling any NVN entry points.</p>
<p>Applications can query current firmware memory usage using the <a class="el" href="namespacenv.html#a66c3f8ebd8731ea4afb3924ed48ae69c" title="Retrieve information about current memory usage status of firmware.">nv::GetGraphicsMemoryInfo</a> function.</p>
<p>The firmware memory is managed by the firmware to satisfy various dynamic memory requirements of the graphics subsystem. This memory management (i.e. suballocation) may require on-demand allocation of tracking structures, which are allocated from the same application provided firmware memory. The tracking structures are not necessarily freed when API objects are finalized, which may appear as small firmware memory leaks.</p>
<p>To release memory donated in <a class="el" href="namespacenv.html#aacadc57952b370f2286108f5835ce726" title="Specify the address and size of memory that is donated to graphics firmware.">nv::InitializeGraphics</a> and <a class="el" href="namespacenv.html#a7d85cfdd1bae1b635cc66b8d58077688" title="Set memory allocator for graphics subsystem.">nv::SetGraphicsAllocator</a>, applications must call <a class="el" href="namespacenv.html#a368247e862f5ffc59a38af42658d7b38" title="Release resources from graphics subsystem.">nv::FinalizeGraphics</a> when the client is no longer using the graphics subsystem. Before calling <a class="el" href="namespacenv.html#a368247e862f5ffc59a38af42658d7b38" title="Release resources from graphics subsystem.">nv::FinalizeGraphics</a>, NVN applications must finalize all initialized NVN objects and terminate all threads that have used the NVN API, other than the thread invoking <a class="el" href="namespacenv.html#a368247e862f5ffc59a38af42658d7b38" title="Release resources from graphics subsystem.">nv::FinalizeGraphics</a>.</p>
<p>The following table lists NVN functions that need driver memory or firmware memory, as well as the maximum amount of memory that they will use per call.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">NVN function   </th><th class="markdownTableHeadCenter">Driver Memory   </th><th class="markdownTableHeadCenter">Firmware Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a>   </td><td class="markdownTableBodyCenter">142 KB   </td><td class="markdownTableBodyCenter">141 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77" title="Install or remove a callback function to be called whenever the debug layer generates a message.">nvn::Device::InstallDebugCallback</a>   </td><td class="markdownTableBodyCenter">32 B   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a> (first queue)   </td><td class="markdownTableBodyCenter">387 KB   </td><td class="markdownTableBodyCenter">401 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a> (subsequent queues)   </td><td class="markdownTableBodyCenter">387 KB   </td><td class="markdownTableBodyCenter">273 KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>   </td><td class="markdownTableBodyCenter">5 KB   </td><td class="markdownTableBodyCenter">See below    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">See below    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">See below    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_window.html#adaa3ca47e35810048c19b5ed351cda9c" title="Initialize a new window object from a window builder.">nvn::Window::Initialize</a>   </td><td class="markdownTableBodyCenter">6 KB   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">See note 2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a>   </td><td class="markdownTableBodyCenter">2 KB   </td><td class="markdownTableBodyCenter">See note 2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">nvn::Queue::Finish</a>   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">See note 2   </td></tr>
</table>
<blockquote class="doxtable">
<p><b>NOTE</b>: Part of the firmware memory needed by <a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a> is used for GPU page table storage. Freeing these page tables may be deferred, if the page tables are shared with other memory pools (see next section). This may appear as if <a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a" title="Finalize a Queue object.">nvn::Queue::Finalize</a> was leaking firmware memory. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE 2</b>: Synchronization functions such as <a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a> also temporarily require some firmware memory (&lt;128 B) that will be freed (or reused) before returning from the function. The precise amount varies based on the underlying implementation. </p>
</blockquote>
<p>Additionally, the following functions may allocate driver memory that will be freed before the function returns.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">NVN function   </th><th class="markdownTableHeadCenter">Driver Memory    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">nvn::Queue::Finish</a>   </td><td class="markdownTableBodyCenter">1 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a>   </td><td class="markdownTableBodyCenter">1 KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>   </td><td class="markdownTableBodyCenter">1 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">nvn::Program::SetShaders</a>   </td><td class="markdownTableBodyCenter">1 KB   </td></tr>
</table>
<p>On the NX platform, ranges of host memory allocated to NVN (via the allocator functions described above, or explicit memory for memory pools, queues, etc.) must not overlap. Overlapping memory ranges will produce undefined results, possibly including graphical corruption and program termination.</p>
<h3><a class="anchor" id="nvn_guide_optimal_queue_memory_size"></a>
Optimal queue memory size</h3>
<p>The NVN driver automatically manages queue command, control, and compute memory as new commands are submitted to the queue. However, an insufficient amount of memory may result in extra flushes, which can negatively affect performance. Whenever the debug layer is enabled, it will report extra flushes via debug callbacks.</p>
<p>Tuning queue memory size during development will allow applications to avoid excessive queue flushes while still limiting total memory consumption.</p>
<p>The commands <a class="el" href="classnvn_1_1_queue.html#a139c7e7a7e280f1a87e0a56436009142" title="Query total queue command memory usage.">nvn::Queue::GetTotalCommandMemoryUsed</a>, <a class="el" href="classnvn_1_1_queue.html#ad32700aee92f014ff277f5a27f1665b5" title="Query total queue control memory usage.">nvn::Queue::GetTotalControlMemoryUsed</a>, and <a class="el" href="classnvn_1_1_queue.html#a95d7fd9337d254e9a81bc7e2fb3e0756" title="Query total queue compute memory usage.">nvn::Queue::GetTotalComputeMemoryUsed</a> return the total amount of queue command, control, and compute memory used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory.">nvn::Queue::ResetMemoryUsageCounts</a>. Because the driver will automatically reuse queue memory after flushes, the total memory usage counts may exceed the amount of memory provided to the queue. If memory usage counts are reset before flushing, usage count queries immediately after the reset may return non-zero values due to commands that have not been flushed.</p>
<p>The sample code below illustrates how these commands can be used to determine the maximum amounts of command, control, and compute memory used by any frame: </p><pre class="fragment">while (app_main_loop) {
    // Render and present a single frame of animation.

    // Get used memory size of queue
    maxCommandMemorySizePerFrame =
            max(maxCommandMemorySizePerFrame , nvnQueueGetTotalCommandMemoryUsed(queue));
    maxControlMemorySizePerFrame =
            max(maxControlMemorySizePerFrame , nvnQueueGetTotalControlMemoryUsed(queue));
    maxComputeMemorySizePerFrame =
            max(maxComputeMemorySizePerFrame , nvnQueueGetTotalComputeMemoryUsed(queue));
    // Reset used memory size of queue
    nvnQueueResetMemoryUsageCounts(queue);
}
</pre><p> Applications can use these maximums to experiment with different memory allocation sizes to see what combination produces the best memory consumption/flushing tradeoff. For control and compute memory, it may not be necessary to allocate much more memory than the maximum per-frame size to avoid mid-frame flushes. For command memory, the situation is more complicated and also involves the flush threshold programmed by nvn::QueueBuilder::SetFlushThreshold. This command lets applications set an approximate amount of command memory that can be used before automatic flushes. Setting a high threshold reduces the number of automatic flushes, but setting a threshold at or near the total amount of queue memory may force the driver to block, waiting on the completion of previously flushed commands before it can reuse command memory for new commands. Applications can also trigger manual queue flushes with <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a>.</p>
<p>Once optimal sizes are determined, they can be used in production code to initialize the sizes of different blocks of queue memory as follows: </p><pre class="fragment">// Use the determined memory size

NVNqueueBuilder queueBuilder;
nvnQueueBuilderSetDefaults(&amp;queueBuilder);

// Allocate enough memory to avoid unnecessary GPFIFO submissions
nvnQueueBuilderSetCommandMemorySize(&amp;queueBuilder, optimalCommandMemorySize);
nvnQueueBuilderSetControlMemorySize(&amp;queueBuilder, optimalControlMemorySize);
nvnQueueBuilderSetComputeMemorySize(&amp;queueBuilder, optimalComputeMemorySize);

nvnQueueBuilderSetCommandFlushThreshold(&amp;queueBuilder,
    optimalCommandMemorySizeFlushThreshold);
</pre> <h3><a class="anchor" id="nvn_guide_memory_pools_firmware_memory_usage"></a>
Firmware memory usage of memory pools</h3>
<p>Memory pools use firmware memory for three purposes:</p>
<ul>
<li>Bookkeeping - firmware bookkeeping data structures</li>
<li>Page tables - storage for GPU page tables</li>
<li>Compression - GPU compression metadata (compressible memory pools only)</li>
</ul>
<p><a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a> will allocate more Page table memory only if the memory pool cannot fit into the previously allocated page tables. Freeing page tables is deferred to <a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930" title="Finalize a Device object.">nvn::Device::Finalize</a>, which may appear as if <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a> was leaking firmware memory. Bookkeeping and Compression resources are freed on <a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a>.</p>
<p>The maximum amount of firmware memory used by <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a> depends on the size and flags of the memory pool, and is the sum of Bookkeeping memory, Page table memory and Compression memory as follows (<em>numPages</em> is the size of the memory pool divided by the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae49ce57d078023cc8ca0890cd3ee8957" title="Size of memory pages used in physical and virtual memory pools.">nvn::DeviceInfo::MEMORY_POOL_PAGE_SIZE</a> and rounded up to the next integer):</p>
<ul>
<li>Physical memory pools, compression disabled<ul>
<li>Bookkeeping: 1040 bytes allocated at <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>, and up to 576 bytes allocated lazily when the physical pool is used in a <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> request for the first time</li>
<li>Page tables: 0 bytes</li>
<li>Compression: 0 bytes</li>
</ul>
</li>
<li>Physical memory pools, compression enabled<ul>
<li>Bookkeeping: 1040 bytes allocated at <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>, and up to 576 bytes allocated lazily when the physical pool is used in a <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> request for the first time</li>
<li>Page tables: 0 bytes</li>
<li>Compression: (round_up(<em>numPages</em> / 56) * 4096) bytes allocated lazily on the first call to <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> that specifies a compressible storage class</li>
</ul>
</li>
<li>Virtual memory pools<ul>
<li>Bookkeeping: (240 + 8 * <em>numPages</em>) bytes</li>
<li>Page tables: (<em>numPages</em> / 1024 * 9500) bytes</li>
<li>Compression: 0 bytes (compression metadata is always associated with physical storage)</li>
</ul>
</li>
<li>Normal memory pools, compression disabled<ul>
<li>Bookkeeping: 1980 bytes</li>
<li>Page tables: (2 * <em>numPages</em> / 1024 * 9500) bytes</li>
<li>Compression: 0 bytes</li>
</ul>
</li>
<li>Normal memory pools, compression enabled<ul>
<li>Bookkeeping: 2730 bytes</li>
<li>Page tables: (3 * <em>numPages</em> / 1024 * 9500) bytes</li>
<li>Compression: (round_up(<em>numPages</em> / 56) * 4096) bytes</li>
</ul>
</li>
</ul>
<p><a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> uses firmware memory as follows:</p>
<ul>
<li>(8 * <em>numRequests</em>) bytes of working memory, where <em>numRequests</em> is the parameter passed to <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>. This working memory will be freed before <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> returns.</li>
<li>Every time the <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> call results in a new physical pool being mapped into the virtual pool, an additional 96 bytes will be allocated from firmware memory. This memory will be freed when the last page from the respective physical pool is unmapped from the virtual pool.</li>
<li>Additionally, <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a> may trigger lazy allocation of Bookkeeping and Compression resources (see above) associated with the physical pools specified in the <em>requests</em> array.</li>
</ul>
<p><a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a> will always free the resources allocated by <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a>. However, it may also allocate up to 720 bytes in some cases, if finalizing the pool introduces virtual address space fragmentation (firmware needs to allocate bookkeeping structures for new free blocks of virtual address space). This is one reason why it is recommended to always keep a small amount of firmware memory available as a safety margin.</p>
<h3><a class="anchor" id="nvn_guide_virtual_address_space_use_of_memory_pool"></a>
Virtual address space use of memory pools</h3>
<p>Memory pools use two distinct virtual address spaces:</p>
<ul>
<li>GPU virtual addresses space<ul>
<li>The total size of the GPU virtual address space is 112GB</li>
<li>Allocation granularity is 64KB</li>
</ul>
</li>
<li>SMMU (System MMU) virtual address space<ul>
<li>The total size of the SMMU address space is 4GB</li>
<li>Allocation granularity is 128KB</li>
</ul>
</li>
</ul>
<p><a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a> allocates contiguous virtual addresses from these address spaces as follows:</p>
<ul>
<li>Physical memory pools allocate from SMMU virtual address space</li>
<li>Virtual memory pools allocate from GPU virtual address space</li>
<li>Normal memory pools allocate from both address spaces</li>
</ul>
<p>Since each memory pool requires a contiguous address range, both address spaces are subject to fragmentation.</p>
<p>For physical and normal pools, the virtual address allocation granularity for the SMMU addresses (128KB) is larger than the smallest memory pool size (64KB for physical pools, 4KB for normal pools). This means that SMMU addresses are wasted for physical and normal memory pools that are smaller than 128KB in size.</p>
<p>If the SMMU address space is exhausted, <a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a> returns <code>NVN_FALSE</code> and an error message is reported through the debug layer ("Unable to map memory to GPU.
This may be caused by too many small memory pools that exhaust the SMMU address space.").</p>
<p>Please refer to the "Maxwell Technical Overview" for the information about the GMMU and the SMMU.</p>
<h3><a class="anchor" id="autotoc_md107"></a>
Performance Notes</h3>
<p>On the NX platform, application developers should avoid frequent use of NVN APIs that request support from the graphics firmware. The performance of these APIs also depends on the overall system load, which is usually higher around vsync. Therefore, reordering these API calls to happen in the middle of the frame may result in increased and more deterministic performance.</p>
<p>The following functions always require firmware support:</p>
<ul>
<li><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930" title="Finalize a Device object.">nvn::Device::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_device.html#afc7eb10400a4c93d173dc280d1e3536f" title="Get timestamp from the device, without queuing like the ReportCounter functions.">nvn::Device::GetCurrentTimestampInNanoseconds</a></li>
<li><a class="el" href="classnvn_1_1_device.html#a738e79b4293d108d8dc311840bfb3cd8" title="Register a fast clear color value.">nvn::Device::RegisterFastClearColor</a></li>
<li><a class="el" href="classnvn_1_1_device.html#a13ad1a88a3be2802f1ff0b91fe681d40" title="Register a signed integer fast clear color value.">nvn::Device::RegisterFastClearColori</a></li>
<li><a class="el" href="classnvn_1_1_device.html#a156ddbeb91f3c434ec521ecee88b7221" title="Register an unsigned integer fast clear color value.">nvn::Device::RegisterFastClearColorui</a></li>
<li><a class="el" href="classnvn_1_1_device.html#aa3c6011bf315852aebffc88f052fee23" title="Register a fast clear depth value.">nvn::Device::RegisterFastClearDepth</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a" title="Finalize a Queue object.">nvn::Queue::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f" title="Wait until all commands previously submitted to a queue have completed execution.">nvn::Queue::Finish</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a></li>
<li><a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a></li>
<li><a class="el" href="classnvn_1_1_window.html#adaa3ca47e35810048c19b5ed351cda9c" title="Initialize a new window object from a window builder.">nvn::Window::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_window.html#a5e385e13f79c8e0f5f05f71e9c0fbe87" title="Finalize a Window object.">nvn::Window::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_memory_pool.html#abbea9cc22e1d74a120cf0cd2c4d94548" title="Initialize a MemoryPool object using a MemoryPoolBuilder object.">nvn::MemoryPool::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_memory_pool.html#a0340c12587c95b6fe6a2e474ba0ba6d2" title="Finalize a MemoryPool object.">nvn::MemoryPool::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a></li>
</ul>
<p>The following functions may require firmware support under certain conditions, as explained below:</p>
<ul>
<li><a class="el" href="classnvn_1_1_texture.html#ac369f6845c5776de5dbedc84b9191e4c" title="Initialize a texture object from a texture builder using storage provided by a memory pool.">nvn::Texture::Initialize</a><ul>
<li>Requires firmware support if and only if the texture specifies <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU.">nvn::TextureFlags::COMPRESSIBLE</a> and the texture's memory pool does not specify <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d" title="Indicates that the memory pool may be used for sparse operations.">nvn::MemoryPoolFlags::VIRTUAL</a>.</li>
<li>In other words, initializing non-compressible textures never requires firmware support, and initalizing any textures in virtual memory pools never requires firmware suppport. Mapping memory pages in a virtual memory pool (via <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool.">nvn::MemoryPool::MapVirtual</a>) for use by a texture does require firmware support.</li>
</ul>
</li>
<li><a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object.">nvn::Queue::FenceSync</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">nvn::Queue::WaitSync</a><ul>
<li>These <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU.">nvn::Queue</a> methods may issue an implicit <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a> call (which requires firmware support) if the amount of unflushed work submitted to the queue exceeds internal allocations.</li>
</ul>
</li>
<li><a class="el" href="classnvn_1_1_sync.html#ad1eb41d009bcd4e48bebe3573bb32397" title="Wait for a Sync object to be signaled on the CPU before returning.">nvn::Sync::Wait</a><ul>
<li>Requires firmware support if the call blocks (timeout is nonzero and the sync object is in unsignaled state), or if the sync object being waited for was returned from <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window.">nvn::Window::AcquireTexture</a>.</li>
</ul>
</li>
</ul>
<p>The following functions require a transition to kernel mode on 32-bit applications (AArch32) but not on 64-bit applications (AArch64):</p>
<ul>
<li><a class="el" href="classnvn_1_1_memory_pool.html#a8ea2213954d833736877717c32b0aee3" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU.">nvn::MemoryPool::FlushMappedRange</a></li>
<li><a class="el" href="classnvn_1_1_memory_pool.html#a9442d2757ba002635d2d40cfa2d86ea5" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.">nvn::MemoryPool::InvalidateMappedRange</a></li>
<li><a class="el" href="classnvn_1_1_buffer.html#a33d9a879a34a17e9328d4c593d817fdd" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU.">nvn::Buffer::FlushMappedRange</a></li>
<li><a class="el" href="classnvn_1_1_buffer.html#ae1c2622cb7e529955750fba45b21a01b" title="Invalidate CPU caches for a range of a buffer that may have been written by the GPU.">nvn::Buffer::InvalidateMappedRange</a></li>
</ul>
<p>The following functions acquire an internal lock to access shared data structures, and calling them from multiple threads simultaneously may result in reduced performance:</p>
<ul>
<li><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446" title="Initialize a Device object from a device builder.">nvn::Device::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930" title="Finalize a Device object.">nvn::Device::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77" title="Install or remove a callback function to be called whenever the debug layer generates a message.">nvn::Device::InstallDebugCallback</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be" title="Initialize a Queue object from a queue builder.">nvn::Queue::Initialize</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a" title="Finalize a Queue object.">nvn::Queue::Finalize</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca" title="Submit commands encapsulated in command buffers to a queue for processing.">nvn::Queue::SubmitCommands</a><ul>
<li>Only when submitting a command buffer containing a hardware downsample.</li>
</ul>
</li>
<li><a class="el" href="classnvn_1_1_program.html#a365787d302b9b33508787046ab18d083" title="Finalize a Program object.">nvn::Program::Finalize</a></li>
</ul>
<p>The following functions acquire an internal lock to access shared data structures on Windows only, and calling them from multiple threads simultaneously may result in reduced performance on that platform.</p>
<ul>
<li><a class="el" href="classnvn_1_1_buffer.html#a33d9a879a34a17e9328d4c593d817fdd" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU.">nvn::Buffer::FlushMappedRange</a></li>
<li><a class="el" href="classnvn_1_1_buffer.html#ae1c2622cb7e529955750fba45b21a01b" title="Invalidate CPU caches for a range of a buffer that may have been written by the GPU.">nvn::Buffer::InvalidateMappedRange</a></li>
<li><a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing.">nvn::Queue::Flush</a></li>
<li><a class="el" href="classnvn_1_1_sampler_pool.html#af39ae66ac172ee0c4804ff4b95fc94e7" title="Register a sampler descriptor in a sampler pool for use via texture handles, using a Sampler object.">nvn::SamplerPool::RegisterSampler</a></li>
<li><a class="el" href="classnvn_1_1_sampler_pool.html#a8ddc47f155142938c3553c6aafcddf37" title="Register a sampler descriptor in a sampler pool for use via texture handles, using SamplerBuilder sta...">nvn::SamplerPool::RegisterSamplerBuilder</a></li>
<li><a class="el" href="classnvn_1_1_texture_pool.html#a0dfac012b673d8e809fe86ca9c941b5a" title="Register an image descriptor in a texture pool for use via image loads and stores.">nvn::TexturePool::RegisterImage</a></li>
<li><a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">nvn::TexturePool::RegisterTexture</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md108"></a>
Forcibly Closing Applications and the number of Active Graphics Resources</h3>
<p>On NX, when the application is in Background focus state and HOME Menu is in use, user can terminate the application from the menu.</p>
<p>When this occurs, the device driver will need to release the Graphics Resources assigned to the application. The Graphics Resources targeted to release includes Memory Pools, Textures, and some other resources which needs to be managed by the GPU.</p>
<p>The release operation will require longer time if more number of Graphics resources needs to be released. And this release time will be counted as part of the applications exit request handling.</p>
<p>If the time necessary for the release exceeds the timeout period, you may face the forced timeout from the OS and message may show to the users informing that the software was closed due to an error. This termination is called Forcibly Closing Applications, and if this happen, it will worsens the user experience.</p>
<p>Benchmarking the time necessary for this Forcibly Closing Application and amount of the Graphics Resources is strongly recommended to find the proper balance point for your application.</p>
<p>For more detail of Forcibly Closing Applications, please see NintendoSDK document.</p>
<h3><a class="anchor" id="autotoc_md109"></a>
Device Information Constants</h3>
<p>The values given by <code>nvnDeviceGetInteger</code> on the NX target platform are defined in the header file <code>"nvn/nvn_DeviceConstantsNX.h"</code>. These values should match the corresponding <code>nvnDeviceGetInteger</code> when run on NX. These values may differ from from the Windows reference implementation. <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da984b90d896c67d5f51418b7963cc45db" title="1 if the NVN debug layer is supported by this version of the driver, 0 otherwise.">nvn::DeviceInfo::SUPPORTS_DEBUG_LAYER</a> has been left out, as that depends on the type of library linked and not the underlying hardware platform.</p>
<h2><a class="anchor" id="nvn_guide_Windows_Reference_Implementation"></a>
24.6. Windows Reference Implementation Details</h2>
<p>On Windows, a reference implementation of NVN is provided through a custom build of the NVIDIA OpenGL driver that runs on systems that meet the following requirements:</p>
<ul>
<li>Operating System: Windows 10 (32- and 64-bit).</li>
<li>GPU: Any NVIDIA GPU from the Maxwell GPU families supported by the custom driver build. A second-generation Maxwell GPU (e.g., GeForce GTX 960, 970, 980) is recommended, because it provides nearly all the NVN API functionality supported by the NX processor.</li>
</ul>
<p>Note that NVN is supported only on custom driver builds; it is not supported on <a href="http://www.geforce.com/drivers">official drivers provided on the NVIDIA website</a>. The baseline driver support for these custom builds is not updated as frequently as the official NVIDIA drivers, so the NVN reference implementation may not support brand-new GeForce products when they first ship. A list of specific recommended and supported GPUs can be found below.</p>
<p>Even if the product name is listed as supported, there may be an unsupported new SKU in the market. This is because the SKUs supported by the NVN Windows driver may be behind support in the latest NVN driver by several months, and the product with same name but a different SKU identifier might be released during those periods. If the supported board has such an annotation below, do not purchase the board until the board is supported.</p>
<p>On Multi GPU systems, NVN picks the first device of the GPUs to initialize NVN driver. On Optimus systems that have a discrete NVIDIA GPU and an integrated non-NVIDIA GPU, the user needs to ensure that the NVIDIA GPU is selected in the 3D Settings sections of the NVIDIA control panel. Otherwise, NVN applications may end up running on the integrated GPU and nvnBootstrapLoader will return NULL. To ensure that the OpenGL is initialized on the NVIDIA GPU on Optimus systems, developers should insert the following code into the main application executable: </p><pre class="fragment">extern "C" {
    declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001;
}
</pre><p> On Optimus systems, the NVIDIA OpenGL implementation will check the executable for this exported variable and ensure that it uses the NVIDIA GPU if found. This variable has no effect on non-Optimus systems.</p>
<p>Some features of the NVN API may not be supported on the Windows reference implementation, depending on the hardware feature set of the GPU being used. For the Windows implementation, there are four hardware feature levels described in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature Level   </th><th class="markdownTableHeadNone">OpenGL Extension   </th><th class="markdownTableHeadNone">Example GPU    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Maxwell (1st generation)   </td><td class="markdownTableBodyNone"><code>NV_blend_equation_advanced_coherent</code>   </td><td class="markdownTableBodyNone">GeForce GTX 750    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Maxwell (2nd generation)   </td><td class="markdownTableBodyNone"><code>NV_conservative_raster</code>   </td><td class="markdownTableBodyNone">GeForce GTX 980   </td></tr>
</table>
<p>The "OpenGL Extension" column indicates an OpenGL extension that can be checked for to determine if the corresponding feature level is supported. The "Example
GPU" column provides one example of the GPUs providing the corresponding feature level.</p>
<p>The following table indicates the feature levels required for various features of the NVN API:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone">Requires    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">STENCIL8 texture format   </td><td class="markdownTableBodyNone">Maxwell (2nd generation)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Native support for GLSL "lowp"/"mediump"   </td><td class="markdownTableBodyNone">Not supported (uses 32-bit math)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Compressed textures using ASTC formats   </td><td class="markdownTableBodyNone">Not natively supported (see NOTE 2)   </td></tr>
</table>
<blockquote class="doxtable">
<p><b>NOTE</b>: For more detail, please refer to the <a href="#nvn_guide_formats_restrictions_on_Windows">Formats Restrictions on the NVN Windows Reference Implementation</a> section. </p>
</blockquote>
<p>The Windows reference implementation can optionally present textures directly to native windows (of type HWND). When using this functionality, applications must pass a valid window object of type HWND to <a class="el" href="classnvn_1_1_window_builder.html#aa6025deb01d766298246f772a5b7957e" title="Set the native window where the textures of this window will be presented to.">nvn::WindowBuilder::SetNativeWindow</a>. The window class that was registered using the Windows <code>RegisterClass</code> function, needs to have the CS_OWNDC flag set. Before using a native window in NVN, an application must set a pixel format using the Windows <code>SetPixelFormat</code> API. The pixel format must be an RGBA format that supports NVIDIA hardware acceleration and has the <code>PFD_DRAW_TO_WINDOW</code>, <code>PFD_SUPPORT_OPENGL</code>, and <code>PFD_DOUBLEBUFFER</code> properties set. If no native window is set, applications must bind a "donor" OpenGL context and drawable using <code>wglMakeCurrent</code> before calling <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window.">nvn::Queue::PresentTexture</a>, as described <a href="#nvn_guide_presentation">elsewhere in the guide</a>.</p>
<h3><a class="anchor" id="autotoc_md110"></a>
GPUs supported by the Windows Reference Implementation</h3>
<p>The following sub-sections identify GPUs known to be supported by the Windows reference implementation.</p>
<p>For each GPU architecture we have two tables, one for Desktop GPUs and one for Notebook GPUs.</p>
<p>Each table consists of two columns, "Name" and "DeviceID(s)". "Name" is the marketing name. "DeviceID(s) is one or more ID which identifies the devices.
In case of "Desktop" they consist of 4 hex values, while in case of "Notebooks" they consist of 3 sets of 4 hex values separated by dots.</p>
<p>Please confirm to the manufacturer for the "Name" and the "DeviceID" and make sure that the devices are supported by the NVN Windows Reference Implementation.</p>
<h4><a class="anchor" id="autotoc_md111"></a>
Second-Generation Maxwell GPUs</h4>
<p>Second-generation Maxwell GPUs have nearly the same feature set as the GPU core inside the NX device. The only NX features not supported by these GPUs are ASTC texture compression and native support for 16-bit floating-point shader math. This class of GPUs is strongly recommended for NVN development on Windows. Additionally, devices with 4GB of video memory are recommended to match the amount of available memory on the NX platform.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 750   </td><td class="markdownTableBodyLeft">1407    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 950   </td><td class="markdownTableBodyLeft">1402    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 960   </td><td class="markdownTableBodyLeft">1406    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 965M   </td><td class="markdownTableBodyLeft">1427    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 970   </td><td class="markdownTableBodyLeft">13C2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 980 Ti   </td><td class="markdownTableBodyLeft">17C8    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX TITAN X   </td><td class="markdownTableBodyLeft">17C2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M2000   </td><td class="markdownTableBodyLeft">1430    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M4000   </td><td class="markdownTableBodyLeft">13F1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M5000   </td><td class="markdownTableBodyLeft">13F0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M6000   </td><td class="markdownTableBodyLeft">17F0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M6000 24GB   </td><td class="markdownTableBodyLeft">17F1   </td></tr>
</table>
<p>Notebook: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 960   </td><td class="markdownTableBodyLeft">1401.8678.1043 1401.119C.1462 1401.1376.174B 1401.2B4D.103C 1401.1032.1019 1401.068B.1028 1401.119B.1462 1401.3200.1462 1401.3203.1462 1401 1401.079A.1028 1401.1138.10DE 1401.2B57.103C 1401.0790.1028    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 965M   </td><td class="markdownTableBodyLeft">13D9.1097.152D 1619.7503.1558 13D9.0688.1028 13D9.B456.1458 13D9.1171.1462 13D9.107D.1025 13D9.6557.1558 1667.1503.1558 1619.171D.1043 13D9.0685.1028 13D9.1125.1462 13D9.105B.1025 13D9.1464.1458 13D9.7700.1558 1619.7701.1558 13D9.116D.1462 13D9.06A3.1028 13D9.3756.1458 13D9.6781.1558 13D9.7702.1558 13D9.1147.1462 1619.2557.1458 13D9.117C.1462 1619.1188.1462 13D9.2555.1458 13D9.5281.1558 13D9.1158.1462 13D9.6540.1558 13D9.7481.1558 13D9.B556.1458 1667.1504.1558 1667.7703.1558 13D9.A456.1458 13D9.1555.1458 13D9.171D.1043 13D9.1164.1462 1619.1557.1458 13D9.A757.1458 13D9.7500.1558 1619.7501.1558 1619.7703.1558 13D9.1134.1462 13D9.113F.1462 1619.1CED.1043 13D9.1103.1462 1667.1703.1558 13D9.6541.1558 13D9.1144.1462 13D9.107E.1025 13D9.1051.1025 1667.7503.1558 1667.1704.1558 13D9.6780.1558 13D9.0020.1414 13D9.7502.1558 13D9.0709.1028 13D9.0708.1028 13D9.1102.1462 13D9.116E.1462 13D9.118B.1462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 970M   </td><td class="markdownTableBodyLeft">13D8.6541.1558 13D8.1133.1462 13D8.674E.1A58 1618.1187.1462 13D8.107E.1025 13D8.1051.1025 13D8.6780.1558 13D8.117B.1462 13D8.0709.1028 13D8.0708.1028 1618.2757.1458 13D8.7502.1558 13D8.1102.1462 1618.0871.1558 13D8.1130.1462 13D8.0870.1558 13D8.22DA.1043 13D8.116E.1462 13D8.B286.19DA 1618.6543.1558 1618.1310.1043 13D8.1555.1458 13D8.A456.1458 13D8.1164.1462 13D8.B282.19DA 1618.1141.1462 13D8.1456.1458 13D8.118A.1462 13D8.4756.1458 1618.1156.1462 1618.7501.1558 13D8.A757.1458 13D8.7500.1558 13D8.C556.1458 1618.1759.1458 13D8.8261.103C 1618.7703.1558 13D8.B284.19DA 13D8.1134.1462 13D8.6555.1558 13D8.AF1D.1462 13D8.674B.1A58 13D8.112D.1462 1618.6542.1558 13D8.AF1C.1462 1618.1CED.1043 13D8.1103.1462 13D8.6781.1558 13D8.3756.1458 13D8.1155.1462 13D8.7702.1558 1618.22DA.1043 13D8.1756.1458 13D8.2456.1458 13D8.1129.152D 13D8.2555.1458 13D8.1128.152D 13D8.6540.1558 13D8.5281.1558 13D8.1158.1462 13D8.7481.1558 13D8.2000.3842 13D8.0376.1558 13D8.B556.1458 13D8.8262.103C 1618.6783.1558 13D8.0688.1028 1618.7503.1558 13D8.1097.152D 13D8.B456.1458 13D8.1128.1462 13D8.1171.1462 13D8.107D.1025 13D8.AF19.1462 13D8.6400.1558 13D8.1199.1462 13D8.1198.1462 13D8.0685.1028 13D8.105B.1025 13D8.1125.1462 13D8.1557.1458 13D8.1140.1043 13D8.1156.1462 13D8.1464.1458 13D8.05AB.1028 1618.1757.1458 1618.6782.1558 1618.7701.1558 13D8.116D.1462 13D8.7700.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 980   </td><td class="markdownTableBodyLeft">13C0.119B.1462 13C0.068B.1028 161A.108B.1025 13DA.1171.1462 161A.1BCD.1043 13C0.1116.10DE 161A.116F.1462 13C0 13DA.7702.1558 13C0.079A.1028 13DA.1408.19DA 161A.11F0.1043 13DA.2748.1458 13C0.0790.1028 13C0.2B49.103C 161A.2758.1458 13C0.86E8.1043 13DA.1146.1462 13DA.1BCD.1043 161A.7703.1558 13DA.1165.1462 13C0.1370.174B 161A.1758.1458 13C0.119C.1462 13DA.B387.180C 13DA.11F0.1043 13DA.1166.1462 161A.12B0.1043 13DA.0870.1558 161A.0871.1558    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 980M   </td><td class="markdownTableBodyLeft">13D7.05AB.1028 1617.6782.1558 1617.7701.1558 13D7.7700.1558 13D7.0685.1028 1617.1140.1462 13D7.105B.1025 13D7.2556.1458 1617.108B.1025 13D7.1171.1462 13D7.107D.1025 13D7.AF19.1462 13D7.112F.1462 13D7.0688.1028 1617.7503.1558 13D7.19FD.1043 1617.1186.1462 13D7.1129.1462 13D7.0376.1558 13D7.8262.103C 13D7.B556.1458 1617.6783.1558 1617.2759.1458 13D7.6540.1558 13D7.5281.1558 13D7.7481.1558 13D7.2000.3842 1617.22DA.1043 13D7.1131.1462 1617.1157.1462 13D7.157D.1043 13D7.6781.1558 13D7.3756.1458 1617.108E.1043 13D7.7702.1558 1617.6542.1558 13D7.AF1C.1462 1617.2002.3842 1617.1CED.1043 13D7.C556.1458 1617.7703.1558 13D7.8261.103C 13D7.AF1D.1462 13D7.4756.1458 1617.3803.17AA 1617.7501.1558 13D7.7500.1558 13D7.1132.1462 13D7.1456.1458 13D7.117A.1462 13D7.1157.1462 1617.0871.1558 13D7.22DA.1043 13D7.0870.1558 13D7.1189.1462 1617.6543.1558 13D7.6780.1558 13D7.0020.1414 13D7.0709.1028 13D7.0708.1028 13D7.7502.1558 13D7.107E.1025 13D7.6556.1558 13D7.1051.1025 13D7.6541.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M2200   </td><td class="markdownTableBodyLeft">1436.80D5.103C 1436.810A.103C 1436.2251.17AA 1436.8109.103C 1436.17B0.1028 1436.116B.1462 1436.80D6.103C 1436.8277.103C 1436.196B.10CF 1436.1968.10CF 1436.07B0.1028 1436.224C.17AA 1436.115B.1462 1436.8270.103C 1436.224D.17AA 1436.8275.103C 1436.8272.103C 1436.115A.1462 1436.2250.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M3000M   </td><td class="markdownTableBodyLeft">13FA.222D.17AA 13FA.80D6.103C 13FA.7500.1558 13FA.8109.103C 13FA.7502.1558 13FA.06DA.1028 13FA.1175.1462 13FA.7700.1558 13FA.1195.1462 13FA.16DA.1028 13FA.222F.17AA 13FA.7702.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M4000M   </td><td class="markdownTableBodyLeft">13F9.222D.17AA 13F9.80D6.103C 13F9.8109.103C 13F9.1178.1462 13F9.06DA.1028 13F9.222F.17AA 13F9.16DA.1028 13F9.1196.1462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M5000M   </td><td class="markdownTableBodyLeft">13F8.7702.1558 13F8.7700.1558 13F8.222F.17AA 13F8.16DA.1028 13F8.11F5.1462 13F8.1179.1462 13F8.06DA.1028 13F8.7502.1558 13F8.222D.17AA 13F8.80D6.103C 13F8.7500.1558 13F8.8109.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M5500   </td><td class="markdownTableBodyLeft">13FB.11B0.1462   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md112"></a>
Pascal GPUs</h4>
<p>Pascal GPUs provide the same basic graphics functionality present in the second-generation Maxwell GPUs, as well as a number of new features. The NVN Windows reference implementation is supported on Pascal-based GPUs but it does not support any Pascal graphics features that are not present in second-generation Maxwell GPUs. Devices with 4GB of video memory or more are recommended, but GPUs with less memory are supported.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">EIZO Quadro MED-XN31LP   </td><td class="markdownTableBodyLeft">1CB3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GT 1010   </td><td class="markdownTableBodyLeft">1D02    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GT 1030   </td><td class="markdownTableBodyLeft">1D01    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1050   </td><td class="markdownTableBodyLeft">1C83    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1050 Ti   </td><td class="markdownTableBodyLeft">1C82    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1060 3GB   </td><td class="markdownTableBodyLeft">1C02 1B84    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1060 5GB   </td><td class="markdownTableBodyLeft">1C04    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1060 6GB   </td><td class="markdownTableBodyLeft">1C03 1B83 1C06    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1070   </td><td class="markdownTableBodyLeft">1B81    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1070 Ti   </td><td class="markdownTableBodyLeft">1B82    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1080   </td><td class="markdownTableBodyLeft">1B80    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1080 Ti   </td><td class="markdownTableBodyLeft">1B06    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA P104-100   </td><td class="markdownTableBodyLeft">1B87    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA P104-101   </td><td class="markdownTableBodyLeft">1BC7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA P106-090   </td><td class="markdownTableBodyLeft">1C09    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA P106-100   </td><td class="markdownTableBodyLeft">1C07    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro GP100   </td><td class="markdownTableBodyLeft">15F0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P1000   </td><td class="markdownTableBodyLeft">1CFB 1CB1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P2000   </td><td class="markdownTableBodyLeft">1CFA 1C30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P2200   </td><td class="markdownTableBodyLeft">1C31    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P400   </td><td class="markdownTableBodyLeft">1CB3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P4000   </td><td class="markdownTableBodyLeft">1BB1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P4200   </td><td class="markdownTableBodyLeft">1BB9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P5000   </td><td class="markdownTableBodyLeft">1BB0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P5200   </td><td class="markdownTableBodyLeft">1BB5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P600   </td><td class="markdownTableBodyLeft">1CB2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P6000   </td><td class="markdownTableBodyLeft">1B30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P620   </td><td class="markdownTableBodyLeft">1CB6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA TITAN Xp   </td><td class="markdownTableBodyLeft">1B02    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA TITAN Xp COLLECTORS EDITION   </td><td class="markdownTableBodyLeft">1B02   </td></tr>
</table>
<p>Notebook: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1050   </td><td class="markdownTableBodyLeft">1C8D.1042.1D05 1C8D.1261.1025 1C8D.086F.1028 1C8D.0851.1028 1C8D.850A.1558 1C8D.1BC0.1043 1C8D.0311.1854 1C8D.1BA0.1043 1C8D.118B.1025 1C81.8454.19DA 1C8D.8478.103C 1C8D.85FD.103C 1C91.651A.1558 1C8D.121A.1462 1C8D.1A10.1043 1C8D.1B30.1043 1C91.0353.1854 1C8D.872B.1558 1C8D.07FA.1028 1C91.87B0.103C 1C91.1068.1D05 1C91.856A.103C 1C91.8640.103C 1C8D.077C.1028 1C91.0924.1028 1C8D.07E0.1028 1C8D.1221.1462 1C8D.3802.17AA 1C8D.0870.1028 1C8D.084A.1028 1C91.1336.1025 1C8D.B344.19DA 1C81.3511.1462 1C8D.39FB.17AA 1C8D.1044.1D05 1C8D.39F9.17AA 1C8D.650A.1558 1C8D.084E.1028 1C8D.1590.1043 1C8D.120B.1462 1C8D.8218.103C 1C91.84F7.103C 1C8D.1207.1025 1C8D.0307.1854 1C8D.8219.103C 1C91.0922.1028 1C8D.1216.1462 1C91.22A7.17AA 1C8D.1460.19DA 1C8D.15E0.1043 1C81.6454.19DA 1C8D.11E1.1043 1C8D.07BE.1028 1C8D.8466.103C 1C8D.0288.1854 1C81.8616.1043 1C8D.8392.103C 1C8D.D456.1458 1C8D.0798.1028 1C8D.1193.152D 1C8D.84ED.103C 1C8D.1970.1043 1C8D.084B.1028 1C8D.120E.1462 1C8D.860A.103C 1C8D.38EC.17AA 1C8D.1159.152D 1C8D.1C00.1043 1C81.8338.103C 1C8D.39FE.17AA 1C91.1332.1025 1C92.123C.1462 1C8D.1187.152D 1C8D.14FE.1043 1C81.1676.1642 1C91.1232.152D 1C8D.821A.103C 1C8D.84F7.103C 1C8D.121C.1025 1C8D.70A1.1558 1C8D.10C1.1043 1C91.85FD.103C 1C8D.11F2.1462 1C8D.1219.1462 1C8D.651A.1558 1C8D.1707.1D72 1C81.8C97.1462 1C8D.8419.103C 1C8D.5067.17AA 1C8D.14EE.1043 1C8D.825D.103C 1C8D.8469.103C 1C92.126D.1462 1C81.9454.19DA 1C8D.55A1.1558 1C91.1234.152D 1C8D.1241.1043 1C8D.2381.1B0A 1C8D.1196.152D 1C91.0923.1028 1C81.1042.1019 1C8D.07FB.1028 1C91.1334.1025 1C8D.1197.1025 1C8D.8640.103C 1C81.5454.174B 1C8D.39D1.17AA 1C8D.120D.1462 1C8D.102E.1D05 1C8D.1162.152D 1C8D.C803.144D 1C8D.0824.1028 1C8D.838F.103C 1C81.0790.1028 1C8D.168E.1043 1C8D.8477.103C 1C91.87AA.103C 1C8D.120C.1462 1C8D.870A.1558 1C8D.11CA.1462 1C8D.39CB.17AA 1C91.84F8.103C 1C8D.8217.103C 1C8D.0850.1028 1C8D.1217.152D 1C8D.39AB.17AA 1C8D.1260.1025 1C91.86C7.103C 1C8D.2382.1B0A 1C81.079A.1028 1C8D.C790.144D 1C8D.1920.1043 1C8D.825E.103C 1C8D.F460.19DA 1C91.106D.1D05 1C92.1245.1462 1C81.1466.19DA 1C8D.852B.1558 1C8D.1BB0.1043 1C91.139E.1025 1C91.85FA.103C 1C8D.1B90.1043 1C8D.07E1.1028 1C91.1387.1025 1C8D.1FC0.1043 1C8D.180E.1043 1C8D.825A.103C 1C8D.77FF.17AA 1C8D.1331.1043 1C91.0949.1028 1C8D.2303.1B0A 1C8D.8422.103C 1C8D.6450.1558 1C8D.84F8.103C 1C8D.11C8.1462 1C81.7454.19DA 1C8D.0826.1028 1C8D.11C9.1462 1C8D.3801.17AA 1C8D.1F40.1043 1C81 1C8D.1222.1462 1C91.8740.103C 1C8D.8259.103C 1C8D.1265.1025 1C81.2454.19DA 1C91.3391.1458 1C8D.087C.1028 1C8D.85FA.103C 1C81.1B02.109F 1C81.11C0.1028 1C8D.1163.152D 1C92.12FF.1043 1C8D.0024.1414 1C8D.1234.1025 1C91.86E3.103C 1C8D.1160.152D 1C91.1337.1025 1C81.2455.174B 1C8D.2460.19DA 1C91.86D4.103C 1C81.068B.1028 1C8D.123C.1462 1C8D.1199.1025 1C8D.1750.1043 1C8D.084D.1028 1C8D.103C.1D05 1C8D.1217.1462 1C81.203B.1043 1C91.0379.1854 1C8D.1021.1043 1C81.099B.144D 1C8D.84EB.103C 1C8D.1128.1025 1C8D.84E9.103C 1C8D.84DA.103C 1C8D.2318.1B0A 1C8D.836B.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1050 Ti   </td><td class="markdownTableBodyLeft">1C8C.118B.1025 1C8C.8478.103C 1C8C.3005.1297 1C8C.121A.1462 1C8C.1261.1025 1C8C.1042.1D05 1C8C.086F.1028 1C8C.850A.1558 1C8C.1221.1462 1C8C.1071.1043 1C8C.07FA.1028 1C8C.872B.1558 1C8F.1284.1462 1C8C.39F8.17AA 1C8C.1041.1043 1C8C.11F3.1462 1C8C.1044.1D05 1C8C.39FB.17AA 1C8C.0870.1028 1C8C.39D0.17AA 1C8C.1194.152D 1C8C.1153.152D 1C8C.15E0.1043 1C8C.8466.103C 1C8C.39FF.17AA 1C8C.120B.1462 1C8C.1590.1043 1C8C.1207.1025 1C8C.D007.1458 1C8C.1216.1462 1C8C.120E.1462 1C8C.142A.1025 1C8C.18FE.1043 1C8C.8392.103C 1C8C.D456.1458 1C8C.0798.1028 1C8C.84ED.103C 1C8C.1970.1043 1C21.1244.1462 1C8C.8469.103C 1C8C.825D.103C 1C8C.3465.1458 1C8C.11F2.1462 1C8C.1219.1462 1C8C.1267.1025 1C8C.651A.1558 1C8C.182E.1043 1C8C.07FB.1028 1C8C.2267.17AA 1C8C.1197.1025 1C8C.3006.1297 1C8C.55A1.1558 1C8C.1155.152D 1C8C.120D.1462 1C8C.102E.1D05 1C8C.39FC.17AA 1C8C.1154.1025 1C8C.1263.1025 1C8C.120C.1462 1C8C.0824.1028 1C8C.C803.144D 1C8C.39FD.17AA 1C8C.838F.103C 1C8C.77FE.17AA 1C21.1801.1D72 1C8C.1920.1043 1C8C.5066.17AA 1C8C.825E.103C 1C8C.11CA.1462 1C8C.870A.1558 1C8C.1260.1025 1C8C.1151.152D 1C8C.235D.1B0A 1C8C.1197.152D 1C8C.2266.17AA 1C8C.825A.103C 1C8C.852B.1558 1C21.1705.1D72 1C8C.0826.1028 1C8C.11C8.1462 1C8C.84F8.103C 1C8C.11C9.1462 1C8C.1222.1462 1C8C.1188.152D 1C8C.6450.1558 1C8C.8422.103C 1C8C.087C.1028 1C8C.3467.1458 1C8C.22BE.1B0A 1C8F.123C.1462 1C8C.8259.103C 1C8C.1265.1025 1C21.1155.1025 1C8C.123C.1462 1C8C.1199.1025 1C8C.1149.152D 1C8C.181E.1043 1C8F.126D.1462 1C8C.1128.1025 1C8C.84DA.103C 1C8C.836B.103C 1C8C.845E.103C 1C8F.126C.1462 1C8C.103C.1D05 1C8C.1217.1462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1060   </td><td class="markdownTableBodyLeft">1C20.1148.152D 1C20.1199.1025 1C20.9501.1558 1C23.0020.1414 1C60.7706.1558 1C20.B758.1458 1C20.1224.1462 1C60.1170.1025 1C20.0887.1028 1C20.7506.1558 1C20.8467.103C 1C20.6B02.1558 1C20.1650.1458 1C20.3555.1458 1C60.1550.1043 1C60.65A3.1558 1C20.1189.152D 1C20.183E.1043 1C60.1132.1025 1C20.67B1.1558 1C20.1201.1462 1C20.1136.152D 1C20.674F.1A58 1C20.0024.1414 1C20.2413.19DA 1C20.6A02.1558 1C60.1218.1462 1C20.154E.1043 1C60.155E.1043 1C60.8260.103C 1C60.088B.1028 1C20.0287.1854 1C20.1265.1025 1C20.11F7.1462 1C20.65A1.1558 1C20.11BC.1462 1C20.1025.1D05 1C20.22BE.1B0A 1C60.0323.1854 1C20.1031.1D05 1C20.C790.144D 1C60.11B3.1462 1C60.1179.1025 1C20.3458.1458 1C20.7509.1558 1C60.1178.1025 1C20.1706.1D72 1C20.153E.1043 1C20.67A2.1558 1C20.11DD.1462 1C20.7504.1558 1C20.67C2.1558 1C20.8703.1558 1C20.3007.1297 1C20.0825.1028 1C20.2000.1A58 1C60.846A.103C 1C20.1135.152D 1C60.1760.1043 1C60.7708.1558 1C60.8393.103C 1C60.7710.1558 1C20.2464.1458 1C20.11D7.1462 1C60.8390.103C 1C20.156E.1043 1C60.67B4.1558 1C20.1652.1458 1C20.D005.1458 1C60.7507.1558 1C20.1223.1462 1C20.11C0.1462 1C20.8700.1558 1C20.1263.1025 1C60.0876.1028 1C20.7707.1558 1C20.8581.103C 1C60.11E6.1462 1C20.1B9E.1043 1C20.F413.19DA 1C20.84DB.103C 1C60.65A4.1558 1C60.1580.1043 1C60.22BE.1B0A 1C60.11BC.1462 1C20.6758.1A58 1C20.0888.1028 1C20.1214.1462 1C60.6B04.1558 1C20.235E.1B0A 1C60.11AF.1462 1C20.11AC.1462 1C20.16A1.1BAB 1C20.0802.1028 1C20.11DE.1462 1C20.155E.1043 1C20.1218.1462 1C20.1267.1025 1C20.3006.1297 1C20.1227.1462 1C60.088C.1028 1C20.1391.1043 1C60.8261.103C 1C60.825F.103C 1C20.B757.1458 1C20.1152.152D 1C60.2007.3842 1C20.67C1.1558 1C20.1011.1043 1C20.67A1.1558 1C20.11AD.1462 1C60.6A04.1558 1C20.1043.1D05 1C60.C167.144D 1C60.17D0.1043 1C20.D555.1458 1C20.6755.1A58 1C20.0885.1028 1C20.3464.1458 1C60.8467.103C 1C20.11F9.1462 1C20.11FB.1462 1C20.1215.1462 1C20.951B.1558 1C20.0322.1854 1C60.0877.1028 1C20.1890.1043 1C60.13F0.1043 1C20.1154.152D 1C60.67A3.1558 1C20.114E.1025 1C60.1800.1043 1C60.6A03.1558 1C20.1198.152D 1C20.0803.1028 1C20.6B01.1558 1C60.84DB.103C 1C20.7705.1558 1C20.4555.1458 1C20.19AE.1043 1C20.95E1.1558 1C20.120F.1462 1C20.3457.1458 1C20.0886.1028 1C60.1177.1025 1C20.8500.1558 1C20.11C1.1462 1C20.851B.1558 1C20.114F.1025 1C20.11D5.1462 1C20.1244.1462 1C20.16D0.1043 1C60.7505.1558 1C20.1210.1462 1C20.1207.1025 1C60.67A4.1558 1C20.1209.1462 1C60.67C4.1558 1C20.C166.144D 1C20.B333.19DA 1C20.120C.1025 1C20.6A01.1558 1C20.1057.1D05 1C60.184E.1043 1C60.11CE.1462 1C20.185E.1043 1C20.7709.1558 1C20.3005.1297 1C20.38E1.17AA 1C20.118B.1025 1C20.0827.1028 1C20.1030.1D05 1C60.6B03.1558 1C20.8478.103C 1C20.1045.1D05 1C20.1150.152D 1C20.846A.103C 1C20.8503.1558 1C20.1261.1025 1C20.65A2.1558 1C20.1802.1D72 1C60.1131.1025 1C20.11E3.1462 1C20.2001.1A58 1C20.39B9.17AA 1C20.67B2.1558 1C60.7510.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1070   </td><td class="markdownTableBodyLeft">1BE1.846A.103C 1BE1.3767.1458 1BE1.8393.103C 1BE1.7710.1558 1BA1.1223.1462 1BE1.7708.1558 1BA1.0772.1028 1BA1.7707.1558 1BE1.1178.1025 1BA1.0775.1028 1BA1.1211.1462 1BA1.F413.19DA 1BE1.121E.1462 1BE1.11E6.1462 1BA1.7509.1558 1BE1.0876.1028 1BE1.65A4.1558 1BA1.076E.1028 1BA1.11C3.1462 1BA1.67C2.1558 1BA1.5756.1458 1BA1.7504.1558 1BA1.67A2.1558 1BA1.11DD.1462 1BA1.1226.1462 1BA1.2000.1A58 1BA1.0778.1028 1BE1.7507.1558 1BE1.39FF.17AA 1BA1.11AE.1462 1BE1.67B4.1558 1BA1.0774.1028 1BE1.3557.1458 1BA1.1225.1462 1BA1.1653.1458 1BA1.1251.1043 1BE1.299C.1458 1BA1.1201.1462 1BE1.65A3.1558 1BA1.67B1.1558 1BA1.0879.1558 1BE1.39FE.17AA 1BA1.6A02.1558 1BE1.7706.1558 1BE1.2009.3842 1BA1.0773.1028 1BA1.11BC.1462 1BA1.11F7.1462 1BA1.65A1.1558 1BE1.2008.3842 1BA1.299B.1458 1BA1.11C2.1462 1BA1.0776.1028 1BE1.8260.103C 1BE1.1218.1462 1BA1.0872.1558 1BA1.9501.1558 1BE1.355D.1458 1BA1.1224.1462 1BE1.088B.1028 1BA1.0875.1558 1BA1.B758.1458 1BE1.16F0.1043 1BA1.0887.1028 1BE1.1560.1458 1BA1.7506.1558 1BE1.1132.1025 1BA1.6B02.1558 1BE1.121F.1462 1BA1.D557.1458 1BE1.3759.1458 1BE1.1011.1043 1BE1.11B9.1462 1BA1.1028.1D05 1BA1.6A01.1558 1BE1.3556.1458 1BE1.1177.1025 1BA1.7709.1558 1BE1.67C4.1558 1BE1.67A4.1558 1BA1.1413.19DA 1BA1.65A2.1558 1BE1.7505.1558 1BE1.0876.1558 1BE1.1211.1462 1BE1.376B.1458 1BE1.84DB.103C 1BE1.3769.1458 1BE1.6A03.1558 1BE1.1800.1043 1BE1.1D00.1043 1BA1.67B2.1558 1BE1.1CB0.1043 1BE1.1131.1025 1BA1.0777.1028 1BA1.7705.1558 1BE1.07C0.1028 1BA1.6B01.1558 1BE1.7510.1558 1BE1.087A.1558 1BE1.0873.1558 1BA1.95E1.1558 1BE1.6B03.1558 1BE1.1470.1043 1BE1.17EE.1043 1BA1.D556.1458 1BE1.3762.1458 1BA1.B333.19DA 1BE1.8261.103C 1BE1.825F.103C 1BE1.1243.1025 1BE1.088C.1028 1BA1.0771.1028 1BE1.0878.1558 1BE1.1660.1043 1BA1.11FB.1462 1BA1.11F9.1462 1BA1.20A1.1558 1BA1.299C.1458 1BA1.1215.1462 1BE1.6B04.1558 1BA2.0020.1414 1BA1.120A.1462 1BE1.3559.1458 1BE1.07C2.1028 1BE1.11BC.1462 1BE1.3558.1458 1BA1.0877.1558 1BA1.1651.1458 1BE1.11AF.1462 1BA1.1158.152D 1BE1.11CF.1462 1BA1.1FD0.1043 1BE1.13F0.1043 1BE1.0877.1028 1BA1.1214.1462 1BA1.0888.1028 1BE1.1F80.1043 1BA1.076D.1028 1BE1.67A3.1558 1BA1.1218.1462 1BA1.11DE.1462 1BE1.11B7.1462 1BE1.83A5.103C 1BA1.1227.1462 1BA1.1035.1D05 1BA1.11E4.1462 1BA1.1032.1D05 1BA1.2005.3842 1BA1.1190.152D 1BE1.6A04.1558 1BE1.17D0.1043 1BE1.376A.1458 1BA1.1560.1458 1BA1.B757.1458 1BA1.11E8.1462 1BA1.67A1.1558 1BA1.11E9.1462 1BA1.67C1.1558    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1080   </td><td class="markdownTableBodyLeft">1BA0.7709.1558 1BE0.1BF0.1043 1BE0.1221.1025 1BE0.1211.1462 1BE0.0876.1558 1BA0.1442.19DA 1BA0.B441.180C 1BE0.1840.1043 1BE0.3764.1458 1BE0.1870.1043 1BA0.7705.1558 1BE0.0873.1558 1BE0.087A.1558 1BE0.123E.1025 1BE0.7510.1558 1BE0.1220.1462 1BE0.0878.1558 1BE0.3766.1458 1BA0.0771.1028 1BE0.088C.1028 1BE0.1B50.1043 1BE0.1570.1043 1BE0.355B.1458 1BE0.1BD0.1043 1BA0.0877.1558 1BE0.1141.1025 1BA0.0888.1028 1BE0.0877.1028 1BA0.1218.1462 1BE0.376E.1458 1BE0.1630.1043 1BE0.1430.1043 1BE0.83A5.103C 1BE0.1ED0.1043 1BE0.7708.1558 1BE0.7710.1558 1BE0.2006.3842 1BA0.F442.19DA 1BA0.7707.1558 1BA0.0772.1028 1BA0.1211.1462 1BE0.0876.1028 1BA0.7509.1558 1BE0.11E6.1462 1BA0.8375.103C 1BE0.376C.1458 1BA0.11AE.1462 1BE0.6750.1A58 1BA0.1570.1043 1BA0.11C4.1462 1BA0.0879.1558 1BE0.11F4.1462 1BE0.299D.1458 1BE0.1031.1043 1BE0.7706.1558 1BE0.1218.1462 1BE0.3761.1458 1BA0.11C5.1462 1BE0.6754.1A58 1BA0.0875.1558 1BE0.088B.1028 1BA0.0872.1558 1BA0.0887.1028 1BE0.1146.1025 1BE0.11BB.1462    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX150   </td><td class="markdownTableBodyLeft">1D10.398C.17AA 1D10.84BC.103C 1D12.1D5E.1043 1D10.83FB.103C 1D10.149A.1025 1D12.1701.1D72 1D10.1DB0.1043 1D12.834C.103C 1D10.1711.1D72 1D10.398D.17AA 1D10.121D.1025 1D10.8589.1558 1D10.653A.1558 1D10.1177.152D 1D10.0809.1028 1D10.827F.103C 1D10.3E09.19E5 1D12.3802.17AA 1C90.0919.1028 1D10.39B0.17AA 1D10.169E.1043 1D10.18EE.1043 1D10.C16F.144D 1D10.55C1.1558 1D10.225E.17AA 1D10.118E.1025 1D10.08A6.1028 1D10.83AD.103C 1D12.8482.103C 1D10.3E05.19E5 1D12.39FF.17AA 1D12.1604.1D72 1D10.233D.1B0A 1D10.8484.103C 1D12.850B.103C 1D10.132C.1025 1D10.1230.1462 1D12.3E04.19E5 1D10.1B30.1043 1D10.A488.1D05 1C90.1D4E.1043 1D10.225B.17AA 1D10.83BA.103C 1D10.1C10.1043 1D10.08A8.1028 1D10.83B0.103C 1D10.11B1.1043 1D10.8485.103C 1D10.1191.1043 1D10.089D.1028 1D10.149B.1025 1D10.1498.1025 1D10.1220.1025 1D10.240F.1B0A 1D10.1060.1D05 1D10.1B10.1043 1D10.089C.1028 1D10.7A21.1558 1D12.83AC.103C 1D12.122B.1025 1D12.15DE.1043 1D10.83FE.103C 1D10.0896.1028 1D10.C792.144D 1D10.2021.1D05 1D10.861C.103C 1D10.83C9.103C 1D10.3E07.19E5 1D10.150E.1043 1D10.8587.1558 1D10.8577.1558 1D10.841C.103C 1D10.83AF.103C 1D12.1703.1D72 1D12.2257.17AA 1D10.18CE.1043 1D10.163E.1043 1D10.1421.1043 1D10.C15E.144D 1D10.850D.103C 1D10.8555.1558 1D12.834B.103C 1D10.1273.1025 1D10.126B.1025 1D10.128E.1025 1D10.C804.144D 1D10.1218.1025 1D10.0918.1028 1D12.1111.1043 1D12.848D.103C 1D12.15CE.1043 1D10.1D6E.1043 1D10.39B1.17AA 1D10.121F.1025 1D10.3963.17AA 1D10.84BF.103C 1D12.83AA.103C 1D10.157E.1043 1D10.0829.1028 1D10.0828.1028 1D10.121A.1025 1D10.84BA.103C 1D10.089F.1028 1C90.09C1.1028 1D10.199E.1043 1D10.83B1.103C 1D12.3801.17AA 1D12.83A9.103C 1D10.1C20.1043 1D10.C812.144D 1D10.8389.103C 1D10.B488.1D05 1D10.127F.1025 1D10.11A1.1043 1D10.119A.1025 1D10.151E.1043 1D10.0305.1854 1D10.17BE.1043 1D10.1329.1025 1D10.84C1.103C 1D10.118D.1025 1D10.08A7.1028 1D10.83AE.103C 1D10.15AE.1043 1D10.7A11.1558 1D10.0895.1028 1D10.1282.1025 1D10.1207.1462 1D12.838E.103C 1D10.1B20.1043    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX230   </td><td class="markdownTableBodyLeft">1D11.09ED.1028 1D11.1358.1025 1D11.3F0D.17AA 1D11.09EC.1028 1D11.130C.1025 1D11.09F7.1028 1D11.1413.1025 1D11.097A.1028 1D11.128E.1025 1D11.121F.1025 1D11.0979.1028 1D11.097B.1028 1D11.0978.1028 1D11.1325.1025 1D11.1415.1025 1D11.0957.1028 1D11.1329.1025 1D11.095D.1028 1D11.133D.1025 1D11.09F8.1028 1D11.1242.152D 1D11.138B.1025 1D11.1389.1025 1D11.0956.1028 1D11.1236.152D 1D11.095A.1028 1D11.130F.1025 1D11.1298.1025 1D11.132C.1025 1D11.0958.1028 1D11.0959.1028 1D11.1380.1025 1D11.1243.152D 1D11.1296.1025 1D11.097C.1028 1D11.0955.1028 1D11.1327.1025    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX250   </td><td class="markdownTableBodyLeft">1D13.08A8.1028 1D13.2444.1B0A 1D13.08A9.1028 1D13.2408.1B0A 1D13.85AB.103C 1D52.1407.1025 1D13.243E.1B0A 1D13.089D.1028 1D13.86AA.103C 1D13.0955.1028 1D13.1060.1D05 1D13.240F.1B0A 1D13.2028.1D05 1D13.0920.1028 1D13.85CF.103C 1D52.3E13.19E5 1D13.089C.1028 1D13.8562.1558 1D13.0959.1028 1D13.85E7.103C 1D13.0958.1028 1D13.106A.1D05 1D13.86E1.103C 1D13.141D.1025 1D13.133F.1025 1D13.2025.1D05 1D13.139C.1025 1D13.3E1F.19E5 1D52.86AE.103C 1D13.095A.1028 1D13.86A2.103C 1D13.107A.1D05 1D52.8649.103C 1D13.85C6.103C 1D13.8542.103C 1D13.08A6.1028 1D13.8726.103C 1D13.0971.1028 1D52.129A.1025 1D52.1701.1D72 1D52.8756.103C 1D13.84BC.103C 1D13.137F.1025 1D13.863F.103C 1D13.5515.1B50 1D13.8670.103C 1D13.0950.1028 1D13.0956.1028 1D13.86B0.103C 1D13.8541.103C 1D13.2027.1D05 1D13.84C1.103C 1D52.85E3.103C 1D13.86E6.103C 1D52.86BB.103C 1D13.85A7.103C 1D13.0895.1028 1D13.08A7.1028 1D13.133D.1025 1D13.55D1.1558 1D13.0908.1028 1D13.85E5.103C 1D52.1409.1025 1D13.1301.1025 1D13.089F.1028 1D52.129C.1025 1D13.85F2.103C 1D13.09C0.1028 1D13.2278.17AA 1D13.1415.1025 1D13.096E.1028 1D13.0945.1028 1D13.0389.1854 1D13.8677.103C 1D13.0957.1028 1D13.1410.1025 1D13.869F.103C 1D13.2283.17AA 1D13.089E.1028 1D13.128E.1025 1D13.091F.1028 1D13.121F.1025 1D13.85F0.103C 1D13.096F.1028 1D13.0951.1028 1D13.1358.1025 1D13.0896.1028 1D13.86B2.103C 1D13.3E20.19E5 1D13.86A7.103C 1D13.86E5.103C 1D13.1413.1025 1D13.22AB.17AA 1D13.86E2.103C 1D13.0970.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX330   </td><td class="markdownTableBodyLeft">1D16.1C1F.1043 1D16.86F7.103C 1D16.1F9F.1043 1D16.09FB.1028 1D16.09D6.1028 1D16.0A24.1028 1D16.883B.103C 1D16.09E8.1028 1D16.09EB.1028 1D16.09E9.1028 1D16.1ECF.1043 1D16.09DE.1028 1D16.0A25.1028 1D16.0A01.1028 1D16.87F3.103C 1D16.0A26.1028 1D16.09EA.1028 1D16.09DB.1028 1D16.17DC.1043 1D16.86E1.103C 1D16.0A07.1028 1D16.1C4F.1043 1D16.22B3.17AA 1D16.868F.103C 1D16.22B0.17AA 1D16.09E0.1028 1D16.0A23.1028 1D16.8757.103C 1D16.86E5.103C 1D16.86F8.103C 1D16.371E.17AA 1D16.0A06.1028 1D16.0A03.1028 1D16.1538.1025 1D16.875C.103C 1D16.09FC.1028 1D16.86F0.103C 1D16.0A04.1028 1D16.87A4.103C 1D16.150F.1025 1D16.09D7.1028 1D16.09DC.1028 1D16.0A02.1028 1D16.0A05.1028 1D16.1F7F.1043 1D16.86E6.103C 1D16.85F4.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX350   </td><td class="markdownTableBodyLeft">1C94.0A02.1028 1C96.1409.1025 1C94.0A89.1028 1C94.5515.1D05 1C94.0A04.1028 1C94.5519.1D05 1C94.5518.1D05 1C94.0A03.1028 1C94.883D.103C 1C94.8989.103C 1C94.09FC.1028 1C96.141B.1025 1C94.87CA.103C 1C94.0A7E.1028 1C94.881C.103C 1C94.0ADB.1028 1C94.0AD9.1028 1C94.87CC.103C 1C96.1407.1025 1C94.09D9.1028 1C94.09D8.1028 1C94.09EA.1028 1C94.0A7D.1028 1C94.89B8.103C 1C94.881E.103C 1C96.136E.1025 1C94.09DF.1028 1C94.0AB0.1028 1C94.1CAF.1043 1C94.5518.1B50 1C94.5519.1B50 1C94.09E9.1028 1C94.09EB.1028 1C94.09E8.1028 1C94.0AB2.1028 1C94.0A01.1028 1C94.898C.103C 1C96.8756.103C 1C94.09FB.1028 1C96.1370.1025    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P1000   </td><td class="markdownTableBodyLeft">1CBB.1CBB.19DA 1CBB.844F.103C 1CBB.A002.144A 1CBB.1831.1028 1CBB.1214.152D 1CBB.B384.19DA 1CBB.225F.17AA 1CBB.1219.1462 1CBB.0889.1028 1CBB.11BD.196E 1CBB.8427.103C 1CBB.2267.17AA 1CBB.8451.103C 1CBB.4100.144A 1CBB.842C.103C 1CBB.198B.10CF 1CBB.842D.103C 1CBB.FCBB.19DA 1CBB.2266.17AA 1CBB.842A.103C 1CBB.1992.10CF 1CBB.1889.1028 1CBB.8429.103C 1CBB.4101.144A 1CBB.842F.103C 1CBB.0831.1028 1CBB.2262.17AA 1CBB.087D.1028    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P2000   </td><td class="markdownTableBodyLeft">1CBA.4200.144A 1CBA.2262.17AA 1CBA.087D.1028 1CBA.0831.1028 1CBA.2268.17AA 1CBA.2269.17AA 1CBA.9176.301F 1CBA.8429.103C 1CBA.B001.1227 1CBA.842F.103C 1CBA.842A.103C 1CBA.B007.1227 1CBA.1889.1028 1CBA.2266.17AA 1CBA.842C.103C 1CBA.3177.301F 1CBA.1991.10CF 1CBA.842D.103C 1CBA.B000.1227 1CBA.4201.144A 1CBA.0889.1028 1CBA.B003.1227 1CBA.1219.1462 1CBA.2267.17AA 1CBA.8451.103C 1CBA.8427.103C 1CBA.121A.1462 1CBA.B004.1227 1CBA.225F.17AA 1CBA.B005.1227 1CBA.B002.1227 1CBA.844F.103C 1CBA.198A.10CF 1CBA.1831.1028 1CBA.1216.1462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P3000   </td><td class="markdownTableBodyLeft">1BB8.224C.17AA 1BB8.8270.103C 1BB8.1BB8.19DA 1BB8.B333.19DA 1BB8.2250.17AA 1BB8.17B1.1028 1BB8.8272.103C 1BB8.11AD.1462 1BB8.1972.10CF 1BB8.1975.10CF 1BB8.FBB8.19DA 1BB8.11B4.10DE 1BB8.07B1.1028 1BB8.1031.1D05 1BB8.11B6.10DE 1BB8.9501.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P3200   </td><td class="markdownTableBodyLeft">1BBB.1831.1028 1BBB.95E1.1558 1BBB.123A.1462 1BBB.0832.1028 1BBB.225F.17AA 1BBB.088A.1028 1BBB.1227.1462 1BBB.0889.1028 1BBB.1243.1462 1BBB.1988.10CF 1BBB.1989.10CF 1BBB.842D.103C 1BBB.198F.10CF 1BBB.1215.1462 1BBB.1231.1462 1BBB.1226.1462 1BBB.1889.1028 1BBB.188A.1028 1BBB.842F.103C 1BBB.1990.10CF 1BBB.1832.1028 1BBB.2269.17AA 1BBB.2268.17AA 1BBB.1229.1462 1BBB.1237.1462 1BBB.0831.1028 1BBB.2262.17AA 1BBB.01F1.1B0A    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P4000   </td><td class="markdownTableBodyLeft">1BB7.9501.1558 1BB7.07B1.1028 1BB7.1971.10CF 1BB7.8272.103C 1BB7.11E9.1462 1BB7.17B1.1028 1BB7.1974.10CF 1BB7.1034.1D05 1BB7.2250.17AA 1BB7.8270.103C 1BB7.224C.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P500   </td><td class="markdownTableBodyLeft">1D33.225B.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P5000   </td><td class="markdownTableBodyLeft">1BB6.8270.103C 1BB6.1970.10CF 1BB6.224C.17AA 1BB6.1973.10CF 1BB6.B333.19DA 1BB6.17B1.1028 1BB6.2250.17AA 1BB6.1BB6.19DA 1BB6.8272.103C 1BB6.11B4.10DE 1BB6.07B1.1028 1BB6.11F1.1462 1BB6.FBB6.19DA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P520   </td><td class="markdownTableBodyLeft">1D34.22B5.17AA 1D34.22B2.17AA 1D34.2281.17AA 1D34.8727.103C 1D34.22A2.17AA 1D34.09A2.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro P600   </td><td class="markdownTableBodyLeft">1CBC.847B.103C 1CBC.848B.103C 1CBC.848A.103C 1CBC.847C.103C 1CBC.0820.1028 1CBC.1993.10CF 1CBC.2268.17AA 1CBC.2269.17AA 1CBC.198C.10CF    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro P620   </td><td class="markdownTableBodyLeft">1CBD.0062.1E26 1CBD.87DA.103C 1CBD.87F0.103C 1CBD.229B.17AA 1CBD.22A6.17AA 1CBD.091A.1028 1CBD.0061.1E26 1CBD.1292.1462 1CBD.09C2.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA TITAN X (Pascal)   </td><td class="markdownTableBodyLeft">1B00.068B.1028 1B00 1B00.079A.1028 1B00.0790.1028 1B00.119A.1028   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md113"></a>
Volta GPUs</h4>
<p>The Volta family of GPUs is also supported, but is not recommended for NVN development. NVN drivers undergo only limited verification on Volta.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro GV100   </td><td class="markdownTableBodyLeft">1DBA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA TITAN V   </td><td class="markdownTableBodyLeft">1D81    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA TITAN V JHH Special Edition   </td><td class="markdownTableBodyLeft">1DBA   </td></tr>
</table>
<p>Notebook:</p>
<p>We have no notebook with Volta GPU supported by NVN Windows Reference Implementation.</p>
<h4><a class="anchor" id="autotoc_md114"></a>
Turing GPUs</h4>
<p>Turing GPUs provide the same basic graphics functionality present in the previous generations GPUs after second-generation Maxwell GPUs, as well as a number of new features. The NVN Windows reference implementation is supported on Turing-based GPUs but it does not support any Turing graphics features that are not present in second-generation Maxwell GPUs.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDA DGX Display   </td><td class="markdownTableBodyLeft">1FB0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA CMP 30HX   </td><td class="markdownTableBodyLeft">2189    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA CMP 40HX   </td><td class="markdownTableBodyLeft">1F0B    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA CMP 50HX   </td><td class="markdownTableBodyLeft">1E09    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA DGX Display   </td><td class="markdownTableBodyLeft">1FB0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650   </td><td class="markdownTableBodyLeft">1F82 1F0A 2188    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650 SUPER   </td><td class="markdownTableBodyLeft">2187    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1660   </td><td class="markdownTableBodyLeft">2184    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1660 SUPER   </td><td class="markdownTableBodyLeft">21C4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1660 Ti   </td><td class="markdownTableBodyLeft">2182    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2060   </td><td class="markdownTableBodyLeft">1E89 1F08    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2060 SUPER   </td><td class="markdownTableBodyLeft">1F06 1F47 1F42    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2070   </td><td class="markdownTableBodyLeft">1F02 1F07    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2070 SUPER   </td><td class="markdownTableBodyLeft">1E84 1EC2 1EC7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080   </td><td class="markdownTableBodyLeft">1E87 1E82    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080 SUPER   </td><td class="markdownTableBodyLeft">1E81    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080 Ti   </td><td class="markdownTableBodyLeft">1E04 1E07    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 3000   </td><td class="markdownTableBodyLeft">1F76    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 4000   </td><td class="markdownTableBodyLeft">1EB1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 5000   </td><td class="markdownTableBodyLeft">1EF5 1EB0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 6000   </td><td class="markdownTableBodyLeft">1E30 1E78    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 8000   </td><td class="markdownTableBodyLeft">1E30 1E78    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro T1000   </td><td class="markdownTableBodyLeft">1FF9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA T1000   </td><td class="markdownTableBodyLeft">1FB0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA T400   </td><td class="markdownTableBodyLeft">1FB2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA T600   </td><td class="markdownTableBodyLeft">1FB1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA TITAN RTX   </td><td class="markdownTableBodyLeft">1E02   </td></tr>
</table>
<p>Notebook: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650   </td><td class="markdownTableBodyLeft">1F99.09EE.1028 1F9D.0A64.1028 1F9D.0A83.1028 1F99.87B5.103C 1F9D.88FF.103C 1F99.09F0.1028 1F9D.1104.1D05 1F99.88DD.103C 1F9D.1364.152D 1F9D.88EB.103C 1F9D.8930.103C 1F99.87AD.103C 1F99.1085.1D05 1F9D.88E4.103C 1F99.8815.103C 1F9D.114A.1D05 1F9D.88F6.103C 1F9D.0A82.1028 1F99.09E2.1028 1F9D.1115.1D05 1F9D.8927.103C 1F99.22DA.17AA 1F9D.88E6.103C 1F9D.8965.103C 1F99.09EF.1028 1F9D.88FA.103C 1F99.878C.103C 1F99.109E.1D05 1F9D.0A81.1028 1F99.09E1.1028 1F99.371F.17AA 1F99.1140.1D05 1F99.87B1.103C 1F99.1102.1D05 1F99.8745.103C 1F99.8742.103C 1F99.1247.152D 1F99.1104.1D05    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650 Ti   </td><td class="markdownTableBodyLeft">2192.1088.1D05 2192.1101.1D05    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650 Ti with Max-Q Design   </td><td class="markdownTableBodyLeft">1F95.1246.152D 1F95.09F3.1028 1F95.0410.1854 1F95.0416.1854 1F95.22C1.17AA 1F95.097D.1028 1F95.1286.152D 1F95.09EE.1028 1F95.87B2.103C 1F95.87B5.103C 1F95.1088.1D05 1F95.1515.1458 1F95.09F0.1028 1F95.8747.103C 1F95.09EF.1028 1F95.86E7.103C 1F95.878C.103C 1F95.8815.103C 1F95.09F4.1028 1F95.09E2.1028 1F95.1100.1D05 1F95.109E.1D05 1F95.098F.1028 1F95.09E1.1028 1F95.22C0.17AA 1F95.87AE.103C 1F95.1099.1D05 1F95.86E8.103C 1F95.878F.103C 1F95.8745.103C 1F95.8788.103C 1F95.8742.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1650 with Max-Q Design   </td><td class="markdownTableBodyLeft">1F91.8575.103C 1F91.0922.1028 1F91.0032.1414 1F91.1F91.19DA 1F91.142A.1025 1F91.0924.1028 1F91.1064.1D05 1F91.86E7.103C 1F91.1574.19DA 1F91.229F.17AA 1F91.3390.1458 1F91.0923.1028 1F91.1078.1D05 1F91.0387.1854 1F91.85FC.103C 1F91.1235.152D 1F91.0352.1854 1F91.08ED.1028 1F91.863E.103C 1F91.08EC.1028 1F91.8604.103C 1F91.106C.1D05 1F91.8601.103C 1F91.1387.1025 1F91.139E.1025 1F91.8641.103C 1F91.22A8.17AA 1F91.86C7.103C 1F91.08EE.1028 1F91.2085.1D05 1F91.86E8.103C 1F91.2428.1B0A 1F91.1231.152D 1F91.08EA.1028 1F91.08EF.1028 1F91.1225.152D 1F91.0905.1028 1F91.85FF.103C 1F91.1400.1025 1F91.86D5.103C 1F91.0949.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 1660 Ti   </td><td class="markdownTableBodyLeft">2191.85FE.103C 2191.86D6.103C 2191.139E.1025 2191.8744.103C 2191.12CC.1462 2191.8748.103C 2191.08EA.1028 2191.8881.103C 2191.870F.103C 2191.08EE.1028 2191.08EB.1028 2191.242A.1B0A 2191.87AF.103C 2191.2086.1D05 2191.872C.103C 2191.1087.1D05 2191.08EF.1028 2191.09E1.1028 2191.8786.103C 2191.878A.103C 2191.107D.1D05 2191.0949.1028 2191.1400.1025 2191.85FB.103C 2191.1096.1D05 2191.1253.152D 2191.8746.103C 2191.1230.152D 2191.87B3.103C 2191.09E2.1028 2191.8603.103C 2191.1288.152D 2191.09F9.1028 2191.0032.1414 2191.1065.1D05 2191.4529.19DA 2191.878D.103C 2191.8600.103C 2191.1233.152D 2191.8574.103C 2191.88A0.103C 2191.2191.19DA 2191.2086.8086 2191.8741.103C 2191.1082.1D05 2191.08EC.1028 2191.1514.1458 2191.1072.1D05 2191.09F3.1028 2191.08ED.1028    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX450   </td><td class="markdownTableBodyLeft">1F97.87E4.103C 1F97.0B31.1028 1F97.8848.103C 1F97.0B26.1028 1F97.87E8.103C 1F97.0A87.1028 1F97.0ADF.1028 1F97.0413.1854 1F9C.8829.103C 1F97.89B8.103C 1F97.0A7D.1028 1F97.881E.103C 1F97.0AE0.1028 1F97.0B23.1028 1F97.0A7C.1028 1F97.881A.103C 1F97.0AB0.1028 1F97.0AE2.1028 1F97.3747.17AA 1F97.3755.17AA 1F97.0B24.1028 1F97.87E6.103C 1F97.884E.103C 1F97.87EE.103C 1F97.0B25.1028 1F9C.22CA.17AA 1F97.0A7F.1028 1F97.0B60.1028 1F97.8826.103C 1F97.0A21.1028 1F97.0A89.1028 1F98.0A67.1028 1F97.0A7B.1028 1F97.0AE1.1028 1F97.0B33.1028 1F97.88B6.103C 1F97.0A66.1028 1F97.8983.103C 1F97.0B30.1028 1F97.3739.17AA 1F9C.22CD.17AA 1F9C.22D3.17AA 1F97.8823.103C 1F97.88B4.103C 1F97.1503.1025 1F97.883D.103C 1F97.898B.103C 1F97.8988.103C 1F97.3749.17AA 1F97.374B.17AA 1F97.88F2.103C 1F97.0B32.1028 1F97.0A80.1028 1F97.0A86.1028 1F97.8850.103C 1F97.0A7E.1028 1F97.8985.103C 1F97.1338.152D    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2060   </td><td class="markdownTableBodyLeft">1F11.8605.103C 1F11.8602.103C 1F11.65D1.1558 1F11.132D.1025 1F11.86C6.103C 1F11.7709.1558 1F11.87A7.103C 1F11.1212.152D 1F15.1097.1D05 1F15.1289.152D 1F15.86C2.1458 1F11.95E1.1558 1F15.1513.1458 1F11.8551.1558 1F11.08EC.1028 1F15.09E2.1028 1F15.8787.103C 1F51.67D4.1558 1F15.09F9.1028 1F11.08ED.1028 1F11.2529.19DA 1F15.1E21.1043 1F11.8603.103C 1F15.09F3.1028 1F15.A005.7377 1F51.08ED.1028 1F11.971D.1558 1F15.1101.1D05 1F11.106F.1D05 1F51.7710.1558 1F15.3011.8086 1F11.3000.1A58 1F11.8600.103C 1F11.67D2.1558 1F11.8606.103C 1F11.1375.1025 1F11.8574.103C 1F11.08EB.1028 1F11.97E1.1558 1F15.8748.103C 1F11.3490.1458 1F15.9529.19DA 1F11.8550.1558 1F11.105F.1D05 1F11.08EF.1028 1F51.65D4.1558 1F51.08EE.1028 1F15.878B.103C 1F11.0348.1854 1F11.0949.1028 1F11.7509.1558 1F11.107C.1D05 1F15.1287.152D 1F11.85FB.103C 1F11.1228.152D 1F51.7510.1558 1F15.1100.1D05 1F51.0349.1854 1F11.85FE.103C 1F11.87A6.103C 1F15.878A.103C 1F15.8746.103C 1F11.1223.152D 1F11.3001.1A58 1F15.1096.1D05 1F15.8607.103C 1F11.1F11.19DA 1F15.3734.17AA 1F11.2429.1B0A 1F11.08EA.1028 1F15.8786.103C 1F51.08EF.1028 1F15.09E1.1028 1F11.08EE.1028 1F11.951D.1558    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2060 with Max-Q Design   </td><td class="markdownTableBodyLeft">1F12.8744.103C 1F12.098F.1028 1F12.878E.103C 1F12.880E.103C 1F12.8741.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2070   </td><td class="markdownTableBodyLeft">1F54.878A.103C 1F50.1226.152D 1F50.08EE.1028 1F50.65D4.1558 1F50.7510.1558 1F50.08EF.1028 1F50.8600.103C 1F50.8574.103C 1F50.8603.103C 1F50.8572.103C 1F50.67D4.1558 1F50.08ED.1028 1F50.8605.103C 1F50.7710.1558 1F50.8573.103C 1F50.133B.1025    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2070 Super with Max-Q Design   </td><td class="markdownTableBodyLeft">1E91.8738.103C 1E91.8529.19DA 1E91.8607.103C 1E91.878A.103C 1E91.22C3.17AA 1E91.1511.1458 1E91.8736.103C 1E91.878B.103C 1E91.3012.8086 1E91.8772.103C 1E91.22C5.17AA 1E91.37B5.103C 1ED1.878A.103C 1ED1.8746.103C 1E91.1251.152D 1E91.874D.103C 1E91.09F9.1028 1ED1.1092.1D05 1ED1.8748.103C 1E91.108A.1D05    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2070 with Max-Q Design   </td><td class="markdownTableBodyLeft">1F10.08EB.1028 1F14.8736.103C 1F14.878B.103C 1F10.08EF.1028 1F10.1529.19DA 1F10.1222.152D 1F14.8748.103C 1F14.8772.103C 1F14.1252.152D 1F10.3493.1458 1F10.2087.8086 1F10.3001.1A58 1F14.8738.103C 1F14.878A.103C 1F10.105E.1D05 1F10.08EA.1028 1F14.8607.103C 1F10.08EE.1028 1F14.8746.103C 1F10.8602.103C 1F10.3794.1458 1F14.09E2.1028 1F10.132D.1025 1F14.09F9.1028 1F10.8573.103C 1F10.105D.1D05 1F10.2554.19DA 1F10.08EC.1028 1F14.1097.1D05 1F10.08ED.1028 1F14.108B.1D05 1F14.1512.1458 1F10.1070.1D05 1F10.2087.1D05 1F10.8572.103C 1F10.1213.152D 1F10.107E.1D05 1F10.8606.103C 1F10.3000.1A58 1F10.1F10.19DA 1F14.09F3.1028    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080   </td><td class="markdownTableBodyLeft">1ED0.08EF.1028 1ED0.7510.1558 1ED0.1323.1025 1ED0.08EE.1028 1ED0.7710.1558 1ED0.132D.1025 1ED0.8605.103C 1ED0.8573.103C 1ED0.133B.1025 1ED0.08ED.1028 1ED0.8603.103C 1ED0.8572.103C 1ED0.8600.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080 Super   </td><td class="markdownTableBodyLeft">1ED3.8748.103C 1ED3.878A.103C 1ED3.8746.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080 Super with Max-Q Design   </td><td class="markdownTableBodyLeft">1E93.7529.19DA 1E93.1089.1D05 1E93.8772.103C 1E93.22C5.17AA 1E93.8736.103C 1E93.8607.103C 1E93.22C3.17AA 1E93.8738.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 2080 with Max-Q Design   </td><td class="markdownTableBodyLeft">1E90.1386.1025 1E90.8573.103C 1E90.8602.103C 1E90.87A7.103C 1E90.7709.1558 1E90.86C6.103C 1E90.08ED.1028 1E90.137E.1025 1E90.08EC.1028 1E90.8572.103C 1E90.8606.103C 1E90.1E90.19DA 1E90.3000.1A58 1E90.1375.1025 1E90.1069.1D05 1E90.08EF.1028 1E90.08EB.1028 1E90.3529.19DA 1E90.7509.1558 1E90.3001.1A58 1E90.87A6.103C 1E90.2002.1A58 1E90.86C7.103C 1E90.08EE.1028 1E90.08EA.1028 1E90.1220.152D    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 3000   </td><td class="markdownTableBodyLeft">1F36.8611.103C 1F36.860C.103C 1F36.140A.1025 1F36.8738.103C 1F36.1277.1462 1F36.8780.103C 1F36.8783.103C 1F36.12B0.1462 1F36.09C3.1028 1F36.8736.103C 1F36.005B.1E26 1F36.09C4.1028 1F36.139E.1025 1F36.1926.1028 1F36.2297.17AA 1F36.8782.103C 1F36.8785.103C 1F36.0927.1028 1F36.8772.103C 1F36.1274.1462 1F36.1927.1028 1F36.12C6.1462 1F36.22BA.17AA 1F36.2296.17AA 1F36.1272.1462 1F36.13CF.1043 1F36.0926.1028 1F36.860F.103C 1F36.0990.1028 1F36.1050.1028 1F36.0032.1414 1F36.860E.103C 1F36.12D1.1462 1F36.22BB.17AA 1F36.22B8.17AA 1F36.229B.17AA 1F36.1375.1025 1F36.005C.1E26    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 4000 with Max-Q Design   </td><td class="markdownTableBodyLeft">1EB6.8785.103C 1EB6.0927.1028 1EB6.8782.103C 1EB6.1281.1462 1EB6.2297.17AA 1EB6.12AF.1043 1EB6.8772.103C 1EB6.8736.103C 1EB6.1926.1028 1EB6.09C4.1028 1EB6.12B0.1462 1EB6.8783.103C 1EB6.09C3.1028 1EB6.860C.103C 1EB6.8780.103C 1EB6.1277.1462 1EB6.8738.103C 1EB6.229B.17AA 1EB6.22B8.17AA 1EB6.22BB.17AA 1EB6.860E.103C 1EB6.129F.1043 1EB6.0926.1028 1EB6.2296.17AA 1EB6.1274.1462 1EB6.22BA.17AA 1EB6.1927.1028 1EB6.12C6.1462    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro RTX 5000 with Max-Q Design   </td><td class="markdownTableBodyLeft">1EB5.22BA.17AA 1EB5.1927.1028 1EB5.12C6.1462 1EB5.1386.1025 1EB5.1274.1462 1EB5.0926.1028 1EB5.2296.17AA 1EB5.860E.103C 1EB5.1A51.1043 1EB5.1375.1025 1EB5.2007.1A58 1EB5.229B.17AA 1EB5.22B8.17AA 1EB5.22BB.17AA 1EB5.8780.103C 1EB5.8738.103C 1EB5.860C.103C 1EB5.09C3.1028 1EB5.12B0.1462 1EB5.8783.103C 1EB5.1926.1028 1EB5.09C4.1028 1EB5.8736.103C 1EB5.8772.103C 1EB5.1A41.1043 1EB5.8785.103C 1EB5.0927.1028 1EB5.2008.1A58 1EB5.8782.103C 1EB5.2297.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro T1000 with Max-Q Design   </td><td class="markdownTableBodyLeft">1FB9.1299.1462 1FB9.8772.103C 1FB9.0906.1028 1FB9.8782.103C 1FB9.097E.1028 1FB9.8785.103C 1FB9.2297.17AA 1FB9.1926.1028 1FB9.139E.1025 1FB9.1387.1025 1FB9.09C4.1028 1FB9.8736.103C 1FB9.005F.1E26 1FB9.22A8.17AA 1FB9.09C3.1028 1FB9.8783.103C 1FB9.8780.103C 1FB9.22C0.17AA 1FB9.8738.103C 1FB9.860C.103C 1FB9.12BE.1462 1FB9.8611.103C 1FB9.1AC1.1043 1FB9.22B8.17AA 1FB9.22BB.17AA 1FB9.0060.1E26 1FB9.229F.17AA 1FB9.860E.103C 1FB9.12BD.1462 1FB9.87F0.103C 1FB9.22C1.17AA 1FB9.860F.103C 1FB9.0926.1028 1FB9.2296.17AA 1FB9.22BA.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro T2000 with Max-Q Design   </td><td class="markdownTableBodyLeft">1FB8.1285.1462 1FB8.0990.1028 1FB8.860F.103C 1FB8.22C1.17AA 1FB8.0926.1028 1FB8.2296.17AA 1FB8.22BA.17AA 1FB8.229B.17AA 1FB8.22B8.17AA 1FB8.22BB.17AA 1FB8.005D.1E26 1FB8.229F.17AA 1FB8.87F0.103C 1FB8.12BD.1462 1FB8.09C3.1028 1FB8.005E.1E26 1FB8.8783.103C 1FB8.8780.103C 1FB8.13BF.1043 1FB8.8738.103C 1FB8.22C0.17AA 1FB8.8611.103C 1FB8.12BE.1462 1FB8.1299.1462 1FB8.8772.103C 1FB8.1294.1462 1FB8.0906.1028 1FB8.8785.103C 1FB8.8782.103C 1FB8.1281.1462 1FB8.097E.1028 1FB8.2297.17AA 1FB8.1926.1028 1FB8.22A8.17AA 1FB8.8736.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA T1200 Laptop GPU   </td><td class="markdownTableBodyLeft">1FBC.8875.103C 1FBC.8872.103C 1FBC.88CE.103C 1FBC.22D9.17AA 1FBC.22D8.17AA 1FBC.8873.103C 1FBC.22E4.17AA 1FBC.22DE.17AA 1FBC.886F.103C 1FBC.12EC.1462 1FBC.8870.103C 1FBC.0A6A.1028 1FBC.88E0.103C 1FBC.22DD.17AA 1FBC.12EB.1462 1FBC.0A62.1028 1FBC.0A69.1028 1FBC.0A68.1028 1FBC.886D.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA T500   </td><td class="markdownTableBodyLeft">1FBB.8848.103C 1FBB.8849.103C 1FBB.0A22.1028 1FBB.22CE.17AA 1FBB.22CB.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA T600 Laptop GPU   </td><td class="markdownTableBodyLeft">1FBA.0A68.1028 1FBA.8911.103C 1FBA.88CE.103C 1FBA.22D9.17AA   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md115"></a>
Ampere GPUs</h4>
<p>Ampere GPUs provide the same basic graphics functionality present in the previous generations GPUs after second-generation Maxwell GPUs, as well as a number of new features. The NVN Windows reference implementation is supported on Ampere-based GPUs but it does not support any Ampere graphics features that are not present in second-generation Maxwell GPUs.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA A10   </td><td class="markdownTableBodyLeft">2236    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA A100 80GB PCIe   </td><td class="markdownTableBodyLeft">20B5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA A100-PCIE-40GB   </td><td class="markdownTableBodyLeft">20F1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA A100-PG509-200   </td><td class="markdownTableBodyLeft">20B0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA A100-SXM4-40GB   </td><td class="markdownTableBodyLeft">20B0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA A100-SXM4-80GB   </td><td class="markdownTableBodyLeft">20B2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA A10G   </td><td class="markdownTableBodyLeft">2237    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA A16   </td><td class="markdownTableBodyLeft">25B6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA A30   </td><td class="markdownTableBodyLeft">20B7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA A40   </td><td class="markdownTableBodyLeft">2235    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA CMP 70HX   </td><td class="markdownTableBodyLeft">248A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA CMP 90HX   </td><td class="markdownTableBodyLeft">220D    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3060   </td><td class="markdownTableBodyLeft">2503 2504    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3060 Ti   </td><td class="markdownTableBodyLeft">2489 2486    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3070   </td><td class="markdownTableBodyLeft">2488 2484    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3070 Ti   </td><td class="markdownTableBodyLeft">2482    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3080   </td><td class="markdownTableBodyLeft">2216 2206    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3080 Ti   </td><td class="markdownTableBodyLeft">2208    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3090   </td><td class="markdownTableBodyLeft">2204    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA PG506-232   </td><td class="markdownTableBodyLeft">20B6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA PG506-242   </td><td class="markdownTableBodyLeft">20B3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA PG506-243   </td><td class="markdownTableBodyLeft">20B3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA RTX A2000   </td><td class="markdownTableBodyLeft">2531    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA RTX A4000   </td><td class="markdownTableBodyLeft">24B0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA RTX A5000   </td><td class="markdownTableBodyLeft">2231    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA RTX A6000   </td><td class="markdownTableBodyLeft">2230   </td></tr>
</table>
<p>Notebook: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3050 Laptop GPU   </td><td class="markdownTableBodyLeft">25A2.115F.1D05 25A2.0A81.1028 25A2.88EC.103C 25A2.0A71.1028 25A2.88E7.103C 25A5.88F9.103C 25A2.3756.17AA 25A2.0A61.1028 25A2.0A64.1028 25A2.88F9.103C 25A2.0A83.1028 25A2.88E5.103C 25A5.88EC.103C 25A2.88F5.103C 25A5.0A71.1028 25A2.88DE.103C 25A2.373A.17AA 25A2.88CD.103C 25A2.8964.103C 25A2.1363.152D 25A2.8900.103C 25A2.891B.103C 25A2.0A5D.1028 25A2.0A82.1028 25A2.0A6E.1028 25A2.1140.1D05    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3050 Ti Laptop GPU   </td><td class="markdownTableBodyLeft">25A0.1141.1D05 25A0.0A61.1028 25A0.8901.103C 25A0.0A71.1028 25A0.88ED.103C 25A0.0A81.1028 25A0.88E7.103C 25A0.22E4.17AA 25A0.0A82.1028 25A0.88DF.103C 25A0.0A6E.1028 25A0.88E5.103C 25A0.0A83.1028 25A0.1362.152D 25A0.88F9.103C 25A0.0A64.1028 25A0.88CD.103C 25A0.88F5.103C 25A0.1160.1D05    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3060 Laptop GPU   </td><td class="markdownTableBodyLeft">2520.88CC.103C 2520.1116.1D05 2520.8930.103C 2520.86D6.1458 2560.88FD.103C 2520.88F8.103C 2520.88F4.103C 2520.86D3.1458 2520.0A64.1028 2520.78CA.1458 2520.0A83.1028 2520.86D9.1458 2520.88E0.103C 2520.1146.1D05 2520.75CA.1458 2520.1524.1458 2520.88EE.103C 2520.1537.1458 2520.75D7.1458 2520.0A5D.1028 2520.8927.103C 2520.3017.8086 2520.75D3.1458 2520.8873.103C 2520.88D1.103C 2520.22E4.17AA 2520.1533.1458 2520.1341.152D 2520.88CB.103C 2520.1111.1D05 2520.88C8.103C 2520.1161.1D05 2520.37D2.1458 2520.88F7.103C 2520.1356.152D 2520.37D5.1458 2520.76C7.1458 2520.8875.103C 2560.0A6E.1028 2520.78D3.1458 2520.78CD.1458 2520.2463.1B0A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3070 Laptop GPU   </td><td class="markdownTableBodyLeft">249D.37D4.1458 249D.1147.1D05 249D.8873.103C 249D.22E4.17AA 249D.88F7.103C 249D.88CB.103C 249D.88C8.103C 249D.78D2.1458 249D.1535.1458 249D.1124.1D05 249D.1117.1D05 249D.75D5.1458 249D.8875.103C 249D.2463.1B0A 249D.78CC.1458 249D.22E3.17AA 249D.75D1.1458 249D.3018.8086 249D.1531.1458 249D.1520.1458 24DD.88FD.103C 249D.75C9.1458 24DD.88CB.103C 24DD.88C8.103C 249D.1113.1D05 249D.88F4.103C 24DD.75C1.1458 249D.88D2.103C 249D.78C9.1458 249D.88E0.103C 249D.8912.103C 249D.86D8.1458 249D.1342.152D 249D.1162.1D05 249D.22E1.17AA 249D.1357.152D 249D.76C5.1458 249D.86D2.1458 249D.37D1.1458 249D.86D5.1458    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce RTX 3080 Laptop GPU   </td><td class="markdownTableBodyLeft">249C.8873.103C 249C.22E4.17AA 249C.86D1.1458 249C.75D0.1458 249C.86D7.1458 249C.1644.19DA 249C.37D0.1458 24DC.88FE.103C 249C.8875.103C 249C.2463.1B0A 249C.37D3.1458 249C.1358.152D 249C.75D4.1458 249C.22E3.17AA 249C.8930.103C 249C.1148.1D05 249C.75C8.1458 249C.1343.152D 249C.0A69.1028 24DC.88F7.103C 249C.1114.1D05 249C.78C8.1458 249C.76C4.1458 249C.78CB.1458 249C.88E0.103C 249C.0A6A.1028 249C.86D4.1458 249C.22E1.17AA 249C.76D1.1458 249C.78D1.1458 249C.8927.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA RTX A2000 Laptop GPU   </td><td class="markdownTableBodyLeft">25B8.22D8.17AA 25B8.22D9.17AA 25B8.8872.103C 25B8.8875.103C 25B8.88CE.103C 25B8.12EC.1462 25B8.0A5E.1028 25B8.8870.103C 25B8.22E4.17AA 25B8.8873.103C 25B8.886F.103C 25B8.22DE.17AA 25B8.88E0.103C 25B8.22DD.17AA 25B8.0A69.1028 25B8.886D.103C 25B8.12EB.1462 25B8.0A62.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA RTX A3000 Laptop GPU   </td><td class="markdownTableBodyLeft">24B8.1315.1462 24B8.12F6.1462 24B8.22DD.17AA 24B8.0A6A.1028 24B8.88E0.103C 24B8.886D.103C 24B8.0A69.1028 24B8.22D8.17AA 24B8.8875.103C 24B8.8872.103C 24B8.130D.1462 24B8.0A5E.1028 24B8.8870.103C 24B8.22DE.17AA 24B8.886F.103C 24B8.22E4.17AA 24B8.8873.103C    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA RTX A4000 Laptop GPU   </td><td class="markdownTableBodyLeft">24B7.22E4.17AA 24B7.8873.103C 24B7.22DE.17AA 24B7.886F.103C 24B7.8870.103C 24B7.8875.103C 24B7.8872.103C 24B7.22D8.17AA 24B7.0A69.1028 24B7.886D.103C 24B7.0A6A.1028 24B7.88E0.103C 24B7.22DD.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA RTX A5000 Laptop GPU   </td><td class="markdownTableBodyLeft">24B6.12F6.1462 24B6.1315.1462 24B6.0A6A.1028 24B6.88E0.103C 24B6.22DD.17AA 24B6.0A69.1028 24B6.886D.103C 24B6.22D8.17AA 24B6.8872.103C 24B6.8875.103C 24B6.130D.1462 24B6.8870.103C 24B6.22E4.17AA 24B6.8873.103C 24B6.886F.103C 24B6.22DE.17AA   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md116"></a>
First-Generation Maxwell GPUs</h4>
<p>First-generation Maxwell GPUs support most of the NVN features available with second-generation Maxwell GPUs, but are missing a number of advanced rendering features. Devices with 4GB of video memory or more are recommended, but GPUs with less memory are supported.</p>
<p>Desktop: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 920MX   </td><td class="markdownTableBodyLeft">134F    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce 930A   </td><td class="markdownTableBodyLeft">1349    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 930MX   </td><td class="markdownTableBodyLeft">134E    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce 945A   </td><td class="markdownTableBodyLeft">1348    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 745   </td><td class="markdownTableBodyLeft">1382    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 750   </td><td class="markdownTableBodyLeft">1381    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 750 Ti   </td><td class="markdownTableBodyLeft">1380    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA NVS 810   </td><td class="markdownTableBodyLeft">13B9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro K1200   </td><td class="markdownTableBodyLeft">13BC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro K2200   </td><td class="markdownTableBodyLeft">13BA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro K620   </td><td class="markdownTableBodyLeft">13BB   </td></tr>
</table>
<p>Notebook: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">DeviceID(s)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 830M   </td><td class="markdownTableBodyLeft">1340.2245.1B0A 1340.0214.2014 1340.2295.103C 1340.2281.103C 1340.0645.1028 1340.233A.103C 1340.2249.1B0A 1340.233B.103C 1340.2339.103C 1340.0646.1028 1340.0632.1028 1340.2296.103C 1340.90D8.1B0A 1340.062C.1028 1340.2B2B.103C 1340.2280.103C 1340.0631.1028 1340.2297.103C 1340.069A.1028 1340.2250.1B0A 1340.90DD.1B0A 1340.062B.1028 1340.2282.103C 1340.2253.1B0A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce 840M   </td><td class="markdownTableBodyLeft">1341.0963.1025 1341.237A.1043 1341.0083.14C0 1341.381C.17AA 1341.1112.1462 1341.2280.103C 1341.0991.1025 1341.229D.103C 1341.0942.1025 1341.381D.17AA 1341.863A.1043 1341.0867.1025 1341.0652.1028 1341.229C.103C 1341.2109.1B0A 1341.5035.1B6C 1341.2297.103C 1341.228E.103C 1341.062E.1028 1341.229A.1043 1341.5040.17AA 1341.0948.1025 1341.3817.17AA 1341.3699.17AA 1341.234A.1043 1341.0966.1025 1341.130D.1043 1341.2250.1B0A 1341.16FD.1043 1341.5042.17AA 1341.5008.1558 1341.380D.17AA 1341.558D.1991 1341.1113.1462 1341.062B.1028 1341.0653.1028 1341.1102.1462 1341.210E.1B0A 1341.2222.1B0A 1341.1093.152D 1341.14FD.1043 1341.0127.1854 1341.3915.17AA 1341.131D.1043 1341.0217.1854 1341.5044.17AA 1341.0656.1028 1341.21A1.103C 1341.2282.103C 1341.170D.1043 1341.1020.152D 1341.16ED.1043 1341.1116.1462 1341.15DD.1043 1341.0877.1025 1341.2253.1B0A 1341.101F.1025 1341.167D.1043 1341.087A.1025 1341.22AA.1043 1341.99A3.1019 1341.0649.1028 1341.2245.1B0A 1341.3812.17AA 1341.3907.17AA 1393.0083.14C0 1341.2295.103C 1341.1003.152D 1341.5037.1B6C 1341.558A.1991 1341.369C.17AA 1341.0886.1025 1341.2229.17AA 1341.2281.103C 1341.15AD.1043 1341.2249.1B0A 1341.3697.17AA 1341.11ED.1043 1341.229B.103C 1341.6502.1558 1341.091C.1025 1341.0922.1025 1393.0653.1028 1341.3813.17AA 1341.0925.1025 1341.381A.17AA 1341.0872.1025 1341.13FD.1043 1341.16AD.1043 1341.16CD.1043 1341.C757.144D 1341.21A0.103C 1341.0882.1025 1341.14AD.1043 1341.091D.1025 1393.1113.1462 1341.3805.17AA 1341.1A40.4352 1341.1117.152D 1341.0863.1025 1341.2296.103C 1341.228D.103C 1341.195D.1043 1341.0214.1854 1341.139D.1043 1341.12DF.1043 1341.2166.103C 1341.158D.1043 1341.21DC.103C 1341.228C.103C 1341.3809.17AA 1341.062C.1028 1341.239A.1043    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 845M   </td><td class="markdownTableBodyLeft">1344.0692.1028 1398.177D.1043    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce 930M   </td><td class="markdownTableBodyLeft">1346.F843.1179 1346.ACB5.1462 1346.2245.1B0A 1346.F834.1179 1346.0004.1179 1346.362C.17AA 1346.AC17.1462 1346.F832.1179 1346.864C.1043 1346.86B3.1043 1346.82A8.103C 1346.2286.1B0A 1346.F821.1179 1346.3636.17AA 1346.0014.1179 1346.F842.1179 1346.86EB.1043 1346.86B8.1043 1346.AA8C.1462 1346.246A.1043 1346.86E5.1043 1346.9E54.17AA 1346.806D.103C 1346.245A.1043 1346.22FA.1043 1346.06D5.1028 1346.80D0.103C 1346.F841.1179 1346.362F.17AA 1346.86E1.1043 1346.000D.1179 1346.06D4.1028 1346.193D.1043 1346.070A.1028 1346.AE68.1462 1346.1A6D.1043 1346.178D.1043 1346.86A5.1043 1346.070B.1028 1346.23CA.1043 1346.30BA.17AA 1346.F823.1179 1346.1A7D.1043 1346.2250.1B0A 1346.2281.1B0A 1346.869D.1043 1346.001D.1179 1346.86EC.1043    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 940M   </td><td class="markdownTableBodyLeft">1347.2281.1B0A 1347.117C.1025 1347.1114.152D 1347.1027.1025 1347.5593.1991 1347.1116.1462 1347.503A.17AA 1347.1127.152D 1347.80E6.103C 1347.1035.1025 139C.1D1D.1043 1347.091B.1025 1347.1D2D.1043 1347.8096.103C 1347.1040.1025 1347.1046.1025 1347.097A.1025 1347.0976.1025 1347.06EF.1028 1347.102D.1025 1347.36BA.17AA 139C.24AA.1043 1347.5590.1991 1347.1113.1462 1347.2250.1B0A 1347.5042.17AA 1347.1A7D.1043 1347.80EE.103C 1347.101E.1043 1347.1008.1025 1347.36B9.17AA 1347.5035.17AA 1347.103E.1025 1347.0985.1025 1347.80E4.103C 1347.105D.1025 1347.5003.1558 1347.80DE.103C 1347.2109.1B0A 1347.105C.1025 1347.AC18.1462 1347.1A6D.1043 1347.1A1D.1043 1347.3829.17AA 1347.1109.152D 1347.107F.1025 1347.80E5.103C 1347.245A.1043 1347.0989.1025 1347.5550.1B50 1347.1042.1025 1347.8095.103C 1347.381D.17AA 1347.6507.1558 1347.0261.1854 1347.818B.103C 139C.1B2D.1043 1347.1063.1025 1347.0963.1025 1347.1B1D.1043 1347.1B6D.1043 1347.1112.1462 1347.101A.1025 1347.0974.1025 1347.80DC.103C 1347.23BA.1043 1347.819F.103C 1347.0971.1025 1347.380B.17AA 1347.241A.1043 1347.0999.1025 1347.1124.152D 1347.246A.1043 1347.102F.1025 1347.5560.1B50 1347.12DF.1043 1347.AA8D.1462 1347.819B.103C 1347.5591.1991 1347.80A3.103C 1347.195D.1043 1347.80DD.103C 1347.9E54.17AA 1347.1174.1025 1347.3917.17AA 1347.504D.17AA 1347.C757.144D 1347.114C.1462 1347.3821.17AA 1347.096D.1025 1347.091D.1025 1347.1CDD.1043 1347.816D.103C 1347.091C.1025 1347.1159.1462 1347.114D.1462 1347.1025.1025 1347.1A9D.1043 1347.1173.1025 1347.098C.1025 1347.1031.1025 1347.0233.1854 1347.10F0.1043 1347.117E.1025 1347.1052.1025 1347.1120.152D 1347.8097.103C 1347.80A5.103C 1347.818C.103C 1347.1109.17C0 1347.0993.1025 1347.228F.1B0A 1347.1077.1025 1347.6508.1558 1347.80EC.103C 1347.86FA.1043 1347.C776.144D 1347.6504.1558 1347.2245.1B0A 1347.1103.1025 1347.3839.17AA 1347.5037.17AA 1347.228B.1B0A 1347.80A4.103C 139C.1ACD.1043 1347.80ED.103C 1347.100D.1025 1347.2225.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce 940MX   </td><td class="markdownTableBodyLeft">134D.14B0.1043 179C.1880.1043 134D.5050.17AA 134D.398D.17AA 134D.1490.1043 134D.13CE.1043 134D.1250.1025 134D.81D4.103C 134B.39EE.17AA 134B.1606.1D72 134D.114A.1025 134D.118E.1043 134D.228F.1B0A 179C.112E.1043 134D.1134.1025 134D.6509.1558 134D.12DE.1043 134D.83FB.103C 134D.83F9.103C 134D.C14A.144D 134D.C776.144D 134D.0781.1028 134D.6504.1558 134D.0266.1854 179C.11E0.1043 134D.117E.1025 134D.8509.1558 134D.122F.1025 134D.839B.103C 134D.505E.17AA 179C.1790.1043 134D.233D.1B0A 134D.109E.1043 134D.8216.103C 134B.39F3.17AA 179C.12AE.1043 134D.119B.1462 179C.1260.1043 134D.30FC.17AA 134D.1900.1043 134D.111B.1025 134D.1167.1462 134D.1168.1025 134D.142E.1043 134D.1710.1043 134D.820A.103C 134D.39CC.17AA 134D.839A.103C 134D.1189.1025 134D.229C.1B0A 134D.159E.1043 134D.111A.1025 134D.834D.103C 134D.145E.1043 134D.116A.1025 134D.C142.144D 134D.114C.1462 134D.138E.1043 134D.1190.1462 179C.128E.1043 134D.3E03.19E5 134D.1220.1025 134B.0008.1414 134D.1650.1043 134D.9E54.17AA 134D.113E.1025 134D.81D3.103C 134D.36DD.17AA 179C.07D1.1028 134D.07EA.1028 134D.39F4.17AA 134D.81CD.103C 134D.1081.1025 134D.819F.103C 134D.8214.103C 134D.1094.1025 134D.1133.1025 134D.1252.1025 134B.1602.1D72 134D.110F.1025 179C.115E.1043 179C.108F.1025 134D.246A.1043 134D.12EE.1043 179C.1133.1025 134D.0783.1028 134D.110C.17C0 134D.3113.17AA 134D.36D0.17AA 134D.0293.1854 134D.839C.103C 134D.820C.103C 134D.36D6.17AA 134D.16AE.1043 134D.0277.1854 179C.1094.1025 134D.108F.1025 134D.1184.152D 134D.841C.103C 134D.2303.1B0A 134D.11A4.1462 179C.110F.1025 134D.83A4.103C 134D.834E.103C 134D.8365.103C 134D.C792.144D 134D.39CE.17AA 134D.39F1.17AA 134D.38E2.17AA 134D.2312.1B0A 134D.14AE.1043 134D.1240.1043 134D.10CE.1043 134D.073F.1028 134D.82C1.103C 134D.AA8E.1462 134D.3824.17AA 179C.111A.1025 134D.2232.17AA 134D.81CE.103C 134D.07EC.1028 134D.121F.1025 134D.1168.1462 134D.2246.17AA 134D.13EE.1043 134D.113C.1025 134D.8368.103C 134D.2319.1B0A 134D.141E.1043 134D.36BB.17AA 134D.5595.1991 134D.6709.1558 134D.139E.1043 134D.120E.1043 134D.83C5.103C 134D.3110.17AA 134D.0786.1028 134D.8314.103C 134D.1218.1025 134D.1183.1462 134D.0744.1028 134D.1191.1462 134D.12CE.1043 134D.112E.1025 134D.148E.1043 134D.0785.1028 134D.1720.1043 134D.114C.1025 134D.11FE.1043 179C.111B.1025 134D.119A.1025 134D.0782.1028 134D.121A.1025 134D.1138.152D 134D.13DE.1043 134D.1123.1025 134D.1158.1025 134D.8363.103C 134D.1A90.1043 134D.C14C.144D 134D.230B.1B0A 134D.0784.1028 179C.1134.1025 134D.83CE.103C 134D.15AE.1043 134D.8310.103C 134D.9833.1019 134D.5500.1558 134D.3647.17AA 179C.1700.1043 134D.22CD.1B0A 134D.11A3.1462 134D.39C8.17AA 134D.1083.1025 134D.119E.1043 134D.2281.1B0A 134D.164E.1043 134D.117C.1025 134D.2248.17AA 179C.14E0.1043 134D.3820.17AA 134D.504F.17AA 134D.505C.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce 945M   </td><td class="markdownTableBodyLeft">1399.103A.1025 1399.103B.1025 1399.1037.1025    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 750 Ti   </td><td class="markdownTableBodyLeft">139D 139D.B323.19DA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 850M   </td><td class="markdownTableBodyLeft">1391.1108.1462 1391.079C.1025 1391.189D.1043 1391.4113.1775 1391.2113.1775 1391.0859.1025 1391.6501.1558 1391.1901.172F 1391.0681.1028 1391.1102.1462 1391.5036.1B6C 1391.22A0.103C 1391.1802.172F 1391.178D.1043 1391.1A50.4352 1391.177D.1043 1391.1113.1462 1391.0113.1775 1391.129D.1043 1391.A456.1458 1391.228E.103C 1391.5018.1558 1391.110A.1462 1391.229C.103C 1391.1115.1462 1391.1A3D.1043 1391.10E3.1462 1391.0963.1025 1391.1112.1462 1391.229D.103C 1391.3801.17AA 1391.11CD.1043 1391.185D.1043 1391.0680.1028 1391.1A51.4352 1391.1120.1462 1391.228C.103C 1391.1706.172F 1391.228D.103C 1391.14AD.1043 1391.1101.152D 1391.091D.1025 1391.079B.1025 1391.154D.1043 1391.0816.1025 1391.1091.152D 1391.091C.1025 1391.0781.1025 1391.229B.103C 1391.1708.172F 1391.17BD.1043 1391.1097.152D 1391.3697.17AA 1391.1252.1775 1391.22CA.1043    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 860M   </td><td class="markdownTableBodyLeft">1392.1097.152D 1392.86D9.1043 1392.1006.1D05 1392.180D.1043 1392.0926.1025 1392.066A.1028 1392.AE67.1462 1392.3812.17AA 1392.B261.19DA 1392.186D.1043 1392.ACB6.1462 1392.2332.103C 1392.1107.1462 1392.157D.1043 1392.558B.1991 1392.2300.1558 1392.0683.1028 1392.ACB3.1462 1392.091D.1025 1392.B248.19DA 1392.1114.1462 1392.3978.17AA 1392.A456.1458 1392.AE69.1462 1392.861E.1043 1392.171D.1043 1392.111F.1462 1392.185D.1043 1392.1025.152D 1392.B230.19DA 1392.674A.1A58 1392.1109.1462 1392.3501.1558 1392.177D.1043 1392.558D.1991 1392.558C.1991    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 950M   </td><td class="markdownTableBodyLeft">139A.1183.1462 139A.80E4.103C 139A.650C.1558 139A.362F.17AA 139A.6709.1558 139A.36B9.17AA 139A.4050.1071 139A.82F3.103C 139A.10A0.1043 139A.1168.1462 139A.116B.1462 139A.1033.1025 139A.8110.103C 139A.103A.1025 139A.AEA2.1462 139A.80DE.103C 139A.C12B.144D 139A.18A0.1043 139A.22BE.1B0A 139A.1060.1043 139A.825B.103C 139A.5019.1558 139A.8258.103C 139A.2312.1B0A 139A.0719.1028 139A.80E5.103C 139A.820D.103C 139A.1112.1462 139A.1139.1462 139A.113B.1462 139A.11A4.1462 139A.1138.1462 139A.2303.1B0A 139A.0963.1025 139A.10E3.1462 139A.230A.1B0A 139A.1102.152D 139A.108F.1025 139A.36D6.17AA 139A.86CE.1043 139A.8709.1558 139A.8188.103C 139A.185D.1043 139A.11CD.1043 139A.6507.1558 139A.3801.17AA 139A.1ACD.1043 139A.505C.17AA 139A.816B.103C 139A.1109.1462 139A.077B.1028 139A.2281.1B0A 139A.11A3.1462 139A.22CD.1B0A 139A.091B.1025 139A.3647.17AA 139A.113A.1462 139A.5500.1558 139A.9833.1019 139A.825E.103C 139A.1510.1043 139A.80E6.103C 139A.1790.1043 139A.1102.1462 139A.17B0.1043 139A.11E0.1043 139A.147E.1043 139A.1A8D.1043 139A.178D.1043 139A.80EE.103C 139A.177D.1043 139A.1191.1462 139A.1260.1043 139A.103B.1025 139A.1113.1462 139A.8155.103C 139A.1C9D.1043 139A.1167.1462 139A.111B.1025 139A.0151.1558 139A.17BD.1043 139A.825C.103C 139A.6505.1558 139A.119B.1462 139A.1097.152D 139A.3640.17AA 139A.86F0.1043 139A.8509.1558 139A.115A.1462 139A.825D.103C 139A.B456.1458 139A.80EC.103C 139A.670C.1558 139A.363F.17AA 139A.6508.1558 139A.F84A.1179 139A.6509.1558 139A.1134.1025 139A.826A.103C 139A.F843.1179 139A.14E0.1043 139A.80ED.103C 139A.80A9.103C 139A.8257.103C 139A.362C.17AA 139A.5580.1B50 139A.4050.1017 139A.116C.1462 139A.8269.103C 139A.650A.1558 139A.241A.1043 139A.129E.1043 139A.380B.17AA 139A.1128.152D 139A.1129.152D 139A.AEA1.1462 139A.80DC.103C 139A.1094.1025 139A.12BE.1043 139A.1D1D.1043 139A.1107.1462 139A.111E.1043 139A.116E.1043 139A.80DD.103C 139A.1130.1043 139A.13CF.1043 139A.1190.1462 139A.091D.1025 139A.114C.1462 139A.0995.1025 139A.F842.1179 139A.22C4.1B0A 139A.8421.103C 139A.403E.1071 139A.2286.1B0A 139A.1037.1025 139A.24AA.1043 139A.86DE.1043 139A.3802.17AA 139A.820E.103C 139A.111A.1025 139A.114D.1462 139A.229C.1B0A 139A.113E.1043 139A.115B.1462 139A.86D3.1043    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce GTX 960M   </td><td class="markdownTableBodyLeft">139B.86EF.1043 139B.3830.17AA 139B.0707.1028 139B.3802.17AA 139B.AF1A.1462 139B.820E.103C 139B.091D.1025 139B.8671.1043 139B.1C5D.1043 139B.1021.1D05 139B.1D3D.1043 139B.115B.1462 139B.1128.152D 139B.2555.1458 139B.C248.19DA 139B.AEA1.1462 139B.1129.152D 139B.5055.17AA 139B.1701.1558 139B.3649.17AA 139B.650A.1558 139B.0172.1558 139B.186D.1043 139B.558F.1991 139B.1107.1462 139B.1D6D.1043 139B.06A3.1028 139B.0170.1558 139B.2316.1558 139B.1420.1043 139B.1D8D.1043 139B.AE6D.1462 139B.100E.1D05 139B.AE6C.1462 139B.1090.1043 139B.1502.1558 139B.116C.1462 139B.3812.17AA 139B.558E.1991 139B.14E0.1043 139B.8257.103C 139B.2B64.103C 139B.825C.103C 139B.674C.1A58 139B.ACB8.1462 139B.06E1.1028 139B.110E.1043 139B.1167.1462 139B.0926.1025 139B.820F.103C 139B.AF19.1462 139B.2333.103C 139B.115A.1462 139B.825D.103C 139B.B456.1458 139B.86D8.1043 139B.8210.103C 139B.1097.152D 139B.1BFD.1043 139B.11E0.1043 139B.3550.1558 139B.1B4D.1043 139B.0006.17AA 139B.104A.1025 139B.AE6E.1462 139B.1501.1558 139B.86C5.1043 139B.1102.1462 139B.1103.152D 139B.1260.1043 139B.1039.1025 139B.103B.1025 139B.177D.1043 139B.06E4.1028 139B.9977.1170 139B.AE82.1462 139B.2B4C.103C 139B.1109.1462 139B.0705.1028 139B.0152.1558 139B.113A.1462 139B.825E.103C 139B.1510.1043 139B.1080.1043 139B.107A.1025 139B.86A3.1043 139B.86AA.1043 139B.0150.1558 139B.0706.1028 139B.1103.1462 139B.820D.103C 139B.5594.1991 139B.18DD.1043 139B.0797.1028 139B.8179.103C 139B.825B.103C 139B.8258.103C 139B.119C.1462 139B.185D.1043 139B.1121.152D 139B.1139.1462 139B.113B.1462 139B.1138.1462 139B.1102.152D 139B.A757.1458 139B.5592.1991 139B.8A75.1AFA 139B.AE6F.1462 139B.AEA2.1462 139B.ACB7.1462 139B.36BF.17AA 139B.3978.17AA 139B.1702.1558 139B.1168.1462 139B.116B.1462 139B.171D.1043 139B.86C6.1043 139B.86C0.1043 139B.1033.1025 139B.AE6B.1462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX110   </td><td class="markdownTableBodyLeft">174E.84A7.103C 174E.10F1.1043 174E.0852.1028 174E.85EE.103C 174E.19DE.1043 174E.C804.144D 174E.398B.17AA 174E.3978.17AA 174E.84DE.103C 174E.397B.17AA 174E.10B1.1043 174E.86B4.103C 174E.85F0.103C 174E.10E1.1043 174E.85F6.103C 174E.1361.1043 174E.19EE.1043 174E.0853.1028 174E.1F60.1043 174E.85F2.103C 174E.1731.1043 174E.862E.103C 174E.8431.103C 174E.08F9.1028 174E.08F8.1028 174E.1161.1043 174E.8447.103C 174E.8533.103C 174E.8634.103C 174E.194E.1043 174E.86C4.103C 174E.19AF.1043 174E.84AB.103C 174E.84A9.103C 174E.177E.1043 174E.174E.1043 174E.86C2.103C 174E.8513.103C 174E.8632.103C 174E.1A0E.1043 174E.1D2E.1043 174E.197E.1043 174E.84A5.103C 174E.8446.103C 174E.18DE.1043 174E.3F0E.17AA 174E.39CC.17AA 174E.86C0.103C 174E.8630.103C 174E.2444.1B0A 174E.5516.1B50 174E.243E.1B0A 174E.193E.1043 174E.176E.1043 174E.19CE.1043 174E.1A6E.1043 174E.171E.1043    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA GeForce MX130   </td><td class="markdownTableBodyLeft">174D.2303.1B0A 174D.1D3E.1043 174D.841C.103C 174D.86E2.103C 174D.1393.1025 174D.8492.103C 174D.1421.1025 174D.84A7.103C 174D.39CE.17AA 174D.861C.103C 174D.8365.103C 174D.17DE.1043 174D.83A4.103C 174D.121F.1025 174D.07EC.1028 174D.84BF.103C 174D.86B4.103C 174D.85F0.103C 174D.397B.17AA 174D.1141.1043 174D.089E.1028 174D.1218.1025 174D.398B.17AA 174D.83C5.103C 174D.128E.1025 174D.869F.103C 174D.1273.1025 174D.113C.1025 174D.8368.103C 174D.1101.1043 174D.85EE.103C 174D.192E.1043 174D.1AFE.1043 174D.119A.1025 174D.8487.103C 174D.0817.1028 174D.127F.1025 174D.1392.1025 174D.862E.103C 174D.1131.1043 174D.10D1.1043 174D.127B.1025 174D.1279.1025 174D.1F10.1043 174D.85F2.103C 174D.84D8.103C 174D.089F.1028 174D.121A.1025 174D.84BA.103C 174D.19FE.1043 174D.8310.103C 174D.83CE.103C 174D.08A7.1028 174D.1418.1025 174D.84C1.103C 174D.1275.1025 174D.85F4.103C 174D.8541.103C 174D.8676.103C 174D.0816.1028 174D.85CE.103C 174D.84A9.103C 174D.1250.1025 174D.84AB.103C 174D.398D.17AA 174D.1151.1043 174D.86C4.103C 174D.850F.103C 174D.83F9.103C 174D.83FB.103C 174D.1134.1025 174D.8634.103C 174D.126C.1025 174D.84BC.103C 174D.398C.17AA 174D.8533.103C 174D.866F.103C 174D.233D.1B0A 174D.84A5.103C 174D.8542.103C 174D.122F.1025 174D.1204.152D 174D.1168.1025 174D.189E.1043 174D.1420.1025 174D.18BE.1043 174D.198E.1043 174D.3977.17AA 174D.86A2.103C 174D.86C2.103C 174D.1277.1025 174D.191E.1043 174D.39CC.17AA 174D.86C0.103C 174D.1258.1025 174D.0819.1028 174D.86E1.103C 174D.1380.1025 174D.0818.1028 174D.1F20.1043 174D.116A.1025 174D.85C5.103C 174D.1A1E.1043 174D.39F4.17AA 174D.07EA.1028 174D.089C.1028 174D.1121.1043 174D.113E.1025 174D.131F.1025 174D.12EE.1043 174D.089D.1028 174D.1252.1025 174D.1296.1025 174D.08A9.1028 174D.1417.1025 174D.1133.1025 174D.08A8.1028    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA N15M-Q3   </td><td class="markdownTableBodyLeft">137A.2232.17AA 137A.505A.17AA 137A.2225.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro K2200M   </td><td class="markdownTableBodyLeft">13B3.113E.1462 13B3.05CD.1028 13B3.1103.1462 13B3.2255.103C 13B3.15CD.1028 13B3.2256.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M1000M   </td><td class="markdownTableBodyLeft">13B1.7700.1558 13B1.116C.1462 13B1.1177.1462 13B1.16D9.1028 13B1.222E.17AA 13B1.194E.10CF 13B1.7702.1558 13B1.80D6.103C 13B1.194D.10CF 13B1.7500.1558 13B1.8108.103C 13B1.116B.1462 13B1.06D9.1028 13B1.8109.103C 13B1.80D4.103C 13B1.2230.17AA 13B1.810A.103C 13B1.7502.1558 13B1.80D5.103C 13B1.01CF.1B0A 13B1.06E5.1028    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M1200   </td><td class="markdownTableBodyLeft">13B6.80D6.103C 13B6.8277.103C 13B6.17B0.1028 13B6.8109.103C 13B6.2251.17AA 13B6.810A.103C 13B6.826D.103C 13B6.1967.10CF 13B6.07B1.1028 13B6.80D5.103C 13B6.196A.10CF 13B6.17B1.1028 13B6.07BF.1028 13B6.115A.1462 13B6.8275.103C 13B6.8272.103C 13B6.224D.17AA 13B6.8270.103C 13B6.07B0.1028 13B6.1033.1D05 13B6.826B.103C    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M2000M   </td><td class="markdownTableBodyLeft">13B0.1176.1462 13B0.194C.10CF 13B0.80D6.103C 13B0.06D9.1028 13B0.8109.103C 13B0.116B.1462 13B0.2230.17AA 13B0.810A.103C 13B0.80D5.103C 13B0.116C.1462 13B0.194B.10CF 13B0.16D9.1028 13B0.222E.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M520   </td><td class="markdownTableBodyLeft">137B.2248.17AA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NVIDIA Quadro M600M   </td><td class="markdownTableBodyLeft">13B2.810A.103C 13B2.1950.10CF 13B2.01CF.1B0A 13B2.80D5.103C 13B2.222D.17AA 13B2.116B.1462 13B2.116C.1462 13B2.194F.10CF 13B2.222F.17AA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">NVIDIA Quadro M620   </td><td class="markdownTableBodyLeft">13B4.824D.103C 13B4.8277.103C 13B4.824C.103C 13B4.07A9.1028 13B4.224C.17AA 13B4.1969.10CF 13B4.2250.17AA 13B4.8275.103C 13B4.1966.10CF   </td></tr>
</table>
<h1><a class="anchor" id="nvn_guide_sec_25"></a>
25. NVN and OpenGL ES</h1>
<p>Applications can use the OpenGL ES graphics API in addition to NVN, and there is limited support for sharing resources between the two. Numerous resources for OpenGL ES programming exist, and its use as an independent API will not be covered here. OpenGL ES versions 2.0, 3.0, 3.1, and 3.2 are supported. OpenGL ES 1.0 and 1.1 are not supported.</p>
<h2><a class="anchor" id="nvn_guide_sec_25_1"></a>
25.1. Creating an OpenGL ES context</h2>
<p>On the Windows reference platform, OpenGL ES is exposed via the standard NVIDIA OpenGL ICD, which is compatible with OpenGL ES via the GL_ARB_ES3_2_compatibility OpenGL extension.</p>
<p>On the NX device, an OpenGL ES context is bootstrapped via the EGL API. Native handles obtained from the window library may be used to create EGLSurface objects, or contexts may use pure offscreen rendering (e.g., via pbuffers or surfaceless contexts).</p>
<p>A current limitation of the NX driver is that if OpenGL ES and NVN are to be used in the same process, the OpenGL ES context must be made current before using any NVN API entrypoints. This limitation will be lifted in a future release.</p>
<h2><a class="anchor" id="nvn_guide_ogl_interop"></a>
25.2. NVN and OpenGL ES Interoperation</h2>
<p><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> objects can be created from OpenGL ES textures. The resulting NVN texture will inherit its attributes from the OpenGL ES texture, and will share its texel storage. To use an OpenGL ES texture as the source of an NVN texture, specify the name of the OpenGL ES texture using <a class="el" href="classnvn_1_1_texture_builder.html#a71e4c3993cc1e351373fd1b78f8b6c78" title="Set the name of the OpenGL texture to use as an external texture source.">nvn::TextureBuilder::SetGLTextureName</a>. Setting a non-zero name will supersede any state specified in the <a class="el" href="classnvn_1_1_texture_builder.html" title="Object specifying state used to construct new texture objects.">nvn::TextureBuilder</a>, except for the Device. When nvn::Texture::Initialized is called with a non-zero GL texture name, the provided name is used to look up a GL texture object using the OpenGL or OpenGL ES context bound on the thread performing the initialization. If a GL texture object is found, the NVN texture is initialized using the state of the GL texture. If no GL texture is found the results of NVN texture initialization are undefined.</p>
<p>There are a number of restrictions on the set of GL textures that can be shared with NVN:</p>
<ul>
<li>The GL texture must be an <em>immutable-format</em> texture.</li>
<li>All GL texture attributes (e.g., target, internal format, etc.) must have NVN equivalents.</li>
<li>Buffer textures are not supported.</li>
<li>Sparse textures are not supported.</li>
</ul>
<p>Once the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object is created, the application is responsible for ensuring that the source texture is not destroyed while the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">nvn::Texture</a> object is in use. Additionally, the application is responsible for synchronizing any texture accesses by either the NVN or OpenGL ES command queues. At present, no cross-API synchronization is supported, so applications must use the CPU to synchronize access using OpenGL/OpenGL ES GLsync and <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> objects.</p>
<p><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> objects can be create from OpenGL Sync objects, and vice-versa. See <a class="el" href="classnvn_1_1_sync.html#ad3ec8da86bb311a28b3a500520d18e8b" title="Use a fenced and flushed NVN Sync object to create a GLsync.">nvn::Sync::CreateGLSync</a> (the source object is the <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">nvn::Sync</a> and the derived object the OpenGL ES Sync object) and <a class="el" href="classnvn_1_1_sync.html#a500dc632d5f1dbc78881c6ad675f9202" title="Use a fenced and flushed GLsync object to initialize a NVN Sync object.">nvn::Sync::InitializeFromFencedGLSync</a> (with reversed source and derived objects) for more details.</p>
<p>There are a few restrictions that apply here as well:</p><ul>
<li>The source object must be valid.</li>
<li>The source object must be fenced when creating the derived object.</li>
<li>The lifetimes of the both objects should be matched.</li>
<li>On the Windows reference platform, using this prevents you from using OpenCL/OpenGL interoperability.</li>
</ul>
<blockquote class="doxtable">
<p>Note: On the windows reference platform, if the application used OpenCL/OpenGL synchronization interoperability before reaching <a class="el" href="classnvn_1_1_sync.html#ad3ec8da86bb311a28b3a500520d18e8b" title="Use a fenced and flushed NVN Sync object to create a GLsync.">nvn::Sync::CreateGLSync</a>, it will fail to generate a GLsync object with an explicit error. But if the application uses OpenCL/OpenGL interoperability after creating GLsync objects through this mechanism, the behavior of said objects is undefined, possibly including hangs or crashes. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
