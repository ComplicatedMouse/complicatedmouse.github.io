<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::account Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1account.html">account</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nn::account Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for the Account System features.  
<a href="namespacenn_1_1account.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_async_context.html">AsyncContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that expresses the state of previously called asynchronous processes.  <a href="classnn_1_1account_1_1_async_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_network_service_account_id.html">NetworkServiceAccountId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The network service account ID.  <a href="structnn_1_1account_1_1_network_service_account_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_nickname.html">Nickname</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user's nickname.  <a href="structnn_1_1account_1_1_nickname.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html">NintendoAccountAuthorizationRequestContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class representing requests to get authorization from a Nintendo Account.  <a href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_nintendo_account_authorization_request_parameters.html">NintendoAccountAuthorizationRequestParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters to use for the OAuth 2.0/Open ID Connect procedures with the Nintendo Account server.  <a href="structnn_1_1account_1_1_nintendo_account_authorization_request_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_cancelled.html">ResultCancelled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: Processing was suspended according to a request from the caller.).  <a href="classnn_1_1account_1_1_result_cancelled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">ResultCancelledByUser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: Processing was suspended according to user operations.).  <a href="classnn_1_1account_1_1_result_cancelled_by_user.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_network_communication_error.html">ResultNetworkCommunicationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: Network communication errors.).  <a href="classnn_1_1account_1_1_result_network_communication_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html">ResultNetworkServiceAccountUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: The network service account is not in a state where it can be used.).  <a href="classnn_1_1account_1_1_result_network_service_account_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_nintendo_account_authorization_interaction_required.html">ResultNintendoAccountAuthorizationInteractionRequired</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: Interaction with the user is required to get Nintendo Account authorization.).  <a href="classnn_1_1account_1_1_result_nintendo_account_authorization_interaction_required.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_token_cache_unavailable.html">ResultTokenCacheUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: Cannot use token cache.).  <a href="classnn_1_1account_1_1_result_token_cache_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1account_1_1_result_user_not_exist.html">ResultUserNotExist</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>account</code>: User account does not exist.).  <a href="classnn_1_1account_1_1_result_user_not_exist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User identifiers added to the account system.  <a href="structnn_1_1account_1_1_uid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle for dealing with a user in the <code>Open</code> state.  <a href="structnn_1_1account_1_1_user_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1account_1_1_user_selection_settings.html">UserSelectionSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for configuring how to display the user selection UI.  <a href="structnn_1_1account_1_1_user_selection_settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:accb35b97a8eca5f6690436550b8b29fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#accb35b97a8eca5f6690436550b8b29fa">PopOpenUsers</a> (int *pOut, <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> outHandles[], int outHandleCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:accb35b97a8eca5f6690436550b8b29fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> of user accounts being maintained in the <code>Open</code> state between programs.  <a href="namespacenn_1_1account.html#accb35b97a8eca5f6690436550b8b29fa">More...</a><br /></td></tr>
<tr class="separator:accb35b97a8eca5f6690436550b8b29fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdef7d061fbc4072e4c003a32ea13e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aecdef7d061fbc4072e4c003a32ea13e8">PushOpenUsers</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aecdef7d061fbc4072e4c003a32ea13e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes user accounts in the <code>Open</code> state available between different programs while maintaining that state.  <a href="namespacenn_1_1account.html#aecdef7d061fbc4072e4c003a32ea13e8">More...</a><br /></td></tr>
<tr class="separator:aecdef7d061fbc4072e4c003a32ea13e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">General Functionality of the Account System</div></td></tr>
<tr class="memitem:abbb0c49f87242e7bd3402c3dcadf6af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#abbb0c49f87242e7bd3402c3dcadf6af8">GetUserCount</a> (int *pOutCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abbb0c49f87242e7bd3402c3dcadf6af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of users added to the account system.  <a href="namespacenn_1_1account.html#abbb0c49f87242e7bd3402c3dcadf6af8">More...</a><br /></td></tr>
<tr class="separator:abbb0c49f87242e7bd3402c3dcadf6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4882ef04d54dca91709f1eb99a888a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a4d4882ef04d54dca91709f1eb99a888a">GetUserExistence</a> (bool *pOutExistence, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4d4882ef04d54dca91709f1eb99a888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a user and determines whether that user has been added to the account system.  <a href="namespacenn_1_1account.html#a4d4882ef04d54dca91709f1eb99a888a">More...</a><br /></td></tr>
<tr class="separator:a4d4882ef04d54dca91709f1eb99a888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456d8bfd2e6389402878af77bc7ecf95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a456d8bfd2e6389402878af77bc7ecf95">ListAllUsers</a> (int *pOutActualLength, <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *outUsers, int arrayLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a456d8bfd2e6389402878af77bc7ecf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of users added to the account system.  <a href="namespacenn_1_1account.html#a456d8bfd2e6389402878af77bc7ecf95">More...</a><br /></td></tr>
<tr class="separator:a456d8bfd2e6389402878af77bc7ecf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bd69651c225e00698b953f2cb952f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a305bd69651c225e00698b953f2cb952f">ListOpenUsers</a> (int *pOutActualLength, <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *outUsers, int arrayLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a305bd69651c225e00698b953f2cb952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of users currently in an open state.  <a href="namespacenn_1_1account.html#a305bd69651c225e00698b953f2cb952f">More...</a><br /></td></tr>
<tr class="separator:a305bd69651c225e00698b953f2cb952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe31852e1c6d319176e313590000dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#affe31852e1c6d319176e313590000dfe">GetLastOpenedUser</a> (<a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *pOutUser) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:affe31852e1c6d319176e313590000dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> for the last user set to an open state.  <a href="namespacenn_1_1account.html#affe31852e1c6d319176e313590000dfe">More...</a><br /></td></tr>
<tr class="separator:affe31852e1c6d319176e313590000dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f04aa7c270a427ff5c7b29eaf97b1a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a1f04aa7c270a427ff5c7b29eaf97b1a2">GetNickname</a> (<a class="el" href="structnn_1_1account_1_1_nickname.html">Nickname</a> *pOut, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1f04aa7c270a427ff5c7b29eaf97b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a user and gets that user's nickname.  <a href="namespacenn_1_1account.html#a1f04aa7c270a427ff5c7b29eaf97b1a2">More...</a><br /></td></tr>
<tr class="separator:a1f04aa7c270a427ff5c7b29eaf97b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1453bf855e6f676a8683c07eeff4a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aaa1453bf855e6f676a8683c07eeff4a0">LoadProfileImage</a> (size_t *pOutActualSize, void *outImage, size_t bufferSize, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa1453bf855e6f676a8683c07eeff4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a user and gets that user's profile image.  <a href="namespacenn_1_1account.html#aaa1453bf855e6f676a8683c07eeff4a0">More...</a><br /></td></tr>
<tr class="separator:aaa1453bf855e6f676a8683c07eeff4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functionality for Account System Applications</div></td></tr>
<tr class="memitem:ac5870470963c9923c63f76e03c8c024e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e">Initialize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac5870470963c9923c63f76e03c8c024e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins using the account system.  <a href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e">More...</a><br /></td></tr>
<tr class="separator:ac5870470963c9923c63f76e03c8c024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ff6287a526dcdb7d596fa34b5a9d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a00ff6287a526dcdb7d596fa34b5a9d2b">ListQualifiedUsers</a> (int *pOutActualLength, <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> outUsers[], int arrayLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a00ff6287a526dcdb7d596fa34b5a9d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of users that have no restrictions (a list of qualified users).  <a href="namespacenn_1_1account.html#a00ff6287a526dcdb7d596fa34b5a9d2b">More...</a><br /></td></tr>
<tr class="separator:a00ff6287a526dcdb7d596fa34b5a9d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fd27c776fbc31c918ea0a84ddb1f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41">OpenUser</a> (<a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *pOutHandle, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a06fd27c776fbc31c918ea0a84ddb1f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a user to an open state and gets the appropriate handle.  <a href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41">More...</a><br /></td></tr>
<tr class="separator:a06fd27c776fbc31c918ea0a84ddb1f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3ac7d2b7f91b612062aaf7859de8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a1a3ac7d2b7f91b612062aaf7859de8c3">TryOpenPreselectedUser</a> (<a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *pOutHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a3ac7d2b7f91b612062aaf7859de8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a user account selected before the application starts, changes the user to the <code>Open</code> state and gets the appropriate handle.  <a href="namespacenn_1_1account.html#a1a3ac7d2b7f91b612062aaf7859de8c3">More...</a><br /></td></tr>
<tr class="separator:a1a3ac7d2b7f91b612062aaf7859de8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ced19bd37a8a2199a5a879437b0716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#af8ced19bd37a8a2199a5a879437b0716">OpenPreselectedUser</a> (<a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *pOutHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8ced19bd37a8a2199a5a879437b0716"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has been deprecated.  <a href="namespacenn_1_1account.html#af8ced19bd37a8a2199a5a879437b0716">More...</a><br /></td></tr>
<tr class="separator:af8ced19bd37a8a2199a5a879437b0716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1a6e0b8cbcef6f62eae042bca5b7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aaf1a6e0b8cbcef6f62eae042bca5b7cb">CloseUser</a> (const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaf1a6e0b8cbcef6f62eae042bca5b7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of the user indicated by the specified handle to <code>Closed</code>.  <a href="namespacenn_1_1account.html#aaf1a6e0b8cbcef6f62eae042bca5b7cb">More...</a><br /></td></tr>
<tr class="separator:aaf1a6e0b8cbcef6f62eae042bca5b7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b05fba3684f82f092acd6bbb7d6ed7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a0b05fba3684f82f092acd6bbb7d6ed7f">GetUserId</a> (<a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *pOut, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b05fba3684f82f092acd6bbb7d6ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the user account ID indicated by the specified handle.  <a href="namespacenn_1_1account.html#a0b05fba3684f82f092acd6bbb7d6ed7f">More...</a><br /></td></tr>
<tr class="separator:a0b05fba3684f82f092acd6bbb7d6ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6aca5d7fd762684b1ee408a35d99f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6">EnsureNetworkServiceAccountAvailable</a> (const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3f6aca5d7fd762684b1ee408a35d99f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks network service account availability.  <a href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6">More...</a><br /></td></tr>
<tr class="separator:a3f6aca5d7fd762684b1ee408a35d99f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c65699d63a542a921a67472e66d642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a97c65699d63a542a921a67472e66d642">IsNetworkServiceAccountAvailable</a> (bool *pOut, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97c65699d63a542a921a67472e66d642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an Open handle and determines whether the network service account can be used.  <a href="namespacenn_1_1account.html#a97c65699d63a542a921a67472e66d642">More...</a><br /></td></tr>
<tr class="separator:a97c65699d63a542a921a67472e66d642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a800930ca2f1f5b402bf4cc25db7f1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a8a800930ca2f1f5b402bf4cc25db7f1d">GetNetworkServiceAccountId</a> (<a class="el" href="structnn_1_1account_1_1_network_service_account_id.html">NetworkServiceAccountId</a> *pOutId, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a800930ca2f1f5b402bf4cc25db7f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a handle for a user in an open state, and gets that user's network service account ID.  <a href="namespacenn_1_1account.html#a8a800930ca2f1f5b402bf4cc25db7f1d">More...</a><br /></td></tr>
<tr class="separator:a8a800930ca2f1f5b402bf4cc25db7f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade43b0fd5b5f5e1ec1752efe37d1ed97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97">EnsureNetworkServiceAccountIdTokenCacheAsync</a> (<a class="el" href="classnn_1_1account_1_1_async_context.html">AsyncContext</a> *pOutContext, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade43b0fd5b5f5e1ec1752efe37d1ed97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a user handle and allocates a cache for the network service account's ID token.  <a href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97">More...</a><br /></td></tr>
<tr class="separator:ade43b0fd5b5f5e1ec1752efe37d1ed97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae1661923ba118f18a5b4af7ff1011a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#afae1661923ba118f18a5b4af7ff1011a">LoadNetworkServiceAccountIdTokenCache</a> (size_t *pOutActualSize, char *buffer, size_t bufferSize, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afae1661923ba118f18a5b4af7ff1011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a user handle and gets the cache for the network service account's ID token.  <a href="namespacenn_1_1account.html#afae1661923ba118f18a5b4af7ff1011a">More...</a><br /></td></tr>
<tr class="separator:afae1661923ba118f18a5b4af7ff1011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97db15f53d40e45b87cbbbc5dfdf17be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a97db15f53d40e45b87cbbbc5dfdf17be">CreateNintendoAccountAuthorizationRequest</a> (<a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html">NintendoAccountAuthorizationRequestContext</a> *pOutRequest, const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle, const <a class="el" href="structnn_1_1account_1_1_nintendo_account_authorization_request_parameters.html">NintendoAccountAuthorizationRequestParameters</a> &amp;param, void *workBuffer, size_t workBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97db15f53d40e45b87cbbbc5dfdf17be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a request to get authorization from a Nintendo Account linked to a network service account.  <a href="namespacenn_1_1account.html#a97db15f53d40e45b87cbbbc5dfdf17be">More...</a><br /></td></tr>
<tr class="separator:a97db15f53d40e45b87cbbbc5dfdf17be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2f73beb9fe78af782a69c7a78b0050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aca2f73beb9fe78af782a69c7a78b0050">StoreSaveDataThumbnailImage</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;uid, const void *imageBuffer, size_t imageBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aca2f73beb9fe78af782a69c7a78b0050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the save data thumbnail image that is displayed in the user selection UI.  <a href="namespacenn_1_1account.html#aca2f73beb9fe78af782a69c7a78b0050">More...</a><br /></td></tr>
<tr class="separator:aca2f73beb9fe78af782a69c7a78b0050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa136f7db1016840d31cf72ce71a72f69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aa136f7db1016840d31cf72ce71a72f69">DeleteSaveDataThumbnailImage</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;uid) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa136f7db1016840d31cf72ce71a72f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the save data thumbnail image displayed in the user selection UI.  <a href="namespacenn_1_1account.html#aa136f7db1016840d31cf72ce71a72f69">More...</a><br /></td></tr>
<tr class="separator:aa136f7db1016840d31cf72ce71a72f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc177826dbe4c44de797c0c23fe4b472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#abc177826dbe4c44de797c0c23fe4b472">PromoteQualification</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abc177826dbe4c44de797c0c23fe4b472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a UI to direct the promotion of the user to the unrestricted state.  <a href="namespacenn_1_1account.html#abc177826dbe4c44de797c0c23fe4b472">More...</a><br /></td></tr>
<tr class="separator:abc177826dbe4c44de797c0c23fe4b472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functionality Specific to User Selection UI Calls</div></td></tr>
<tr class="memitem:a749534bdfdee56eebe9203a526390b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a749534bdfdee56eebe9203a526390b32">ShowUserSelector</a> (<a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *pOut, const <a class="el" href="structnn_1_1account_1_1_user_selection_settings.html">UserSelectionSettings</a> &amp;arg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a749534bdfdee56eebe9203a526390b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the UI for selecting users.  <a href="namespacenn_1_1account.html#a749534bdfdee56eebe9203a526390b32">More...</a><br /></td></tr>
<tr class="separator:a749534bdfdee56eebe9203a526390b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4361809245aa7ba31faebc3686f8aaea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a4361809245aa7ba31faebc3686f8aaea">ShowUserSelector</a> (<a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *pOut) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4361809245aa7ba31faebc3686f8aaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the UI for selecting users.  <a href="namespacenn_1_1account.html#a4361809245aa7ba31faebc3686f8aaea">More...</a><br /></td></tr>
<tr class="separator:a4361809245aa7ba31faebc3686f8aaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffe66d07e66590baff98b70b30722d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a4ffe66d07e66590baff98b70b30722d7">ShowUserCreator</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4ffe66d07e66590baff98b70b30722d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the UI for creating new users.  <a href="namespacenn_1_1account.html#a4ffe66d07e66590baff98b70b30722d7">More...</a><br /></td></tr>
<tr class="separator:a4ffe66d07e66590baff98b70b30722d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d3b1a71167484e01d54e08c580acc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#af4d3b1a71167484e01d54e08c580acc1">ShowLicenseRequirementsForNetworkService</a> (const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af4d3b1a71167484e01d54e08c580acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays license information for the network service to requesting users.  <a href="namespacenn_1_1account.html#af4d3b1a71167484e01d54e08c580acc1">More...</a><br /></td></tr>
<tr class="separator:af4d3b1a71167484e01d54e08c580acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical Capacity of the Account System</div></td></tr>
<tr class="memitem:a1e7ac3fae982d6a6825e8f242ee61d2b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a1e7ac3fae982d6a6825e8f242ee61d2b">UserCountMax</a> = 8</td></tr>
<tr class="memdesc:a1e7ac3fae982d6a6825e8f242ee61d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of users that the account system can manage at the same time.  <a href="namespacenn_1_1account.html#a1e7ac3fae982d6a6825e8f242ee61d2b">More...</a><br /></td></tr>
<tr class="separator:a1e7ac3fae982d6a6825e8f242ee61d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1287bb99842cbc1f1ac21d86a1f80737"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a1287bb99842cbc1f1ac21d86a1f80737">NicknameBytesMax</a> = 32</td></tr>
<tr class="memdesc:a1287bb99842cbc1f1ac21d86a1f80737"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes for nicknames that can be configured for users.  <a href="namespacenn_1_1account.html#a1287bb99842cbc1f1ac21d86a1f80737">More...</a><br /></td></tr>
<tr class="separator:a1287bb99842cbc1f1ac21d86a1f80737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48034b809eb0ddc1a8c1dbcd8133f9c3"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a48034b809eb0ddc1a8c1dbcd8133f9c3">ProfileImageBytesMax</a> = 128 * 1024</td></tr>
<tr class="memdesc:a48034b809eb0ddc1a8c1dbcd8133f9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of bytes for a profile image that can be set by the user.  <a href="namespacenn_1_1account.html#a48034b809eb0ddc1a8c1dbcd8133f9c3">More...</a><br /></td></tr>
<tr class="separator:a48034b809eb0ddc1a8c1dbcd8133f9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27559177c66aded724c5691d7c98c3d0"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a27559177c66aded724c5691d7c98c3d0">NetworkServiceAccountIdTokenLengthMax</a> = 3072</td></tr>
<tr class="memdesc:a27559177c66aded724c5691d7c98c3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the network service account ID token.  <a href="namespacenn_1_1account.html#a27559177c66aded724c5691d7c98c3d0">More...</a><br /></td></tr>
<tr class="separator:a27559177c66aded724c5691d7c98c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1b12020bba6639ccef79d23f89161"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a57a1b12020bba6639ccef79d23f89161">NintendoAccountAuthorizationCodeLengthMax</a> = 512</td></tr>
<tr class="memdesc:a57a1b12020bba6639ccef79d23f89161"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of the Nintendo Account authorization code.  <a href="namespacenn_1_1account.html#a57a1b12020bba6639ccef79d23f89161">More...</a><br /></td></tr>
<tr class="separator:a57a1b12020bba6639ccef79d23f89161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f60d4be447019cfb6f4e58a50531b2"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#aa2f60d4be447019cfb6f4e58a50531b2">NintendoAccountIdTokenLengthMax</a> = 1536</td></tr>
<tr class="memdesc:aa2f60d4be447019cfb6f4e58a50531b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of the Nintendo Account account ID token.  <a href="namespacenn_1_1account.html#aa2f60d4be447019cfb6f4e58a50531b2">More...</a><br /></td></tr>
<tr class="separator:aa2f60d4be447019cfb6f4e58a50531b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8463419c967fe243faedf8c88e0cf47b"><td class="memItemLeft" align="right" valign="top"><a id="a8463419c967fe243faedf8c88e0cf47b"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a8463419c967fe243faedf8c88e0cf47b">RequiredBufferSizeForNintendoAccountAuthorizationRequestContext</a> = 4096</td></tr>
<tr class="memdesc:a8463419c967fe243faedf8c88e0cf47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer size, in bytes, needed for creating a valid <code><a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html" title="The class representing requests to get authorization from a Nintendo Account.">nn::account::NintendoAccountAuthorizationRequestContext</a></code> object. <br /></td></tr>
<tr class="separator:a8463419c967fe243faedf8c88e0cf47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Definitions of Types and Values for the User Selection UI</div></td></tr>
<tr class="memitem:acc263608192f7bbdef34e3b5ae007258"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1account_1_1_user_selection_settings.html">UserSelectionSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#acc263608192f7bbdef34e3b5ae007258">DefaultUserSelectionSettings</a> = {{<a class="el" href="namespacenn_1_1account.html#ae6d17c482c1a86531eb4fbbcc542ef6b">InvalidUid</a>}, false, false, false, false, false}</td></tr>
<tr class="memdesc:acc263608192f7bbdef34e3b5ae007258"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the default settings when calling the user selection UI.  <a href="namespacenn_1_1account.html#acc263608192f7bbdef34e3b5ae007258">More...</a><br /></td></tr>
<tr class="separator:acc263608192f7bbdef34e3b5ae007258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Definitions of the Account System's Foundation Types, Values, and Operators</h2></td></tr>
<tr class="memitem:ae6d17c482c1a86531eb4fbbcc542ef6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#ae6d17c482c1a86531eb4fbbcc542ef6b">InvalidUid</a> = {{0x00ull, 0x00ull}}</td></tr>
<tr class="memdesc:ae6d17c482c1a86531eb4fbbcc542ef6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> value that is always invalid.  <a href="namespacenn_1_1account.html#ae6d17c482c1a86531eb4fbbcc542ef6b">More...</a><br /></td></tr>
<tr class="separator:ae6d17c482c1a86531eb4fbbcc542ef6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a55bd8ba1ad981e975c1d34d963387c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#a1a55bd8ba1ad981e975c1d34d963387c">operator==</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;lhs, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a55bd8ba1ad981e975c1d34d963387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> equality operator.  <a href="namespacenn_1_1account.html#a1a55bd8ba1ad981e975c1d34d963387c">More...</a><br /></td></tr>
<tr class="separator:a1a55bd8ba1ad981e975c1d34d963387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6890503fceb4d59636add821b291040"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1account.html#af6890503fceb4d59636add821b291040">operator!=</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;lhs, const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;rhs) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6890503fceb4d59636add821b291040"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> non-equality operator.  <a href="namespacenn_1_1account.html#af6890503fceb4d59636add821b291040">More...</a><br /></td></tr>
<tr class="separator:af6890503fceb4d59636add821b291040"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for the Account System features. </p>
<p> <b>Details</b> <br  />
 This namespace contains the various features provided by the Account System. The Account System provides the following features.</p>
<h3><a class="anchor" id="autotoc_md221"></a>
User Management Features</h3>
<p>The Account System issues and manages identifiers that the system and applications can use to differentiate users. The system and the application can use these user identifiers to distinguish among users and selectively provide services. However, applications can only distinguish among and selectively provide services to unrestricted (qualified) users. (Described below.)</p>
<p>The account system manages changes in the status of users so the system can detect when the application is distinguishing among users to selectively provide services. On the Account System, individual users are in one of either of the two following states.</p><ul>
<li>The <code>Closed</code> state.<ul>
<li>In this state, the application is currently not providing any service explicitly to that user.</li>
<li>For example, when a user is not selected as the player in a game application, that user is in the <code>Closed</code> state.</li>
</ul>
</li>
<li>The <code>Open</code> state.<ul>
<li>In this state, the application is currently providing some service explicitly to that user.</li>
<li>For example, when a user is selected as the player in a game application, that user is in the <code>Open</code> state.</li>
</ul>
</li>
</ul>
<p>When the application first starts, all users are in the <code>Closed</code> state. The application must use the <code><a class="el" href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41" title="Changes a user to an open state and gets the appropriate handle.">nn::account::OpenUser()</a></code> and <code><a class="el" href="namespacenn_1_1account.html#aaf1a6e0b8cbcef6f62eae042bca5b7cb" title="Changes the state of the user indicated by the specified handle to Closed.">nn::account::CloseUser()</a></code> functions to change the status of the user in accordance with the user's usage state. The situations where a user must be in the <code>Open</code> state vary depending on the platform, so see the guidelines for each platform.</p>
<h4><a class="anchor" id="autotoc_md222"></a>
Unrestricted Users</h4>
<p>Applications can only distinguish among and selectively provide services to unrestricted (qualified) users. For restricted (unqualified) users, applications can still get the user identifier and other user information but cannot change the associated user account to the <code>Open</code> state. Applications are free to use this user identifier and user information as long as they do not attempt to use it to call the <code><a class="el" href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41" title="Changes a user to an open state and gets the appropriate handle.">nn::account::OpenUser()</a></code> function.</p>
<p>The current restriction state of each user account is determined by the system when the application starts. Even for the same application, the restriction state of the user might change from one time the application starts to the next. In addition, in NX Add-On 13.2.0 and later, some function calls update the user's restriction state to the latest state. (You can revert to the conventional behavior with a setting in the NMETA file.)</p>
<p>For more information about the restrictions applied to user accounts by the system, see the Account Library documentation.</p>
<h3><a class="anchor" id="autotoc_md223"></a>
Profile Management Features</h3>
<p>For convenience, the Account System manages the profile information for individual users when the application shows users in a GUI. The Account System manages the following kinds of user profile information.</p><ul>
<li>Nicknames.<ul>
<li>Stores nicknames that can be changed by the console system.</li>
<li>The stored nickname can be any UTF-8 encoded string up to <code>NicknameBytesMax</code> bytes, excluding the terminating character.</li>
</ul>
</li>
<li>Profile images.<ul>
<li>Stores profile images that can be changed by the system.</li>
<li>For more information about the format of profile images, see <code><a class="el" href="namespacenn_1_1account.html#aaa1453bf855e6f676a8683c07eeff4a0" title="Specifies a user and gets that user&#39;s profile image.">nn::account::LoadProfileImage()</a></code>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md224"></a>
Network Service Account Management Features</h3>
<h4><a class="anchor" id="autotoc_md225"></a>
Network Service Account</h4>
<p>A network service account is required in order to use the Friend System and the NEX features. It is an account that is used only internally by the system. The Account System manages the associations of users with network service accounts. Each user can have up to one associated network service account.</p>
<p>The network service account is created automatically by the system using a procedure that is hidden in the system. The existence of the network service account is not made known to the user. A network service account is implicitly provided as a result of other actions. Accordingly, the existence of network service accounts does not need to be clear to users and we ask that you do not make it so. The system will take care of the process of guiding users on how to use network services.</p>
<p>Note that the network service accounts of individual users are not set in stone and can be replaced or deleted due to external factors. Do not implement your application based on fixed user network service accounts. Instead, get that information from the Account System every time the application starts. There will also be situations where multiple user accounts, across multiple devices, are linked to a single, identical, network account. The ratio of user accounts to network service accounts is expressed as N:1. Multiple user accounts on the same device would never be linked to the same network service account.</p>
<h4><a class="anchor" id="autotoc_md226"></a>
Data Maintained by the Network Service Account</h4>
<p>The network service account maintains friend relationships among users in addition to the blocked user list. In addition, the network service account identifier, or ID, serves as a user ID across multiple devices.</p>
<p>The data specific to a network service account that an application can access from the account system is as follows, along with examples of their use.</p>
<ul>
<li>Check whether a network service account exists.<ul>
<li>Can be used to determine whether network services are available to a user.</li>
<li>This check occurs as part of the determination of preconditions for the following actions. A specific result value is returned when there are violations.</li>
</ul>
</li>
<li>Accessing a network service account ID.<ul>
<li>Can be used as a user identifier for services based on network service accounts like the friend system and NEX.</li>
</ul>
</li>
<li>Getting network service account authentication data or the ID token.<ul>
<li>When an application communicates independently with the network service account server, it can be used to verify that communication is specific to formally authenticated users. The login for a network service account can occur after authenticating the ID token from the network service account server. </li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abbb0c49f87242e7bd3402c3dcadf6af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0c49f87242e7bd3402c3dcadf6af8">&#9670;&nbsp;</a></span>GetUserCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetUserCount </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of users added to the account system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>Location to store the user count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code><em>pOutCount</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOutCount</em></code> &gt;= <code>0</code> &amp;&amp; <code>*<em>pOutCount</em></code> &lt;= <code>UserCountMax</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of users added to the account system. The maximum number of users that can be added to the account system is <code>UserCountMax</code>. You cannot get a higher value.</p>
<p>Use <code><a class="el" href="namespacenn_1_1account.html#a456d8bfd2e6389402878af77bc7ecf95" title="Gets a list of users added to the account system.">ListAllUsers()</a></code> to also get a list of users added to the account system. </p>

</div>
</div>
<a id="a4d4882ef04d54dca91709f1eb99a888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4882ef04d54dca91709f1eb99a888a">&#9670;&nbsp;</a></span>GetUserExistence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetUserExistence </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOutExistence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a user and determines whether that user has been added to the account system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutExistence</td><td>Location to store whether the user has been added, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code>static_cast&lt;bool&gt;(user)</code> == <code>true</code>.</li>
<li><code><em>pOutExistence</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Determines whether the user corresponding to the specified <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> has been added to the account system. </p>

</div>
</div>
<a id="a456d8bfd2e6389402878af77bc7ecf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456d8bfd2e6389402878af77bc7ecf95">&#9670;&nbsp;</a></span>ListAllUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ListAllUsers </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>outUsers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of users added to the account system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutActualLength</td><td>Location to store the number of users added to the account system. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outUsers</td><td>Location to store the user list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The number of elements within <code><em>outUsers</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code><em>pOutActualLength</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutUsers</em></code> != <code>nullptr</code>.</li>
<li><code><em>arrayLength</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOutActualLength</em></code> &gt;= <code>0</code> &amp;&amp; <code>*<em>pOutActualLength</em></code> &lt;= <code>UserCountMax</code>.</li>
<li><code><em>outUsers</em>[0, min(<em>arrayLength</em>, *<em>pOutActualLength</em>))</code> has a valid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code>.</li>
<li><code><em>outUsers</em>[0, min(<em>arrayLength</em>, *<em>pOutActualLength</em>), <em>arrayLength</em>)</code> has an invalid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a list of users added to the account system. The maximum number of users that can be added to the account system is <code>UserCountMax</code>. You cannot get a longer list.</p>
<p>This list shows all users, regardless of whether they are in the <code>Closed</code> state or the <code>Open</code> state. The order in which users are listed is determined by the system.</p>
<p>We recommend using <code><a class="el" href="namespacenn_1_1account.html#abbb0c49f87242e7bd3402c3dcadf6af8" title="Gets the number of users added to the account system.">GetUserCount()</a></code> when you just want to get to the number of users added to the account system. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_friends_play_history_2_friends_play_history_8cpp-example.html#a5">FriendsPlayHistory/FriendsPlayHistory.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a13">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a11">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a305bd69651c225e00698b953f2cb952f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305bd69651c225e00698b953f2cb952f">&#9670;&nbsp;</a></span>ListOpenUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ListOpenUsers </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>outUsers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of users currently in an open state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutActualLength</td><td>Location to store the number of users currently in an open state. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outUsers</td><td>Location to store the user list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The number of elements within <code><em>outUsers</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code><em>pOutActualLength</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutUsers</em></code> != <code>nullptr</code>.</li>
<li><code><em>arrayLength</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOutActualLength</em></code> &gt;= <code>0</code> &amp;&amp; <code>*<em>pOutActualLength</em></code> &lt;= <code>UserCountMax</code>.</li>
<li><code><em>outUsers</em>[0, min(<em>arrayLength</em>, *<em>pOutActualLength</em>))</code> has a valid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code>.</li>
<li><code><em>outUsers</em>[0, min(<em>arrayLength</em>, *<em>pOutActualLength</em>), <em>arrayLength</em>)</code> has an invalid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a list of users currently in an open state in the account system. The order in which users are listed is determined by the system. </p>

</div>
</div>
<a id="affe31852e1c6d319176e313590000dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe31852e1c6d319176e313590000dfe">&#9670;&nbsp;</a></span>GetLastOpenedUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetLastOpenedUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>pOutUser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> for the last user set to an open state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutUser</td><td>Location to store the <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code><em>pOutUser</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If the relevant user exists, <code>static_cast&lt;bool&gt;(*pOutUser)</code> == <code>true</code>.</li>
<li>If not, <code>static_cast&lt;bool&gt;(*pOutUser)</code> == <code>false</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> for the last user set to an open state within the account system. When the expected return value does not exist for reasons including the deletion of the user, <code>*<em>pOutUser</em></code> has an invalid value.</p>
<p>This function is designed to be used to reference the cursor's initial position, for example, when creating a proprietary user-selection GUI for the application. </p>

</div>
</div>
<a id="a1f04aa7c270a427ff5c7b29eaf97b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f04aa7c270a427ff5c7b29eaf97b1a2">&#9670;&nbsp;</a></span>GetNickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetNickname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_nickname.html">Nickname</a> *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a user and gets that user's nickname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>Location to store the nickname. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_user_not_exist.html">nn::account::ResultUserNotExist</a> The target user account does not exist.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code>static_cast&lt;bool&gt;(user)</code> == <code>true</code>.</li>
<li><code><em>pOut</em></code> != <code>nullptr</code>.</li>
<li>The user indicated by <code><em>user</em></code> exists. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>There is at least one <code>\0</code> in <code><em>pOut</em>-&gt;name[0, NicknameBytesMax]</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specifies a user and gets the nickname set for that user. If no profile has been set for the user, the next valid value is returned.</p><ul>
<li><code><em>pOut</em>-&gt;name[0]</code> == '\0'. </li>
</ul>

</div>
</div>
<a id="aaa1453bf855e6f676a8683c07eeff4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1453bf855e6f676a8683c07eeff4a0">&#9670;&nbsp;</a></span>LoadProfileImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::LoadProfileImage </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutActualSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a user and gets that user's profile image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutActualSize</td><td>Location to store the actual size, in bytes, of the profile image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outImage</td><td>Location to store the profile image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, that can be written to <code><em>outImage</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_user_not_exist.html">nn::account::ResultUserNotExist</a> The target user account does not exist.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code>static_cast&lt;bool&gt;(user)</code> == <code>true</code>.</li>
<li><code><em>pOutActualSize</em></code> != <code>nullptr</code>.</li>
<li>The user indicated by <code><em>user</em></code> exists. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOutActualSize</em></code> maintains the actual size, in bytes, for the image data.</li>
<li>When <code><em>outImage</em></code> != <code>nullptr</code>, <code><em>outImage</em>[0, min(*<em>pOutActualSize</em>, <em>bufferSize</em>))</code> maintains the image data.</li>
<li>The image data maintained in <code><em>outImage</em></code> can be parsed as JPEG data.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a profile image for the specified user. Specify <code>nullptr</code> for the second parameter to get just the size, in bytes, of the profile image.</p>
<p>The profile image conforms to the following format.</p><ul>
<li>Image resolution is 256 pixels for both height and width.</li>
<li>The color space is sRGB.</li>
<li>A baseline JPEG format.<ul>
<li>The YCbCr sampling ratio must be 4:2:0, 4:2:2, or 4:4:4.</li>
<li>When EXIF data exists, it is indeterminate.</li>
</ul>
</li>
<li>The size, in bytes, can only be up to 128 KB (131,072 bytes), </li>
</ul>

</div>
</div>
<a id="ac5870470963c9923c63f76e03c8c024e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5870470963c9923c63f76e03c8c024e">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::account::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins using the account system. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The account system is available.</dd></dl>
<p> <b>Details</b> <br  />
 Initializes the account system library and makes it available. Call at least once when the application starts, before using the account system. Initialization only occurs the first time this function is called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_account_application_2_account_application__main_8cpp-example.html#a1">AccountApplication/AccountApplication_Main.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a113">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a36">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a32">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_friends_play_history_2_friends_play_history_8cpp-example.html#a1">FriendsPlayHistory/FriendsPlayHistory.cpp</a>, <a class="el" href="_friends_presence_2_friends_presence_8cpp-example.html#a42">FriendsPresence/FriendsPresence.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a31">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_friends_simple_2_friends_simple_8cpp-example.html#a34">FriendsSimple/FriendsSimple.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a11">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a1">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a1">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a16">MultiProgramApplication/Main/Main.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a9">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a00ff6287a526dcdb7d596fa34b5a9d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ff6287a526dcdb7d596fa34b5a9d2b">&#9670;&nbsp;</a></span>ListQualifiedUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ListQualifiedUsers </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutActualLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a>&#160;</td>
          <td class="paramname"><em>outUsers</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of users that have no restrictions (a list of qualified users). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutActualLength</td><td>The location for storing the number of users. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outUsers</td><td>Location to store the user list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLength</td><td>The number of elements within <code><em>outUsers</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The library is already initialized.</li>
<li><code><em>pOutActualLength</em></code> != <code>nullptr</code>.</li>
<li><code><em>pOutUsers</em></code> != <code>nullptr</code>.</li>
<li><code><em>arrayLength</em></code> &gt; <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutActualLength</em></code> &gt;= <code>0</code> &amp;&amp; <code><em>*pOutActualLength</em></code> &lt;= <code>UserCountMax</code>.</li>
<li><code><em>outUsers</em>[0, min(<em>arrayLength</em>, <em>*pOutActualLength</em>))</code> stores valid UIDs.</li>
<li><code><em>outUsers</em>[min(<em>arrayLength</em>, <em>*pOutActualLength</em>), <em>arrayLength)</em></code> stores invalid UIDs.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets a list of those users registered in the account system that have no restrictions (a list of qualified users).</p>
<p>This list shows all unrestricted users, regardless of whether they are in the <code>Closed</code> or the <code>Open</code> state. The order in which users are listed is determined by the system. </p>

</div>
</div>
<a id="a06fd27c776fbc31c918ea0a84ddb1f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fd27c776fbc31c918ea0a84ddb1f41">&#9670;&nbsp;</a></span>OpenUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::OpenUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a user to an open state and gets the appropriate handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHandle</td><td>Handle for the target user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The user's open process succeeded.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_user_not_exist.html">nn::account::ResultUserNotExist</a> The target user account does not exist.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li>The user indicated by <code><em>user</em></code> is in the <code>Closed</code> state.</li>
<li>In terms of content management, the preconditions are met to perform the <code>Open</code> operation on the user. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutHandle</em></code> is available.</li>
<li>The user indicated by <code><em>user</em></code> is in an open state.</li>
<li><code><em>user</em></code> is returned by the next <code><a class="el" href="namespacenn_1_1account.html#affe31852e1c6d319176e313590000dfe" title="Gets the Uid for the last user set to an open state.">GetLastOpenedUser()</a></code> call.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the state of the specified user from <code>Closed</code> to <code>Open</code> and gets that handle.</p>
<p>Calling this function notifies the console system that the target user has begun use of the application.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1account.html#a00ff6287a526dcdb7d596fa34b5a9d2b" title="Gets a list of users that have no restrictions (a list of qualified users).">nn::account::ListQualifiedUsers()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a39">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a12">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_friends_play_history_2_friends_play_history_8cpp-example.html#a7">FriendsPlayHistory/FriendsPlayHistory.cpp</a>, <a class="el" href="_friends_presence_2_friends_presence_8cpp-example.html#a20">FriendsPresence/FriendsPresence.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a37">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_friends_simple_2_friends_simple_8cpp-example.html#a39">FriendsSimple/FriendsSimple.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a16">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a7">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a12">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1a3ac7d2b7f91b612062aaf7859de8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3ac7d2b7f91b612062aaf7859de8c3">&#9670;&nbsp;</a></span>TryOpenPreselectedUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::account::TryOpenPreselectedUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is a user account selected before the application starts, changes the user to the <code>Open</code> state and gets the appropriate handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutHandle</td><td>Handle for the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the user account was selected before the application starts.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The selected user was in the <code>Closed</code> state when the application started. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>If <code>true</code> is returned, <code><em>*pOutHandle</em></code> is available.</li>
<li>If <code>true</code> is returned, the user selected when the application starts is in the <code>Open</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function sets the <code>StartupUserAccount</code> included in <a href="../../Package/contents/Pages/Page_166503043.html">Writing the NMETA File </a>to a value other than <code>None</code> so that it can be used in the created application. For applications with this setting, a maximum of one user account is specified when the application starts. This function changes the state of this user account from <code>Closed</code> to <code>Open</code> and gets the appropriate handle.</p>
<p>As long as <code>IsOptional</code> is not specified in the <code>StartupUserAccountOption</code> included in Writing the NMETA File, this function always returns <code>true</code>. When <code>IsOptional</code> is specified in <code>StartupUserAccountOption</code>, this function may return <code>false</code>.</p>
<p>When this function returns <code>true</code>, the system is notified that the target user has started using the application. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a4">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8ced19bd37a8a2199a5a879437b0716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ced19bd37a8a2199a5a879437b0716">&#9670;&nbsp;</a></span>OpenPreselectedUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::OpenPreselectedUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> *&#160;</td>
          <td class="paramname"><em>pOutHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has been deprecated. </p>
<p>Use <em><a class="el" href="namespacenn_1_1account.html#a1a3ac7d2b7f91b612062aaf7859de8c3" title="If there is a user account selected before the application starts, changes the user to the Open state...">TryOpenPreselectedUser()</a></em> instead. </p>

</div>
</div>
<a id="aaf1a6e0b8cbcef6f62eae042bca5b7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1a6e0b8cbcef6f62eae042bca5b7cb">&#9670;&nbsp;</a></span>CloseUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::account::CloseUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the state of the user indicated by the specified handle to <code>Closed</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is available. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>handle</em></code> is unavailable.</li>
<li>The user indicated by <code><em>handle</em></code> is in the <code>Closed</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Changes the specified user from the <code>Open</code> to the <code>Closed</code> state. The specified handle ceases to be usable.</p>
<p>Calling this function notifies the console system that the target user has ended use of the application. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a40">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a16">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_friends_play_history_2_friends_play_history_8cpp-example.html#a12">FriendsPlayHistory/FriendsPlayHistory.cpp</a>, <a class="el" href="_friends_presence_2_friends_presence_8cpp-example.html#a23">FriendsPresence/FriendsPresence.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a41">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_friends_simple_2_friends_simple_8cpp-example.html#a42">FriendsSimple/FriendsSimple.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a18">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a9">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a6">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a13">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0b05fba3684f82f092acd6bbb7d6ed7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b05fba3684f82f092acd6bbb7d6ed7f">&#9670;&nbsp;</a></span>GetUserId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetUserId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the user account ID indicated by the specified handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>The UID indicating the target user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is available. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOut</em></code> maintains the UID for the target user.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the UID for the user account indicated by the specified handle. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a11">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a8">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3f6aca5d7fd762684b1ee408a35d99f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6aca5d7fd762684b1ee408a35d99f6">&#9670;&nbsp;</a></span>EnsureNetworkServiceAccountAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::EnsureNetworkServiceAccountAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks network service account availability. </p>
<p>If necessary, activates the network service account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The network service account is available.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">nn::account::ResultCancelledByUser</a> The process was explicitly canceled, based on user intent. Do not handle this result as an error.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><a class="el" href="namespacenn_1_1account.html#a97c65699d63a542a921a67472e66d642" title="Specifies an Open handle and determines whether the network service account can be used.">IsNetworkServiceAccountAvailable()</a></code> function returns <code>true</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Checks network service account availability. If necessary, activates the network service account. This function immediate returns a success and is finalized when the network service account for the user specified when this function was called is available. Otherwise, the system UI is displayed while processing occurs to enable the network service account.</p>
<p>This function neither communicates nor queries the availability of the network service account server. Availability can change while running features that result in communication, such as the <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code> function, even when this function immediately succeeds as a result.</p>
<p>The conditions for using network service accounts are described in the Account Library section of the SDK documentation.</p>
<p>This function can block threads from the caller to display the NX system. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a23">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a97c65699d63a542a921a67472e66d642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c65699d63a542a921a67472e66d642">&#9670;&nbsp;</a></span>IsNetworkServiceAccountAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::IsNetworkServiceAccountAvailable </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies an Open handle and determines whether the network service account can be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>Whether the network service account can be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOut</em></code> = <code>true</code> only when the network service account of the target user can be used.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specifies a user handle and checks whether the network service account can be used. You cannot provide network services for users who cannot use a network service account.</p>
<p>We normally recommend using the <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code> function, and not this function, when using network service accounts. Use this function only when you want to avoid sending notification messages with the <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code> function.</p>
<p>This function neither communicates nor queries the availability of the network service account server. Availability can change while running features that result in communication, such as the <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code> function, even when <code><em>*pOut</em></code> == <code>true</code> when this function is called as a result.</p>
<p>The conditions for using network service accounts are described in the Account Library section of the SDK documentation. </p>

</div>
</div>
<a id="a8a800930ca2f1f5b402bf4cc25db7f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a800930ca2f1f5b402bf4cc25db7f1d">&#9670;&nbsp;</a></span>GetNetworkServiceAccountId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::GetNetworkServiceAccountId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_network_service_account_id.html">NetworkServiceAccountId</a> *&#160;</td>
          <td class="paramname"><em>pOutId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a handle for a user in an open state, and gets that user's network service account ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutId</td><td>The network service account ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html">nn::account::ResultNetworkServiceAccountUnavailable</a>, The network service account is not available. Make the network service account available by running <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code>, which allows you to resolve this error. must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutId</em></code> != <code>nullptr</code>.</li>
<li>The <code><a class="el" href="namespacenn_1_1account.html#a97c65699d63a542a921a67472e66d642" title="Specifies an Open handle and determines whether the network service account can be used.">IsNetworkServiceAccountAvailable()</a></code> function returns <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutId</em></code> maintains the network service account ID for the target user.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specifies a user handle and gets that user's network service account ID. A network service account is needed when using the friends system, <code><a class="el" href="namespacenn_1_1friends.html" title="Namespace for the friends library.">nn::friends</a></code>, or NEX functionality.</p>
<p>Users can have only one network service account. This account, however, can be replaced or deleted due to external causes. For this reason, the ID is not fixed. As a result, use <code><a class="el" href="namespacenn_1_1account.html#a8a800930ca2f1f5b402bf4cc25db7f1d" title="Specifies a handle for a user in an open state, and gets that user&#39;s network service account ID.">GetNetworkServiceAccountId()</a></code> for your application when using network services to get and use the latest <code><a class="el" href="structnn_1_1account_1_1_network_service_account_id.html" title="The network service account ID.">NetworkServiceAccountId</a></code> value. Do not design applications with the expectation that a user's <code><a class="el" href="structnn_1_1account_1_1_network_service_account_id.html" title="The network service account ID.">NetworkServiceAccountId</a></code> value is fixed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a38">FriendsProfileImage/FriendsProfileImage.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ade43b0fd5b5f5e1ec1752efe37d1ed97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade43b0fd5b5f5e1ec1752efe37d1ed97">&#9670;&nbsp;</a></span>EnsureNetworkServiceAccountIdTokenCacheAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::EnsureNetworkServiceAccountIdTokenCacheAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1account_1_1_async_context.html">AsyncContext</a> *&#160;</td>
          <td class="paramname"><em>pOutContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a user handle and allocates a cache for the network service account's ID token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutContext</td><td>The <code><a class="el" href="classnn_1_1account_1_1_async_context.html" title="Class that expresses the state of previously called asynchronous processes.">nn::account::AsyncContext</a></code> object for receiving notifications of asynchronous processing completion and results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Successfully began allocation of the token cache for the network service account ID. That ID token cache can be used when the <code>GetResult()</code> function returns success for the obtained <code><a class="el" href="classnn_1_1account_1_1_async_context.html" title="Class that expresses the state of previously called asynchronous processes.">AsyncContext</a></code>.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html">nn::account::ResultNetworkServiceAccountUnavailable</a>, The network service account is not available. Make the network service account available by running <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code>, which allows you to resolve this error. must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutContext</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><a class="el" href="namespacenn_1_1account.html#afae1661923ba118f18a5b4af7ff1011a" title="Specifies a user handle and gets the cache for the network service account&#39;s ID token.">LoadNetworkServiceAccountIdTokenCache()</a></code> succeeds for the same user immediately after <code><em>*pOutContext</em></code> is signaled.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Specifies a user handle and allocates a cache for the network service account's ID token. A completion is immediately notified for the <code><a class="el" href="classnn_1_1account_1_1_async_context.html" title="Class that expresses the state of previously called asynchronous processes.">nn::account::AsyncContext</a></code> object returned with this function when a cache already exists for an ID token with sufficient time until it lapses. This function gets an ID token after authenticating the network service account and then creates a cache for it when the old token ID has lapsed. The system event for a <code><a class="el" href="classnn_1_1account_1_1_async_context.html" title="Class that expresses the state of previously called asynchronous processes.">nn::account::AsyncContext</a></code> object is signaled when creation of the cache is complete.</p>
<p>You can get the cache for the ID token allocated by this function using <code><a class="el" href="namespacenn_1_1account.html#afae1661923ba118f18a5b4af7ff1011a" title="Specifies a user handle and gets the cache for the network service account&#39;s ID token.">LoadNetworkServiceAccountIdTokenCache()</a></code>.</p>
<p>This function communicates with the Internet.</p>
<p>Determined that a network service account could not be used during the asynchronous processing resulting from this function. The <code>GetResult()</code> function for the <code><a class="el" href="classnn_1_1account_1_1_async_context.html" title="Class that expresses the state of previously called asynchronous processes.">AsyncContext</a></code> object might return <code><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html" title="A class that represents error Result values (account: The network service account is not in a state w...">ResultNetworkServiceAccountUnavailable</a></code>. In that case, make the network service account available by running <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code>, which allows you to resolve this error. </p>

</div>
</div>
<a id="afae1661923ba118f18a5b4af7ff1011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae1661923ba118f18a5b4af7ff1011a">&#9670;&nbsp;</a></span>LoadNetworkServiceAccountIdTokenCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::LoadNetworkServiceAccountIdTokenCache </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutActualSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a user handle and gets the cache for the network service account's ID token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutActualSize</td><td>Actual length of the ID token (excluding terminators) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The location storing the ID token. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size, in bytes, that can be written to <code><em>buffer</em></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Successfully obtained the ID token cache.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html">nn::account::ResultNetworkServiceAccountUnavailable</a>, The network service account is not available. Make the network service account available by running <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code>, which allows you to resolve this error. must be handled.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_token_cache_unavailable.html">nn::account::ResultTokenCacheUnavailable</a> Cannot use the ID token cache. Run <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code>.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutActualSize</em></code> != <code>nullptr</code>.</li>
<li><code><em>buffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1account.html#a27559177c66aded724c5691d7c98c3d0" title="Maximum length of the network service account ID token.">nn::account::NetworkServiceAccountIdTokenLengthMax</a></code>.</li>
<li>The <code><a class="el" href="namespacenn_1_1account.html#a97c65699d63a542a921a67472e66d642" title="Specifies an Open handle and determines whether the network service account can be used.">IsNetworkServiceAccountAvailable()</a></code> function returns <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutActualSize</em></code> maintains the actual length of the ID token, exclusive of the terminator.</li>
<li>The ASCII string in the range from <code><em>buffer</em>[0, <em>*pOutActualSize</em>)</code> can be used as a valid ID token.</li>
<li>The ID token is terminated with <code>\0</code> only when <code><em>*pOutActualSize</em></code> &lt; <code><em>bufferSize</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the cache for the allocated ID token using <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code>. The ID token is obtained as a URL-encoded string. Its maximum length, exclusive of a terminator, is <code><a class="el" href="namespacenn_1_1account.html#a27559177c66aded724c5691d7c98c3d0" title="Maximum length of the network service account ID token.">nn::account::NetworkServiceAccountIdTokenLengthMax</a></code>.</p>
<p>ID tokens obtained with this function have an expiration date. They expire at a particular time after they have been obtained. When the time to expiration is at least thirty minutes since <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code> was called, you can normally use the ID token during that period. In principle, whenever you use an ID token, use <code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code> and this function to get the token again. Sending an expired ID token to the server can result in a failure to authenticate the ID token on the server.</p>
<p>The ID tokens available with this function include data specific to the application that called the function. Do not share ID tokens with other applications. Do not use ID tokens saved to save data or elsewhere because it is possible for a user's network service account to be modified or deleted during intervals when the application is not running. </p>

</div>
</div>
<a id="a97db15f53d40e45b87cbbbc5dfdf17be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97db15f53d40e45b87cbbbc5dfdf17be">&#9670;&nbsp;</a></span>CreateNintendoAccountAuthorizationRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::CreateNintendoAccountAuthorizationRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html">NintendoAccountAuthorizationRequestContext</a> *&#160;</td>
          <td class="paramname"><em>pOutRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_nintendo_account_authorization_request_parameters.html">NintendoAccountAuthorizationRequestParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>workBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a request to get authorization from a Nintendo Account linked to a network service account. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutRequest</td><td>The address where the created request will be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> indicating the target user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The parameter to use for authentication and authorization procedures with the Nintendo Account server. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">workBuffer</td><td>The work memory required for storing the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workBufferSize</td><td>The size (in bytes) of <code><em>workBuffer</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> Succeeded.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_network_service_account_unavailable.html">nn::account::ResultNetworkServiceAccountUnavailable</a>, The network-service account is not available. Make the network service account available by running <code><a class="el" href="namespacenn_1_1account.html#a3f6aca5d7fd762684b1ee408a35d99f6" title="Checks network service account availability.">EnsureNetworkServiceAccountAvailable()</a></code>, which allows you to resolve this error. must be handled.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOutRequest</em></code> != <code>nullptr</code>.</li>
<li><code><em>workBuffer</em></code> != <code>nullptr</code>.</li>
<li><code>reinterpret_cast&lt;uintptr_t&gt;(<em>workBuffer</em>)</code> % <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code> == <code>0</code>.</li>
<li><code><em>workBufferSize</em></code> &gt;= <code><a class="el" href="namespacenn_1_1account.html#a8463419c967fe243faedf8c88e0cf47b" title="The buffer size, in bytes, needed for creating a valid nn::account::NintendoAccountAuthorizationReque...">nn::account::RequiredBufferSizeForNintendoAccountAuthorizationRequestContext</a></code>.</li>
<li><code><em>workBufferSize</em></code> % <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code> == <code>0</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOutRequest</em></code> is a valid request.</li>
<li>While the created request is valid, a range of <code><em>workBufferSize</em></code> bytes in <code><em>workBuffer</em></code> cannot be accessed.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Creates a request for the application to get authorization from a Nintendo Account linked to the network-service account for the specified user. After the request is created, the process of getting authorization can be conducted asynchronously and the result can be obtained from the <code><a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html" title="The class representing requests to get authorization from a Nintendo Account.">NintendoAccountAuthorizationRequestContext</a></code> object specified in the parameter.</p>
<p>This function communicates with the Internet.</p>
<p>The memory space that is specified for work memory cannot be accessed while it is storing a request with a valid <code><a class="el" href="classnn_1_1account_1_1_nintendo_account_authorization_request_context.html" title="The class representing requests to get authorization from a Nintendo Account.">NintendoAccountAuthorizationRequestContext</a></code> object. </p>

</div>
</div>
<a id="aca2f73beb9fe78af782a69c7a78b0050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2f73beb9fe78af782a69c7a78b0050">&#9670;&nbsp;</a></span>StoreSaveDataThumbnailImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::StoreSaveDataThumbnailImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>imageBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>imageBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the save data thumbnail image that is displayed in the user selection UI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>The UID for the target user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageBuffer</td><td>Pointer to the image to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageBufferSize</td><td><code><em>imageBuffer</em></code> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><em>imageBuffer</em></code> and <code><em>imageBufferSize</em></code> are aligned to <code><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="This constant stores the minimum unit for memory operations.">nn::os::MemoryPageSize</a></code>. </dd>
<dd>
Can read and write to the [imageBuffer, imageBuffer + imageBufferSize) region.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html">nn::fs::ResultTargetNotFound</a> The target save data has not been created.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function blocks until the save process has completed. The image buffer has the following requirements.</p><ul>
<li>Image format: RGBA8</li>
<li>Tiling: linear</li>
<li>Image gamma: sRGB</li>
<li>Width in pixels: 256</li>
<li>Height in pixels: 144 As a result, the image buffer size is expected to receive 256  144  4, or 147,456 bytes. </li>
</ul>

</div>
</div>
<a id="aa136f7db1016840d31cf72ce71a72f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa136f7db1016840d31cf72ce71a72f69">&#9670;&nbsp;</a></span>DeleteSaveDataThumbnailImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::DeleteSaveDataThumbnailImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the save data thumbnail image displayed in the user selection UI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uid</td><td>The UID for the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded.</li>
<li><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html">nn::fs::ResultTargetNotFound</a> The target save data has not been created.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
This function blocks until the delete process has completed. You can revert the save data thumbnail image, displayed in the user selection UI, to its default state by using this when resetting or removing save data. </p>

</div>
</div>
<a id="abc177826dbe4c44de797c0c23fe4b472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc177826dbe4c44de797c0c23fe4b472">&#9670;&nbsp;</a></span>PromoteQualification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::account::PromoteQualification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a UI to direct the promotion of the user to the unrestricted state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID of the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The restricted state of the specified <code><em>user</em></code> is updated.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
If there are restrictions on the specified user, a UI is displayed, directing the promotion of the user to the unrestricted state. If the specified user is already unrestricted, the function does nothing.</p>
<p><b>Note</b></p>
<p>This function does not return the result of whether the specified user is restricted. Call the <code><a class="el" href="namespacenn_1_1account.html#a00ff6287a526dcdb7d596fa34b5a9d2b" title="Gets a list of users that have no restrictions (a list of qualified users).">nn::account::ListQualifiedUsers()</a></code> function and use that result. </p>

</div>
</div>
<a id="a749534bdfdee56eebe9203a526390b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749534bdfdee56eebe9203a526390b32">&#9670;&nbsp;</a></span>ShowUserSelector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ShowUserSelector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_selection_settings.html">UserSelectionSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the UI for selecting users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>Where the selected user ID is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Parameters needed for display.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> A user has been selected.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">nn::account::ResultCancelledByUser</a> User selection was explicitly canceled, based on user intent. Do not handle this result as an error.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOut</em></code> maintains the UID for the target user.</li>
<li>Store <code>InvalidUid</code> in <code><em>pOut</em></code> and return <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">nn::ResultSuccess()</a></code> when the skip button that appears when <code><em>arg.showSkipButton</em></code> == <code>true</code> was selected.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>This function blocks until either user selection or a cancellation occurs.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenn_1_1account.html#acc263608192f7bbdef34e3b5ae007258" title="These are the default settings when calling the user selection UI.">DefaultUserSelectionSettings</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_catalog_2_main_8cpp-example.html#a118">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a38">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a14">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, <a class="el" href="_friends_presence_2_friends_presence_8cpp-example.html#a19">FriendsPresence/FriendsPresence.cpp</a>, <a class="el" href="_friends_profile_image_2_friends_profile_image_8cpp-example.html#a35">FriendsProfileImage/FriendsProfileImage.cpp</a>, <a class="el" href="_friends_simple_2_friends_simple_8cpp-example.html#a37">FriendsSimple/FriendsSimple.cpp</a>, and <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a3">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4361809245aa7ba31faebc3686f8aaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4361809245aa7ba31faebc3686f8aaea">&#9670;&nbsp;</a></span>ShowUserSelector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ShowUserSelector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> *&#160;</td>
          <td class="paramname"><em>pOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the UI for selecting users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>Where the selected user ID is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> A user has been selected.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">nn::account::ResultCancelledByUser</a> User selection was explicitly canceled, based on user intent. Do not handle this result as an error.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pOut</em></code> != <code>nullptr</code>. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code>*<em>pOut</em></code> maintains the UID for the target user.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>This function blocks until either user selection or a cancellation occurs.</li>
<li>The behavior is the same as when <code><a class="el" href="namespacenn_1_1account.html#acc263608192f7bbdef34e3b5ae007258">DefaultUserSelectionSettings</a></code> is specified for <code><a class="el" href="namespacenn_1_1account.html#a749534bdfdee56eebe9203a526390b32" title="Calls the UI for selecting users.">ShowUserSelector( Uid*, const UserSelectionSettings&amp; )</a></code>. </li>
</ul>

</div>
</div>
<a id="a4ffe66d07e66590baff98b70b30722d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffe66d07e66590baff98b70b30722d7">&#9670;&nbsp;</a></span>ShowUserCreator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ShowUserCreator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the UI for creating new users. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> A user has been created.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">nn::account::ResultCancelledByUser</a> User creation was explicitly canceled, based on user intent. Do not handle this result as an error.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><ul>
<li>This function blocks until user input ends in the UI. </li>
</ul>

</div>
</div>
<a id="af4d3b1a71167484e01d54e08c580acc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d3b1a71167484e01d54e08c580acc1">&#9670;&nbsp;</a></span>ShowLicenseRequirementsForNetworkService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::account::ShowLicenseRequirementsForNetworkService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays license information for the network service to requesting users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> for the user to whom to display license information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="classnn_1_1_result.html">nn::Result</a></code> that represents the process result.<ul>
<li><a class="el" href="classnn_1_1_result_success.html">nn::ResultSuccess</a> The process succeeded. The network service account license information may be updated due to user operations.</li>
<li><a class="el" href="classnn_1_1account_1_1_result_cancelled_by_user.html">nn::account::ResultCancelledByUser</a> The process was explicitly canceled, based on user intent. Do not handle this result as an error.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function displays the system UI that describes the license information for the user's network service account. The network service account may obtain new licenses as a result of user operations in this UI.</p>
<p>This function is called when the program validates the network service license of the user and determines that a network service license is needed. In short, use this function when the program matches the following conditions. To avoid displaying the referenced UI to the user when not required, do not call this function when these conditions are not met.</p>
<ul>
<li>The license verification process has been explicitly disabled (<code><a class="el" href="namespacenn_1_1account.html#ade43b0fd5b5f5e1ec1752efe37d1ed97" title="Specifies a user handle and allocates a cache for the network service account&#39;s ID token.">nn::account::EnsureNetworkServiceAccountIdTokenCacheAsync()</a></code> function) when obtaining the network service account ID token.</li>
<li>The user must obtain a license for network service usage as determined by the result of an analysis of the network service account ID token by the program. </li>
</ul>

</div>
</div>
<a id="aecdef7d061fbc4072e4c003a32ea13e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdef7d061fbc4072e4c003a32ea13e8">&#9670;&nbsp;</a></span>PushOpenUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::account::PushOpenUsers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes user accounts in the <code>Open</code> state available between different programs while maintaining that state. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The caller is a program that is a multi-program application. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>The <code><a class="el" href="namespacenn_1_1account.html#accb35b97a8eca5f6690436550b8b29fa" title="Gets the UserHandle of user accounts being maintained in the Open state between programs.">PopOpenUsers()</a></code> function can reacquire <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> for users currently in the <code>Open</code> state.</li>
<li>The <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> objects already acquired for user accounts currently in the <code>Open</code> state become unavailable.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the program is a multi-program application, all user accounts in the <code>Open</code> state retain that state and become available among the different programs. You can use the <code><a class="el" href="namespacenn_1_1account.html#accb35b97a8eca5f6690436550b8b29fa" title="Gets the UserHandle of user accounts being maintained in the Open state between programs.">PopOpenUsers()</a></code> function to get the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> of the user accounts being maintained in the <code>Open</code> state among programs.</p>
<p>When this function is called multiple times, all user accounts in the <code>Open</code> state at the time of the function call are retained in that state, including those user accounts already being maintained in that state.</p>
<p>Use this function when the same users will be using the application before and after the programs are switched. Calling <code><a class="el" href="namespacenn_1_1account.html#aaf1a6e0b8cbcef6f62eae042bca5b7cb" title="Changes the state of the user indicated by the specified handle to Closed.">CloseUser()</a></code> and <code><a class="el" href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41" title="Changes a user to an open state and gets the appropriate handle.">OpenUser()</a></code> continuously on the same user accounts before and after the programs are switched might violate the guidelines.</p>
<p>If the users will change at the same time that the programs are switched, we recommend that you do not use this function, and instead call <code><a class="el" href="namespacenn_1_1account.html#aaf1a6e0b8cbcef6f62eae042bca5b7cb" title="Changes the state of the user indicated by the specified handle to Closed.">CloseUser()</a></code> before the programs are switched, and call <code><a class="el" href="namespacenn_1_1account.html#a06fd27c776fbc31c918ea0a84ddb1f41" title="Changes a user to an open state and gets the appropriate handle.">OpenUser()</a></code> on those different user accounts after the programs are switched. This reduces the dependencies among programs and makes them easier to implement and test. </p>

</div>
</div>
<a id="accb35b97a8eca5f6690436550b8b29fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb35b97a8eca5f6690436550b8b29fa">&#9670;&nbsp;</a></span>PopOpenUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::account::PopOpenUsers </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1account_1_1_user_handle.html">UserHandle</a>&#160;</td>
          <td class="paramname"><em>outHandles</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outHandleCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> of user accounts being maintained in the <code>Open</code> state between programs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>The region for storing the obtained <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> count. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outHandles</td><td>The region for storing the obtained <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outHandleCount</td><td>The number of elements in <code><em>outHandles</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The caller is a program that is a multi-program application.</li>
<li><code><em>outHandleCount</em></code> &gt;= the number of user accounts being maintained in the <code>Open</code> state in between programs. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li><code><em>*pOut</em></code> &lt;= <code>UserCountMax</code>.</li>
<li><code><em>outHandles</em>[0]</code>, ..., <code><em>outHandles</em>[*<em>pOut</em> - 1]</code> store valid <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> objects.</li>
<li>The <code><a class="el" href="namespacenn_1_1account.html#accb35b97a8eca5f6690436550b8b29fa" title="Gets the UserHandle of user accounts being maintained in the Open state between programs.">PopOpenUsers()</a></code> function cannot get the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> again of users currently in the <code>Open</code> state.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 If the program is a multi-program application, gets the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> of all user accounts being maintained in the <code>Open</code> state between programs. Unless the <code><a class="el" href="namespacenn_1_1account.html#aecdef7d061fbc4072e4c003a32ea13e8" title="Makes user accounts in the Open state available between different programs while maintaining that sta...">PushOpenUsers()</a></code> function is called, no program can get the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code>, but an error does not occur.</p>
<p>Regardless of the number of times the <code><a class="el" href="namespacenn_1_1account.html#aecdef7d061fbc4072e4c003a32ea13e8" title="Makes user accounts in the Open state available between different programs while maintaining that sta...">PushOpenUsers()</a></code> function has been called before, this function gets the <code><a class="el" href="structnn_1_1account_1_1_user_handle.html" title="The handle for dealing with a user in the Open state.">UserHandle</a></code> of all user accounts being maintained in the <code>Open</code> state at that time. </p>

</div>
</div>
<a id="a1a55bd8ba1ad981e975c1d34d963387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a55bd8ba1ad981e975c1d34d963387c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::account::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> equality operator. </p>
<p> <b>Details</b> <br  />
 Verifies the equivalence of two provided <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> values. When those two values are equivalent, this operator returns <code>true</code>. Otherwise, this operator returns <code>false</code>.</p>
<p>Comparing a valid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> against an invalid one always returns <code>false</code>. Comparing two invalid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> values always returns <code>true</code>. </p>

</div>
</div>
<a id="af6890503fceb4d59636add821b291040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6890503fceb4d59636add821b291040">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::account::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> non-equality operator. </p>
<p> <b>Details</b> <br  />
 Verifies that two provided <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> values are different. When those two values are different, this operator returns <code>true</code>. Otherwise, this operator returns <code>false</code>.</p>
<p>Comparing a valid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> against an invalid one always returns <code>true</code>. Comparing two invalid <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> values always returns <code>false</code>. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e7ac3fae982d6a6825e8f242ee61d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7ac3fae982d6a6825e8f242ee61d2b">&#9670;&nbsp;</a></span>UserCountMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::account::UserCountMax = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of users that the account system can manage at the same time. </p>
<p> <b>Details</b> <br  />
 The account system can manage as many as this value's number of users at the same time. When the account system is already managing this many users, you cannot add new users. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_friends_play_history_2_friends_play_history_8cpp-example.html#a3">FriendsPlayHistory/FriendsPlayHistory.cpp</a>, and <a class="el" href="_prepo_simple_2_prepo_simple_8cpp-example.html#a10">PrepoSimple/PrepoSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1287bb99842cbc1f1ac21d86a1f80737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1287bb99842cbc1f1ac21d86a1f80737">&#9670;&nbsp;</a></span>NicknameBytesMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::account::NicknameBytesMax = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes for nicknames that can be configured for users. </p>
<p> <b>Details</b> <br  />
 This is the maximum number of bytes, exclusive of a terminating character, for nicknames that users can configure. </p>

</div>
</div>
<a id="a48034b809eb0ddc1a8c1dbcd8133f9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48034b809eb0ddc1a8c1dbcd8133f9c3">&#9670;&nbsp;</a></span>ProfileImageBytesMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::account::ProfileImageBytesMax = 128 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of bytes for a profile image that can be set by the user. </p>
<p> <b>Details</b> <br  />
 This defines the largest size in bytes for profile images that can be set by the user. </p>

</div>
</div>
<a id="a27559177c66aded724c5691d7c98c3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27559177c66aded724c5691d7c98c3d0">&#9670;&nbsp;</a></span>NetworkServiceAccountIdTokenLengthMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::account::NetworkServiceAccountIdTokenLengthMax = 3072</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the network service account ID token. </p>
<p> <b>Details</b> <br  />
 The length, exclusive of terminators, is the upper limit for the network service account ID token, which is an ASCII-encoded string. </p>

</div>
</div>
<a id="a57a1b12020bba6639ccef79d23f89161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1b12020bba6639ccef79d23f89161">&#9670;&nbsp;</a></span>NintendoAccountAuthorizationCodeLengthMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::account::NintendoAccountAuthorizationCodeLengthMax = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length of the Nintendo Account authorization code. </p>
<p> <b>Details</b> <br  />
 The Nintendo Account authorization code (an ASCII code string) can be no longer than this maximum length, excluding the termination character. </p>

</div>
</div>
<a id="aa2f60d4be447019cfb6f4e58a50531b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f60d4be447019cfb6f4e58a50531b2">&#9670;&nbsp;</a></span>NintendoAccountIdTokenLengthMax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::account::NintendoAccountIdTokenLengthMax = 1536</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length of the Nintendo Account account ID token. </p>
<p> <b>Details</b> <br  />
 The Nintendo Account ID token (an ASCII code string) can be no longer than this maximum length, excluding the termination character. </p>

</div>
</div>
<a id="acc263608192f7bbdef34e3b5ae007258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc263608192f7bbdef34e3b5ae007258">&#9670;&nbsp;</a></span>DefaultUserSelectionSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1account_1_1_user_selection_settings.html">UserSelectionSettings</a> nn::account::DefaultUserSelectionSettings = {{<a class="el" href="namespacenn_1_1account.html#ae6d17c482c1a86531eb4fbbcc542ef6b">InvalidUid</a>}, false, false, false, false, false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the default settings when calling the user selection UI. </p>
<p> <b>Details</b> <br  />
 These are the default settings when calling the user selection UI. The users that can be selected match the users returned by the <code><a class="el" href="namespacenn_1_1account.html#a00ff6287a526dcdb7d596fa34b5a9d2b" title="Gets a list of users that have no restrictions (a list of qualified users).">ListQualifiedUsers()</a></code> function.</p>
<p>The <code><a class="el" href="namespacenn_1_1account.html#a749534bdfdee56eebe9203a526390b32" title="Calls the UI for selecting users.">ShowUserSelector()</a></code> function that does not take <code><a class="el" href="structnn_1_1account_1_1_user_selection_settings.html" title="Structure for configuring how to display the user selection UI.">UserSelectionSettings</a></code> as an argument operates based on these settings. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_catalog_2_main_8cpp-example.html#a116">EcCatalog/Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae6d17c482c1a86531eb4fbbcc542ef6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d17c482c1a86531eb4fbbcc542ef6b">&#9670;&nbsp;</a></span>InvalidUid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1account_1_1_uid.html">Uid</a> nn::account::InvalidUid = {{0x00ull, 0x00ull}}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code> value that is always invalid. </p>
<p> <b>Details</b> <br  />
 This value represents a <code><a class="el" href="structnn_1_1account_1_1_uid.html" title="User identifiers added to the account system.">Uid</a></code>-type value that cannot be used as a user identifier. This means that the account system will not create users with <code>InvalidUid</code> as valid users. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_album_save_screenshot_2_album_save_screenshot__main_8cpp-example.html#a18">AlbumSaveScreenshot/AlbumSaveScreenshot_Main.cpp</a>, <a class="el" href="_friends_friend_invitation_2_friends_friend_invitation_8cpp-example.html#a5">FriendsFriendInvitation/FriendsFriendInvitation.cpp</a>, and <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a9">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
