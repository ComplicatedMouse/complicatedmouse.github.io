<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvn::BarrierBits Struct Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="structnvn_1_1_barrier_bits.html">BarrierBits</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="structnvn_1_1_barrier_bits-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvn::BarrierBits Struct Reference<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__enum.html">API Enum Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Controls the ordering of commands and invalidation of caches for <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a>.  
 <a href="structnvn_1_1_barrier_bits.html#details">More...</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2c58577ff4595e150d961bc1cfc808d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5">Enum</a> { <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee">ORDER_PRIMITIVES</a> = 0x00000001
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7">ORDER_FRAGMENTS</a> = 0x00000002
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aebc5d0a824a75a2c8656b6be18403692">ORDER_FRAGMENTS_TILED</a> = 0x00000004
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4">ORDER_INDIRECT_DATA</a> = 0x00000008
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a9e69c1611d60167aabe53bc267ead1a9">INVALIDATE_TEXTURE</a> = 0x00000010
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5af1c1a082ea6e170974efc753d8e04db3">INVALIDATE_SHADER</a> = 0x00000020
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5a6b577811b7e71491b735c2540bad6e0a">INVALIDATE_TEXTURE_DESCRIPTOR</a> = 0x00000040
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5ac8720bba76d8ece30ef1e222564e7085">INVALIDATE_ZCULL</a> = 0x00000080
, <br />
&#160;&#160;<a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5aa9b1e43aeb830c6a60bfdca764d8ac5f">INVALIDATE_L2_CACHE</a> = 0x00000100
<br />
 }</td></tr>
<tr class="memdesc:a2c58577ff4595e150d961bc1cfc808d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated values for the type <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">BarrierBits</a>.  <a href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5">More...</a><br /></td></tr>
<tr class="separator:a2c58577ff4595e150d961bc1cfc808d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Controls the ordering of commands and invalidation of caches for <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a>. </p>
<p>Rendering and compute dispatch commands sent to NVN queues are executed on the GPU using a hardware pipeline, with no guarantee that work for one draw call or dispatch completes before work on the next draw call or dispatch starts. Additionally, some units of the GPU maintain caches that are not automatically invalidated when cached data are overwritten by the CPU or other units of the GPU. This bitfield type is used by <a class="el" href="classnvn_1_1_command_buffer.html#a1d9df9457cbd501a6035720f31979752" title="Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.">CommandBuffer::Barrier</a> to order the processing of commands sent before and after the barrier and to invalidate GPU caches before processing commands sent after the barrier. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2c58577ff4595e150d961bc1cfc808d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c58577ff4595e150d961bc1cfc808d5">&#9670;&nbsp;</a></span>Enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structnvn_1_1_barrier_bits.html#a2c58577ff4595e150d961bc1cfc808d5">nvn::BarrierBits::Enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated values for the type <a class="el" href="structnvn_1_1_barrier_bits.html" title="Controls the ordering of commands and invalidation of caches for CommandBuffer::Barrier.">BarrierBits</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5a06a52602108f785ae61f729672885dee"></a>ORDER_PRIMITIVES&#160;</td><td class="fielddoc"><p>Ensure that primitives and compute dispatches from after the barrier don't start until all such work from before the barrier has completed. </p>
<dl class="section warning"><dt>Warning</dt><dd>ORDER_PRIMITIVES does not ensure that all work before the barrier completes before fetching per-draw data for indirect draws and compute dispatches after the barrier. If per-draw data needed by indirect draws or dispatches are produced by commands executed by the GPU, a barrier with the ORDER_INDIRECT_DATA bit set is required. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5a14ad18f3abf9b6bdcf34d22751d399d7"></a>ORDER_FRAGMENTS&#160;</td><td class="fielddoc"><p>Ensure that fragments from after the barrier don't start until all fragments from before the barrier have finished. </p>
<p>ORDER_FRAGMENTS ensures that all fragments spawned by commands sent before the barrier complete execution on the GPU before processing any fragments spawned by commands sent after the barrier. This is useful for cases like render-to-texture, where one rendering pass writes to a texture as a render target, and the next pass reads the values written in a fragment shader.</p>
<dl class="section note"><dt>Note</dt><dd>ORDER_FRAGMENTS <em>only</em> orders fragment shader execution and subsequent per-fragment operations (e.g., depth and stencil tests, blending, and stores to the framebuffer). Vertex processing for draw calls sent after the barrier may begin before fragments from before the barrier complete; to ensure proper order for dependent vertex processing work, ORDER_PRIMITIVES should be used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>On the Windows reference implementation for Turing and older GPUs, there are a few exceptions to the ordering guarantee for ORDER_FRAGMENTS. The GPU may begin processing depth/stencil clears or depth/stencil testing (including buffer updates) for fragments after the barrier before completing all processing of fragments before the barrier. When fragments from after the barrier perform such updates to a texture not yet read by fragments from before the barrier, a heavier barrier like ORDER_PRIMITIVES is necessary to ensure the "new" fragments don't overwrite values not yet read by "old" ones. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5aebc5d0a824a75a2c8656b6be18403692"></a>ORDER_FRAGMENTS_TILED&#160;</td><td class="fielddoc"><p>Ensure that fragments from after the barrier don't start until all fragments from before the barrier in the same screen-space tile have finished. </p>
<p>ORDER_FRAGMENTS_TILED behaves like ORDER_FRAGMENTS, except that it only guarantees the ordering of fragments within screen-space tiles. If two fragments belong to different screen-space tiles, work for one fragment from after the barrier may begin before work for the other fragment from before the barrier completes. This mode is useful for render-to-texture operations where the second texturing pass accesses texels written during the first pass with the same (x,y) coordinates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5af28c9a9c0844d5e10b871341d9ce66a4"></a>ORDER_INDIRECT_DATA&#160;</td><td class="fielddoc"><p>Ensure that all work before the barrier completes before fetching per-draw data for indirect draws and compute dispatches after the barrier. </p>
<p>When executing indirect draws or compute dispatches, the GPU might fetch per-draw data before previous GPU work has completed, even in cases where the application waits on a sync object using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>. A barrier with this bit set is required to ensure that the GPU doesn't prematurely fetch the indirect data. Note that this bit is not required when the indirect data are written by the CPU.</p>
<dl class="section warning"><dt>Warning</dt><dd>ORDER_INDIRECT_DATA requires more expensive synchronization than ORDER_PRIMITIVES and should be used only when required. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5a9e69c1611d60167aabe53bc267ead1a9"></a>INVALIDATE_TEXTURE&#160;</td><td class="fielddoc"><p>Invalidate caches used to hold texture data fetched via sampler or image variables. </p>
<p>When texture memory is written to by either the CPU or by GPU commands other than copy commands, applications must invalidate the texture cache. If the texture memory is written by non-copy GPU commands, applications must also ensure that the GPU commands producing the new data have completed, either by setting an ORDER bit in the barrier or by waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5af1c1a082ea6e170974efc753d8e04db3"></a>INVALIDATE_SHADER&#160;</td><td class="fielddoc"><p>Invalidate caches used to hold shader code and data from uniform or shader storage blocks. </p>
<p>When shader code, uniform blocks, or shader storage blocks are written to by either the CPU or the GPU commands other than copy commands, applications must invalidate the shader caches. If the memory is written by non-copy GPU commands, applications must also ensure that the GPU commands producing the new data have completed, either by setting an ORDER bit in the barrier or by waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress.">Sync</a> object.</p>
<p>In particular, before executing new shader code used by <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">Program::SetShaders</a>, the shader caches must be invalidated to ensure it they are not holding old instructions using the same memory as the new shader code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5a6b577811b7e71491b735c2540bad6e0a"></a>INVALIDATE_TEXTURE_DESCRIPTOR&#160;</td><td class="fielddoc"><p>Invalidate caches used to hold texture and sampler descriptors. </p>
<p>When new texture, image, or sampler descriptors are registered in the texture or sampler pools using <a class="el" href="classnvn_1_1_texture_pool.html#a310e22deed370a593617c4a73c394f5f" title="Register a texture descriptor in a texture pool for use via texture handles.">TexturePool::RegisterTexture</a>, <a class="el" href="classnvn_1_1_texture_pool.html#a0dfac012b673d8e809fe86ca9c941b5a" title="Register an image descriptor in a texture pool for use via image loads and stores.">TexturePool::RegisterImage</a>, <a class="el" href="classnvn_1_1_sampler_pool.html#af39ae66ac172ee0c4804ff4b95fc94e7" title="Register a sampler descriptor in a sampler pool for use via texture handles, using a Sampler object.">SamplerPool::RegisterSampler</a>, or <a class="el" href="classnvn_1_1_sampler_pool.html#a8ddc47f155142938c3553c6aafcddf37" title="Register a sampler descriptor in a sampler pool for use via texture handles, using SamplerBuilder sta...">SamplerPool::RegisterSamplerBuilder</a>, the texture descriptor cache must be invalidated to avoid the possibility of fetching stale texture or sampler pool entries.</p>
<p>note The texture and sampler descriptor caches are automatically invalidated when command buffers are flushed, as well as when switching to a new texture or sampler pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5ac8720bba76d8ece30ef1e222564e7085"></a>INVALIDATE_ZCULL&#160;</td><td class="fielddoc"><p>Invalidate GPU ZCull storage after direct depth texture updates. </p>
<p>For depth textures, the GPU maintains internal <em>ZCull</em> storage that is used to accelerate depth and stencil testing. The ZCull hardware tracks updates to the depth buffer when processing clears and depth buffer updates from the depth test, and maintains a low-resolution representation of the depth buffer. ZCull data can often be used to quickly determine if fragments will pass or fail the depth test. When a depth texture is updated via copy commands such as <a class="el" href="classnvn_1_1_command_buffer.html#acc27996fe951eb5f8f9c852c0dca88f7" title="Copy texture data from a region of one Texture object into a region of another Texture object.">CommandBuffer::CopyTextureToTexture</a>, the ZCull storage will be out of date and require invalidation. When a depth buffer is updated only by clears or normal rendering, barriers with INVALIDATE_ZCULL will unnecessarily reduce performance.</p>
<dl class="section note"><dt>Note</dt><dd>The ZCull storage is automatically invalidated when switching to a new depth render target using <a class="el" href="classnvn_1_1_command_buffer.html#ad4940982011cd1c5c8cc1c9e25262f70" title="Sets color and depth/stencil textures in the framebuffer.">CommandBuffer::SetRenderTargets</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2c58577ff4595e150d961bc1cfc808d5aa9b1e43aeb830c6a60bfdca764d8ac5f"></a>INVALIDATE_L2_CACHE&#160;</td><td class="fielddoc"><p>Invalidates the L2 cache. </p>
<p>Invalidating the L2 cache may be necessary when writing different RAW formats to the same physical memory location.For more details, see the Memory Pool Aliasing section of the NVN Programming Guide.</p>
<dl class="section warning"><dt>Warning</dt><dd>in addition to invalidating the cache, this flag performs a wait-for-idle. This may negatively impact performance. </dd></dl>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
