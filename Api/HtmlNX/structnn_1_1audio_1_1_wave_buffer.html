<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::audio::WaveBuffer Struct Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1audio.html">audio</a></li><li class="navelem"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html">WaveBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structnn_1_1audio_1_1_wave_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nn::audio::WaveBuffer Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Structure for handling waveform input provided to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>.  
 <a href="structnn_1_1audio_1_1_wave_buffer.html#details">More...</a></p>

<p><code>#include &lt;nn/audio/audio_WaveBuffer.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html">MemberOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The option to specify enabled or disabled for each <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> structure member.  <a href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad7ea254b8bcd4cfa996c2187969a1989"><td class="memItemLeft" align="right" valign="top"><a id="ad7ea254b8bcd4cfa996c2187969a1989"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#ad7ea254b8bcd4cfa996c2187969a1989">buffer</a></td></tr>
<tr class="memdesc:ad7ea254b8bcd4cfa996c2187969a1989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer address that maintains the waveform data to play back. <br /></td></tr>
<tr class="separator:ad7ea254b8bcd4cfa996c2187969a1989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4159c74e68b2339196b804a1dbbbf"><td class="memItemLeft" align="right" valign="top"><a id="af5f4159c74e68b2339196b804a1dbbbf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#af5f4159c74e68b2339196b804a1dbbbf">contextSize</a></td></tr>
<tr class="memdesc:af5f4159c74e68b2339196b804a1dbbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the data specified for <code><em>pContext</em></code>. <br /></td></tr>
<tr class="separator:af5f4159c74e68b2339196b804a1dbbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510857dab35b885cc45775d3ca0e2d9c"><td class="memItemLeft" align="right" valign="top"><a id="a510857dab35b885cc45775d3ca0e2d9c"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a510857dab35b885cc45775d3ca0e2d9c">endSampleOffset</a></td></tr>
<tr class="memdesc:a510857dab35b885cc45775d3ca0e2d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset location for ending playback, in samples. <br /></td></tr>
<tr class="separator:a510857dab35b885cc45775d3ca0e2d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09535d7c451e0b53d0c1c4acba8af70d"><td class="memItemLeft" align="right" valign="top"><a id="a09535d7c451e0b53d0c1c4acba8af70d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a09535d7c451e0b53d0c1c4acba8af70d">isEndOfStream</a></td></tr>
<tr class="memdesc:a09535d7c451e0b53d0c1c4acba8af70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for clearing the number of playback samples for <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> after playback has ended. <br /></td></tr>
<tr class="separator:a09535d7c451e0b53d0c1c4acba8af70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8998952082859b6ab22549250fad5003"><td class="memItemLeft" align="right" valign="top"><a id="a8998952082859b6ab22549250fad5003"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a8998952082859b6ab22549250fad5003">loop</a></td></tr>
<tr class="memdesc:a8998952082859b6ab22549250fad5003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop playback flag. <br /></td></tr>
<tr class="separator:a8998952082859b6ab22549250fad5003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446e9b7e15b4b54785bd96264a6256d9"><td class="memItemLeft" align="right" valign="top"><a id="a446e9b7e15b4b54785bd96264a6256d9"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a446e9b7e15b4b54785bd96264a6256d9">loopCount</a></td></tr>
<tr class="memdesc:a446e9b7e15b4b54785bd96264a6256d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop count. <br /></td></tr>
<tr class="separator:a446e9b7e15b4b54785bd96264a6256d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfd26dd8ee60f9b81f1aa3960c2bb92"><td class="memItemLeft" align="right" valign="top"><a id="a7dfd26dd8ee60f9b81f1aa3960c2bb92"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a7dfd26dd8ee60f9b81f1aa3960c2bb92">loopEndSampleOffset</a></td></tr>
<tr class="memdesc:a7dfd26dd8ee60f9b81f1aa3960c2bb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop playback end position offset [Sample]. <br /></td></tr>
<tr class="separator:a7dfd26dd8ee60f9b81f1aa3960c2bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8481768fdac33690cc391ba23252bb01"><td class="memItemLeft" align="right" valign="top"><a id="a8481768fdac33690cc391ba23252bb01"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a8481768fdac33690cc391ba23252bb01">loopStartSampleOffset</a></td></tr>
<tr class="memdesc:a8481768fdac33690cc391ba23252bb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop playback start position offset [Sample]. <br /></td></tr>
<tr class="separator:a8481768fdac33690cc391ba23252bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b836718c60e740f6728d29ca686393"><td class="memItemLeft" align="right" valign="top"><a id="a04b836718c60e740f6728d29ca686393"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a04b836718c60e740f6728d29ca686393">pContext</a></td></tr>
<tr class="memdesc:a04b836718c60e740f6728d29ca686393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context data. <br /></td></tr>
<tr class="separator:a04b836718c60e740f6728d29ca686393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd91dcb09e9ee27c717728270c0e3c3"><td class="memItemLeft" align="right" valign="top"><a id="a0dd91dcb09e9ee27c717728270c0e3c3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a0dd91dcb09e9ee27c717728270c0e3c3">size</a></td></tr>
<tr class="memdesc:a0dd91dcb09e9ee27c717728270c0e3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the buffer specified for <code><em>buffer</em></code>, in bytes. <br /></td></tr>
<tr class="separator:a0dd91dcb09e9ee27c717728270c0e3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06a8f9b5986c743352b492c3bf5d911"><td class="memItemLeft" align="right" valign="top"><a id="af06a8f9b5986c743352b492c3bf5d911"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#af06a8f9b5986c743352b492c3bf5d911">startSampleOffset</a></td></tr>
<tr class="memdesc:af06a8f9b5986c743352b492c3bf5d911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset location for starting playback, in samples. <br /></td></tr>
<tr class="separator:af06a8f9b5986c743352b492c3bf5d911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8ab913202da90a5692e1ad709f41b357"><td class="memItemLeft" align="right" valign="top"><a id="a8ab913202da90a5692e1ad709f41b357"></a>
static constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html#a8ab913202da90a5692e1ad709f41b357">LoopCountForever</a> = -1</td></tr>
<tr class="memdesc:a8ab913202da90a5692e1ad709f41b357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number representing an infinite loop count. <br /></td></tr>
<tr class="separator:a8ab913202da90a5692e1ad709f41b357"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure for handling waveform input provided to a <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. </p>
<p> <b>Details</b> <br  />
 This structure handles the waveform data to play. Specify the data to play back using <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> to <code><em>buffer</em></code> and <code><em>size</em></code>. If you are dealing with data in multichannel format, you need to store sample data for each channel in accordance with the prescribed formats for each sample format. If the data is in PCM format, store the samples one after the next in interleaved format for each channel. For other formats, multichannel playback is not supported by the current release. You can specify the playback start and end positions for the waveform data specified in <code><em>buffer</em></code> using <code><em>startSampleOffset</em></code> and <code><em>endSampleOffset</em></code>. The unit for the data is samples. Specify <code><em>startSampleOffset</em></code> and <code><em>endSampleOffset</em></code> so that (<code><em>endSampleOffset</em></code> - <code><em>startSampleOffset</em></code>) is the number of samples to play back. For example, if 1000 samples of waveform data are specified as the buffer, specify <code>0</code> for <code><em>startSampleOffset</em></code> and <code>1000</code> for <code><em>endSampleOffset</em></code> to play all of these waveforms.</p>
<p>Setting <code><em>loop</em></code> to <code>true</code> loops playback of the relevant <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> by <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code>. The behavior of this loop playback can be controlled using the following three members.</p><ul>
<li>Use <code><em>loopStartSampleOffset</em></code> to specify the loop start position offset.</li>
<li>Use <code><em>loopEndSampleOffset</em></code> to specify the loop end position offset.</li>
<li>Use <code><em>loopCount</em></code> to specify the loop count. When <code>LoopCountForever</code> is specified, the loop count becomes infinite. If <code>0</code> is specified, loop playback is not performed.</li>
</ul>
<p>However, the values of these members are only valid when specifying an instance where <code><em>pMemberOptions</em>-&gt;isLoopInfoEnabled</code> == <code>true</code> in the <code><em>pMemberOptions</em></code> argument when calling <code><a class="el" href="namespacenn_1_1audio.html#aa58886eeb3fac72d6e84dcad5d2704df" title="Adds a WaveBuffer object to VoiceType.">nn::audio::AppendWaveBuffer</a>(VoiceType* <em>pVoice</em>, const WaveBuffer* <em>pWaveBuffer</em>, const <a class="el" href="structnn_1_1audio_1_1_wave_buffer_1_1_member_options.html" title="The option to specify enabled or disabled for each WaveBuffer structure member.">WaveBuffer::MemberOptions</a>* <em>pMemberOptions</em>)</code>. If an instance where this is <code>false</code> is specified, these three member values are ignored, and the following behavior results.</p><ul>
<li>The loop start position is the <code><em>startSampleOffset</em></code> position.</li>
<li>The loop end position is the <code><em>endSampleOffset</em></code> position.</li>
<li>The loop count is infinite.</li>
</ul>
<p>The following behavior occurs when <code><em>pMemberOptions-</em>&gt;isLoopInfoEnabled</code> == <code>true</code>.</p><ul>
<li>First, the area between <code><em>startSampleOffset</em></code> and <code><em>endSampleOffset</em></code> is played once.</li>
<li>Afterward, the region between <code><em>loopStartSampleOffset</em></code> and <code><em>loopEndSampleOffset</em></code> is played <code><em>loopCount</em></code> times.</li>
</ul>
<p>Even for a <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> instance with an infinite loop count, if <code>PlayState_Stop</code> is specified in <code><a class="el" href="namespacenn_1_1audio.html#a04a09b692d969f08155cf7f0f57d9ace" title="Sets the play state for the VoiceType object.">nn::audio::SetVoicePlayState()</a></code>, or <code><a class="el" href="namespacenn_1_1audio.html#afb313288140d4236cd42e19aca3f98e6" title="Sets all WaveBuffer objects registered to VoiceType as finished being played.">nn::audio::FlushWaveBuffers()</a></code> is called, for the <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> that the <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> instance is added to, that <code><a class="el" href="structnn_1_1audio_1_1_wave_buffer.html" title="Structure for handling waveform input provided to a VoiceType.">WaveBuffer</a></code> is treated as having been played. For more information, see <code><a class="el" href="namespacenn_1_1audio.html#a04a09b692d969f08155cf7f0f57d9ace" title="Sets the play state for the VoiceType object.">nn::audio::SetVoicePlayState()</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#afb313288140d4236cd42e19aca3f98e6" title="Sets all WaveBuffer objects registered to VoiceType as finished being played.">nn::audio::FlushWaveBuffers()</a></code>. Setting <code><em>isEndOfStream</em></code> to <code>true</code> clears the number of <code><a class="el" href="structnn_1_1audio_1_1_voice_type.html" title="Structure that controls waveform input to the renderer.">VoiceType</a></code> playback samples, or, in practical terms, the value available using <code><a class="el" href="namespacenn_1_1audio.html#a6913685f14bb0b350eabb2517eb11dd4" title="Gets the number of samples that have been played by the VoiceType object.">nn::audio::GetVoicePlayedSampleCount()</a></code>, to <code>0</code>. <code><em>pContext</em></code> is used to specify the various types of context data, including parameters needed in conjunction with this waveform data. In the current release, it is used to specify <code><a class="el" href="structnn_1_1audio_1_1_adpcm_context.html" title="ADPCM context information.">nn::audio::AdpcmContext</a></code> to loop playback of ADPCM waveform data. Specify <code>nullptr</code> for waveform data that is not required to be set.</p>
<p>The following two memory regions must lie within the memory space maintained by <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code>.</p><ul>
<li>The buffer specified for <code><em>buffer</em></code>.</li>
<li>If data is specified for <code><em>pContext</em></code>, then that data.</li>
</ul>
<p>For more information, see <code><a class="el" href="structnn_1_1audio_1_1_memory_pool_type.html" title="Structure for representing memory regions used by an audio renderer.">nn::audio::MemoryPoolType</a></code> and <code><a class="el" href="namespacenn_1_1audio.html#a8e7b32e31ba3ea6f61c00c752c3a90d0" title="Gets a memory pool for an audio renderer.">nn::audio::AcquireMemoryPool()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#_a91">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#_a67">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#_a163">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#_a125">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#_a48">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_2_audio_multiple_renderer_8cpp-example.html#_a38">AudioMultipleRenderer/AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#_a95">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#_a80">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#_a91">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#_a134">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#_a57">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#_a100">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#_a52">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#_a64">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, and <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#_a9">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>.</dd>
</dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
