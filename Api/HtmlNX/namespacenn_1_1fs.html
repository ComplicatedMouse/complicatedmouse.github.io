<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nn::fs Namespace Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1fs.html">fs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nn::fs Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the file system library.  
<a href="namespacenn_1_1fs.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that represents the cache storage information.  <a href="structnn_1_1fs_1_1_cache_storage_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle for getting the cache storage list.  <a href="structnn_1_1fs_1_1_cache_storage_list_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing directory entries.  <a href="structnn_1_1fs_1_1_directory_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for working with a directory.  <a href="structnn_1_1fs_1_1_directory_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for working with a file.  <a href="structnn_1_1fs_1_1_file_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that defines file timestamp information.  <a href="structnn_1_1fs_1_1_file_time_stamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_mount_host_option.html">MountHostOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The option specifiers for <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code>.  <a href="structnn_1_1fs_1_1_mount_host_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option specifier to use when reading files.  <a href="structnn_1_1fs_1_1_read_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_allocation_memory_failed.html">ResultAllocationMemoryFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Insufficient memory.).  <a href="classnn_1_1fs_1_1_result_allocation_memory_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_already_exists.html">ResultAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: There is already a file or directory with the same name.).  <a href="classnn_1_1fs_1_1_result_already_exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_data_corrupted.html">ResultDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Detected data corruption or tampering.).  <a href="classnn_1_1fs_1_1_result_data_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_deferred_process_retry_failure.html">ResultDeferredProcessRetryFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: An access error occurred, and resolving delayed processing failed.).  <a href="classnn_1_1fs_1_1_result_deferred_process_retry_failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_directory_not_empty.html">ResultDirectoryNotEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Target directory contains an entry.).  <a href="classnn_1_1fs_1_1_result_directory_not_empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_directory_status_changed.html">ResultDirectoryStatusChanged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Directory status changed while listing contents.).  <a href="classnn_1_1fs_1_1_result_directory_status_changed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_access_failed.html">ResultGameCardAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Failed to access the game card.).  <a href="classnn_1_1fs_1_1_result_game_card_access_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_card_access_failure.html">ResultGameCardCardAccessFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: GameCard - Game card access error.).  <a href="classnn_1_1fs_1_1_result_game_card_card_access_failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_initialize_asic_failure.html">ResultGameCardInitializeAsicFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: GameCard - ASIC initialization error.).  <a href="classnn_1_1fs_1_1_result_game_card_initialize_asic_failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_logo_data_corrupted.html">ResultGameCardLogoDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Detected data corruption or tampering in the logo data on the game card.).  <a href="classnn_1_1fs_1_1_result_game_card_logo_data_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_entry_corrupted.html">ResultHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host entry is corrupted.).  <a href="classnn_1_1fs_1_1_result_host_entry_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_corrupted.html">ResultHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host file is corrupted.).  <a href="classnn_1_1fs_1_1_result_host_file_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_data_corrupted.html">ResultHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Host data is corrupted.).  <a href="classnn_1_1fs_1_1_result_host_file_data_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_system_corrupted.html">ResultHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Detected host file system data corruption or tampering.).  <a href="classnn_1_1fs_1_1_result_host_file_system_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_individual_file_data_cache_already_enabled.html">ResultIndividualFileDataCacheAlreadyEnabled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The individual file data cache is already enabled.).  <a href="classnn_1_1fs_1_1_result_individual_file_data_cache_already_enabled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_invalid_host_handle.html">ResultInvalidHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Invalid host handle.).  <a href="classnn_1_1fs_1_1_result_invalid_host_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_invalid_rom_host_handle.html">ResultInvalidRomHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Invalid host handle.).  <a href="classnn_1_1fs_1_1_result_invalid_rom_host_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_mmc_access_failed.html">ResultMmcAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Failed to access system memory.).  <a href="classnn_1_1fs_1_1_result_mmc_access_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html">ResultMountNameAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The mount name already exists, or is already mounted to HostRoot.).  <a href="classnn_1_1fs_1_1_result_mount_name_already_exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_nca_external_key_unavailable.html">ResultNcaExternalKeyUnavailable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Cannot use the external NCA key.).  <a href="classnn_1_1fs_1_1_result_nca_external_key_unavailable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_not_implemented.html">ResultNotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Operation not implemented.).  <a href="classnn_1_1fs_1_1_result_not_implemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_out_of_range.html">ResultOutOfRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Operation is out of range.).  <a href="classnn_1_1fs_1_1_result_out_of_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_partition_not_found.html">ResultPartitionNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Cannot find the target partition.).  <a href="classnn_1_1fs_1_1_result_partition_not_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html">ResultPathAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Target already exists.).  <a href="classnn_1_1fs_1_1_result_path_already_exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">ResultPathNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Cannot find the target in the specified path.).  <a href="classnn_1_1fs_1_1_result_path_not_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_entry_corrupted.html">ResultRomHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host entry is corrupted.).  <a href="classnn_1_1fs_1_1_result_rom_host_entry_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_corrupted.html">ResultRomHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host file is corrupted.).  <a href="classnn_1_1fs_1_1_result_rom_host_file_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_data_corrupted.html">ResultRomHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Host data is corrupted.).  <a href="classnn_1_1fs_1_1_result_rom_host_file_data_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_system_corrupted.html">ResultRomHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Detected host file system data corruption or tampering.).  <a href="classnn_1_1fs_1_1_result_rom_host_file_system_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_entry_corrupted.html">ResultSaveDataHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host entry is corrupted.).  <a href="classnn_1_1fs_1_1_result_save_data_host_entry_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_corrupted.html">ResultSaveDataHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The host file is corrupted.).  <a href="classnn_1_1fs_1_1_result_save_data_host_file_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_data_corrupted.html">ResultSaveDataHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Host data is corrupted.).  <a href="classnn_1_1fs_1_1_result_save_data_host_file_data_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_system_corrupted.html">ResultSaveDataHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Detected host file system data corruption or tampering.).  <a href="classnn_1_1fs_1_1_result_save_data_host_file_system_corrupted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_invalid_host_handle.html">ResultSaveDataInvalidHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Invalid host handle.).  <a href="classnn_1_1fs_1_1_result_save_data_invalid_host_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_sd_card_access_failed.html">ResultSdCardAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Failed to access the SD card.).  <a href="classnn_1_1fs_1_1_result_sd_card_access_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html">ResultTargetLocked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Target is locked.).  <a href="classnn_1_1fs_1_1_result_target_locked.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_target_locked_with_abort.html">ResultTargetLockedWithAbort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Target is locked.).  <a href="classnn_1_1fs_1_1_result_target_locked_with_abort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html">ResultTargetNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Target not found.).  <a href="classnn_1_1fs_1_1_result_target_not_found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unexpected.html">ResultUnexpected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Unknown failure.).  <a href="classnn_1_1fs_1_1_result_unexpected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unsupported_sdk_version.html">ResultUnsupportedSdkVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The SDK version is not supported.).  <a href="classnn_1_1fs_1_1_result_unsupported_sdk_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unsupported_version.html">ResultUnsupportedVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: The version is too new.).  <a href="classnn_1_1fs_1_1_result_unsupported_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html">ResultUsableSpaceNotEnough</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Not enough free space.).  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html">ResultUsableSpaceNotEnoughForCacheStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Not enough free space to create cache storage.).  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_save_data.html">ResultUsableSpaceNotEnoughForSaveData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents error <code><a class="el" href="classnn_1_1_result.html">Result</a></code> values (<code>fs</code>: Not enough free space to create save data.).  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_save_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option specifier to use when writing files.  <a href="structnn_1_1fs_1_1_write_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9860dee956c54cadf027c37d54adeb28"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a>) (size_t)</td></tr>
<tr class="memdesc:a9860dee956c54cadf027c37d54adeb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer for memory allocation.  <a href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">More...</a><br /></td></tr>
<tr class="separator:a9860dee956c54cadf027c37d54adeb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c75b075241d17f1b52cd9eefa851aa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a>) (void *, size_t)</td></tr>
<tr class="memdesc:a07c75b075241d17f1b52cd9eefa851aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer for memory deallocation.  <a href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">More...</a><br /></td></tr>
<tr class="separator:a07c75b075241d17f1b52cd9eefa851aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5fc46cd05067c210b62e96f903a2fe85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85a2824a031f5834c762620e321ac8933c6">DirectoryEntryType_Directory</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85a194470d850d5968a491fd9ef6145d5a0">DirectoryEntryType_File</a>
<br />
 }</td></tr>
<tr class="memdesc:a5fc46cd05067c210b62e96f903a2fe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing directory entry types.  <a href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">More...</a><br /></td></tr>
<tr class="separator:a5fc46cd05067c210b62e96f903a2fe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6758dcecf390a3c4028a8651fc5d305d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305d">MountHostOptionFlag</a> { <a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a">MountHostOptionFlag_PseudoCaseSensitive</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:a6758dcecf390a3c4028a8651fc5d305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for specifying the <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code> options.  <a href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305d">More...</a><br /></td></tr>
<tr class="separator:a6758dcecf390a3c4028a8651fc5d305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bc03cdbe641524cab284a7fe7ba705"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">OpenDirectoryMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a6cabc455dd34f3d7562137ea63a5daab">OpenDirectoryMode_Directory</a> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a560a621c8b1cb6f228ea202b9efd7432">OpenDirectoryMode_File</a> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a1769c5d739757a86e8f98bddbc3ee9c5">OpenDirectoryMode_All</a> = OpenDirectoryMode_Directory | OpenDirectoryMode_File
<br />
 }</td></tr>
<tr class="memdesc:a34bc03cdbe641524cab284a7fe7ba705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to specify the mode when opening a directory.  <a href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">More...</a><br /></td></tr>
<tr class="separator:a34bc03cdbe641524cab284a7fe7ba705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c97b79cce78a95c2333dbc9053b9393"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">OpenMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d">OpenMode_Read</a> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03">OpenMode_Write</a> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1">OpenMode_AllowAppend</a> = 1 &lt;&lt; 2
<br />
 }</td></tr>
<tr class="memdesc:a4c97b79cce78a95c2333dbc9053b9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to specify the mode when opening a file.  <a href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">More...</a><br /></td></tr>
<tr class="separator:a4c97b79cce78a95c2333dbc9053b9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a9f55e854a9755c9264838caa97d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3a0fa1620fa464966eddf7e9a82a0eef91">Priority_Realtime</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3a3fe1f52283573973940fa566d116289e">Priority_Normal</a>
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3aa4c563bb69a4dfd6ac970ba42def209a">Priority_Low</a>
<br />
 }</td></tr>
<tr class="memdesc:a2e4a9f55e854a9755c9264838caa97d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access priority.  <a href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">More...</a><br /></td></tr>
<tr class="separator:a2e4a9f55e854a9755c9264838caa97d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4fdd50e0892400c07232f714caa14d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">WriteOptionFlag</a> { <a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14da2956e16dac576b2b7eff3142e18ac2c0">WriteOptionFlag_Flush</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:afb4fdd50e0892400c07232f714caa14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for specifying options to use when writing files.  <a href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">More...</a><br /></td></tr>
<tr class="separator:afb4fdd50e0892400c07232f714caa14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Cache Storage</div></td></tr>
<tr class="memitem:a38a958348ad64793a93e82a5a556d7b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a38a958348ad64793a93e82a5a556d7b4">MountCacheStorage</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38a958348ad64793a93e82a5a556d7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a cache storage.  <a href="namespacenn_1_1fs.html#a38a958348ad64793a93e82a5a556d7b4">More...</a><br /></td></tr>
<tr class="separator:a38a958348ad64793a93e82a5a556d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab217b088ff86a675d869cc9fb38390ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab217b088ff86a675d869cc9fb38390ac">MountCacheStorage</a> (const char *name, int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab217b088ff86a675d869cc9fb38390ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the index and mounts the cache storage.  <a href="namespacenn_1_1fs.html#ab217b088ff86a675d869cc9fb38390ac">More...</a><br /></td></tr>
<tr class="separator:ab217b088ff86a675d869cc9fb38390ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directory API Resources</div></td></tr>
<tr class="memitem:af1ecb9478fe0f9dee627b65111cdbe29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29">ReadDirectory</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a> *entryBuffer, <a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle, int64_t entryBufferCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af1ecb9478fe0f9dee627b65111cdbe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the child entries of a directory.  <a href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29">More...</a><br /></td></tr>
<tr class="separator:af1ecb9478fe0f9dee627b65111cdbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa6a54b0d39dfd293b11cd1c0073aafb1">GetDirectoryEntryCount</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of child entries in a directory.  <a href="namespacenn_1_1fs.html#aa6a54b0d39dfd293b11cd1c0073aafb1">More...</a><br /></td></tr>
<tr class="separator:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af8d0fa5050c0f77a0a6f14a0b78f9b58">CloseDirectory</a> (<a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a directory.  <a href="namespacenn_1_1fs.html#af8d0fa5050c0f77a0a6f14a0b78f9b58">More...</a><br /></td></tr>
<tr class="separator:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae21d0f79e4d074e120c814a8936a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42">OpenDirectory</a> (<a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> *outValue, const char *path, int mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acae21d0f79e4d074e120c814a8936a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a directory.  <a href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42">More...</a><br /></td></tr>
<tr class="separator:acae21d0f79e4d074e120c814a8936a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File API Resources</div></td></tr>
<tr class="memitem:a81801a404563984f8c6cc1483cc6d730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">ReadFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a81801a404563984f8c6cc1483cc6d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into the specified memory.  <a href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">More...</a><br /></td></tr>
<tr class="separator:a81801a404563984f8c6cc1483cc6d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a90b280140b3e9d7eb83af3e807e4c0c3">ReadFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file, without options, into the specified memory.  <a href="namespacenn_1_1fs.html#a90b280140b3e9d7eb83af3e807e4c0c3">More...</a><br /></td></tr>
<tr class="separator:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa57d27066c8c88b6bf354fcfb3a8f394">ReadFile</a> (size_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into the specified memory, and gets the size of the loaded data.  <a href="namespacenn_1_1fs.html#aa57d27066c8c88b6bf354fcfb3a8f394">More...</a><br /></td></tr>
<tr class="separator:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a913ce9dd7154b430118e99b4867b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a433a913ce9dd7154b430118e99b4867b">ReadFile</a> (size_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a433a913ce9dd7154b430118e99b4867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file, without options, into the specified memory, and gets the size of the loaded data.  <a href="namespacenn_1_1fs.html#a433a913ce9dd7154b430118e99b4867b">More...</a><br /></td></tr>
<tr class="separator:a433a913ce9dd7154b430118e99b4867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4351ff3a319e9a63093324a669492ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab">WriteFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, const void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab4351ff3a319e9a63093324a669492ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of the specified memory to a file.  <a href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab">More...</a><br /></td></tr>
<tr class="separator:ab4351ff3a319e9a63093324a669492ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76">FlushFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that data written with <code><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="Writes the contents of the specified memory to a file.">WriteFile()</a></code> is actually saved to the file.  <a href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76">More...</a><br /></td></tr>
<tr class="separator:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab469b77c1d8c44eaedb9b6d658aba6c6">SetFileSize</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of a file.  <a href="namespacenn_1_1fs.html#ab469b77c1d8c44eaedb9b6d658aba6c6">More...</a><br /></td></tr>
<tr class="separator:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba29e01d386e809349d60eccdb15ff21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">GetFileSize</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba29e01d386e809349d60eccdb15ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a file.  <a href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">More...</a><br /></td></tr>
<tr class="separator:aba29e01d386e809349d60eccdb15ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2805c57e6c7c5ec8fbc7d30e7137deae">GetFileOpenMode</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode specified when the file was opened.  <a href="namespacenn_1_1fs.html#a2805c57e6c7c5ec8fbc7d30e7137deae">More...</a><br /></td></tr>
<tr class="separator:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bd9e828751bd4f953acfa765278f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">CloseFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8bd9e828751bd4f953acfa765278f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a file.  <a href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">More...</a><br /></td></tr>
<tr class="separator:ac8bd9e828751bd4f953acfa765278f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">OpenFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> *outValue, const char *path, int mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file.  <a href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">More...</a><br /></td></tr>
<tr class="separator:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for File Data Cache</div></td></tr>
<tr class="memitem:a1cb2578c957151c15e7a61836173bdc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a1cb2578c957151c15e7a61836173bdc2">EnableGlobalFileDataCache</a> (void *pBuffer, size_t bufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1cb2578c957151c15e7a61836173bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables global file data caching.  <a href="namespacenn_1_1fs.html#a1cb2578c957151c15e7a61836173bdc2">More...</a><br /></td></tr>
<tr class="separator:a1cb2578c957151c15e7a61836173bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f154d34fd5f9d2d9bc0d742d745b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a31f154d34fd5f9d2d9bc0d742d745b6a">DisableGlobalFileDataCache</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a31f154d34fd5f9d2d9bc0d742d745b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables global file data caching.  <a href="namespacenn_1_1fs.html#a31f154d34fd5f9d2d9bc0d742d745b6a">More...</a><br /></td></tr>
<tr class="separator:a31f154d34fd5f9d2d9bc0d742d745b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d72712742fd49f26a5bd36cce94d481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2d72712742fd49f26a5bd36cce94d481">EnableIndividualFileDataCache</a> (const char *path, void *pBuffer, size_t bufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2d72712742fd49f26a5bd36cce94d481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables individual file data caching.  <a href="namespacenn_1_1fs.html#a2d72712742fd49f26a5bd36cce94d481">More...</a><br /></td></tr>
<tr class="separator:a2d72712742fd49f26a5bd36cce94d481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774744bdd98a6a252de1262ce56f4ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a774744bdd98a6a252de1262ce56f4ef6">DisableIndividualFileDataCache</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a774744bdd98a6a252de1262ce56f4ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables individual file data caching.  <a href="namespacenn_1_1fs.html#a774744bdd98a6a252de1262ce56f4ef6">More...</a><br /></td></tr>
<tr class="separator:a774744bdd98a6a252de1262ce56f4ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File System API Resources</div></td></tr>
<tr class="memitem:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c">CreateFile</a> (const char *path, int64_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a file.  <a href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c">More...</a><br /></td></tr>
<tr class="separator:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812ac4964fb5564467c5475c1b9fb16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a812ac4964fb5564467c5475c1b9fb16b">DeleteFile</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a812ac4964fb5564467c5475c1b9fb16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file.  <a href="namespacenn_1_1fs.html#a812ac4964fb5564467c5475c1b9fb16b">More...</a><br /></td></tr>
<tr class="separator:a812ac4964fb5564467c5475c1b9fb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09dbc3816b9e95562081f9411711c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">CreateDirectory</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad09dbc3816b9e95562081f9411711c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory.  <a href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">More...</a><br /></td></tr>
<tr class="separator:ad09dbc3816b9e95562081f9411711c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a40e072fc4b9bd6a36b6902b117ba85d0">DeleteDirectory</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a directory.  <a href="namespacenn_1_1fs.html#a40e072fc4b9bd6a36b6902b117ba85d0">More...</a><br /></td></tr>
<tr class="separator:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd">DeleteDirectoryRecursively</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively deletes a directory including any child entries.  <a href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd">More...</a><br /></td></tr>
<tr class="separator:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b7fdae71cfa75a6c45552c4195b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87">CleanDirectoryRecursively</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae52b7fdae71cfa75a6c45552c4195b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function recursively deletes all child entries contained in the directory.  <a href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87">More...</a><br /></td></tr>
<tr class="separator:ae52b7fdae71cfa75a6c45552c4195b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea">RenameFile</a> (const char *currentPath, const char *newPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a file.  <a href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea">More...</a><br /></td></tr>
<tr class="separator:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c7c7cce23b0a368e83d115baafe17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17">RenameDirectory</a> (const char *currentPath, const char *newPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a394c7c7cce23b0a368e83d115baafe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a directory.  <a href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17">More...</a><br /></td></tr>
<tr class="separator:a394c7c7cce23b0a368e83d115baafe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5cf6e2f2c5a0c4e404ba3dd782cc98bc">GetEntryType</a> (<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> *outValue, const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the entry.  <a href="namespacenn_1_1fs.html#a5cf6e2f2c5a0c4e404ba3dd782cc98bc">More...</a><br /></td></tr>
<tr class="separator:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d264d61ffaeb4ad26e6bcbf6565b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aea4d264d61ffaeb4ad26e6bcbf6565b0">GetFreeSpaceSize</a> (int64_t *outValue, const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aea4d264d61ffaeb4ad26e6bcbf6565b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets free space.  <a href="namespacenn_1_1fs.html#aea4d264d61ffaeb4ad26e6bcbf6565b0">More...</a><br /></td></tr>
<tr class="separator:aea4d264d61ffaeb4ad26e6bcbf6565b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac021c163ba94a44a2b53cb848c462930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930">SetAllocator</a> (<a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a> alloc, <a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a> dealloc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac021c163ba94a44a2b53cb848c462930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the memory allocator to use in the <code>fs</code> library.  <a href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930">More...</a><br /></td></tr>
<tr class="separator:ac021c163ba94a44a2b53cb848c462930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a95249afd4a87a55d319dfecb0466c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac8a95249afd4a87a55d319dfecb0466c">Unmount</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8a95249afd4a87a55d319dfecb0466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a mounted file system and frees the resources.  <a href="namespacenn_1_1fs.html#ac8a95249afd4a87a55d319dfecb0466c">More...</a><br /></td></tr>
<tr class="separator:ac8a95249afd4a87a55d319dfecb0466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3759f457229862688d05fe6caeae0367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3759f457229862688d05fe6caeae0367">IsMounted</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3759f457229862688d05fe6caeae0367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the mount named <code><em>name</em></code> is already mounted.  <a href="namespacenn_1_1fs.html#a3759f457229862688d05fe6caeae0367">More...</a><br /></td></tr>
<tr class="separator:a3759f457229862688d05fe6caeae0367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Host PC API</div></td></tr>
<tr class="memitem:a1b85bf3f3cf038cb67a991a3e3304751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751">MountHost</a> (const char *name, const char *rootPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b85bf3f3cf038cb67a991a3e3304751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts the specified directory in the file system of the host PC and makes it available for operations.  <a href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751">More...</a><br /></td></tr>
<tr class="separator:a1b85bf3f3cf038cb67a991a3e3304751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debd540f8e0207460e0a7a31edac92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3debd540f8e0207460e0a7a31edac92d">MountHost</a> (const char *name, const char *rootPath, const <a class="el" href="structnn_1_1fs_1_1_mount_host_option.html">MountHostOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3debd540f8e0207460e0a7a31edac92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts the specified directory in the file system of the host PC and makes it available for operations.  <a href="namespacenn_1_1fs.html#a3debd540f8e0207460e0a7a31edac92d">More...</a><br /></td></tr>
<tr class="separator:a3debd540f8e0207460e0a7a31edac92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea39d2487ac28bc767cd699eeeebe11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11">MountHostRoot</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ea39d2487ac28bc767cd699eeeebe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts the file system of the host PC and enables operations using the same paths as in Windows.  <a href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11">More...</a><br /></td></tr>
<tr class="separator:a2ea39d2487ac28bc767cd699eeeebe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591fb29e0966ef5f550d4110a5aa4866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a591fb29e0966ef5f550d4110a5aa4866">MountHostRoot</a> (const <a class="el" href="structnn_1_1fs_1_1_mount_host_option.html">MountHostOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a591fb29e0966ef5f550d4110a5aa4866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts the file system of the host PC and enables operations using the same paths as in Windows.  <a href="namespacenn_1_1fs.html#a591fb29e0966ef5f550d4110a5aa4866">More...</a><br /></td></tr>
<tr class="separator:a591fb29e0966ef5f550d4110a5aa4866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d6e6459dca7d8274564bcfc5de757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757">UnmountHostRoot</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade5d6e6459dca7d8274564bcfc5de757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file system mounted with <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">MountHostRoot()</a></code> and frees the resources.  <a href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757">More...</a><br /></td></tr>
<tr class="separator:ade5d6e6459dca7d8274564bcfc5de757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access Priority APIs</div></td></tr>
<tr class="memitem:a3280722d232526f011908c2e7e50400d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3280722d232526f011908c2e7e50400d">SetPriorityOnCurrentThread</a> (<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3280722d232526f011908c2e7e50400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the access priority.  <a href="namespacenn_1_1fs.html#a3280722d232526f011908c2e7e50400d">More...</a><br /></td></tr>
<tr class="separator:a3280722d232526f011908c2e7e50400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0bae7e05be65b11e83a5a63640680f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a1b0bae7e05be65b11e83a5a63640680f">GetPriorityOnCurrentThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b0bae7e05be65b11e83a5a63640680f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the access priority.  <a href="namespacenn_1_1fs.html#a1b0bae7e05be65b11e83a5a63640680f">More...</a><br /></td></tr>
<tr class="separator:a1b0bae7e05be65b11e83a5a63640680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for RamDisk</div></td></tr>
<tr class="memitem:a47158cdf85f271b33de66713208f4b55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a47158cdf85f271b33de66713208f4b55">GetRamDiskBufferSize</a> (size_t spaceSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a47158cdf85f271b33de66713208f4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer size used for RamDisk.  <a href="namespacenn_1_1fs.html#a47158cdf85f271b33de66713208f4b55">More...</a><br /></td></tr>
<tr class="separator:a47158cdf85f271b33de66713208f4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2297587a324a49250429c4569e0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a0ef2297587a324a49250429c4569e0a1">MountRamDisk</a> (const char *name, void *pBuffer, size_t bufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ef2297587a324a49250429c4569e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds and mounts the file system in memory.  <a href="namespacenn_1_1fs.html#a0ef2297587a324a49250429c4569e0a1">More...</a><br /></td></tr>
<tr class="separator:a0ef2297587a324a49250429c4569e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ROM Resource Data API Resources</div></td></tr>
<tr class="memitem:a5df6e3385c795a5bd046790ef7f17f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d">QueryMountRomCacheSize</a> (size_t *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5df6e3385c795a5bd046790ef7f17f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size needed for the <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom</a></code> file system cache.  <a href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d">More...</a><br /></td></tr>
<tr class="separator:a5df6e3385c795a5bd046790ef7f17f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd">MountRom</a> (const char *name, void *pFileSystemCacheBuffer, size_t fileSystemCacheBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts ROM resource data.  <a href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd">More...</a><br /></td></tr>
<tr class="separator:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Debugging</div></td></tr>
<tr class="memitem:a7a6592b4b0351945aa259359dcb464cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a7a6592b4b0351945aa259359dcb464cd">CanMountRomForDebug</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7a6592b4b0351945aa259359dcb464cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom()</a></code> is available.  <a href="namespacenn_1_1fs.html#a7a6592b4b0351945aa259359dcb464cd">More...</a><br /></td></tr>
<tr class="separator:a7a6592b4b0351945aa259359dcb464cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767e38eb403bd2ebb4374c5214dc0e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a767e38eb403bd2ebb4374c5214dc0e95">MountSaveDataForDebug</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a767e38eb403bd2ebb4374c5214dc0e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts save data for debugging.  <a href="namespacenn_1_1fs.html#a767e38eb403bd2ebb4374c5214dc0e95">More...</a><br /></td></tr>
<tr class="separator:a767e38eb403bd2ebb4374c5214dc0e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c23b8227d3d07d54779875f565d698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa8c23b8227d3d07d54779875f565d698">EnsureSaveDataForDebug</a> (int64_t saveDataSize, int64_t saveDataJournalSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8c23b8227d3d07d54779875f565d698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates save data for debugging.  <a href="namespacenn_1_1fs.html#aa8c23b8227d3d07d54779875f565d698">More...</a><br /></td></tr>
<tr class="separator:aa8c23b8227d3d07d54779875f565d698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ef874060b922b93756ddff212fefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a196ef874060b922b93756ddff212fefa">MountSdCardForDebug</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a196ef874060b922b93756ddff212fefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts an SD card using the mount name that specifies the file system for handling it.  <a href="namespacenn_1_1fs.html#a196ef874060b922b93756ddff212fefa">More...</a><br /></td></tr>
<tr class="separator:a196ef874060b922b93756ddff212fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329828b4375a88fa6567f6a74f207fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a329828b4375a88fa6567f6a74f207fac">GetFileTimeStampForDebug</a> (<a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a> *outTimeStamp, const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a329828b4375a88fa6567f6a74f207fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timestamp of the file in the target path.  <a href="namespacenn_1_1fs.html#a329828b4375a88fa6567f6a74f207fac">More...</a><br /></td></tr>
<tr class="separator:a329828b4375a88fa6567f6a74f207fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">APIs for ROM Resource Data for Multi-Program Applications</div></td></tr>
<tr class="memitem:aa2ac4546c16bdf7a05078a76c10279d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa2ac4546c16bdf7a05078a76c10279d3">CanMountRomForDebug</a> (int programIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa2ac4546c16bdf7a05078a76c10279d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">nn::fs::MountRom(const char*, int, void*, size_t)</a></code> can be executed for the specified program.  <a href="namespacenn_1_1fs.html#aa2ac4546c16bdf7a05078a76c10279d3">More...</a><br /></td></tr>
<tr class="separator:aa2ac4546c16bdf7a05078a76c10279d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663914b6aa85ed8cc0e1700b14bf3ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a663914b6aa85ed8cc0e1700b14bf3ae8">QueryMountRomCacheSize</a> (size_t *pOutValue, int programIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a663914b6aa85ed8cc0e1700b14bf3ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size required for the <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">nn::fs::MountRom(const char*, int, void*, size_t)</a></code> file system cache for the specified program.  <a href="namespacenn_1_1fs.html#a663914b6aa85ed8cc0e1700b14bf3ae8">More...</a><br /></td></tr>
<tr class="separator:a663914b6aa85ed8cc0e1700b14bf3ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b6b37427a68d2ee452b50ab6b86a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c">MountRom</a> (const char *name, int programIndex, void *pFileSystemCacheBuffer, size_t fileSystemCacheBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a22b6b37427a68d2ee452b50ab6b86a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount the resource data (ROM) for the specified program.  <a href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c">More...</a><br /></td></tr>
<tr class="separator:a22b6b37427a68d2ee452b50ab6b86a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Save Data API Resources</div></td></tr>
<tr class="memitem:a90c27aaf70aec66968715663cd8c5415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415">SetSaveDataRootPath</a> (const char *rootPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90c27aaf70aec66968715663cd8c5415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a path on the host PC to use as the save data location.  <a href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415">More...</a><br /></td></tr>
<tr class="separator:a90c27aaf70aec66968715663cd8c5415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f48fe542ce22263e1399e3b50190e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae5f48fe542ce22263e1399e3b50190e8">EnsureSaveData</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5f48fe542ce22263e1399e3b50190e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates save data.  <a href="namespacenn_1_1fs.html#ae5f48fe542ce22263e1399e3b50190e8">More...</a><br /></td></tr>
<tr class="separator:ae5f48fe542ce22263e1399e3b50190e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbda9f24e47b02bb74da4558bbd0760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afdbda9f24e47b02bb74da4558bbd0760">MountSaveData</a> (const char *name, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afdbda9f24e47b02bb74da4558bbd0760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts save data after specifying a user.  <a href="namespacenn_1_1fs.html#afdbda9f24e47b02bb74da4558bbd0760">More...</a><br /></td></tr>
<tr class="separator:afdbda9f24e47b02bb74da4558bbd0760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b846d93790ec79b2d6fee53e97db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adf5b846d93790ec79b2d6fee53e97db9">MountSaveDataReadOnly</a> (const char *name, const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a> applicationId, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adf5b846d93790ec79b2d6fee53e97db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts save data as read-only for an application that corresponds to the application ID after specifying a user.  <a href="namespacenn_1_1fs.html#adf5b846d93790ec79b2d6fee53e97db9">More...</a><br /></td></tr>
<tr class="separator:adf5b846d93790ec79b2d6fee53e97db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed0c325479ee3b3fd508ed3696394f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a7ed0c325479ee3b3fd508ed3696394f2">IsSaveDataExisting</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7ed0c325479ee3b3fd508ed3696394f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified user account save data exists.  <a href="namespacenn_1_1fs.html#a7ed0c325479ee3b3fd508ed3696394f2">More...</a><br /></td></tr>
<tr class="separator:a7ed0c325479ee3b3fd508ed3696394f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a28b9a47a0c5c176a39f0cf240a91f31c">IsSaveDataExisting</a> (const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a> applicationId, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether user account save data that corresponds to the specified application ID exists.  <a href="namespacenn_1_1fs.html#a28b9a47a0c5c176a39f0cf240a91f31c">More...</a><br /></td></tr>
<tr class="separator:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00da1e7839368723e5196b1a5b12e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af00da1e7839368723e5196b1a5b12e53">GetSaveDataSizeMax</a> (int64_t *outSaveDataSizeMax, int64_t *outSaveDataJournalSizeMax) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af00da1e7839368723e5196b1a5b12e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum expansion size of the save data.  <a href="namespacenn_1_1fs.html#af00da1e7839368723e5196b1a5b12e53">More...</a><br /></td></tr>
<tr class="separator:af00da1e7839368723e5196b1a5b12e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab83b2cf5e8413aa2833c8df5d2771bf9">ExtendSaveData</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user, int64_t saveDataSize, int64_t saveDataJournalSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the save data.  <a href="namespacenn_1_1fs.html#ab83b2cf5e8413aa2833c8df5d2771bf9">More...</a><br /></td></tr>
<tr class="separator:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a313238d8b1826e81fe12bad80f82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a92a313238d8b1826e81fe12bad80f82f">GetSaveDataSize</a> (int64_t *outSaveDataSize, int64_t *outSaveDataJournalSize, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92a313238d8b1826e81fe12bad80f82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current size of the save data.  <a href="namespacenn_1_1fs.html#a92a313238d8b1826e81fe12bad80f82f">More...</a><br /></td></tr>
<tr class="separator:a92a313238d8b1826e81fe12bad80f82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Save Data Transaction Management APIs</div></td></tr>
<tr class="memitem:ac2f25cffd056f24d6facfda13f977fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac2f25cffd056f24d6facfda13f977fa6">CommitSaveData</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac2f25cffd056f24d6facfda13f977fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is deprecated.  <a href="namespacenn_1_1fs.html#ac2f25cffd056f24d6facfda13f977fa6">More...</a><br /></td></tr>
<tr class="separator:ac2f25cffd056f24d6facfda13f977fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Temporary Storage</div></td></tr>
<tr class="memitem:a8191828699cf3d29befe8dbd710db421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a8191828699cf3d29befe8dbd710db421">MountTemporaryStorage</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8191828699cf3d29befe8dbd710db421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts temporary storage.  <a href="namespacenn_1_1fs.html#a8191828699cf3d29befe8dbd710db421">More...</a><br /></td></tr>
<tr class="separator:a8191828699cf3d29befe8dbd710db421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transaction Management APIs</div></td></tr>
<tr class="memitem:ab534529ae3c325863fe1eb34bd03c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab534529ae3c325863fe1eb34bd03c872">Commit</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab534529ae3c325863fe1eb34bd03c872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits updated content for file systems, in which the journaling feature is enabled.  <a href="namespacenn_1_1fs.html#ab534529ae3c325863fe1eb34bd03c872">More...</a><br /></td></tr>
<tr class="separator:ab534529ae3c325863fe1eb34bd03c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90e600c3fc51adb6823a4ef900fad3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac90e600c3fc51adb6823a4ef900fad3a">Commit</a> (const char *const *nameArray, int nameCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac90e600c3fc51adb6823a4ef900fad3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simultaneously commits updates to multiple file systems that have the multicommit feature enabled.  <a href="namespacenn_1_1fs.html#ac90e600c3fc51adb6823a4ef900fad3a">More...</a><br /></td></tr>
<tr class="separator:ac90e600c3fc51adb6823a4ef900fad3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API for Downloadable Content</div></td></tr>
<tr class="memitem:afcb1fa310028d36752df80ff69beec4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c">QueryMountAddOnContentCacheSize</a> (size_t *pOutValue, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a> targetIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afcb1fa310028d36752df80ff69beec4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size needed for the <code>MountAddOnContent</code> file system cache.  <a href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c">More...</a><br /></td></tr>
<tr class="separator:afcb1fa310028d36752df80ff69beec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92caf5815857651653369e760f85a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad92caf5815857651653369e760f85a66">MountAddOnContent</a> (const char *name, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a> targetIndex, void *pFileSystemCacheBuffer, size_t fileSystemCacheBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad92caf5815857651653369e760f85a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a read-only file system to handle downloadable content.  <a href="namespacenn_1_1fs.html#ad92caf5815857651653369e760f85a66">More...</a><br /></td></tr>
<tr class="separator:ad92caf5815857651653369e760f85a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">API Resources for Cache Storage With Indexes</div></td></tr>
<tr class="memitem:a4916142164a7a335694945e38513e9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a4916142164a7a335694945e38513e9c5">GetCacheStorageMax</a> (int *outCacheStorageIndexMax, int64_t *outCacheStorageDataAndJournalSizeMax) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4916142164a7a335694945e38513e9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size and maximum index of the cache storage.  <a href="namespacenn_1_1fs.html#a4916142164a7a335694945e38513e9c5">More...</a><br /></td></tr>
<tr class="separator:a4916142164a7a335694945e38513e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3735c46a459dbf4ba3d6de862b611d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af3735c46a459dbf4ba3d6de862b611d4">CreateCacheStorage</a> (int index, int64_t cacheStorageSize, int64_t cacheStorageJournalSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3735c46a459dbf4ba3d6de862b611d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the cache storage.  <a href="namespacenn_1_1fs.html#af3735c46a459dbf4ba3d6de862b611d4">More...</a><br /></td></tr>
<tr class="separator:af3735c46a459dbf4ba3d6de862b611d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af995ec08995ebe685afd6c13a648a692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af995ec08995ebe685afd6c13a648a692">GetCacheStorageSize</a> (int64_t *outCacheStorageSize, int64_t *outCacheStorageJournalSize, int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af995ec08995ebe685afd6c13a648a692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cache storage size for the specified index.  <a href="namespacenn_1_1fs.html#af995ec08995ebe685afd6c13a648a692">More...</a><br /></td></tr>
<tr class="separator:af995ec08995ebe685afd6c13a648a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adf2bd15a53fcc2a6c8895de9c264ab86">DeleteCacheStorage</a> (int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the cache storage with the specified index.  <a href="namespacenn_1_1fs.html#adf2bd15a53fcc2a6c8895de9c264ab86">More...</a><br /></td></tr>
<tr class="separator:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeabd5e452034e8f7db0d8580952a5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adeabd5e452034e8f7db0d8580952a5dd">OpenCacheStorageList</a> (<a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> *outValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adeabd5e452034e8f7db0d8580952a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the cache storage list.  <a href="namespacenn_1_1fs.html#adeabd5e452034e8f7db0d8580952a5dd">More...</a><br /></td></tr>
<tr class="separator:adeabd5e452034e8f7db0d8580952a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d272600ab91d4e735bbb40d8845e938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a4d272600ab91d4e735bbb40d8845e938">ReadCacheStorageList</a> (int *outValue, <a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a> *infoBuffer, <a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> handle, int infoBufferCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4d272600ab91d4e735bbb40d8845e938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the cache storage information.  <a href="namespacenn_1_1fs.html#a4d272600ab91d4e735bbb40d8845e938">More...</a><br /></td></tr>
<tr class="separator:a4d272600ab91d4e735bbb40d8845e938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c1f6d8788be687eb914f53f723fba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a92c1f6d8788be687eb914f53f723fba7">CloseCacheStorageList</a> (<a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92c1f6d8788be687eb914f53f723fba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the cache storage list.  <a href="namespacenn_1_1fs.html#a92c1f6d8788be687eb914f53f723fba7">More...</a><br /></td></tr>
<tr class="separator:a92c1f6d8788be687eb914f53f723fba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5bc5a4754186c3d3e0af88ad84db2095"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5bc5a4754186c3d3e0af88ad84db2095">EntryNameLengthMax</a> = 768</td></tr>
<tr class="memdesc:a5bc5a4754186c3d3e0af88ad84db2095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length (in bytes) of the name of an entry in the file system.  <a href="namespacenn_1_1fs.html#a5bc5a4754186c3d3e0af88ad84db2095">More...</a><br /></td></tr>
<tr class="separator:a5bc5a4754186c3d3e0af88ad84db2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9d2fc668ed4c867c52e62103bf57b8"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5b9d2fc668ed4c867c52e62103bf57b8">MountNameLengthMax</a> = 15</td></tr>
<tr class="memdesc:a5b9d2fc668ed4c867c52e62103bf57b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size (in bytes) of the name that can be specified when mounting a resource.  <a href="namespacenn_1_1fs.html#a5b9d2fc668ed4c867c52e62103bf57b8">More...</a><br /></td></tr>
<tr class="separator:a5b9d2fc668ed4c867c52e62103bf57b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5765422e17f81856298a59f759cc2a8c"><td class="memItemLeft" align="right" valign="top">constexpr const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c">PathSizeMax</a> = 768</td></tr>
<tr class="memdesc:a5765422e17f81856298a59f759cc2a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum path length, in bytes.  <a href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c">More...</a><br /></td></tr>
<tr class="separator:a5765422e17f81856298a59f759cc2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af211cba76d2e055b22ebf228aed3b"><td class="memItemLeft" align="right" valign="top"><a id="ae6af211cba76d2e055b22ebf228aed3b"></a>
constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae6af211cba76d2e055b22ebf228aed3b">RamDiskSpaceSizeMax</a> = 4194304000</td></tr>
<tr class="memdesc:ae6af211cba76d2e055b22ebf228aed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum RamDisk file system capacity. <br /></td></tr>
<tr class="separator:ae6af211cba76d2e055b22ebf228aed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6cf75ef80840470f80a1a03f54dcfa"><td class="memItemLeft" align="right" valign="top"><a id="a5d6cf75ef80840470f80a1a03f54dcfa"></a>
constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5d6cf75ef80840470f80a1a03f54dcfa">SaveDataExtensionUnitSize</a> = 1 * 1024 * 1024</td></tr>
<tr class="memdesc:a5d6cf75ef80840470f80a1a03f54dcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit size that can be specified for the save data extension. <br /></td></tr>
<tr class="separator:a5d6cf75ef80840470f80a1a03f54dcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the file system library. </p>
<h3><a class="anchor" id="autotoc_md294"></a>
Feature Overview</h3>
<p>The <code>fs</code> library provides a means of performing operations on various file systems, including save data and the file system on a development PC. Basic features such as opening a directory are common to all file systems, but file system-specific features and limitations are defined separately as file system attributes.</p>
<h4><a class="anchor" id="autotoc_md295"></a>
Common Preconditions</h4>
<p>Functions that perform operations on files and directories require a valid handle for the target file or directory. Also, unless noted otherwise, pointer arguments must point to valid memory.</p>
<h4><a class="anchor" id="autotoc_md296"></a>
Result Objects</h4>
<p>Depending on the type of file system being mounted, <code><a class="el" href="classnn_1_1_result.html" title="Represents the generic result of an operation.">Result</a></code> objects that are not from the <code>fs</code> library could be returned.</p>
<p><a class="anchor" id="memory_allocation"></a></p>
<h4><a class="anchor" id="autotoc_md297"></a>
Memory Allocation</h4>
<p>The <code><a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a></code> API allocates memory internally.</p>
<p>By default, <code>malloc()</code> and <code>free()</code> are used for memory allocation. For more information about <code>malloc()</code> and <code>free()</code>, see <code><a class="el" href="namespacenn_1_1init.html#a216ae7a5ca53a1c1e6dc0514f7283974" title="Initializes a memory allocator.">nn::init::InitializeAllocator()</a></code>.</p>
<p>You can specify the allocators you use for memory allocation by calling <code><a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="Sets the memory allocator to use in the fs library.">nn::fs::SetAllocator()</a></code> in advance. You must set an allocator that returns 8-byte aligned addresses.</p>
<p>Memory allocated for mounting the file system, opening files, and opening directories is released when the corresponding file system is unmounted, the file is closed, or the directory is closed. If no <code><a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a></code> function is being called, no file or directory is open, and no file system is mounted, it is assured that no memory has been allocated by an allocator (all allocated memory has been deallocated).</p>
<p>Memory usage guidelines are as follows. These values may increase and decrease in the future. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Duration   </th><th class="markdownTableHeadNone">Approximate Amount of Memory Used    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mounting File System   </td><td class="markdownTableBodyNone">Number of simultaneous mounts × approximately 2 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Opening Files   </td><td class="markdownTableBodyNone">Number of files opened simultaneously × approximately 512 bytes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Opening Directories   </td><td class="markdownTableBodyNone">Number of directories opened simultaneously × approximately 2 KB   </td></tr>
</table>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In addition to this, memory can be transiently allocated and deallocated during calls to <code><a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a></code> functions, so some leeway is required for memory. For calls to <code><a class="el" href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd" title="Recursively deletes a directory including any child entries.">nn::fs::DeleteDirectoryRecursively()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87" title="This function recursively deletes all child entries contained in the directory.">nn::fs::CleanDirectoryRecursively()</a></code> on the file system other than for RamDisk, a memory space of roughly 3 KB + (2 KB × number of levels in the directory being processed) is transiently allocated and deallocated during the function calls. For other functions, roughly 6 KB of memory can be transiently allocated and deallocated during the function call. For functions that specify a path, memory roughly equivalent to the expanded relative path, and memory corresponding to the path length and directory levels, is allocated and deallocated during the function call. Example: Around 4 KB for an absolute path of 80 bytes and a five-level directory. Example: Around 16 KB for an absolute path of 768 bytes and a 12-level directory.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 In addition to this, some 4 KB of memory can be transiently allocated and deallocated during calls to <code><a class="el" href="namespacenn_1_1fs.html" title="Namespace for the file system library.">nn::fs</a></code> functions, so some leeway is required for memory. Also, for functions that specify a path, memory roughly equivalent to the expanded relative path is allocated and deallocated during the function call.</div><div class="platform_section" data-platform="NX"></div><p> Make it explicit to any user of the function group that sufficient memory must be allocatable using either an allocator specified in advance using <code><a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="Sets the memory allocator to use in the fs library.">nn::fs::SetAllocator()</a></code> or <code>malloc()</code>. This is particularly important when using file system features that could access non-characteristic programs, such as libraries.</p>
<h4><a class="anchor" id="autotoc_md298"></a>
Thread Safety</h4>
<p>Multiple functions from an <code>fs</code> library that targets different file systems can be called simultaneously. That said, mutual exclusion might be needed when targeting the same file system. The details are as follows.</p>
<p>The API resources for the file system and the <code><a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b" title="Opens a file.">OpenFile()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42" title="Opens a directory.">OpenDirectory()</a></code> functions operate correctly even when multiple instances are called simultaneously. The following table presents information about API resources for files and directories that specify a handle in their operations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">API Type   </th><th class="markdownTableHeadNone">Applies to Same Handle   </th><th class="markdownTableHeadNone">Applies to Different Handles    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">File functions that only perform the read operation (<code><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="Loads the content of the file into the specified memory.">ReadFile()</a></code>, <code><a class="el" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21" title="Gets the size of a file.">GetFileSize()</a></code>, <code><a class="el" href="namespacenn_1_1fs.html#a2805c57e6c7c5ec8fbc7d30e7137deae" title="Gets the mode specified when the file was opened.">GetFileOpenMode()</a></code>)   </td><td class="markdownTableBodyNone">Multiple APIs may be called simultaneously.   </td><td class="markdownTableBodyNone">Multiple APIs may be called simultaneously.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">File functions that perform operations other than read (other than <code><a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b" title="Opens a file.">OpenFile()</a></code> and the preceding functions)   </td><td class="markdownTableBodyNone">These APIs must be called exclusively.   </td><td class="markdownTableBodyNone">Multiple APIs may be called simultaneously.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Directory functions (other than <code><a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42" title="Opens a directory.">OpenDirectory()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#aa6a54b0d39dfd293b11cd1c0073aafb1" title="Gets the number of child entries in a directory.">GetDirectoryEntryCount()</a></code>)   </td><td class="markdownTableBodyNone">These APIs must be called exclusively.   </td><td class="markdownTableBodyNone">Multiple APIs may be called simultaneously.   </td></tr>
</table>
<p>Unless clearly stated otherwise, exclusion is required for calls to API resources other than those mentioned in the table, and for calls to combinations of functions where some do and some do not support simultaneous calls to multiple instances. For example, if multiple threads call <code><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="Writes the contents of the specified memory to a file.">WriteFile()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="Loads the content of the file into the specified memory.">ReadFile()</a></code> non-exclusively on the same handle, the data obtained by <code><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="Loads the content of the file into the specified memory.">ReadFile()</a></code> depends on the timing of operations. For example, if multiple threads call <code><a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29" title="Lists the child entries of a directory.">ReadDirectory()</a></code> nonexclusively on the same handle, the directory enumeration processes of each thread collides, and behavior is not ensured.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 There is a single communication path to system memory and to each game card and SD card, so multiple simultaneous attempts to access data located on the same medium from an application will be blocked. For more information about ways to optimize performance, see <a href="../../Package/contents/Pages/Page_185130689.html">Performance</a> for the <code>fs</code> library in NintendoSDK Documents.</div><div class="platform_section" data-platform="NX"></div> <h3><a class="anchor" id="autotoc_md299"></a>
Terminology</h3>
<h4><a class="anchor" id="autotoc_md300"></a>
File System</h4>
<p>The basic unit of operations in the <code>fs</code> library, the file system that stores directories and files. Mounting a file system allows you to perform operations on the directories and files that belong to the file system.</p>
<p><a class="anchor" id="entry"></a></p>
<h4><a class="anchor" id="autotoc_md301"></a>
Entry</h4>
<p>Refers to both directories and files. The maximum length of an entry name depends on the file system. For more information, see <a class="el" href="namespacenn_1_1fs.html#path_and_entry_max_length">Path and Entry Max Length </a> .</p>
<p><a class="anchor" id="mount_name"></a></p>
<h4><a class="anchor" id="autotoc_md302"></a>
Mount Name</h4>
<p>A string provided by the user to identify a file system when it is mounted for use. After the mount operation, the mount name is used to specify the file system to access. The mount name must meet all of the following conditions to be a valid mount name.</p><ul>
<li>It must be a string of two bytes or more, from two to <code><a class="el" href="namespacenn_1_1fs.html#a5b9d2fc668ed4c867c52e62103bf57b8" title="Maximum size (in bytes) of the name that can be specified when mounting a resource.">nn::fs::MountNameLengthMax</a></code> +1 bytes, including the terminating null character.</li>
<li>Starts with something other than @.</li>
<li>The name does not contain any colons (:) or forward slashes (/).</li>
<li>It is not a single one-byte alphabetical letter.</li>
<li>The name is not being used as the mount name for another mounted file system.</li>
</ul>
<p>A valid mount name must be passed to the functions that specify a mount name. The encoding is UTF-8. Case-sensitive.</p>
<p><a class="anchor" id="entry_path"></a></p>
<h4><a class="anchor" id="autotoc_md303"></a>
Path</h4>
<p>An identifier that uniquely defines an entry. The <code>fs</code> library uses strings. Example: "MountName:/path/to/file". The path must meet all of the following conditions to be a valid path.</p><ul>
<li>It begins with [mount_name + ":"].</li>
<li>The mount name is a valid mount name.</li>
<li>The mount name is one that is already mounted.</li>
<li>[mount name + ":"] must be followed by a string of two bytes or more, from two to <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes, including the terminating null character.</li>
<li>The directory delimiter is either / (a slash) or \ (two backslashes).</li>
<li>Entry names do not use the symbols &lt; &gt; * ? : or |.</li>
</ul>
<p>A valid path must be passed to the functions that specify a path. The encoding is UTF-8. The distinction between uppercase and lowercase characters is based on the file system. For more information, see <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . The maximum length of a path depends on the file system. For more information, see <a class="el" href="namespacenn_1_1fs.html#path_and_entry_max_length">Path and Entry Max Length </a> . The same delimiter and encoding is used even when representing a path on the host PC.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 There are particular constraints on paths used with the SD Card File System. For more information, see <a href="../../Package/contents/Pages/Page_112886110.html">SD Card</a> in NintendoSDK Documents.</div><div class="platform_section" data-platform="NX"></div><p> <a class="anchor" id="supported_filesystem"></a> </p><h3>Supported File System</h3>
<p>For more information about file systems, see <a href="../../Package/contents/Pages/Page_107320200.html">Features</a> in the <code>fs</code> library features in NintendoSDK Documents.</p><ul>
<li>ROM File System: A read-only file system to handle resource data. Can be mounted using the <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom()</a></code> function. The journaling feature and the multicommit feature are disabled.</li>
<li>Save Data File System (*) A file system to handle save data. Can be mounted using the functions <code><a class="el" href="namespacenn_1_1fs.html#afdbda9f24e47b02bb74da4558bbd0760" title="Mounts save data after specifying a user.">nn::fs::MountSaveData()</a></code>, <code><a class="el" href="namespacenn_1_1fs.html#adf5b846d93790ec79b2d6fee53e97db9" title="Mounts save data as read-only for an application that corresponds to the application ID after specify...">nn::fs::MountSaveDataReadOnly()</a></code>, and <code><a class="el" href="namespacenn_1_1fs.html#a767e38eb403bd2ebb4374c5214dc0e95" title="Mounts save data for debugging.">nn::fs::MountSaveDataForDebug()</a></code>. The journaling feature is enabled. The multicommit feature is also enabled, except when <code><a class="el" href="namespacenn_1_1fs.html#adf5b846d93790ec79b2d6fee53e97db9" title="Mounts save data as read-only for an application that corresponds to the application ID after specify...">nn::fs::MountSaveDataReadOnly()</a></code> is used.</li>
<li>RamDisk File System This file system can manipulate the built-in memory of file systems. Use <code><a class="el" href="namespacenn_1_1fs.html#a0ef2297587a324a49250429c4569e0a1" title="Builds and mounts the file system in memory.">nn::fs::MountRamDisk()</a></code> to mount it. The journaling feature and the multicommit feature are disabled.</li>
<li>Host File System: This file system can control the file system on the host PC. Can be mounted using the functions <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code>. The journaling feature and the multicommit feature are disabled. It can only be used during development.</li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>Downloadable Content File System: This read-only file system handles downloadable content. Can be mounted using the <code><a class="el" href="namespacenn_1_1fs.html#ad92caf5815857651653369e760f85a66" title="Mounts a read-only file system to handle downloadable content.">nn::fs::MountAddOnContent()</a></code> function. The journaling feature and the multicommit feature are disabled.</li>
<li>Temporary Storage File System (*) A file system used when the application temporarily saves files. Can be mounted using the <code><a class="el" href="namespacenn_1_1fs.html#a8191828699cf3d29befe8dbd710db421" title="Mounts temporary storage.">nn::fs::MountTemporaryStorage()</a></code> function. The journaling feature and the multicommit feature are disabled. You must apply in advance to use temporary storage.</li>
<li>Cache Storage File System (*) A file system used when the application saves files that can be regenerated and reacquired. Can be mounted using the <code><a class="el" href="namespacenn_1_1fs.html#a38a958348ad64793a93e82a5a556d7b4" title="Mounts a cache storage.">nn::fs::MountCacheStorage()</a></code> function. The journaling feature is enabled, but the multicommit feature is disabled. You must apply in advance to use cache storage.</li>
<li>SD Card File System: This file system can control the file system on SD cards. Can be mounted using the <code><a class="el" href="namespacenn_1_1fs.html#a196ef874060b922b93756ddff212fefa" title="Mounts an SD card using the mount name that specifies the file system for handling it.">nn::fs::MountSdCardForDebug()</a></code> function. The journaling feature and the multicommit feature are disabled. It can only be used during development.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div> <h4>Limits on the Number of Simultaneously Mounted File Systems</h4>
<p>Depending on the file system, there are limits on the number of file systems that can be mounted at the same time. The number of mounted file systems is only checked for the following kinds of file systems.</p><ul>
<li>The preceding file systems marked with an asterisk (*). File systems for the same target but with different mount names cannot be mounted at the same time. For the file systems marked with an asterisk (*), the maximum combined number of files systems for different targets that can be mounted at the same time is 10. Running the <code><a class="el" href="namespacenn_1_1fs.html#a7ed0c325479ee3b3fd508ed3696394f2" title="Determines whether the specified user account save data exists.">nn::fs::IsSaveDataExisting()</a></code> function also counts toward this number of mounted file systems.</li>
<li>ROM File System: For the ROM file system, a maximum of 10 file systems with different mount names can be mounted at the same time. Running the <code><a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d" title="Get the size needed for the nn::fs::MountRom file system cache.">nn::fs::QueryMountRomCacheSize()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a7a6592b4b0351945aa259359dcb464cd" title="Determines whether nn::fs::MountRom() is available.">nn::fs::CanMountRomForDebug()</a></code> functions also counts toward this number of mounted file systems.</li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>Downloadable Content File System: A maximum of 128 downloadable content file systems can be mounted at the same time, including file systems for the same target but with different mount names. Running the <code><a class="el" href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c" title="Get the size needed for the MountAddOnContent file system cache.">nn::fs::QueryMountAddOnContentCacheSize()</a></code> function also counts toward this number of mounted file systems.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div> <h4>Limits on the Number of Simultaneously Open Files and Directories</h4>
<p>Depending on the file system, there are limits on the number of files and directories that can be open at the same time. The number of open files and directories is only checked for the following kinds of file systems.</p><ul>
<li>The preceding file systems marked with an asterisk (*). For the file systems marked with an asterisk (*), the maximum number of files and directories that can be open at the same time is 256. Opening the same target multiple times also counts towards the number of open targets. While running, the <code><a class="el" href="namespacenn_1_1fs.html#a2d72712742fd49f26a5bd36cce94d481" title="Enables individual file data caching.">nn::fs::EnableIndividualFileDataCache()</a></code> function also counts towards the number of open targets.</li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>Host system, and ROM file systems when the application is started in RAW format (NSPD). The total number of files and directories that are open is 200.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><p> <a class="anchor" id="path_and_entry_max_length"></a> </p><h4>Path and Entry Name Max Length</h4>
<p><a class="el" href="namespacenn_1_1fs.html#entry_path">Path </a> and <a class="el" href="namespacenn_1_1fs.html#entry">entry </a> maximum name length (excluding mount name) depend on the file system and runtime environment.</p><ul>
<li>ROM File System: Paths are limited to a maximum of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes, including the terminating null character. Entry names are limited to a maximum of <code><a class="el" href="namespacenn_1_1fs.html#a5bc5a4754186c3d3e0af88ad84db2095" title="Maximum length (in bytes) of the name of an entry in the file system.">nn::fs::EntryNameLengthMax</a></code> + 1 bytes, including the terminating null character.</li>
<li>Host File System: Files paths are limited to a maximum of 260 characters, including the terminating null character. Directory paths are limited to a maximum of 248 characters, including the terminating null character. For file systems mounted with the <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> function, this restriction applies to the length of the path combined with <code><em>rootPath</em></code>. Entry names are limited to a maximum of 256 characters, including the terminating null character.</li>
<li>Save Data File System, RamDisk File System: Paths are limited to a maximum of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes, including the terminating null character. Entry names are limited to a maximum of 64 + 1 bytes, including the terminating null character.</li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>Downloadable Content File System: Same as ROM file system above.</li>
<li>Host File System: If Windows long path support is enabled, paths may be extended to a maximum of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes, including the terminating null character. In Windows 10 (1607) and later, long path support can be enabled by using Regedit to change the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem LongPathsEnabled key from 0 to 1. For more information, see Windows specifications. <a href="../../Package/contents/Pages/Page_847744809.html">Target Manager 2</a> supports Windows long paths, but <a href="../../Package/contents/Pages/Page_93359711.html">Target Manager</a> does not.</li>
<li>ROM file systems when the application is started in RAW format (NSPD) Same as Host file system above.</li>
<li>Temporary Storage File System, Cache Storage File System: Same as Save Data file system above.</li>
<li>SD Card File System: Paths are limited to a maximum of 260 bytes, including the terminating null character. Entry names are limited to a maximum of 255 bytes, including the terminating null character.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><p> <a class="anchor" id="case-sensitivity"></a> </p><h4>Case-Sensitivity (Distinction Between Uppercase and Lowercase Characters)</h4>
<p>Aside from the mount name, the case sensitivity of the path is handled differently depending on the file system. (That is, the mount name is case-sensitive.) Case-sensitive file systems are case-sensitive, and entries with names with different cases can be placed under the same directory. Case-insensitive file systems are not case-sensitive, and the target file can be opened even when specifying a path with different cases.</p><ul>
<li>ROM File System, Save Data File System, RamDisk File System: Case-sensitive. Assuming that you are authoring in a PC environment or exporting save data content to the host PC, we do not recommend placing entry names with different cases under the same directory.</li>
<li>Host File System: Based on the host PC environment. Depending on the host PC file system and settings, its behavior might be case-insensitive. When using it as a substitute for another file system during development, we recommend distinguishing between uppercase and lowercase characters to make it easy to transition to a case-sensitive file system.</li>
</ul>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
<ul>
<li>Downloadable Content File System, Temporary Storage File System, Cache Storage File System: The ROM file systems described earlier have the same behavior as the save data file system and RamDisk file system.</li>
<li>SD Card File System: Based on the SD format. FAT and exFAT are case-sensitive. When using it as a substitute for another file system during development, we recommend distinguishing between uppercase and lowercase characters to make it easy to transition to a case-sensitive file system.</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div> </div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a9860dee956c54cadf027c37d54adeb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9860dee956c54cadf027c37d54adeb28">&#9670;&nbsp;</a></span>AllocateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* nn::fs::AllocateFunction) (size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer for memory allocation. </p>
<p> <b>Details</b> <br  />
 Specify in the <code>SetAllocator</code> function. </p>

</div>
</div>
<a id="a07c75b075241d17f1b52cd9eefa851aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c75b075241d17f1b52cd9eefa851aa">&#9670;&nbsp;</a></span>DeallocateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::fs::DeallocateFunction) (void *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer for memory deallocation. </p>
<p> <b>Details</b> <br  />
 Specify in the <code>SetAllocator</code> function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afb4fdd50e0892400c07232f714caa14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4fdd50e0892400c07232f714caa14d">&#9670;&nbsp;</a></span>WriteOptionFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">nn::fs::WriteOptionFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for specifying options to use when writing files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afb4fdd50e0892400c07232f714caa14da2956e16dac576b2b7eff3142e18ac2c0"></a>WriteOptionFlag_Flush&#160;</td><td class="fielddoc"><p>Specify this flag to flush immediately after writing. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4c97b79cce78a95c2333dbc9053b9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c97b79cce78a95c2333dbc9053b9393">&#9670;&nbsp;</a></span>OpenMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">nn::fs::OpenMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to specify the mode when opening a file. </p>
<p> <b>Details</b> <br  />
 Specifies the mode to use when opening a file. Specify multiple flags using a bitwise OR operator as required. Sharing is possible only in read mode. Sharing is not supported with write operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d"></a>OpenMode_Read&#160;</td><td class="fielddoc"><p>Specifies read mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03"></a>OpenMode_Write&#160;</td><td class="fielddoc"><p>Specifies write mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1"></a>OpenMode_AllowAppend&#160;</td><td class="fielddoc"><p>Allows append operations. </p>
</td></tr>
</table>

</div>
</div>
<a id="a34bc03cdbe641524cab284a7fe7ba705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bc03cdbe641524cab284a7fe7ba705">&#9670;&nbsp;</a></span>OpenDirectoryMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">nn::fs::OpenDirectoryMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to specify the mode when opening a directory. </p>
<p> <b>Details</b> <br  />
 Specifies the mode to use when opening a directory. Only child entries of the specified kinds are listed by <code><a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29" title="Lists the child entries of a directory.">nn::fs::ReadDirectory()</a></code>. You can specify multiple flags by using the bitwise OR operator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34bc03cdbe641524cab284a7fe7ba705a6cabc455dd34f3d7562137ea63a5daab"></a>OpenDirectoryMode_Directory&#160;</td><td class="fielddoc"><p>Only list subdirectories. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34bc03cdbe641524cab284a7fe7ba705a560a621c8b1cb6f228ea202b9efd7432"></a>OpenDirectoryMode_File&#160;</td><td class="fielddoc"><p>Only list the files in this directory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34bc03cdbe641524cab284a7fe7ba705a1769c5d739757a86e8f98bddbc3ee9c5"></a>OpenDirectoryMode_All&#160;</td><td class="fielddoc"><p>Lists all child entries. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5fc46cd05067c210b62e96f903a2fe85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc46cd05067c210b62e96f903a2fe85">&#9670;&nbsp;</a></span>DirectoryEntryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">nn::fs::DirectoryEntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated type representing directory entry types. </p>
<p> <b>Details</b> <br  />
 These enumerators identify whether a directory entry is a file or a directory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5fc46cd05067c210b62e96f903a2fe85a2824a031f5834c762620e321ac8933c6"></a>DirectoryEntryType_Directory&#160;</td><td class="fielddoc"><p>Directory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fc46cd05067c210b62e96f903a2fe85a194470d850d5968a491fd9ef6145d5a0"></a>DirectoryEntryType_File&#160;</td><td class="fielddoc"><p>File. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6758dcecf390a3c4028a8651fc5d305d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6758dcecf390a3c4028a8651fc5d305d">&#9670;&nbsp;</a></span>MountHostOptionFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305d">nn::fs::MountHostOptionFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for specifying the <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code> options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a"></a>MountHostOptionFlag_PseudoCaseSensitive&#160;</td><td class="fielddoc"><p>Specify when handling the path as case-sensitive. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2e4a9f55e854a9755c9264838caa97d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a9f55e854a9755c9264838caa97d3">&#9670;&nbsp;</a></span>Priority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">nn::fs::Priority</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The access priority. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2e4a9f55e854a9755c9264838caa97d3a0fa1620fa464966eddf7e9a82a0eef91"></a>Priority_Realtime&#160;</td><td class="fielddoc"><p>Specifies accessing with high priority suited to real-time processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4a9f55e854a9755c9264838caa97d3a3fe1f52283573973940fa566d116289e"></a>Priority_Normal&#160;</td><td class="fielddoc"><p>Specifies accessing with normal priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e4a9f55e854a9755c9264838caa97d3aa4c563bb69a4dfd6ac970ba42def209a"></a>Priority_Low&#160;</td><td class="fielddoc"><p>Specifies accessing with low priority. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a38a958348ad64793a93e82a5a556d7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a958348ad64793a93e82a5a556d7b4">&#9670;&nbsp;</a></span>MountCacheStorage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountCacheStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a cache storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000062">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The cache storage is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/CacheStorageSize</code> is set to a valid value greater than <code>0</code>.</li>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/CacheStorageJournalSize</code> is set to a valid value greater than <code>0</code>.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You must apply in advance to use cache storage. For more information, see NintendoSDK Documents &gt; Features &gt; Basic Features &gt; fs Library &gt; Manual &gt; Features &gt; <a href="../../Package/contents/Pages/Page_224957652.html">Cache Storage</a>. </p>

</div>
</div>
<a id="ab217b088ff86a675d869cc9fb38390ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab217b088ff86a675d869cc9fb38390ac">&#9670;&nbsp;</a></span>MountCacheStorage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountCacheStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the index and mounts the cache storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the cache storage to mount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000063">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The specified cache storage is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The cache storage with the specified index exists.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You must apply in advance to use cache storage. For more information, see <a href="../../Package/contents/Pages/Page_276903214.html">Indexed Cache Storage</a> in the <code>fs</code> library documentation. </p>

</div>
</div>
<a id="af1ecb9478fe0f9dee627b65111cdbe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ecb9478fe0f9dee627b65111cdbe29">&#9670;&nbsp;</a></span>ReadDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadDirectory </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>entryBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>entryBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the child entries of a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Number of child entries stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entryBuffer</td><td>Buffer to store child entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Directory handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entryBufferCount</td><td>Number of elements in <code><em>entryBuffer</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000064">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The length of <code><em>entryBuffer</em></code> is at least <code><em>entryBufferCount</em></code>.</li>
<li><code><em>entryBufferCount</em></code> &gt;= <code>0</code>.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function stores up to <code><em>entryBufferCount</em></code> directory entries from the directory represented by <code><em>handle</em></code> in <code><em>entryBuffer</em></code> and outputs the number of entries stored to <code><em>outValue</em></code>. Any additional values in <code><em>entryBuffer</em></code> beyond the number indicated by <code><em>outValue</em></code> are undefined. The entry types that are listed are specified in the <code><em>option</em></code> argument that was passed when opening the directory. The order in which entries are listed is undefined. If this function is called multiple times on the same handle, it lists entries starting from the end of the previous call and returns as soon as the last entry is reached. Any successive calls on the same handle return with <code><em>outValue</em></code> = <code>0</code>. Creates an entry for open directories; behavior is undefined when removed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a90">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a12">EcCatalog/Main.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a11">FsHost/FsHost.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a9">ImguiDemo/ImguiDemo.cpp</a>, and <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_cache_8cpp-example.html#a13">NvnSimple/NvnSimpleSharedLib/FileCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa6a54b0d39dfd293b11cd1c0073aafb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a54b0d39dfd293b11cd1c0073aafb1">&#9670;&nbsp;</a></span>GetDirectoryEntryCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetDirectoryEntryCount </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of child entries in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Number of child entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Directory handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000065">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the number of entries in the directory represented by <code><em>handle</em></code>, and stores it in <code><em>outValue</em></code>. Returns the count of the type of child entries specified in the <code><em>option</em></code> flag when the directory was opened. The state of the handle is not changed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a88">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, and <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_cache_8cpp-example.html#a12">NvnSimple/NvnSimpleSharedLib/FileCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8d0fa5050c0f77a0a6f14a0b78f9b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d0fa5050c0f77a0a6f14a0b78f9b58">&#9670;&nbsp;</a></span>CloseDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the directory to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Closes the directory represented by <code><em>handle</em></code> and releases the resource. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a93">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a14">EcCatalog/Main.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a13">FsHost/FsHost.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a11">ImguiDemo/ImguiDemo.cpp</a>, and <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_cache_8cpp-example.html#a7">NvnSimple/NvnSimpleSharedLib/FileCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a81801a404563984f8c6cc1483cc6d730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81801a404563984f8c6cc1483cc6d730">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into the specified memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset from the beginning of the file at which to start reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to store data read from the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Read options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000066">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code>.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>buffer</em></code> points to valid memory.</li>
<li><code><em>size</em></code> is less than or equal to the size of <code><em>buffer</em></code>.</li>
<li><code><em>offset</em></code> &gt;= <code>0</code>.</li>
<li><code><em>offset</em></code> + <code><em>size</em></code> &lt;= The file size</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function reads <code><em>size</em></code> bytes of data starting from <code><em>offset</em></code> bytes from the beginning of the file represented by <code><em>handle</em></code>, and writes it to the memory starting from <code><em>buffer</em></code>. If the specified load range exceeds the end of the file, the process aborts as a precondition failure. For cases where the load range specification may exceed the end of the file, use the <code><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="Loads the content of the file into the specified memory.">nn::fs::ReadFile</a>(size_t* <em>outValue</em>, <a class="el" href="structnn_1_1fs_1_1_file_handle.html" title="Handle for working with a file.">FileHandle</a> <em>handle</em>, int64_t <em>offset</em>, void* <em>buffer</em>, size_t <em>size</em>, const <a class="el" href="structnn_1_1fs_1_1_read_option.html" title="Option specifier to use when reading files.">ReadOption</a>&amp; <em>option</em>)</code> overload function which takes the size of the loaded data as the output argument. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a11">AocSimple/AocSimple.cpp</a>, <a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#a31">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#a22">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a13">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a13">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a21">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a21">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a44">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a13">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a13">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a13">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a11">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a13">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a6">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a54">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a11">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a11">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a24">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a13">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a71">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a37">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a24">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a16">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a9">FsRom/FsRom.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a24">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a25">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a15">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a9">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a8">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a40">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a45">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a23">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a21">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a7">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a161">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a163">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a162">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a52">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a49">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a174">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a158">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a23">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a162">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a159">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a23">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a23">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a25">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a159">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a23">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_system_8cpp-example.html#a8">NvnSimple/NvnSimpleSharedLib/FileSystem.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#a7">NvnTutorial/AssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_load_scene_8cpp-example.html#a9">NvnTutorial/LoadScene.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a6">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a37">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a26">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a38">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a7">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a7">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a34">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a55">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a27">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a14">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a11">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a27">VfxSimple/main.cpp</a>, and <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a17">VkSimple/VkSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a90b280140b3e9d7eb83af3e807e4c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b280140b3e9d7eb83af3e807e4c0c3">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file, without options, into the specified memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset from the beginning of the file at which to start reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to store data read from the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000067">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code>.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>buffer</em></code> points to valid memory.</li>
<li><code><em>size</em></code> is less than or equal to the size of <code><em>buffer</em></code>.</li>
<li><code><em>offset</em></code> &gt;= <code>0</code>.</li>
<li><code><em>offset</em></code> + <code><em>size</em></code> &lt;= The file size</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function reads <code><em>size</em></code> bytes of data starting from <code><em>offset</em></code> bytes from the beginning of the file represented by <code><em>handle</em></code>, and writes it to the memory starting from <code><em>buffer</em></code>. If the specified load range exceeds the end of the file, the process aborts as a precondition failure. For cases where the load range specification may exceed the end of the file, use the <code><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="Loads the content of the file into the specified memory.">nn::fs::ReadFile</a>(size_t* <em>outValue</em>, <a class="el" href="structnn_1_1fs_1_1_file_handle.html" title="Handle for working with a file.">FileHandle</a> <em>handle</em>, int64_t <em>offset</em>, void* <em>buffer</em>, size_t <em>size</em>)</code> overload function which takes the size of the loaded data as the output argument. </p>

</div>
</div>
<a id="aa57d27066c8c88b6bf354fcfb3a8f394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57d27066c8c88b6bf354fcfb3a8f394">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into the specified memory, and gets the size of the loaded data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Number of bytes read from data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset from the beginning of the file at which to start reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to store data read from the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Read options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000068">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code>.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>buffer</em></code> points to valid memory.</li>
<li><code><em>size</em></code> is less than or equal to the size of <code><em>buffer</em></code>.</li>
<li><code><em>offset</em></code> &gt;= <code>0</code>.</li>
<li><code><em>offset</em></code> &lt;= the file size.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function reads <code><em>size</em></code> bytes of data starting from <code><em>offset</em></code> bytes from the beginning of the file represented by <code><em>handle</em></code>, and writes it to the memory starting from <code><em>buffer</em></code>. If <code><em>offset</em></code> + <code><em>size</em></code> exceeds the file size, the data is read up to the end of the file. Any additional values in <code><em>buffer</em></code> beyond the end of the file are undefined. It sends the number of bytes of data that were read to <code><em>outValue</em></code>. </p>

</div>
</div>
<a id="a433a913ce9dd7154b430118e99b4867b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433a913ce9dd7154b430118e99b4867b">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file, without options, into the specified memory, and gets the size of the loaded data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Number of bytes read from data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset from the beginning of the file at which to start reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to store data read from the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000069">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code>.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>buffer</em></code> points to valid memory.</li>
<li><code><em>size</em></code> is less than or equal to the size of <code><em>buffer</em></code>.</li>
<li><code><em>offset</em></code> &gt;= <code>0</code>.</li>
<li><code><em>offset</em></code> &lt;= the file size.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function reads <code><em>size</em></code> bytes of data starting from <code><em>offset</em></code> bytes from the beginning of the file represented by <code><em>handle</em></code>, and writes it to the memory starting from <code><em>buffer</em></code>. If <code><em>offset</em></code> + <code><em>size</em></code> exceeds the file size, the data is read up to the end of the file. Any additional values in <code><em>buffer</em></code> beyond the end of the file are undefined. It sends the number of bytes of data that were read to <code><em>outValue</em></code>. This overloaded function does not require any <code><a class="el" href="structnn_1_1fs_1_1_read_option.html" title="Option specifier to use when reading files.">ReadOption</a></code> to be specified. </p>

</div>
</div>
<a id="ab4351ff3a319e9a63093324a669492ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4351ff3a319e9a63093324a669492ab">&#9670;&nbsp;</a></span>WriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::WriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the contents of the specified memory to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset from the beginning of the file at which to start writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Write options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000070">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
<li>(<code><em>offset</em></code> + <code><em>size</em></code> &lt;= the file size) || (The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1" title="Allows append operations.">nn::fs::OpenMode_AllowAppend</a></code>.)</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>buffer</em></code> points to valid memory.</li>
<li><code><em>offset</em></code> &gt;= <code>0</code>.</li>
<li><code><em>size</em></code> is less than or equal to the size of <code><em>buffer</em></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function writes <code><em>size</em></code> bytes of the data starting from <code><em>buffer</em></code> to the position that is <code><em>offset</em></code> bytes from the beginning of the file represented by <code><em>handle</em></code>. If there is not enough space, this function returns <code>ResultNotEnoughSpace</code> without writing anything. If <code>option.flush</code> = <code>true</code> was executed, and the write operation was successful, <code><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="Ensures that data written with WriteFile() is actually saved to the file.">nn::fs::FlushFile()</a></code> will be executed simultaneously. Writing to the file and expanding the file size will not occur if <code><em>size</em></code> is set to <code>0</code>. Even in this case, if <code><em>option</em>.flush</code> = <code>true</code>, <code><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="Ensures that data written with WriteFile() is actually saved to the file.">nn::fs::FlushFile()</a></code> will be executed. If <code><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></code> fails, the file size may be too large. The content of the range of the attempted write operation is not guaranteed. This function must be called exclusive of other file operation functions on the same handle. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a17">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a27">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a19">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a11">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a19">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a20">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a10">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a14">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, and <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a28">ImguiDemo/ImguiDemo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a543a813b9e0c46a2d6ccb24d7c863a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543a813b9e0c46a2d6ccb24d7c863a76">&#9670;&nbsp;</a></span>FlushFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::FlushFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that data written with <code><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="Writes the contents of the specified memory to a file.">WriteFile()</a></code> is actually saved to the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000071">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function ensures that the data written to the file represented by <code><em>handle</em></code> is actually written to the file. This function must be called exclusive of other file operation functions on the same handle. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a21">FsHost/FsHost.cpp</a>, and <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a30">ImguiDemo/ImguiDemo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab469b77c1d8c44eaedb9b6d658aba6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab469b77c1d8c44eaedb9b6d658aba6c6">&#9670;&nbsp;</a></span>SetFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::SetFileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the size of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>File size after change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000072">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target file is opened in a mode that includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>size</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function changes the size of the file represented by <code><em>handle</em></code> to <code><em>size</em></code> bytes. The <code><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="Ensures that data written with WriteFile() is actually saved to the file.">FlushFile()</a></code> function does not need to be called after calling this function. If the return value is <code><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></code>, the file size does not change from before the function was called. This function must be called exclusive of other file operation functions on the same handle. </p>

</div>
</div>
<a id="aba29e01d386e809349d60eccdb15ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba29e01d386e809349d60eccdb15ff21">&#9670;&nbsp;</a></span>GetFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetFileSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Location where the file size is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000073">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function gets the size of the file represented by <code><em>handle</em></code> and writes it to <code><em>outValue</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#a30">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#a21">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a12">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a12">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a19">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a19">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a43">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a10">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a12">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a10">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a8">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a11">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a4">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a53">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a9">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a10">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a20">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a12">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a69">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a36">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a22">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a12">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a7">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a6">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a41">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a43">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a21">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a19">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a5">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a171">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a183">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a172">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a61">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a58">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a184">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a168">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a21">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a172">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a169">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a21">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a21">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a23">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a169">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a21">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_system_8cpp-example.html#a7">NvnSimple/NvnSimpleSharedLib/FileSystem.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#a6">NvnTutorial/AssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_load_scene_8cpp-example.html#a8">NvnTutorial/LoadScene.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a5">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a36">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a25">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a37">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a5">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a5">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a33">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a53">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a24">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a10">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a8">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a24">VfxSimple/main.cpp</a>, and <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a16">VkSimple/VkSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2805c57e6c7c5ec8fbc7d30e7137deae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2805c57e6c7c5ec8fbc7d30e7137deae">&#9670;&nbsp;</a></span>GetFileOpenMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::fs::GetFileOpenMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode specified when the file was opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>File handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mode that was specified when the file was opened (an <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393" title="Flags to specify the mode when opening a file.">nn::fs::OpenMode</a></code> type element or bitwise OR of elements).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8bd9e828751bd4f953acfa765278f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bd9e828751bd4f953acfa765278f84">&#9670;&nbsp;</a></span>CloseFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Handle of the file to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Closes the file represented by <code><em>handle</em></code> and releases the resource. If the <code><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="Ensures that data written with WriteFile() is actually saved to the file.">FlushFile()</a></code> function has not been called, this function stops the program and logs the event, even if the last write operation to the handle was successful. If the write operation fails due to the storage media being removed or other reason, the program can still close even if the <code><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="Ensures that data written with WriteFile() is actually saved to the file.">FlushFile()</a></code> function has not been called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a12">AocSimple/AocSimple.cpp</a>, <a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#a32">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#a23">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a14">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a14">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a22">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a22">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a46">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a14">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a14">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a14">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a13">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a14">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a7">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a55">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a12">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a12">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a21">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a11">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a72">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a30">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a25">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a14">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a10">FsRom/FsRom.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a22">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a23">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a13">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a17">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a12">FsSetAllocator/FsSetAllocator.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a14">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a13">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a43">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a47">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a24">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a22">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a9">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a162">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a164">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a163">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a53">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a50">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a175">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a159">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a29">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a163">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a160">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a29">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a29">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a31">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a160">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a29">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a34">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a36">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_system_8cpp-example.html#a9">NvnSimple/NvnSimpleSharedLib/FileSystem.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#a8">NvnTutorial/AssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_load_scene_8cpp-example.html#a10">NvnTutorial/LoadScene.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a7">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a45">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a35">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a39">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a9">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a9">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a35">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a54">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a26">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a13">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a10">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a26">VfxSimple/main.cpp</a>, and <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a18">VkSimple/VkSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1cb2578c957151c15e7a61836173bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb2578c957151c15e7a61836173bdc2">&#9670;&nbsp;</a></span>EnableGlobalFileDataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::EnableGlobalFileDataCache </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables global file data caching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The buffer to use for caching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>pBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>bufferSize</em></code> &gt;= <code>1048576</code> (1 MiB).</li>
<li>Global file data caching is not enabled by this function.</li>
<li>Global file data caching is not enabled by the default <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> function defined by the <code>init</code> library.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Passes cache memory and enables global file data caching. When you enable global file data caching, all subsequently accessed file data is cached automatically inside the <code>fs</code> library. To disable global file data caching enabled by this function and free the memory that was passed, use the <code><a class="el" href="namespacenn_1_1fs.html#a31f154d34fd5f9d2d9bc0d742d745b6a" title="Disables global file data caching.">DisableGlobalFileDataCache()</a></code> function. This function can be called in any environment, but the file systems usable by the cache differ depending on the environment and method of starting the application. For more information, see <a href="../../Package/contents/Pages/Page_313329665.html">Global File Data Cache</a> in NintendoSDK Documents. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a12">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a31f154d34fd5f9d2d9bc0d742d745b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f154d34fd5f9d2d9bc0d742d745b6a">&#9670;&nbsp;</a></span>DisableGlobalFileDataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::DisableGlobalFileDataCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables global file data caching. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>Global file data caching is not enabled by the default <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> function defined by the <code>init</code> library.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Disables global file data caching and frees the cache memory.</p>
<p>Nothing happens if global file data caching has already been disabled.</p>
<p>This function cannot be used to disable the global file data cache enabled by the default <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> function defined by the <code>init</code> library. If a cache is not required, the definition of <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> must be replaced in the application. For more information, see <a href="../../Package/contents/Pages/Page_313329665.html">Global File Data Cache</a> in NintendoSDK Documents. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_global_file_data_cache_manually_enabled_2_fs_global_file_data_cache_manually_enabled_8cpp-example.html#a13">FsFileDataCache/FsGlobalFileDataCacheManuallyEnabled/FsGlobalFileDataCacheManuallyEnabled.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2d72712742fd49f26a5bd36cce94d481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d72712742fd49f26a5bd36cce94d481">&#9670;&nbsp;</a></span>EnableIndividualFileDataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::EnableIndividualFileDataCache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables individual file data caching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The target file path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>The buffer to use for caching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000074">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target file cannot be found. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_individual_file_data_cache_already_enabled.html" title="A class that represents error Result values (fs: The individual file data cache is already enabled....">ResultIndividualFileDataCacheAlreadyEnabled</a></b> The target file is already cached. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> Cannot open target file because it is already open with <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code> specified as the mode. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> != <code>nullptr</code>.</li>
<li><code><em>pBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The size of the file indicated by <code><em>path</em></code> is <code><em>bufferSize</em></code> or smaller.</li>
<li>The number of files and directories open in the target file system is less than the number of files and directories that can be opened at the same time as listed in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Enables individual file data caching for the file indicated by <code><em>path</em></code>. The specified buffer is managed in the <code>fs</code> library until <code><a class="el" href="namespacenn_1_1fs.html#a774744bdd98a6a252de1262ce56f4ef6" title="Disables individual file data caching.">nn::fs::DisableIndividualFileDataCache()</a></code> is run. When this function runs, all data from the target file is loaded in the specified buffer and is subsequently used as cache. Subsequent reading of target file data references the cache. Loading of data to the target file is applied to both the actual data and cache.</p>
<p>Individual file data caching is disabled in the following situations. (To free the buffer from management in the <code>fs</code> library, the separate <code><a class="el" href="namespacenn_1_1fs.html#a774744bdd98a6a252de1262ce56f4ef6" title="Disables individual file data caching.">DisableIndividualFileDataCache()</a></code> must be run.)</p><ul>
<li>The file system that includes the target file is unmounted.</li>
<li>The target file is open with <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1" title="Allows append operations.">nn::fs::OpenMode_AllowAppend</a></code> specified as the mode.</li>
<li>The size of the target file was changed using <code><a class="el" href="namespacenn_1_1fs.html#ab469b77c1d8c44eaedb9b6d658aba6c6" title="Changes the size of a file.">nn::fs::SetFileSize()</a></code>.</li>
<li>The file instance indicated by <code><em>path</em></code> was changed using <code><a class="el" href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c" title="Creates a file.">nn::fs::CreateFile()</a></code> or <code><a class="el" href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea" title="Renames a file.">nn::fs::RenameFile()</a></code> after a function like <code><a class="el" href="namespacenn_1_1fs.html#a812ac4964fb5564467c5475c1b9fb16b" title="Deletes a file.">nn::fs::DeleteFile()</a></code> was called.</li>
<li>The <code><a class="el" href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17" title="Renames a directory.">nn::fs::RenameDirectory()</a></code> function was run in the file system that includes the target file.</li>
</ul>
<p>Cache management is performed for each mounted file system. Even when the file is the same, if the mount names are different, the file is treated as separate file cache for each file system.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 Individual file data caching does not work in the Windows environment. You can still call this function, but cache is not referenced.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 Individual file data caching does not work with the following file systems. You can still call this function for files in these file systems, but cache is not referenced.<ul>
<li>RamDisk</li>
<li>Host PC</li>
<li>SD card</li>
<li>ROM file systems when the application is started in RAW format (NSPD)</li>
<li>File system for save data and cache storage when <code><a class="el" href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415" title="Configures a path on the host PC to use as the save data location.">nn::fs::SetSaveDataRootPath()</a></code> is called</li>
</ul>
</div><div class="platform_section" data-platform="NX"></div><p> To disable individual file data caching and free the memory that was passed, use the <code><a class="el" href="namespacenn_1_1fs.html#a774744bdd98a6a252de1262ce56f4ef6" title="Disables individual file data caching.">DisableIndividualFileDataCache()</a></code> function. For more information, see <a href="../../Package/contents/Pages/Page_331387295.html">Individual File Data Cache</a> in NintendoSDK Documents. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a5">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a774744bdd98a6a252de1262ce56f4ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774744bdd98a6a252de1262ce56f4ef6">&#9670;&nbsp;</a></span>DisableIndividualFileDataCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::DisableIndividualFileDataCache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables individual file data caching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The target file path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p> <b>Details</b> <br  />
 Disables individual file data caching for the file indicated by <code><em>path</em></code>, and frees the buffer used as cache from <code>fs</code> library management. If individual file data caching is already disabled, the buffer that was used as cache is freed from <code>fs</code> library management if it is so managed. Nothing happens if individual file data caching is already disabled and the buffer that was used as cache is freed. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a8">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3e89c4d57cc8379265894ff7f3e98b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e89c4d57cc8379265894ff7f3e98b2c">&#9670;&nbsp;</a></span>CreateFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the new file to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the new file to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000075">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> There are no directories within the path. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="A class that represents error Result values (fs: Target already exists.).">ResultPathAlreadyExists</a></b> The target file already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
<li><code><em>size</em></code> &gt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function creates a new file of <code><em>size</em></code> bytes in the location indicated by <code><em>path</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a15">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a24">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a24">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a6">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a6">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a15">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a15">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a5">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a6">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a7">FsSetAllocator/FsSetAllocator.cpp</a>, and <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a25">ImguiDemo/ImguiDemo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a812ac4964fb5564467c5475c1b9fb16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812ac4964fb5564467c5475c1b9fb16b">&#9670;&nbsp;</a></span>DeleteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the file to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000076">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target file cannot be found. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The target file cannot be deleted because it is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function deletes the file indicated by <code><em>path</em></code>. This function fails if the target file is already opened by another process. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a14">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a23">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a23">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a28">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a13">FsSetAllocator/FsSetAllocator.cpp</a>, and <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a24">ImguiDemo/ImguiDemo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad09dbc3816b9e95562081f9411711c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09dbc3816b9e95562081f9411711c4a">&#9670;&nbsp;</a></span>CreateDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the new directory to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000077">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> There are no directories within the path. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="A class that represents error Result values (fs: Target already exists.).">ResultPathAlreadyExists</a></b> The target directory already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function creates a new directory in the location indicated by <code><em>path</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a5">FsHost/FsHost.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a40e072fc4b9bd6a36b6902b117ba85d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e072fc4b9bd6a36b6902b117ba85d0">&#9670;&nbsp;</a></span>DeleteDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the directory to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000078">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target directory cannot be found. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_directory_not_empty.html" title="A class that represents error Result values (fs: Target directory contains an entry....">ResultDirectoryNotEmpty</a></b> The target directory cannot be deleted because it contains child entries. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The target directory cannot be deleted because it is open. Cannot be deleted because a child entry is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
<li>The directory indicated by <code><em>path</em></code> is not the root directory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function deletes the directory indicated by <code><em>path</em></code>. The directory cannot be deleted if it contains any child entries. This function also fails if the target directory is opened by another process. </p>

</div>
</div>
<a id="ad6c41cd88ca1bd0cace5a443f4bc3efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c41cd88ca1bd0cace5a443f4bc3efd">&#9670;&nbsp;</a></span>DeleteDirectoryRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively deletes a directory including any child entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the directory to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000079">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target directory cannot be found. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The target directory cannot be deleted because it is open. Cannot be deleted because a child entry is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
<li>The directory indicated by <code><em>path</em></code> is not the root directory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function recursively deletes the directory indicated by <code><em>path</em></code>.</p>
<p>The function fails if the target is opened by another process. If the process fails before completion, any entries that were deleted up to the point of failure remain deleted. If the process fails before completion, which entries were deleted and which were not deleted is not defined. This function can be used on directory structures of any depth because the maximum amount of stack space used is fixed.</p>
<p>The directory indicated by <code><em>path</em></code> itself is also deleted. If you want to delete only the child entries without deleting the directory indicated by <code><em>path</em></code>, use the <code><a class="el" href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87" title="This function recursively deletes all child entries contained in the directory.">nn::fs::CleanDirectoryRecursively()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a26">FsHost/FsHost.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae52b7fdae71cfa75a6c45552c4195b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52b7fdae71cfa75a6c45552c4195b87">&#9670;&nbsp;</a></span>CleanDirectoryRecursively()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CleanDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function recursively deletes all child entries contained in the directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the directory to delete the child entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000080">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target directory cannot be found. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> Cannot be deleted because a child entry is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li>The mount name in <code><em>path</em></code> is for a writeable file system.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function recursively deletes all child entries contained in the directory indicated by <code><em>path</em></code>.</p>
<p>The function fails if the target is opened by another process. If the process fails before completion, any entries that were deleted up to the point of failure remain deleted. If the process fails before completion, which entries were deleted and which were not deleted is not defined. This function can be used on directory structures of any depth because the maximum amount of stack space used is fixed.</p>
<p>The directory indicated by <code><em>path</em></code> itself is not deleted. If you want to delete both the directory indicated by <code><em>path</em></code> and the child entries, use the <code><a class="el" href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd" title="Recursively deletes a directory including any child entries.">nn::fs::DeleteDirectoryRecursively()</a></code> function. </p>

</div>
</div>
<a id="aaa1a2e4d197a78400b604debc9c7c4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1a2e4d197a78400b604debc9c7c4ea">&#9670;&nbsp;</a></span>RenameFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::RenameFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames a file. </p>
<p>You can also use this function to move a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPath</td><td>File path before the change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>File path after the change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000081">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The original file to be renamed cannot be found. There are no directories within the path after it was renamed. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="A class that represents error Result values (fs: Target already exists.).">ResultPathAlreadyExists</a></b> The renamed file already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The original file to be renamed cannot be moved if it is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>currentPath</em></code> and <code><em>newPath</em></code> are<a class="el" href="namespacenn_1_1fs.html#entry_path">valid paths </a> .</li>
<li>The mount name in <code><em>currentPath</em></code> and <code><em>newPath</em></code> refer to the same file system.</li>
<li>The mount name in <code><em>currentPath</em></code> and <code><em>newPath</em></code> is for a writeable file system.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function renames the file indicated by <code><em>currentPath</em></code> to <code><em>newPath</em></code>. The file cannot be moved if it is open. </p>

</div>
</div>
<a id="a394c7c7cce23b0a368e83d115baafe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394c7c7cce23b0a368e83d115baafe17">&#9670;&nbsp;</a></span>RenameDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::RenameDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames a directory. </p>
<p>You can also use this function to move a directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPath</td><td>Directory path before the change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Directory path after the change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000082">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The original directory to be renamed cannot be found. There are no directories within the path after it was renamed. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="A class that represents error Result values (fs: Target already exists.).">ResultPathAlreadyExists</a></b> The renamed directory already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The original directory to be renamed cannot be renamed because it is open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>currentPath</em></code> and <code><em>newPath</em></code> are<a class="el" href="namespacenn_1_1fs.html#entry_path">valid paths </a> .</li>
<li>The mount name in <code><em>currentPath</em></code> and <code><em>newPath</em></code> refer to the same file system.</li>
<li>The mount name in <code><em>currentPath</em></code> and <code><em>newPath</em></code> is for a writeable file system.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function renames the directory indicated by <code><em>currentPath</em></code> to <code><em>newPath</em></code>. The paths of any child entries are changed at the same time.</p>
<p>The move fails if the destination already contains an entry with the same name. Consequently, this function cannot be used for merging directories. </p>

</div>
</div>
<a id="a5cf6e2f2c5a0c4e404ba3dd782cc98bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf6e2f2c5a0c4e404ba3dd782cc98bc">&#9670;&nbsp;</a></span>GetEntryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetEntryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Type of directory entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Target entry path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000083">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target entry does not exist. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the directory entry type of the target path.</p>
<p>It can be used to check whether a file or directory exists. If there are no entries in the target path, the function returns <code><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></code>. In this case, <code><em>outValue</em></code> is undefined. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a5">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a22">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a13">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a13">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a4">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, and <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a4">FsSdCardForDebug/FsSdCardForDebug.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aea4d264d61ffaeb4ad26e6bcbf6565b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4d264d61ffaeb4ad26e6bcbf6565b0">&#9670;&nbsp;</a></span>GetFreeSpaceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetFreeSpaceSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets free space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Size in bytes of the free space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Mount name specified when mounting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000084">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li>The mount name indicated by <code><em>name</em></code> is already mounted.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets free space for the file system specified by the mount name. Because space in any file system is also occupied by meta information and block management, you may not be able to create the file size the size of the obtained amount of free space. In file systems that are used with their space defined in advance, such as save data, a design that is not dependent on free space, or a design that manages the increase and decrease in data elements, is appropriate.</p>
<p>This function is available in SDK 9.0.0 and later.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The value of the free space obtained using the host file system mounted by <code><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751" title="Mounts the specified directory in the file system of the host PC and makes it available for operation...">nn::fs::MountHost()</a></code> is dependent on the path specified at the time of mounting and the host PC environment. The free space on a host file system mounted by <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code> cannot be obtained. If you have attempted to get free space for the save data and cache storage file systems mounted after <code><a class="el" href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415" title="Configures a path on the host PC to use as the save data location.">nn::fs::SetSaveDataRootPath()</a></code>, the value of the free space of the file systems placed in system memory will not be obtained. Instead, a value dependent on the path specified in <code><a class="el" href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415" title="Configures a path on the host PC to use as the save data location.">nn::fs::SetSaveDataRootPath()</a></code> and the host PC environment will be obtained.</div><div class="platform_section" data-platform="NX"></div> 
</div>
</div>
<a id="a0f2b5b30657b1ffaf1dec49bfb36462b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2b5b30657b1ffaf1dec49bfb36462b">&#9670;&nbsp;</a></span>OpenFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>File handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The file access mode (an <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393" title="Flags to specify the mode when opening a file.">nn::fs::OpenMode</a></code> type element or bitwise OR of elements).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000085">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target file cannot be found. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> Cannot open target file because it is already open with <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code> specified as the mode. Cannot open target file with <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code> specified as the mode because it is already open. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li><code><em>mode</em></code> is an <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393" title="Flags to specify the mode when opening a file.">nn::fs::OpenMode</a></code> element or a bitwise OR of elements.</li>
<li><code><em>mode</em></code> includes either <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code> or <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code> if not both.</li>
<li>If <code><em>mode</em></code> includes <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>, the file system is write enabled.</li>
<li>Does not exceed the maximum number that can be open at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function opens the file indicated by <code><em>path</em></code> and sends the corresponding handle to <code><em>outValue</em></code>. Specify whether to open the file in read or write mode in <code><em>mode</em></code>. If you will be writing in a way that extends the original size of the file, you must specify both <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code> and <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1" title="Allows append operations.">nn::fs::OpenMode_AllowAppend</a></code>. After a file is opened, it cannot be deleted or renamed until the handle is closed. Multiple instances of the same file can be open at the same time only by using <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code> mode to open a file that is open in <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d" title="Specifies read mode.">nn::fs::OpenMode_Read</a></code> mode. If you attempt to open multiple instances of the same file under any other conditions, <code><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></code> is returned. This function can be called multiple times against the same file and file system. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a10">AocSimple/AocSimple.cpp</a>, <a class="el" href="_atk_addon_sound_archive_2_atk_addon_sound_archive_8cpp-example.html#a27">AtkAddonSoundArchive/AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_2_atk_group_8cpp-example.html#a19">AtkGroup/AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a8">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a8">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a15">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a15">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a41">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a6">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a8">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a6">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a5">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a9">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a2">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a51">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a7">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a8">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a18">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a9">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a66">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a26">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a15">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a9">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a7">FsRom/FsRom.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a17">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a18">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a8">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a9">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a10">FsSetAllocator/FsSetAllocator.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a4">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a3">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a36">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a40">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a17">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a17">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a2">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a159">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a157">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a160">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a50">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a47">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a172">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a156">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a18">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a160">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a157">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a18">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a18">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a20">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a157">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a18">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a32">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a34">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_system_8cpp-example.html#a4">NvnSimple/NvnSimpleSharedLib/FileSystem.cpp</a>, <a class="el" href="_nvn_tutorial_2_asset_file_loading_helper_8cpp-example.html#a4">NvnTutorial/AssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial_2_load_scene_8cpp-example.html#a6">NvnTutorial/LoadScene.cpp</a>, <a class="el" href="_nvn_tutorial_2_multi_threaded_asset_file_loading_helper_8cpp-example.html#a2">NvnTutorial/MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a34">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a23">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a34">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a2">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a2">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a30">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a50">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a21">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a7">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a5">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a21">VfxSimple/main.cpp</a>, and <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a13">VkSimple/VkSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acae21d0f79e4d074e120c814a8936a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae21d0f79e4d074e120c814a8936a42">&#9670;&nbsp;</a></span>OpenDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Directory handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the directory to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The targets to list (an <code><a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705" title="Flags to specify the mode when opening a directory.">nn::fs::OpenDirectoryMode</a></code> type element or bitwise OR of elements).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000086">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target directory cannot be found. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> points to valid memory.</li>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
<li><code><em>mode</em></code> is an element of <code><a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705" title="Flags to specify the mode when opening a directory.">nn::fs::OpenDirectoryMode</a></code>.</li>
<li>Does not exceed the maximum number that can be open at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function opens the directory indicated by <code><em>path</em></code> and sends the corresponding handle to <code><em>outValue</em></code>. Only child entries of the kinds specified by <code><em>mode</em></code> are listed by <code><a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29" title="Lists the child entries of a directory.">nn::fs::ReadDirectory()</a></code>. This function can be called multiple times against the same directory and file system. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a86">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a10">EcCatalog/Main.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a8">FsHost/FsHost.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a7">ImguiDemo/ImguiDemo.cpp</a>, and <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_file_cache_8cpp-example.html#a9">NvnSimple/NvnSimpleSharedLib/FileCache.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1b85bf3f3cf038cb67a991a3e3304751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b85bf3f3cf038cb67a991a3e3304751">&#9670;&nbsp;</a></span>MountHost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHost </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts the specified directory in the file system of the host PC and makes it available for operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The mount name that indicates this file system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootPath</td><td>Path on the host PC to bind to <code><em>name</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000087">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The directory represented by <code><em>rootPath</em></code> cannot be found. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> Could not connect to the host PC. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>rootPath</em></code> is the absolute or relative path to an existing directory on the host PC.</li>
<li>The directory delimiter for <code><em>rootPath</em></code> is either / (a slash) or \ (two backslashes).</li>
<li>If <code><em>rootPath</em></code> is a relative path, it does not go back to the hierarchy higher than the origin.</li>
<li><code><em>rootPath</em></code> is a string of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes or less, including the terminating null character.</li>
<li>Connected to the host PC.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function mounts a file system on the host PC and makes it available for use. After calling this function, you can access the file system on the host PC by prepending <code>(<em>name</em>):</code> to the beginning of the path argument for each function. The actual path being accessed on the host PC is relative to <code><em>rootPath</em></code>. For instance, if you call <code>MountHost("host", "D:/tmp"); DeleteFile("host:/file");</code>, the <code>D:/tmp/file</code> file on the host PC is deleted.</p>
<p>Whether path handling is case-sensitive is dependent on the file system on the host PC.</p>
<p>You can specify a relative path for <code><em>rootPath</em></code>. In this case, the starting path differs depending on the runtime environment. For more information, see <a href="../../Package/contents/Pages/Page_213598244.html">Host PC</a> in NintendoSDK Documents. Specifying <code>""</code> for <code><em>rootPath</em></code> also specifies the origin of the relative path. You cannot specify a relative path through higher levels of the hierarchy. (For example, "../" or "./dir/../../" cannot be specified.)</p>
<p>You cannot specify a single letter for <code><em>name</em></code>. The reason is that even though you can use an absolute path on the host PC when you call the <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">MountHostRoot()</a></code> function, this single-letter name overlaps with the Windows drive letter used in that path. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a34">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a2">FsHost/FsHost.cpp</a>, <a class="el" href="_image_jpeg_encoding_2_image_jpeg_encoding_8cpp-example.html#a39">ImageJpegEncoding/ImageJpegEncoding.cpp</a>, <a class="el" href="_image_png_encoding_2_image_png_encoding_8cpp-example.html#a18">ImagePngEncoding/ImagePngEncoding.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a12">ImguiDemo/ImguiDemo.cpp</a>, and <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a12">Openssl/Client/OpensslClient.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3debd540f8e0207460e0a7a31edac92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debd540f8e0207460e0a7a31edac92d">&#9670;&nbsp;</a></span>MountHost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHost </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_mount_host_option.html">MountHostOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts the specified directory in the file system of the host PC and makes it available for operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The mount name that indicates this file system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootPath</td><td>Path on the host PC associated with <code><em>name</em></code> (This path does not need to have the host PC path and <code><em>case</em></code> together). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Mount option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000088">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The directory represented by <code><em>rootPath</em></code> cannot be found. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> Could not connect to the host PC. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>rootPath</em></code> is the absolute or relative path to an existing directory on the host PC.</li>
<li>The directory delimiter for <code><em>rootPath</em></code> is either / (a slash) or \ (two backslashes).</li>
<li>If <code><em>rootPath</em></code> is a relative path, it does not go back to the hierarchy higher than the origin.</li>
<li><code><em>rootPath</em></code> is a string of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes or less, including the terminating null character.</li>
<li>Connected to the host PC.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function mounts a file system on the host PC and makes it available for use. After calling this function, you can access the file system on the host PC by prepending <code>(<em>name</em>):</code> to the beginning of the path argument for each function. The actual path being accessed on the host PC is relative to <code><em>rootPath</em></code>. For instance, if you call <code>MountHost("host", "D:/tmp"); DeleteFile("host:/file");</code>, the <code>D:/tmp/file</code> file on the host PC is deleted.</p>
<p>Whether path handling is case-sensitive is dependent on the file system on the host PC and the <code><em>option</em></code> parameter. If the file system on the PC is case-sensitive, handling is case-sensitive regardless of <code><em>option</em></code>. If the file system on the PC is case-insensitive and <code><a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a" title="Specify when handling the path as case-sensitive.">nn::fs::MountHostOptionFlag_PseudoCaseSensitive</a></code> is not specified in <code><em>option</em></code>, handling is case-insensitive. If the file system on the PC is case-insensitive and <code><a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a" title="Specify when handling the path as case-sensitive.">nn::fs::MountHostOptionFlag_PseudoCaseSensitive</a></code> is specified in <code><em>option</em></code>, handling is case-sensitive with the following exceptions.</p><ul>
<li><code><a class="el" href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c" title="Creates a file.">nn::fs::CreateFile()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a" title="Creates a directory.">nn::fs::CreateDirectory()</a></code></li>
<li>File path of <code><a class="el" href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea" title="Renames a file.">nn::fs::RenameFile()</a></code> after the change</li>
<li>Directory path of <code><a class="el" href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17" title="Renames a directory.">nn::fs::RenameDirectory()</a></code> after the change</li>
</ul>
<p>You can specify a relative path for <code><em>rootPath</em></code>. In this case, the starting path differs depending on the runtime environment. For more information, see <a href="../../Package/contents/Pages/Page_213598244.html">Host PC</a> in NintendoSDK Documents. Specifying <code>""</code> for <code><em>rootPath</em></code> also specifies the origin of the relative path. You cannot specify a relative path through higher levels of the hierarchy. (For example, "../" or "./dir/../../" cannot be specified.)</p>
<p>You cannot specify a single letter for <code><em>name</em></code>. The reason is that even though you can use an absolute path on the host PC when you call the <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">MountHostRoot()</a></code> function, this single-letter name overlaps with the Windows drive letter used in that path. </p>

</div>
</div>
<a id="a2ea39d2487ac28bc767cd699eeeebe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea39d2487ac28bc767cd699eeeebe11">&#9670;&nbsp;</a></span>MountHostRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHostRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts the file system of the host PC and enables operations using the same paths as in Windows. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000089">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> Could not connect to the host PC. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> There is already a file system on the host PC. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>Connected to the host PC.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function mounts a file system on the host PC and makes it available for use. After you have called this function you can specify an absolute path on the host PC as the path for files and directories. Unlike other file systems, when mounting with this function, call the <code><a class="el" href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757" title="Unmounts a file system mounted with MountHostRoot() and frees the resources.">nn::fs::UnmountHostRoot()</a></code> function to unmount.</p>
<p>Whether path handling is case-sensitive is dependent on the file system on the host PC. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_viewer_2_atk_viewer_8cpp-example.html#a8">AtkViewer/AtkViewer.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a29">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a4">FsSetAllocator/FsSetAllocator.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a29">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a41">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a144">Ui2dViewerSimple/main.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a10">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a591fb29e0966ef5f550d4110a5aa4866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591fb29e0966ef5f550d4110a5aa4866">&#9670;&nbsp;</a></span>MountHostRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHostRoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_mount_host_option.html">MountHostOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts the file system of the host PC and enables operations using the same paths as in Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Mount option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000090">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> Could not connect to the host PC. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> There is already a file system on the host PC. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>Connected to the host PC.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function mounts a file system on the host PC and makes it available for use. After you have called this function you can specify an absolute path on the host PC as the path for files and directories. Unlike other file systems, when mounting with this function, call the <code><a class="el" href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757" title="Unmounts a file system mounted with MountHostRoot() and frees the resources.">nn::fs::UnmountHostRoot()</a></code> function to unmount.</p>
<p>Whether path handling is case-sensitive is dependent on the file system on the host PC and the <code><em>option</em></code> parameter. If the file system on the PC is case-sensitive, handling is case-sensitive regardless of <code><em>option</em></code>. If the file system on the PC is case-insensitive and <code><a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a" title="Specify when handling the path as case-sensitive.">nn::fs::MountHostOptionFlag_PseudoCaseSensitive</a></code> is not specified in <code><em>option</em></code>, handling is case-insensitive. If the file system on the PC is case-insensitive and <code><a class="el" href="namespacenn_1_1fs.html#a6758dcecf390a3c4028a8651fc5d305da16a5f8ea6c8ab5480ba0b3d07429b61a" title="Specify when handling the path as case-sensitive.">nn::fs::MountHostOptionFlag_PseudoCaseSensitive</a></code> is specified in <code><em>option</em></code>, handling is case-sensitive with the following exceptions.</p><ul>
<li><code><a class="el" href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c" title="Creates a file.">nn::fs::CreateFile()</a></code></li>
<li><code><a class="el" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a" title="Creates a directory.">nn::fs::CreateDirectory()</a></code></li>
<li>File path of <code><a class="el" href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea" title="Renames a file.">nn::fs::RenameFile()</a></code> after the change</li>
<li>Directory path of <code><a class="el" href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17" title="Renames a directory.">nn::fs::RenameDirectory()</a></code> after the change </li>
</ul>

</div>
</div>
<a id="ade5d6e6459dca7d8274564bcfc5de757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5d6e6459dca7d8274564bcfc5de757">&#9670;&nbsp;</a></span>UnmountHostRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::UnmountHostRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file system mounted with <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">MountHostRoot()</a></code> and frees the resources. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The file system was mounted by <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code>.</li>
<li>No files or directories are opened by the file system mounted by <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Unmounts a file system that was mounted by <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code> and frees the resources. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_atk_viewer_2_atk_viewer_8cpp-example.html#a15">AtkViewer/AtkViewer.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a30">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a14">FsSetAllocator/FsSetAllocator.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a36">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a43">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a145">Ui2dViewerSimple/main.cpp</a>, and <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a11">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac021c163ba94a44a2b53cb848c462930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac021c163ba94a44a2b53cb848c462930">&#9670;&nbsp;</a></span>SetAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a>&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the memory allocator to use in the <code>fs</code> library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Function to allocate memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dealloc</td><td>Function to deallocate memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>This API is not called even once within the program.</li>
<li>No <code>fs</code> library APIs to allocate memory are called within the program.</li>
<li><code><em>alloc</em></code> != <code>nullptr</code> &amp;&amp; <code><em>dealloc</em></code> != <code>nullptr</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Sets the memory allocators to use with the <code>fs</code> library to <code>alloc</code> and <code>dealloc</code>. For alloc, set an allocator that returns 8-byte aligned addresses.</p>
<p>If you intend to call this function, you must call it once before any other functions of the <code>fs</code> library have been called. If <code>fs</code> library functions that allocate memory are called without having first called this function, the default allocator that uses <code>malloc()</code> and <code>free()</code> are used to allocate memory. If the default allocator is used even once, this function cannot be called. For this reason, we recommend calling this function at places like the top of <code><a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="Startup initialization routine.">nninitStartup()</a></code> or <code>nnMain()</code>, where it is certain that no other <code>fs</code> library functions have been called.</p>
<p>Also see <a class="el" href="namespacenn_1_1fs.html#memory_allocation">Memory Allocation </a> . </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a16">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a17">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a24">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a24">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a3">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_out_2_audio_out_8cpp-example.html#a36">AudioOut/AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_2_audio_out_with_resampler_8cpp-example.html#a36">AudioOutWithResampler/AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a17">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a17">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a17">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a14">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a79">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a31">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_set_allocator_2_fs_set_allocator_8cpp-example.html#a3">FsSetAllocator/FsSetAllocator.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a26">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_image_jpeg_decoding_2_image_jpeg_decoding_8cpp-example.html#a41">ImageJpegDecoding/ImageJpegDecoding.cpp</a>, <a class="el" href="_image_jpeg_encoding_2_image_jpeg_encoding_8cpp-example.html#a37">ImageJpegEncoding/ImageJpegEncoding.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a149">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a147">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a150">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a37">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a34">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a162">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a146">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a330">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a150">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a147">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a229">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a229">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a231">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a147">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a229">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a7">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a0">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_multi_program_application_2_main_2_main_8cpp-example.html#a8">MultiProgramApplication/Main/Main.cpp</a>, <a class="el" href="_ngc_simple_2_ngc_simple_8cpp-example.html#a19">NgcSimple/NgcSimple.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_nx_8cpp-example.html#a27">NvnTutorial/TutorialBaseClass.Nx.cpp</a>, <a class="el" href="_nvn_tutorial_2_tutorial_base_class_8_windows_8cpp-example.html#a18">NvnTutorial/TutorialBaseClass.Windows.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a34">SpyAudio/SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a90">Ui2dDemo/Main.cpp</a>, <a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a143">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a54">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a77">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a68">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a142">VfxSimple/main.cpp</a>, and <a class="el" href="_web_demo_2_web_demo__main_8cpp-example.html#a3">WebDemo/WebDemo_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac8a95249afd4a87a55d319dfecb0466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a95249afd4a87a55d319dfecb0466c">&#9670;&nbsp;</a></span>Unmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::Unmount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a mounted file system and frees the resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Mount name specified when mounting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The mount name indicated by <code><em>name</em></code> is already mounted.</li>
<li>No files or directories in the mount specified by <code><em>name</em></code> are open.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function unmounts a mounted file system and frees the resources. This function unmounts any file system, excluding those mounted by the <code><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="Mounts the file system of the host PC and enables operations using the same paths as in Windows.">nn::fs::MountHostRoot()</a></code> function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a13">AocSimple/AocSimple.cpp</a>, <a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a20">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a21">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a28">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a28">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a8">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a21">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a20">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a21">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a18">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a4">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a17">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a5">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a4">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a5">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a14">Demo1/Demo1.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a15">EcCatalog/Main.cpp</a>, <a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a43">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a103">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_2_fontll_save_to_jpeg_8cpp-example.html#a48">FontllSaveToJpeg/FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a9">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_host_2_fs_host_8cpp-example.html#a27">FsHost/FsHost.cpp</a>, <a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a19">FsRamDisk/FsRamDisk.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a11">FsRom/FsRom.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a27">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a28">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a18">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a18">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a208">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a264">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a97">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a61">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a30">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_image_jpeg_decoding_2_image_jpeg_decoding_8cpp-example.html#a46">ImageJpegDecoding/ImageJpegDecoding.cpp</a>, <a class="el" href="_image_jpeg_encoding_2_image_jpeg_encoding_8cpp-example.html#a40">ImageJpegEncoding/ImageJpegEncoding.cpp</a>, <a class="el" href="_image_png_decoding_2_image_png_decoding_8cpp-example.html#a27">ImagePngDecoding/ImagePngDecoding.cpp</a>, <a class="el" href="_image_png_encoding_2_image_png_encoding_8cpp-example.html#a21">ImagePngEncoding/ImagePngEncoding.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a13">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a25">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a152">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a150">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a153">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a43">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a40">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a165">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a149">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a333">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a153">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a150">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a232">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a232">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a234">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a150">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a232">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a35">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a42">MoviePlayerSimple/MoviePlayerSimple.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a38">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial03_asset_file_loading_2_nvn_tutorial03_8cpp-example.html#a32">NvnTutorial03AssetFileLoading/NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a41">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_setting_up_render_state_2_nvn_tutorial05_8cpp-example.html#a31">NvnTutorial05SettingUpRenderState/NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a46">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_multi_threaded_renderer_2_nvn_tutorial07_8cpp-example.html#a24">NvnTutorial07MultiThreadedRenderer/NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_gpu_statistics_2_nvn_tutorial08_8cpp-example.html#a24">NvnTutorial08GpuStatistics/NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a36">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a28">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_nvn_tutorial12_deferred_renderer_2_nvn_tutorial12_8cpp-example.html#a14">NvnTutorial12DeferredRenderer/NvnTutorial12.cpp</a>, <a class="el" href="_nvn_tutorial13_screen_space_a_o_2_nvn_tutorial13_8cpp-example.html#a14">NvnTutorial13ScreenSpaceAO/NvnTutorial13.cpp</a>, <a class="el" href="_nvn_tutorial14_frustum_culling_2_nvn_tutorial14_8cpp-example.html#a14">NvnTutorial14FrustumCulling/NvnTutorial14.cpp</a>, <a class="el" href="_nvn_tutorial15_h_l_s_l_2_nvn_tutorial15_8cpp-example.html#a33">NvnTutorial15HLSL/NvnTutorial15.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a20">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a26">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a26">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a39">SpyAudio/SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a149">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a129">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a148">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a115">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a183">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a39">VkSimple/VkSimple.cpp</a>, and <a class="el" href="_web_demo_2_web_demo__main_8cpp-example.html#a8">WebDemo/WebDemo_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3759f457229862688d05fe6caeae0367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3759f457229862688d05fe6caeae0367">&#9670;&nbsp;</a></span>IsMounted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::IsMounted </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the mount named <code><em>name</em></code> is already mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000091">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> Indicates that <code><em>name</em></code> is already mounted. <br  />
 </p>
<p class="enddd"><b>false</b> Indicates that <code><em>name</em></code> is not mounted.</p>
</dd></dl>
<p> <b>Details</b> <br  />
 Determines whether <code><em>name</em></code> is already mounted. This function is used for assertions that the mount named <code><em>name</em></code> is already mounted or is not yet mounted. Use this function when the mount status of file systems for libraries and the like is being managed by a separate program. We do not recommend using the value returned by this function as a condition for changing the mount status of a file system. If your implementation unintentionally mounts and unmounts the file system repeatedly, you might not to able to pass the limit set on the frequency of reading. </p>

</div>
</div>
<a id="a3280722d232526f011908c2e7e50400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3280722d232526f011908c2e7e50400d">&#9670;&nbsp;</a></span>SetPriorityOnCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetPriorityOnCurrentThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the access priority. </p>
<p> <b>Details</b> <br  />
 Sets the access priority in the current thread. For more information, see the section on access priority in <a href="../../Package/contents/Pages/Page_277373520.html">NintendoSDK Documents</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>The access priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a1b0bae7e05be65b11e83a5a63640680f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0bae7e05be65b11e83a5a63640680f">&#9670;&nbsp;</a></span>GetPriorityOnCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> nn::fs::GetPriorityOnCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the access priority. </p>
<p> <b>Details</b> <br  />
 Gets the access priority in the current thread. For more information, see the section on access priority in <a href="../../Package/contents/Pages/Page_277373520.html">NintendoSDK Documents</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The access priority. </dd></dl>

</div>
</div>
<a id="a47158cdf85f271b33de66713208f4b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47158cdf85f271b33de66713208f4b55">&#9670;&nbsp;</a></span>GetRamDiskBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::fs::GetRamDiskBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>spaceSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buffer size used for RamDisk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spaceSize</td><td>File system capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size used for RamDisk.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>spaceSize</em></code> is less than <code><a class="el" href="namespacenn_1_1fs.html#ae6af211cba76d2e055b22ebf228aed3b" title="The maximum RamDisk file system capacity.">nn::fs::RamDiskSpaceSizeMax</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 To build a RamDisk file system with <code><em>spaceSize</em></code> capacity, gets the buffer size specified for <code><a class="el" href="namespacenn_1_1fs.html#a0ef2297587a324a49250429c4569e0a1" title="Builds and mounts the file system in memory.">nn::fs::MountRamDisk()</a></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a1">FsRamDisk/FsRamDisk.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0ef2297587a324a49250429c4569e0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2297587a324a49250429c4569e0a1">&#9670;&nbsp;</a></span>MountRamDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountRamDisk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds and mounts the file system in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Buffer used for the file system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000092">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>pBuffer</em></code> points to valid memory.</li>
<li><code><em>bufferSize</em></code> is greater than the value obtained when <code>0</code> is specified for <code><a class="el" href="namespacenn_1_1fs.html#a47158cdf85f271b33de66713208f4b55" title="Gets the buffer size used for RamDisk.">nn::fs::GetRamDiskBufferSize()</a></code>.</li>
<li><code><em>bufferSize</em></code> is less than the value obtained when <code><a class="el" href="namespacenn_1_1fs.html#ae6af211cba76d2e055b22ebf228aed3b" title="The maximum RamDisk file system capacity.">nn::fs::RamDiskSpaceSizeMax</a></code> is specified for <code><a class="el" href="namespacenn_1_1fs.html#a47158cdf85f271b33de66713208f4b55" title="Gets the buffer size used for RamDisk.">nn::fs::GetRamDiskBufferSize()</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 The contents of the file system are not made persistent and the file system is always empty immediately after mounting. The specified buffer is updated regardless of the success or failure of the return value. For more information, see <a href="../../Package/contents/Pages/Page_685577216.html">RamDisk</a> in NintendoSDK Documents. This function is available in SDK 10.0.0 and later. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_ram_disk_2_fs_ram_disk_8cpp-example.html#a4">FsRamDisk/FsRamDisk.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5df6e3385c795a5bd046790ef7f17f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df6e3385c795a5bd046790ef7f17f2d">&#9670;&nbsp;</a></span>QueryMountRomCacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::QueryMountRomCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size needed for the <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom</a></code> file system cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Size needed for the file system cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000093">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target ROM resource data exists.</li>
<li><code><em>pOutValue</em></code> points to valid memory.</li>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
</p><div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 Gets a fixed value in a Windows environment, regardless of the content of the resource (ROM) data.</div><div class="platform_section" data-platform="Windows"></div><div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 Gets a fixed value in an NX environment, when a RAW (NSPD) application is open, regardless of the content of the resource (ROM) data. The size of the cache buffer needed by the ultimate NX application is the size that is available when the application in NSP format is running.</div><div class="platform_section" data-platform="NX"></div> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a18">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a19">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a26">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a26">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a5">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a19">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a18">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a19">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a16">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_breakpad_simple_2_breakpad_simple_8cpp-example.html#a2">BreakpadSimple/BreakpadSimple.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a1">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a15">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a2">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a2">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a2">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a8">Demo1/Demo1.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a4">EcCatalog/Main.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a80">FontDemo/Main.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a2">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a2">FsRom/FsRom.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a204">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a246">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a74">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a48">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a28">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_image_jpeg_decoding_2_image_jpeg_decoding_8cpp-example.html#a43">ImageJpegDecoding/ImageJpegDecoding.cpp</a>, <a class="el" href="_image_png_decoding_2_image_png_decoding_8cpp-example.html#a23">ImagePngDecoding/ImagePngDecoding.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a1">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a13">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a150">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a148">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a151">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a38">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a35">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a163">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a147">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a331">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a151">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a148">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a230">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a230">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a232">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a148">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a230">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a21">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial03_asset_file_loading_2_nvn_tutorial03_8cpp-example.html#a28">NvnTutorial03AssetFileLoading/NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a31">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_setting_up_render_state_2_nvn_tutorial05_8cpp-example.html#a27">NvnTutorial05SettingUpRenderState/NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a29">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_multi_threaded_renderer_2_nvn_tutorial07_8cpp-example.html#a19">NvnTutorial07MultiThreadedRenderer/NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_gpu_statistics_2_nvn_tutorial08_8cpp-example.html#a19">NvnTutorial08GpuStatistics/NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a18">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a25">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_nvn_tutorial12_deferred_renderer_2_nvn_tutorial12_8cpp-example.html#a9">NvnTutorial12DeferredRenderer/NvnTutorial12.cpp</a>, <a class="el" href="_nvn_tutorial13_screen_space_a_o_2_nvn_tutorial13_8cpp-example.html#a9">NvnTutorial13ScreenSpaceAO/NvnTutorial13.cpp</a>, <a class="el" href="_nvn_tutorial14_frustum_culling_2_nvn_tutorial14_8cpp-example.html#a9">NvnTutorial14FrustumCulling/NvnTutorial14.cpp</a>, <a class="el" href="_nvn_tutorial15_h_l_s_l_2_nvn_tutorial15_8cpp-example.html#a29">NvnTutorial15HLSL/NvnTutorial15.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a13">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a14">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a13">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a36">SpyAudio/SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a91">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a55">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a102">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a93">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a165">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a24">VkSimple/VkSimple.cpp</a>, and <a class="el" href="_web_demo_2_web_demo__main_8cpp-example.html#a4">WebDemo/WebDemo_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2e453fe1fbf8f818dc45bbd2897105cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e453fe1fbf8f818dc45bbd2897105cd">&#9670;&nbsp;</a></span>MountRom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountRom </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFileSystemCacheBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSystemCacheBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts ROM resource data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileSystemCacheBuffer</td><td>The buffer for file system cache. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystemCacheBufferSize</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000094">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target ROM resource data exists.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>pFileSystemCacheBuffer</em></code> points to valid memory.</li>
<li><code><em>fileSystemCacheBufferSize</em></code> is larger than the value obtained by <code>QueryMountRomCacheSize(size_t* <em>pOutValue</em>)</code>.</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Mounts a read-only ROM file system, using name as the mount name, to handle ROM resource data. We do not recommend specifying different mount names, calling this function multiple times, and mounting the file system multiple times. If you mount the file system multiple times, you must specify a different cache buffer for each mount. For more information about the specification and placement of source data (ROM), see the Fs Library <a href="../../Package/contents/Pages/Page_107320203.html">Resource Data (ROM)</a> documentation. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_audio_cpu_renderer_2_audio_cpu_renderer_8cpp-example.html#a19">AudioCpuRenderer/AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_2_audio_device_8cpp-example.html#a20">AudioDevice/AudioDevice.cpp</a>, <a class="el" href="_audio_effect_2_audio_effect_8cpp-example.html#a27">AudioEffect/AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_2_audio_effect_aux_utility_8cpp-example.html#a27">AudioEffectAuxUtility/AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_2_audio_memory_pool_8cpp-example.html#a7">AudioMemoryPool/AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_2_audio_performance_metrics_8cpp-example.html#a20">AudioPerformanceMetrics/AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_2_audio_renderer_8cpp-example.html#a19">AudioRenderer/AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_2_audio_sink_8cpp-example.html#a20">AudioSink/AudioSink.cpp</a>, <a class="el" href="_audio_splitter_2_audio_splitter_8cpp-example.html#a17">AudioSplitter/AudioSplitter.cpp</a>, <a class="el" href="_breakpad_simple_2_breakpad_simple_8cpp-example.html#a4">BreakpadSimple/BreakpadSimple.cpp</a>, <a class="el" href="_codec_aac_decoder_2_codec_aac_decoder_8cpp-example.html#a3">CodecAacDecoder/CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_2_codec_opus_codec_processing_time_8cpp-example.html#a16">CodecOpusCodecProcessingTime/CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_2_codec_opus_decoder_8cpp-example.html#a4">CodecOpusDecoder/CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_2_codec_opus_encoder_8cpp-example.html#a3">CodecOpusEncoder/CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_2_codec_opus_multi_stream_decoder_8cpp-example.html#a4">CodecOpusMultiStreamDecoder/CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a11">Demo1/Demo1.cpp</a>, <a class="el" href="_ec_catalog_2_main_8cpp-example.html#a7">EcCatalog/Main.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a82">FontDemo/Main.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a3">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_rom_2_fs_rom_8cpp-example.html#a4">FsRom/FsRom.cpp</a>, <a class="el" href="_gfx_primitive_renderer_2_gfx_primitive_renderer_8cpp-example.html#a207">GfxPrimitiveRenderer/GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_2_gfx_simple_8cpp-example.html#a247">GfxSimple/GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_2_gfx_simple_compute_8cpp-example.html#a75">GfxSimpleCompute/GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence_2_hid_controller_sequence__main_8cpp-example.html#a50">HidControllerSequence/HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_real_time_converter_2_hid_vibration_real_time_converter_8cpp-example.html#a29">HidVibrationRealTimeConverter/HidVibrationRealTimeConverter.cpp</a>, <a class="el" href="_image_jpeg_decoding_2_image_jpeg_decoding_8cpp-example.html#a45">ImageJpegDecoding/ImageJpegDecoding.cpp</a>, <a class="el" href="_image_png_decoding_2_image_png_decoding_8cpp-example.html#a25">ImagePngDecoding/ImagePngDecoding.cpp</a>, <a class="el" href="_imgui_demo_2_imgui_demo_8cpp-example.html#a4">ImguiDemo/ImguiDemo.cpp</a>, <a class="el" href="_independent_build_system_2_main_8cpp-example.html#a15">IndependentBuildSystem/Main.cpp</a>, <a class="el" href="_mii_compressed_texture_2_mii_compressed_texture_8cpp-example.html#a151">MiiCompressedTexture/MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_2_mii_database_8cpp-example.html#a149">MiiDatabase/MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_2_mii_dynamic_mask_8cpp-example.html#a152">MiiDynamicMask/MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_2_mii_g3d_headwear_8cpp-example.html#a41">MiiG3dHeadwear/MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_2_mii_g3d_simple_8cpp-example.html#a38">MiiG3dSimple/MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_2_mii_headwear_example_8cpp-example.html#a164">MiiHeadwearExample/MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_2_mii_mip_map_8cpp-example.html#a148">MiiMipMap/MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_2_mii_premultiplied_alpha_icon_8cpp-example.html#a332">MiiPremultipliedAlphaIcon/MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_2_mii_shader_example_8cpp-example.html#a152">MiiShaderExample/MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_2_mii_simple_8cpp-example.html#a149">MiiSimple/MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_2_mii_simple_icon_8cpp-example.html#a231">MiiSimpleIcon/MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_2_mii_simple_icon_body_8cpp-example.html#a231">MiiSimpleIconBody/MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_2_mii_simple_variable_icon_body_8cpp-example.html#a233">MiiSimpleVariableIconBody/MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_2_mii_system_resource_8cpp-example.html#a149">MiiSystemResource/MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_2_mii_transparent_adjuster_8cpp-example.html#a231">MiiTransparentAdjuster/MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_simple_framework_8cpp-example.html#a22">NvnSimple/NvnSimpleSharedLib/SimpleFramework.cpp</a>, <a class="el" href="_nvn_tutorial03_asset_file_loading_2_nvn_tutorial03_8cpp-example.html#a30">NvnTutorial03AssetFileLoading/NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_multi_threaded_asset_file_loading_2_nvn_tutorial04_8cpp-example.html#a33">NvnTutorial04MultiThreadedAssetFileLoading/NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_setting_up_render_state_2_nvn_tutorial05_8cpp-example.html#a29">NvnTutorial05SettingUpRenderState/NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_frame_buffering_2_nvn_tutorial06_8cpp-example.html#a31">NvnTutorial06FrameBuffering/NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_multi_threaded_renderer_2_nvn_tutorial07_8cpp-example.html#a21">NvnTutorial07MultiThreadedRenderer/NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_gpu_statistics_2_nvn_tutorial08_8cpp-example.html#a21">NvnTutorial08GpuStatistics/NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_shader_specialization_2_nvn_tutorial09_8cpp-example.html#a20">NvnTutorial09ShaderSpecialization/NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_runtime_texture_compression_2_nvn_tutorial11_8cpp-example.html#a27">NvnTutorial11RuntimeTextureCompression/NvnTutorial11.cpp</a>, <a class="el" href="_nvn_tutorial12_deferred_renderer_2_nvn_tutorial12_8cpp-example.html#a11">NvnTutorial12DeferredRenderer/NvnTutorial12.cpp</a>, <a class="el" href="_nvn_tutorial13_screen_space_a_o_2_nvn_tutorial13_8cpp-example.html#a11">NvnTutorial13ScreenSpaceAO/NvnTutorial13.cpp</a>, <a class="el" href="_nvn_tutorial14_frustum_culling_2_nvn_tutorial14_8cpp-example.html#a11">NvnTutorial14FrustumCulling/NvnTutorial14.cpp</a>, <a class="el" href="_nvn_tutorial15_h_l_s_l_2_nvn_tutorial15_8cpp-example.html#a31">NvnTutorial15HLSL/NvnTutorial15.cpp</a>, <a class="el" href="_openssl_2_client_2_openssl_client_8cpp-example.html#a14">Openssl/Client/OpensslClient.cpp</a>, <a class="el" href="_ro_simple_2_ro_dead_strip_static_application_2_ro_dead_strip_static_application_8cpp-example.html#a16">RoSimple/RoDeadStripStaticApplication/RoDeadStripStaticApplication.cpp</a>, <a class="el" href="_ro_simple_2_ro_static_application_2_ro_static_application_8cpp-example.html#a15">RoSimple/RoStaticApplication/RoStaticApplication.cpp</a>, <a class="el" href="_spy_audio_2_spy_audio_8cpp-example.html#a38">SpyAudio/SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a93">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a57">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a104">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a95">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a167">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_2_vk_simple_8cpp-example.html#a26">VkSimple/VkSimple.cpp</a>, and <a class="el" href="_web_demo_2_web_demo__main_8cpp-example.html#a6">WebDemo/WebDemo_Main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7a6592b4b0351945aa259359dcb464cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6592b4b0351945aa259359dcb464cd">&#9670;&nbsp;</a></span>CanMountRomForDebug() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::CanMountRomForDebug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom()</a></code> is available. </p>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000095">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">MountRom()</a></code> is available for use. <br  />
 </p>
<p class="enddd"><b>false</b> <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">MountRom()</a></code> is not available.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. </p>

</div>
</div>
<a id="aa2ac4546c16bdf7a05078a76c10279d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac4546c16bdf7a05078a76c10279d3">&#9670;&nbsp;</a></span>CanMountRomForDebug() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::CanMountRomForDebug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>programIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">nn::fs::MountRom(const char*, int, void*, size_t)</a></code> can be executed for the specified program. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">programIndex</td><td>Index of the target program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000096">Return Values:</a></b></dt><dd><p class="startdd"><b>true</b> <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">MountRom(const char*, int, void*, size_t)</a></code> can be executed. <br  />
 </p>
<p class="enddd"><b>false</b> <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">MountRom(const char*, int, void*, size_t)</a></code> cannot be executed. </p>
</dd></dl>

</div>
</div>
<a id="a663914b6aa85ed8cc0e1700b14bf3ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663914b6aa85ed8cc0e1700b14bf3ae8">&#9670;&nbsp;</a></span>QueryMountRomCacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::QueryMountRomCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>programIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size required for the <code><a class="el" href="namespacenn_1_1fs.html#a22b6b37427a68d2ee452b50ab6b86a1c" title="Mount the resource data (ROM) for the specified program.">nn::fs::MountRom(const char*, int, void*, size_t)</a></code> file system cache for the specified program. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target ROM resource data exists.</li>
<li><code><em>pOutValue</em></code> points to valid memory.</li>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Aside from the need to specify the target program, this function is the same as the standard <code><a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d" title="Get the size needed for the nn::fs::MountRom file system cache.">nn::fs::QueryMountRomCacheSize(size_t*)</a></code>. For more information, see <code><a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d" title="Get the size needed for the nn::fs::MountRom file system cache.">nn::fs::QueryMountRomCacheSize(size_t*)</a></code>. To reference resource data from another program, you must have the application that includes the program to be referenced installed in advance. For more information, see <a href="../../Package/contents/Pages/Page_309702322.html">Multi-Program Applications</a> in NintendoSDK Documents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Size needed for the file system cache. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programIndex</td><td>Index of the target program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000097">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>

</div>
</div>
<a id="a22b6b37427a68d2ee452b50ab6b86a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b6b37427a68d2ee452b50ab6b86a1c">&#9670;&nbsp;</a></span>MountRom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountRom </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>programIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFileSystemCacheBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSystemCacheBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount the resource data (ROM) for the specified program. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target ROM resource data exists.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>pFileSystemCacheBuffer</em></code> points to valid memory.</li>
<li><code><em>fileSystemCacheBufferSize</em></code> is larger than the size that can be obtained by <code>QueryMountRomCacheSize(size_t* <em>pOutValue</em>, int)</code>.</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Aside from the need to specify the target program, this function is the same as <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom(const char*, void*, size_t)</a></code>. For more information, see <code><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="Mounts ROM resource data.">nn::fs::MountRom(const char*, void*, size_t)</a></code>. To reference resource data from another program, you must have the application that includes the program to be referenced installed in advance. For more information, see <a href="../../Package/contents/Pages/Page_309702322.html">Multi-Program Applications</a> in NintendoSDK Documents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">programIndex</td><td>Index of the target program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileSystemCacheBuffer</td><td>The buffer for file system cache. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystemCacheBufferSize</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000098">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. </p>
</dd></dl>

</div>
</div>
<a id="a90c27aaf70aec66968715663cd8c5415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c27aaf70aec66968715663cd8c5415">&#9670;&nbsp;</a></span>SetSaveDataRootPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetSaveDataRootPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a path on the host PC to use as the save data location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootPath</td><td>Directory path on the host PC to use as the save data location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>rootPath</em></code> is the absolute or relative path to an existing directory on the host PC.</li>
<li>The directory delimiter for <code><em>rootPath</em></code> is either / (a slash) or \ (two backslashes).</li>
<li>If <code><em>rootPath</em></code> is a relative path, it does not go back to the hierarchy higher than the origin.</li>
<li><code><em>rootPath</em></code> is a string of <code><a class="el" href="namespacenn_1_1fs.html#a5765422e17f81856298a59f759cc2a8c" title="Maximum path length, in bytes.">nn::fs::PathSizeMax</a></code> + 1 bytes or less, including the terminating null character.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. Must be run before mounting save data. For more information, see the <code>fs</code> library <a href="../../Package/contents/Pages/Page_107320205.html">Save Data</a> documentation.</p>
<p>You can specify a relative path for <code><em>rootPath</em></code>. In this case, the starting path differs depending on the runtime environment. For more information, see <a href="../../Package/contents/Pages/Page_213598244.html">Host PC</a> in NintendoSDK Documents. Specifying <code>""</code> for <code><em>rootPath</em></code> also specifies the origin of the relative path. You cannot specify a relative path through higher levels of the hierarchy. (For example, "../" or "./dir/../../" cannot be specified.)</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 The API settings have the same effect on cache storage.</div><div class="platform_section" data-platform="NX"></div> 
</div>
</div>
<a id="a767e38eb403bd2ebb4374c5214dc0e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767e38eb403bd2ebb4374c5214dc0e95">&#9670;&nbsp;</a></span>MountSaveDataForDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveDataForDebug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts save data for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000099">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The save data is in use. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> The save data location was not found.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. This function mounts save data with a mount name of <code><em>name</em></code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a2">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa8c23b8227d3d07d54779875f565d698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c23b8227d3d07d54779875f565d698">&#9670;&nbsp;</a></span>EnsureSaveDataForDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::EnsureSaveDataForDebug </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataJournalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates save data for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataSize</td><td>The size of the data storage region for the save data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataJournalSize</td><td>The size of the journal region for the save data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000100">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The save data is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="A class that represents error Result values (fs: Target not found.).">ResultTargetNotFound</a></b> The save data location was not found.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>saveDataSize</em></code> and <code><em>saveDataJournalSize</em></code> are both multiples of 16 * 1024.</li>
<li><code><em>saveDataSize</em></code> + <code><em>saveDataJournalSize</em></code> &lt;= 4000 * 1024 * 1024</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. If save data for debugging that exceeds the specified size already exists, this function returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></code> without performing any operations. If save data for debugging that is smaller than the specified size already exists, this function expands the save data to the specified size. </p>

</div>
</div>
<a id="ac2f25cffd056f24d6facfda13f977fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f25cffd056f24d6facfda13f977fa6">&#9670;&nbsp;</a></span>CommitSaveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CommitSaveData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is deprecated. </p>
<p>Please check the details for usage conditions and substitute functions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd></dd></dl>
<p>Commits updates to the save data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Mount name specified when mounting the target save data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000101">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The mount name of mounted save data is <code><em>name</em></code>.</li>
<li>The files in the mount specified by <code><em>name</em></code> are not open in modes that include <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Commits the update content to save data. If you unmount or close the program without calling this program, save data content is rolled back to the last time a commit was successful. If the program closes while this function is executing, save data content either reverts to the point when the last commit was successful, or applies all updates. Content is not corrupted or partially updated. We do not recommend using this function. Use <code><a class="el" href="namespacenn_1_1fs.html#ab534529ae3c325863fe1eb34bd03c872" title="Commits updated content for file systems, in which the journaling feature is enabled.">nn::fs::Commit()</a></code> instead. </p>

</div>
</div>
<a id="a196ef874060b922b93756ddff212fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196ef874060b922b93756ddff212fefa">&#9670;&nbsp;</a></span>MountSdCardForDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSdCardForDebug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts an SD card using the mount name that specifies the file system for handling it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000102">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_sd_card_access_failed.html" title="A class that represents error Result values (fs: Failed to access the SD card.).">ResultSdCardAccessFailed</a></b> Access to the SD card failed. </p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. If the function is called in an environment without an SD card slot, a substitute region is mounted. For more information, see the Fs Library <a href="../../Package/contents/Pages/Page_112886110.html">SD Card</a> documentation. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_fs_sd_card_for_debug_2_fs_sd_card_for_debug_8cpp-example.html#a2">FsSdCardForDebug/FsSdCardForDebug.cpp</a>, <a class="el" href="_movie_decoder_player_2_movie_decoder_player_8cpp-example.html#a25">MovieDecoderPlayer/MovieDecoderPlayer.cpp</a>, and <a class="el" href="_movie_player_simple_2_movie_player_simple_8cpp-example.html#a37">MoviePlayerSimple/MoviePlayerSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8191828699cf3d29befe8dbd710db421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8191828699cf3d29befe8dbd710db421">&#9670;&nbsp;</a></span>MountTemporaryStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountTemporaryStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts temporary storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000103">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The temporary storage is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/TemporaryStorageSize</code> is set to a valid value greater than <code>0</code>.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 You must apply in advance to use temporary storage. For more information, see NintendoSDK Documents &gt; Features &gt; Basic Features &gt; fs Library &gt; Manual &gt; Features &gt; <a href="../../Package/contents/Pages/Page_224955140.html">Temporary Storage</a>. </p>

</div>
</div>
<a id="ab534529ae3c325863fe1eb34bd03c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab534529ae3c325863fe1eb34bd03c872">&#9670;&nbsp;</a></span>Commit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::Commit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits updated content for file systems, in which the journaling feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Mount name specified when mounting the target file system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000104">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The mount name that is mounted is <code><em>name</em></code>.</li>
<li>The files in the mount specified by <code><em>name</em></code> are not open in modes that include <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Commits updated content for file systems specified by a mount name. For file systems with the journaling feature enabled, if you unmount or halt the program without calling this function, data content is rolled back to the previous time a commit was successful. If the program closes while this function is executing, the content of the data either reverts to the point when the previous commit was successful, or all updates are applied, so that content is not corrupted or partially updated. You do not need to call this function for file systems in which the journaling feature is not enabled. For more information about determining whether the journaling feature is enabled on each file system, see <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a28">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a26">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a27">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>, and <a class="el" href="_fs_save_data_for_debug_2_fs_save_data_for_debug_8cpp-example.html#a17">FsSaveDataForDebug/FsSaveDataForDebug.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac90e600c3fc51adb6823a4ef900fad3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90e600c3fc51adb6823a4ef900fad3a">&#9670;&nbsp;</a></span>Commit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::Commit </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>nameArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simultaneously commits updates to multiple file systems that have the multicommit feature enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameArray</td><td>The array of mount names specified when mounting the file systems. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameCount</td><td>The number of mount names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000105">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>All of the elements in <code><em>nameArray</em></code> are mount names of file systems that have already been mounted.</li>
<li>All of the elements in <code><em>nameArray</em></code> are mount names of file systems where the multicommit feature is enabled.</li>
<li>All of the elements in <code><em>nameArray</em></code> are mount names of file systems that can be written to.</li>
<li>None of the files in any of the mounts specified by <code><em>nameArray</em></code> are open in modes that include <code><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03" title="Specifies write mode.">nn::fs::OpenMode_Write</a></code>.</li>
<li><code><em>nameArray</em></code> does not include any duplicate mount names.</li>
<li><code><em>nameCount</em></code> &gt;= <code>0</code>.</li>
<li><code><em>nameCount</em></code> &lt;= <code>0</code>.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Simultaneously commits updates to the file systems corresponding to the specified mount names. If the program is stopped while this function is executing, the content of the data either reverts to what it was at the time of the last successful commit for all specified file systems, or all of the updates are applied to all of the specified file systems, meaning that it is never the case that the updates are applied to only some of the file systems. For more information about determining whether the multicommit feature is enabled on each file system, see <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </p>

</div>
</div>
<a id="afcb1fa310028d36752df80ff69beec4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb1fa310028d36752df80ff69beec4c">&#9670;&nbsp;</a></span>QueryMountAddOnContentCacheSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::QueryMountAddOnContentCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a>&#160;</td>
          <td class="paramname"><em>targetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size needed for the <code>MountAddOnContent</code> file system cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>Size needed for the file system cache. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetIndex</td><td>Downloadable content index for the target downloadable content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000173">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target downloadable content has been installed.</li>
<li><code><em>pOutValue</em></code> points to valid memory.</li>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a4">AocSimple/AocSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad92caf5815857651653369e760f85a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92caf5815857651653369e760f85a66">&#9670;&nbsp;</a></span>MountAddOnContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountAddOnContent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a>&#160;</td>
          <td class="paramname"><em>targetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFileSystemCacheBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSystemCacheBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a read-only file system to handle downloadable content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetIndex</td><td>Downloadable content index for the target downloadable content. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileSystemCacheBuffer</td><td>The buffer for file system cache. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystemCacheBufferSize</td><td>The buffer size. You can get the required buffer size with <code>QueryMountAddOnContentCacheSize(size_t* <em>pOutValue</em>, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba" title="Type that represents the downloadable content index.">nn::aoc::AddOnContentIndex</a> <em>targetIndex</em>)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000174">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The target downloadable content has been installed.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code><em>pFileSystemCacheBuffer</em></code> != <code>nullptr</code>.</li>
<li><code><em>fileSystemCacheBufferSize</em></code> must be at least the size available using <code>QueryMountAddOnContentCacheSize(size_t* <em>pOutValue</em>, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba" title="Type that represents the downloadable content index.">nn::aoc::AddOnContentIndex</a> <em>targetIndex</em>)</code>.</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_aoc_simple_2_aoc_simple_8cpp-example.html#a7">AocSimple/AocSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4916142164a7a335694945e38513e9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4916142164a7a335694945e38513e9c5">&#9670;&nbsp;</a></span>GetCacheStorageMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::GetCacheStorageMax </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outCacheStorageIndexMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outCacheStorageDataAndJournalSizeMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum size and maximum index of the cache storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageIndexMax</td><td>The maximum cache storage index (<code>NintendoSdkMeta/Application/CacheStorageIndexMax</code> in the NMETA file). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageDataAndJournalSizeMax</td><td>The maximum total size of the data storage areas and journaling areas of each cache storage (the value of <code>NintendoSdkMeta/Application/CacheStorageDataAndJournalSizeMax</code> in the NMETA file).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outCacheStorageIndexMax</em></code> indicates valid memory.</li>
<li><code><em>outCacheStorageDataAndJournalSizeMax</em></code> indicates valid memory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the maximum size and maximum index, of the cache storage, that can be specified by <code><a class="el" href="namespacenn_1_1fs.html#af3735c46a459dbf4ba3d6de862b611d4" title="Creates the cache storage.">nn::fs::CreateCacheStorage()</a></code>. Gets <code>0</code> if no maximum cache storage size is specified in the NMETA file.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In the Windows environment, gets the fixed value (maximum variable value).</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="af3735c46a459dbf4ba3d6de862b611d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3735c46a459dbf4ba3d6de862b611d4">&#9670;&nbsp;</a></span>CreateCacheStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateCacheStorage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cacheStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cacheStorageJournalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the cache storage. </p>
<p> <b>Details</b> <br  />
 Creates a cache storage of the specified size. If there is insufficient space, displays a UI for allocating space or the error viewer applet. For more information, see <a href="../../Package/contents/Pages/Page_276903214.html">Indexed Cache Storage</a> in the <code>fs</code> library documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Cache storage index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheStorageSize</td><td>The size of the data save area of the cache storage to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheStorageJournalSize</td><td>The size of the journaling region of the cache storage to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The maximum size of the cache storage is specified in <code>NintendoSdkMeta/Application/CacheStorageDataAndJournalSizeMax</code> of the NMETA file.</li>
<li>The maximum index value is specified in <code>NintendoSdkMeta/Application/CacheStorageIndexMax</code> of the NMETA file.</li>
<li><code><em>cacheStorageSize</em></code> + <code><em>cacheStorageJournalSize</em></code> &lt;= <code>CacheStorageDataAndJournalSizeMax</code></li>
<li><code><em>index</em></code> &lt;= <code>CacheStorageIndexMax</code></li>
<li>A cache storage with the same index does not exist.</li>
<li>A cache storage with the same index is not mounted.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>There is a cache storage for the specified index where the data save area &gt;= <code><em>cacheStorageSize</em></code> and the journaling region &gt;= <code><em>cacheStorageJournalSize</em></code>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000175">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html" title="A class that represents error Result values (fs: Not enough free space to create cache storage....">ResultUsableSpaceNotEnoughForCacheStorage</a></b> Not enough free space. </p>
</dd></dl>

</div>
</div>
<a id="af995ec08995ebe685afd6c13a648a692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af995ec08995ebe685afd6c13a648a692">&#9670;&nbsp;</a></span>GetCacheStorageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetCacheStorageSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outCacheStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outCacheStorageJournalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cache storage size for the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageSize</td><td>Cache storage size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageJournalSize</td><td>The size of the journaling region of the cache storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the cache storage to get the size for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>There is a cache storage for the specified index.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000176">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>

</div>
</div>
<a id="adf2bd15a53fcc2a6c8895de9c264ab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2bd15a53fcc2a6c8895de9c264ab86">&#9670;&nbsp;</a></span>DeleteCacheStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteCacheStorage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the cache storage with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the cache storage to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>There is a cache storage for the specified index.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000177">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The specified cache storage is in use. </p>
</dd></dl>

</div>
</div>
<a id="adeabd5e452034e8f7db0d8580952a5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeabd5e452034e8f7db0d8580952a5dd">&#9670;&nbsp;</a></span>OpenCacheStorageList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenCacheStorageList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the cache storage list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Cache storage list handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outValue</em></code> points to valid memory.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000178">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. </dd></dl>

</div>
</div>
<a id="a4d272600ab91d4e735bbb40d8845e938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d272600ab91d4e735bbb40d8845e938">&#9670;&nbsp;</a></span>ReadCacheStorageList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadCacheStorageList </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a> *&#160;</td>
          <td class="paramname"><em>infoBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the cache storage information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Cache storage count. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoBuffer</td><td><code><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html" title="The structure that represents the cache storage information.">CacheStorageInfo</a></code> storage destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Cache storage list handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoBufferCount</td><td>The number of elements in <code><em>infoBuffer</em></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The length of <code><em>infoBuffer</em></code> is at least <code><em>infoBufferCount</em></code>.</li>
<li><code><em>infoBufferCount</em></code> &gt;= <code>0</code></li>
<li><code><em>handle</em></code> is a valid handle.</li>
<li><code><em>outValue</em></code> points to valid memory.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000179">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<p> <b>Details</b> <br  />
 Stores a maximum of <code><em>infoBufferCount</em></code> sets of cache storage information in <code><em>infoBuffer</em></code> and sends the number of stored sets of information to <code><em>outValue</em></code>. Any additional values in <code><em>infoBuffer</em></code> beyond the number indicated by <code><em>outValue</em></code> are undefined. </p>

</div>
</div>
<a id="a92c1f6d8788be687eb914f53f723fba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c1f6d8788be687eb914f53f723fba7">&#9670;&nbsp;</a></span>CloseCacheStorageList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseCacheStorageList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the cache storage list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Cache storage list handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>handle</em></code> is a valid handle.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ae5f48fe542ce22263e1399e3b50190e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f48fe542ce22263e1399e3b50190e8">&#9670;&nbsp;</a></span>EnsureSaveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::EnsureSaveData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates save data. </p>
<p> <b>Details</b> <br  />
 Creates user account save data linked to the specified <code><em>user</em></code>, and other save data needed by the application. If the save data already exists, the function returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></code> without doing anything. User account save data is not created for any user account other than that linked to the specified <code><em>user</em></code>. If there is insufficient space, displays a UI for allocating space or the error viewer applet. For more information, see the <code>fs</code> library <a href="../../Package/contents/Pages/Page_107320205.html">Save Data</a> documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000180">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The specified save data is in use.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The account system library has been initialized by <code><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="Begins using the account system.">nn::account::Initialize()</a></code>.</li>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li>The user account specified by <code><em>user</em></code> exists. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a41">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a19">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, and <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a10">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afdbda9f24e47b02bb74da4558bbd0760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbda9f24e47b02bb74da4558bbd0760">&#9670;&nbsp;</a></span>MountSaveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts save data after specifying a user. </p>
<p> <b>Details</b> <br  />
 This function mounts save data for a specified user with a mount name of <code><em>name</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000181">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The specified save data is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/UserAccountSaveDataSize</code> is set to a valid value greater than <code>0</code>.</li>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/UserAccountSaveDataJournalSize</code> is set to a valid value greater than <code>0</code>.</li>
<li>The target save data exists.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ec_consumable_service_item_manager_2_ec_consumable_service_item_manager_8cpp-example.html#a42">EcConsumableServiceItemManager/EcConsumableServiceItemManager.cpp</a>, <a class="el" href="_fs_file_data_cache_2_fs_individual_file_data_cache_2_fs_individual_file_data_cache_8cpp-example.html#a21">FsFileDataCache/FsIndividualFileDataCache/FsIndividualFileDataCache.cpp</a>, <a class="el" href="_fs_save_data_ensured_by_application_2_fs_save_data_ensured_by_application_8cpp-example.html#a12">FsSaveDataEnsuredByApplication/FsSaveDataEnsuredByApplication.cpp</a>, and <a class="el" href="_fs_save_data_ensured_by_system_2_fs_save_data_ensured_by_system_8cpp-example.html#a12">FsSaveDataEnsuredBySystem/FsSaveDataEnsuredBySystem.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="adf5b846d93790ec79b2d6fee53e97db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5b846d93790ec79b2d6fee53e97db9">&#9670;&nbsp;</a></span>MountSaveDataReadOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveDataReadOnly </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a>&#160;</td>
          <td class="paramname"><em>applicationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts save data as read-only for an application that corresponds to the application ID after specifying a user. </p>
<p> <b>Details</b> <br  />
 Mounts the save data that corresponds to the specified application ID and user as read-only, using the <code><em>name</em></code> mount name. Exits when writing to the mounted save data. Contact Nintendo if you need to mount in a writable state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the mount point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">applicationId</td><td>Target application ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000182">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="interdd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="A class that represents error Result values (fs: Target is locked.).">ResultTargetLocked</a></b> The specified save data is in use. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="A class that represents error Result values (fs: The mount name already exists, or is already mounted...">ResultMountNameAlreadyExists</a></b> The file system represented by <code><em>name</em></code> already exists.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>If the specified application ID is for another application, the elements <code>Id = applicationId</code> and <code>Accessibility = Read</code> are described in <code>NintendoSdkMeta/Core/FsAccessControlData/SaveDataOwnerIds</code> in the NMETA file.</li>
<li>The target save data exists.</li>
<li><code><em>name</em></code> is a <a class="el" href="namespacenn_1_1fs.html#mount_name">valid mount name </a> .</li>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li>Does not exceed the maximum number of file systems that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7ed0c325479ee3b3fd508ed3696394f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed0c325479ee3b3fd508ed3696394f2">&#9670;&nbsp;</a></span>IsSaveDataExisting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::IsSaveDataExisting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified user account save data exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if it exists.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a28b9a47a0c5c176a39f0cf240a91f31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b9a47a0c5c176a39f0cf240a91f31c">&#9670;&nbsp;</a></span>IsSaveDataExisting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::IsSaveDataExisting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a>&#160;</td>
          <td class="paramname"><em>applicationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether user account save data that corresponds to the specified application ID exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">applicationId</td><td>Target application ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if it exists.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The number of mounted file systems is less than the maximum number that can be mounted at the same time, as described in <a class="el" href="namespacenn_1_1fs.html#supported_filesystem">Supported File Systems </a> . </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af00da1e7839368723e5196b1a5b12e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00da1e7839368723e5196b1a5b12e53">&#9670;&nbsp;</a></span>GetSaveDataSizeMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::GetSaveDataSizeMax </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataSizeMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataJournalSizeMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum expansion size of the save data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataSizeMax</td><td>Maximum expansion size of the save data's data save area (value of <code>NintendoSdkMeta/Application/UserAccountSaveDataSizeMax</code> in the NMETA file). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataJournalSizeMax</td><td>Maximum expansion size of the save data journaling area (value of <code>NintendoSdkMeta/Application/UserAccountSaveDataJournalSizeMax</code> in the NMETA file).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outSaveDataSizeMax</em></code> indicates valid memory.</li>
<li><code><em>outSaveDataJournalSizeMax</em></code> indicates valid memory.</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 Gets the maximum expansion size of the data save area and journaling area, of the user account save data, that can be specified by <code><a class="el" href="namespacenn_1_1fs.html#ab83b2cf5e8413aa2833c8df5d2771bf9" title="Extends the save data.">nn::fs::ExtendSaveData()</a></code> Gets <code>0</code> if no maximum expansion size is specified in the NMETA file.</p>
<div class="platform_section" data-platform="Windows"> <b>Windows</b> Platform Only: <br  />
 In the Windows environment, gets the fixed value (maximum variable value).</div><div class="platform_section" data-platform="Windows"></div> 
</div>
</div>
<a id="ab83b2cf5e8413aa2833c8df5d2771bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83b2cf5e8413aa2833c8df5d2771bf9">&#9670;&nbsp;</a></span>ExtendSaveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ExtendSaveData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataJournalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the save data. </p>
<p> <b>Details</b> <br  />
 Extends the size of the user account save data linked to <code><em>user</em></code>. If an extension is not necessary, the function returns <code><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></code> without doing anything. If there is insufficient space, displays a UI for allocating space or the error viewer applet. For more information, see the <code>fs</code> library <a href="../../Package/contents/Pages/Page_107320205.html">Save Data</a> documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataSize</td><td>The size of the data storage region for the save data after the extension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataJournalSize</td><td>The size of the journal region for the save data after the extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000183">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="A class that represents error Result values (fs: Not enough free space.).">ResultUsableSpaceNotEnough</a></b> Not enough free space.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/UserAccountSaveDataSizeMax</code> is set to a valid value greater than <code>0</code>.</li>
<li>In the NMETA file, <code>NintendoSdkMeta/Application/UserAccountSaveDataJournalSizeMax</code> is set to a valid value greater than <code>0</code>.</li>
<li>The target save data exists.</li>
<li>The target save data is not mounted.</li>
<li>The target save data has not been extended the maximum number of times.</li>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li><code><em>saveDataSize</em></code> is equal to or less than the value set for <code>NintendoSdkMeta/Application/UserAccountSaveDataSizeMax</code> in the NMETA file.</li>
<li><code><em>saveDataJournalSize</em></code> is equal to or less than the value set for <code>NintendoSdkMeta/Application/UserAccountSaveDataJournalSizeMax</code> in the NMETA file.</li>
<li><code><em>saveDataSize</em></code> and <code><em>saveDataJournalSize</em></code> are both multiples of <code><a class="el" href="namespacenn_1_1fs.html#a5d6cf75ef80840470f80a1a03f54dcfa" title="The unit size that can be specified for the save data extension.">nn::fs::SaveDataExtensionUnitSize</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a92a313238d8b1826e81fe12bad80f82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a313238d8b1826e81fe12bad80f82f">&#9670;&nbsp;</a></span>GetSaveDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetSaveDataSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataJournalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current size of the save data. </p>
<p> <b>Details</b> <br  />
 Gets the size of the data storage region and the journal region for the user account save data linked to <code><em>user</em></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataSize</td><td>The size of the data storage region for the save data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataJournalSize</td><td>The size of the journal region for the save data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>The UID indicating the target user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000184">Return Values:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outSaveDataSize</em></code> points to valid memory.</li>
<li><code><em>outSaveDataJournalSize</em></code> points to valid memory.</li>
<li><code>static_cast&lt;bool&gt;(<em>user</em>)</code> == <code>true</code>.</li>
<li>The target save data exists. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a329828b4375a88fa6567f6a74f207fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329828b4375a88fa6567f6a74f207fac">&#9670;&nbsp;</a></span>GetFileTimeStampForDebug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetFileTimeStampForDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>outTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the timestamp of the file in the target path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outTimeStamp</td><td>The file's timestamp. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation. <br  />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000185">Return Values:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Represents a successful Result.">ResultSuccess</a></b> Succeeded. <br  />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="A class that represents error Result values (fs: Cannot find the target in the specified path....">ResultPathNotFound</a></b> The target entry does not exist.</p>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code><em>outTimeStamp</em></code> points to valid memory.</li>
<li><code><em>path</em></code> is a <a class="el" href="namespacenn_1_1fs.html#entry_path">valid path </a> .</li>
</ul>
</dd></dl>
<p> <b>Details</b> <br  />
 This function can be used only for debugging. If you get the timestamp for an open file, the timestamp might not be updated when the file is accessed.</p>
<div class="platform_section" data-platform="NX"> <b>NX</b> Platform Only: <br  />
 It can be used with the host file system for NX Add-On 3.1.0 and later. The timestamp specification depends on the host PC environment. With NX Add-On 4.1.0 and later, you can use the function with the SD card file system. For more information, see the Fs Library <a href="../../Package/contents/Pages/Page_112886110.html">SD Card</a> documentation. You cannot use this function with any file systems other than the preceding ones.</div><div class="platform_section" data-platform="NX"></div> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5bc5a4754186c3d3e0af88ad84db2095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc5a4754186c3d3e0af88ad84db2095">&#9670;&nbsp;</a></span>EntryNameLengthMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int nn::fs::EntryNameLengthMax = 768</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum length (in bytes) of the name of an entry in the file system. </p>
<p>This does not include the terminating null character.</p>
<p> <b>Details</b> <br  />
 Maximum entry name length is restricted by the file system and runtime environment. For more information, see <a class="el" href="namespacenn_1_1fs.html#path_and_entry_max_length">Path and Entry Max Length </a> . </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_ui2d_viewer_simple_2main_8cpp-example.html#a47">Ui2dViewerSimple/main.cpp</a>, <a class="el" href="_unit_test_with_googletest_2_unit_test_with_googletest_8cpp-example.html#a2">UnitTestWithGoogletest/UnitTestWithGoogletest.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a18">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a4">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a2">VfxManualEmitterSet/main.cpp</a>, and <a class="el" href="_vfx_simple_2main_8cpp-example.html#a18">VfxSimple/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5765422e17f81856298a59f759cc2a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5765422e17f81856298a59f759cc2a8c">&#9670;&nbsp;</a></span>PathSizeMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int nn::fs::PathSizeMax = 768</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum path length, in bytes. </p>
<p>This does not include the terminating null character.</p>
<p> <b>Details</b> <br  />
 The maximum path length is restricted by the file system and runtime environment. For more information, see <a class="el" href="namespacenn_1_1fs.html#path_and_entry_max_length">Path and Entry Max Length </a> . </p>

</div>
</div>
<a id="a5b9d2fc668ed4c867c52e62103bf57b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9d2fc668ed4c867c52e62103bf57b8">&#9670;&nbsp;</a></span>MountNameLengthMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const int nn::fs::MountNameLengthMax = 15</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size (in bytes) of the name that can be specified when mounting a resource. </p>
<p>This does not include the terminating null character. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
