<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvn::Device Class Reference | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_device.html">Device</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnvn_1_1_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvn::Device Class Reference<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API class used to represent a specific GPU/device.  
 <a href="classnvn_1_1_device.html#details">More...</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02562438c161015a28a045ac7fbb2930"><td class="memItemLeft" align="right" valign="top"><a id="a02562438c161015a28a045ac7fbb2930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930">Finalize</a> ()</td></tr>
<tr class="memdesc:a02562438c161015a28a045ac7fbb2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object. <br /></td></tr>
<tr class="separator:a02562438c161015a28a045ac7fbb2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61010691331b790d583d62686eb0ef35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35">FinalizeCommandHandle</a> (<a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> handles)</td></tr>
<tr class="memdesc:a61010691331b790d583d62686eb0ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a command handle.  <a href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35">More...</a><br /></td></tr>
<tr class="separator:a61010691331b790d583d62686eb0ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e3e5dbe332486255a99e42cd232d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69">GenerateDebugDomainId</a> (const char *name) const</td></tr>
<tr class="memdesc:a69e3e5dbe332486255a99e42cd232d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a unique ID by atomically incrementing a global counter on each request.  <a href="classnvn_1_1_device.html#a69e3e5dbe332486255a99e42cd232d69">More...</a><br /></td></tr>
<tr class="separator:a69e3e5dbe332486255a99e42cd232d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7eb10400a4c93d173dc280d1e3536f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#afc7eb10400a4c93d173dc280d1e3536f">GetCurrentTimestampInNanoseconds</a> () const</td></tr>
<tr class="memdesc:afc7eb10400a4c93d173dc280d1e3536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp from the device, without queuing like the ReportCounter functions.  <a href="classnvn_1_1_device.html#afc7eb10400a4c93d173dc280d1e3536f">More...</a><br /></td></tr>
<tr class="separator:afc7eb10400a4c93d173dc280d1e3536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729521dc2ff483516ce4b2c2ea6104d4"><td class="memItemLeft" align="right" valign="top"><a id="a729521dc2ff483516ce4b2c2ea6104d4"></a>
<a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a729521dc2ff483516ce4b2c2ea6104d4">GetDepthMode</a> () const</td></tr>
<tr class="memdesc:a729521dc2ff483516ce4b2c2ea6104d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device. <br /></td></tr>
<tr class="separator:a729521dc2ff483516ce4b2c2ea6104d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb4449bdf78ef1c6f27f915cdbed775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a5eb4449bdf78ef1c6f27f915cdbed775">GetDepthMode_fastpath</a> () const</td></tr>
<tr class="memdesc:a5eb4449bdf78ef1c6f27f915cdbed775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device.  <a href="classnvn_1_1_device.html#a5eb4449bdf78ef1c6f27f915cdbed775">More...</a><br /></td></tr>
<tr class="separator:a5eb4449bdf78ef1c6f27f915cdbed775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1c4bf2070f7657bea6caf219556836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a9e1c4bf2070f7657bea6caf219556836">GetImageHandle</a> (int imageID) const</td></tr>
<tr class="memdesc:a9e1c4bf2070f7657bea6caf219556836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to use for image loads and stores to a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object.  <a href="classnvn_1_1_device.html#a9e1c4bf2070f7657bea6caf219556836">More...</a><br /></td></tr>
<tr class="separator:a9e1c4bf2070f7657bea6caf219556836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7f1b1a14adb645b1dde270a8bc7d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c">GetInteger</a> (<a class="el" href="structnvn_1_1_device_info.html">DeviceInfo</a> pname, int *v) const</td></tr>
<tr class="memdesc:a0f7f1b1a14adb645b1dde270a8bc7d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query properties of a device.  <a href="classnvn_1_1_device.html#a0f7f1b1a14adb645b1dde270a8bc7d6c">More...</a><br /></td></tr>
<tr class="separator:a0f7f1b1a14adb645b1dde270a8bc7d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2badd327c2e74493127bc13f004ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__funcptrs.html#gadea6f5a69c8fd9e20a3c0b4cedde14c4">GenericFuncPtrFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a2e2badd327c2e74493127bc13f004ae6">GetProcAddress</a> (const char *name) const</td></tr>
<tr class="memdesc:a2e2badd327c2e74493127bc13f004ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a function pointer for a specified C interface entry point for a device.  <a href="classnvn_1_1_device.html#a2e2badd327c2e74493127bc13f004ae6">More...</a><br /></td></tr>
<tr class="separator:a2e2badd327c2e74493127bc13f004ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27ddc3288d516169a135a2bfc64536d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#af27ddc3288d516169a135a2bfc64536d">GetSeparateSamplerHandle</a> (int samplerID) const</td></tr>
<tr class="memdesc:af27ddc3288d516169a135a2bfc64536d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object.  <a href="classnvn_1_1_device.html#af27ddc3288d516169a135a2bfc64536d">More...</a><br /></td></tr>
<tr class="separator:af27ddc3288d516169a135a2bfc64536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7522a850ed7058114a6681dfaae07994"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a7522a850ed7058114a6681dfaae07994">getSeparateSamplerHandle</a> (int samplerID) const NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:a7522a850ed7058114a6681dfaae07994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object.  <a href="classnvn_1_1_device.html#a7522a850ed7058114a6681dfaae07994">More...</a><br /></td></tr>
<tr class="separator:a7522a850ed7058114a6681dfaae07994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e764abad3e6e33d4cd0c5e352f4bcd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a7e764abad3e6e33d4cd0c5e352f4bcd9">GetSeparateTextureHandle</a> (int textureID) const</td></tr>
<tr class="memdesc:a7e764abad3e6e33d4cd0c5e352f4bcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object.  <a href="classnvn_1_1_device.html#a7e764abad3e6e33d4cd0c5e352f4bcd9">More...</a><br /></td></tr>
<tr class="separator:a7e764abad3e6e33d4cd0c5e352f4bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79589e14ce5376baa5acb751db41950a"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a79589e14ce5376baa5acb751db41950a">getSeparateTextureHandle</a> (int textureID) const NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:a79589e14ce5376baa5acb751db41950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object.  <a href="classnvn_1_1_device.html#a79589e14ce5376baa5acb751db41950a">More...</a><br /></td></tr>
<tr class="separator:a79589e14ce5376baa5acb751db41950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6983ea4efc5026a583c6df1aeced9fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a6983ea4efc5026a583c6df1aeced9fe0">GetTexelFetchHandle</a> (int textureID) const</td></tr>
<tr class="memdesc:a6983ea4efc5026a583c6df1aeced9fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object for use in texel fetches.  <a href="classnvn_1_1_device.html#a6983ea4efc5026a583c6df1aeced9fe0">More...</a><br /></td></tr>
<tr class="separator:a6983ea4efc5026a583c6df1aeced9fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1c52b97f2667307df5e299c637fa41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a8d1c52b97f2667307df5e299c637fa41">GetTextureHandle</a> (int textureID, int samplerID) const</td></tr>
<tr class="memdesc:a8d1c52b97f2667307df5e299c637fa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a combined pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects.  <a href="classnvn_1_1_device.html#a8d1c52b97f2667307df5e299c637fa41">More...</a><br /></td></tr>
<tr class="separator:a8d1c52b97f2667307df5e299c637fa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac270fbaf6eb5c0fa2ddea450eb743853"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ac270fbaf6eb5c0fa2ddea450eb743853">GetTimestampInNanoseconds</a> (const <a class="el" href="structnvn_1_1_counter_data.html">CounterData</a> *counterData) const</td></tr>
<tr class="memdesc:ac270fbaf6eb5c0fa2ddea450eb743853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds.  <a href="classnvn_1_1_device.html#ac270fbaf6eb5c0fa2ddea450eb743853">More...</a><br /></td></tr>
<tr class="separator:ac270fbaf6eb5c0fa2ddea450eb743853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d8918ab718054ff724bf25772c28e"><td class="memItemLeft" align="right" valign="top"><a id="a567d8918ab718054ff724bf25772c28e"></a>
<a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a567d8918ab718054ff724bf25772c28e">GetWindowOriginMode</a> () const</td></tr>
<tr class="memdesc:a567d8918ab718054ff724bf25772c28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device. <br /></td></tr>
<tr class="separator:a567d8918ab718054ff724bf25772c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e56b8a6b367fcb7f11621826085521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a56e56b8a6b367fcb7f11621826085521">GetWindowOriginMode_fastpath</a> () const</td></tr>
<tr class="memdesc:a56e56b8a6b367fcb7f11621826085521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device.  <a href="classnvn_1_1_device.html#a56e56b8a6b367fcb7f11621826085521">More...</a><br /></td></tr>
<tr class="separator:a56e56b8a6b367fcb7f11621826085521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf52158b706accb2295c006c86f9c446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446">Initialize</a> (const <a class="el" href="classnvn_1_1_device_builder.html">DeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:abf52158b706accb2295c006c86f9c446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object from a device builder.  <a href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446">More...</a><br /></td></tr>
<tr class="separator:abf52158b706accb2295c006c86f9c446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6e83411cc5edbc861c58f9c34dbb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77">InstallDebugCallback</a> (const <a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">DebugCallbackFunc</a> callback, void *callbackData, <a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:abf6e83411cc5edbc861c58f9c34dbb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install or remove a callback function to be called whenever the debug layer generates a message.  <a href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77">More...</a><br /></td></tr>
<tr class="separator:abf6e83411cc5edbc861c58f9c34dbb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629ebb7e66ba37d3794352d3ec4caf6"><td class="memItemLeft" align="right" valign="top"><a id="ac629ebb7e66ba37d3794352d3ec4caf6"></a>
<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ac629ebb7e66ba37d3794352d3ec4caf6">IsExternalDebuggerAttached</a> () const</td></tr>
<tr class="memdesc:ac629ebb7e66ba37d3794352d3ec4caf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an external debugger is attached when running an NVN application. <br /></td></tr>
<tr class="separator:ac629ebb7e66ba37d3794352d3ec4caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e79b4293d108d8dc311840bfb3cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a738e79b4293d108d8dc311840bfb3cd8">RegisterFastClearColor</a> (const float *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a738e79b4293d108d8dc311840bfb3cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear color value.  <a href="classnvn_1_1_device.html#a738e79b4293d108d8dc311840bfb3cd8">More...</a><br /></td></tr>
<tr class="separator:a738e79b4293d108d8dc311840bfb3cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a13ad1a88a3be2802f1ff0b91fe681d40">RegisterFastClearColori</a> (const int *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signed integer fast clear color value.  <a href="classnvn_1_1_device.html#a13ad1a88a3be2802f1ff0b91fe681d40">More...</a><br /></td></tr>
<tr class="separator:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ddbeb91f3c434ec521ecee88b7221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a156ddbeb91f3c434ec521ecee88b7221">RegisterFastClearColorui</a> (const uint32_t *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a156ddbeb91f3c434ec521ecee88b7221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unsigned integer fast clear color value.  <a href="classnvn_1_1_device.html#a156ddbeb91f3c434ec521ecee88b7221">More...</a><br /></td></tr>
<tr class="separator:a156ddbeb91f3c434ec521ecee88b7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c6011bf315852aebffc88f052fee23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#aa3c6011bf315852aebffc88f052fee23">RegisterFastClearDepth</a> (float depth)</td></tr>
<tr class="memdesc:aa3c6011bf315852aebffc88f052fee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear depth value.  <a href="classnvn_1_1_device.html#aa3c6011bf315852aebffc88f052fee23">More...</a><br /></td></tr>
<tr class="separator:aa3c6011bf315852aebffc88f052fee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dce30d998836c084565626acab5d4bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a2dce30d998836c084565626acab5d4bf">SetAutomaticCheckpointsByDebugGroup</a> (uint32_t domainId, const char *debugGroupName)</td></tr>
<tr class="memdesc:a2dce30d998836c084565626acab5d4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control automatic checkpoint event markers by debug group.  <a href="classnvn_1_1_device.html#a2dce30d998836c084565626acab5d4bf">More...</a><br /></td></tr>
<tr class="separator:a2dce30d998836c084565626acab5d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f953a0c82977cf4a303ef0e22b6a8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a83f953a0c82977cf4a303ef0e22b6a8a">SetAutomaticCheckpointsEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:a83f953a0c82977cf4a303ef0e22b6a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control automatic checkpoint event markers.  <a href="classnvn_1_1_device.html#a83f953a0c82977cf4a303ef0e22b6a8a">More...</a><br /></td></tr>
<tr class="separator:a83f953a0c82977cf4a303ef0e22b6a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac329ed3baeb7ab1e42838a4c1e25d51e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ac329ed3baeb7ab1e42838a4c1e25d51e">SetAutomaticCheckpointsMask</a> (<a class="el" href="structnvn_1_1_automatic_checkpoints_mask.html">AutomaticCheckpointsMask</a> mask)</td></tr>
<tr class="memdesc:ac329ed3baeb7ab1e42838a4c1e25d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control for which commands automatic checkpoint event markers are added.  <a href="classnvn_1_1_device.html#ac329ed3baeb7ab1e42838a4c1e25d51e">More...</a><br /></td></tr>
<tr class="separator:ac329ed3baeb7ab1e42838a4c1e25d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8329f8ab914685b62660ad6f78edde8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ae8329f8ab914685b62660ad6f78edde8">SetAutomaticCheckpointsSamplingInterval</a> (int interval)</td></tr>
<tr class="memdesc:ae8329f8ab914685b62660ad6f78edde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control how frequently automatic checkpoint event markers are inserted.  <a href="classnvn_1_1_device.html#ae8329f8ab914685b62660ad6f78edde8">More...</a><br /></td></tr>
<tr class="separator:ae8329f8ab914685b62660ad6f78edde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86458577a6260fb5fab9f22f2010e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ac86458577a6260fb5fab9f22f2010e0f">SetCheckpointCallStacksEnable</a> (<a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> enable)</td></tr>
<tr class="memdesc:ac86458577a6260fb5fab9f22f2010e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control call stack capture for checkpoint event markers.  <a href="classnvn_1_1_device.html#ac86458577a6260fb5fab9f22f2010e0f">More...</a><br /></td></tr>
<tr class="separator:ac86458577a6260fb5fab9f22f2010e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78937197f9881c6448e21e314da1141e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a78937197f9881c6448e21e314da1141e">SetCheckpointMaxCallStacksDepth</a> (int depth)</td></tr>
<tr class="memdesc:a78937197f9881c6448e21e314da1141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control call stack capture depth for checkpoint event markers.  <a href="classnvn_1_1_device.html#a78937197f9881c6448e21e314da1141e">More...</a><br /></td></tr>
<tr class="separator:a78937197f9881c6448e21e314da1141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814ee872c59196a0a66ccad71f02cd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a814ee872c59196a0a66ccad71f02cd32">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a814ee872c59196a0a66ccad71f02cd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object.  <a href="classnvn_1_1_device.html#a814ee872c59196a0a66ccad71f02cd32">More...</a><br /></td></tr>
<tr class="separator:a814ee872c59196a0a66ccad71f02cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a7a578db399ec77a9ecccc24fd4695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a11a7a578db399ec77a9ecccc24fd4695">SetDepthMode</a> (<a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a> depthMode)</td></tr>
<tr class="memdesc:a11a7a578db399ec77a9ecccc24fd4695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="classnvn_1_1_device.html#a11a7a578db399ec77a9ecccc24fd4695">More...</a><br /></td></tr>
<tr class="separator:a11a7a578db399ec77a9ecccc24fd4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b16c0700df10288ed92ab6730f3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#afb4b16c0700df10288ed92ab6730f3d3">SetDepthMode_fastpath</a> (<a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a> depthMode)</td></tr>
<tr class="memdesc:afb4b16c0700df10288ed92ab6730f3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="classnvn_1_1_device.html#afb4b16c0700df10288ed92ab6730f3d3">More...</a><br /></td></tr>
<tr class="separator:afb4b16c0700df10288ed92ab6730f3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef418dbea511a5d15eee5743b35f8c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#aef418dbea511a5d15eee5743b35f8c4e">SetIntermediateShaderCache</a> (int numMaxEntries)</td></tr>
<tr class="memdesc:aef418dbea511a5d15eee5743b35f8c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the shader cache for the Windows reference platform to store fat binary intermediate results.  <a href="classnvn_1_1_device.html#aef418dbea511a5d15eee5743b35f8c4e">More...</a><br /></td></tr>
<tr class="separator:aef418dbea511a5d15eee5743b35f8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b476ebbecf1ccfe30270b088de497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497">SetWindowOriginMode</a> (<a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:ace9b476ebbecf1ccfe30270b088de497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497">More...</a><br /></td></tr>
<tr class="separator:ace9b476ebbecf1ccfe30270b088de497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a2503d4e94e42d6a800583c27c0205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a72a2503d4e94e42d6a800583c27c0205">SetWindowOriginMode_fastpath</a> (<a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:a72a2503d4e94e42d6a800583c27c0205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="classnvn_1_1_device.html#a72a2503d4e94e42d6a800583c27c0205">More...</a><br /></td></tr>
<tr class="separator:a72a2503d4e94e42d6a800583c27c0205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4e753408a85ba15e96b4aef57534f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#abc4e753408a85ba15e96b4aef57534f6">WalkDebugDatabase</a> (<a class="el" href="structnvn_1_1_debug_object_type.html">DebugObjectType</a> type, <a class="el" href="group__nvn__cpp__funcptrs.html#ga1e02e3cb3d0921116b9c1a54fc99fa3b">WalkDebugDatabaseCallbackFunc</a> callback, void *userParam) const</td></tr>
<tr class="memdesc:abc4e753408a85ba15e96b4aef57534f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk through the debug layer object database.  <a href="classnvn_1_1_device.html#abc4e753408a85ba15e96b4aef57534f6">More...</a><br /></td></tr>
<tr class="separator:abc4e753408a85ba15e96b4aef57534f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>API class used to represent a specific GPU/device. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_nvn_simple_2_nvn_simple_shared_lib_2_graphics_context_8cpp-example.html#_a2">NvnSimple/NvnSimpleSharedLib/GraphicsContext.cpp</a>, <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_context_8h-example.html#_a0">nvnsimple/NvnSimpleSharedLib/GraphicsContext.h</a>, and <a class="el" href="nvnsimple_2_nvn_simple_shared_lib_2_graphics_system_8h-example.html#_a6">nvnsimple/NvnSimpleSharedLib/GraphicsSystem.h</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abf52158b706accb2295c006c86f9c446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf52158b706accb2295c006c86f9c446">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_device_builder.html">DeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object from a device builder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classnvn_1_1_device_builder.html" title="Object specifying state used to construct new device objects.">DeviceBuilder</a> object holding properties of the new <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a814ee872c59196a0a66ccad71f02cd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814ee872c59196a0a66ccad71f02cd32">&#9670;&nbsp;</a></span>SetDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device.">Device</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e2badd327c2e74493127bc13f004ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2badd327c2e74493127bc13f004ae6">&#9670;&nbsp;</a></span>GetProcAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__funcptrs.html#gadea6f5a69c8fd9e20a3c0b4cedde14c4">GenericFuncPtrFunc</a> nvn::Device::GetProcAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a function pointer for a specified C interface entry point for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the C entry point to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7f1b1a14adb645b1dde270a8bc7d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7f1b1a14adb645b1dde270a8bc7d6c">&#9670;&nbsp;</a></span>GetInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::GetInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_device_info.html">DeviceInfo</a>&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query properties of a device. </p>
<dl class="section note"><dt>Note</dt><dd><em>device</em> may be NULL when querying supported API or GPU shader code versions prior to creating a device object. For all other queries, <em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pname</td><td>Property to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Value associated with the property, returned to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc7eb10400a4c93d173dc280d1e3536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7eb10400a4c93d173dc280d1e3536f">&#9670;&nbsp;</a></span>GetCurrentTimestampInNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvn::Device::GetCurrentTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp from the device, without queuing like the ReportCounter functions. </p>
<p>See the <a class="el" href="nvn_index.html#nvn_guide_counters">Counters</a> section of the NVN Programming Guide for more detail.</p>
<dl class="section note"><dt>Note</dt><dd><em>device</em> must point at a valid NVN device object. </dd></dl>

</div>
</div>
<a id="aef418dbea511a5d15eee5743b35f8c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef418dbea511a5d15eee5743b35f8c4e">&#9670;&nbsp;</a></span>SetIntermediateShaderCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetIntermediateShaderCache </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMaxEntries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the shader cache for the Windows reference platform to store fat binary intermediate results. </p>
<p>If the NVN platform is NX, this function does nothing.</p>
<p>On the Windows reference implemenetation, <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">Program::SetShaders</a> will compile machine code that can run on the attached GPU, using intermediate shader code and specialization information stored in the provided control data. If the same shader is compiled with different specialization information (via glslcCompileSpecialized) using this cache can avoid re-processing the same shader code on each call to <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders.">Program::SetShaders</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numMaxEntries</td><td>Maximum number of entries that the intermediate shader cache can hold. If this is 0, the cache will be disabled and any previous cache resources will be cleaned up. If a non-zero value is used, the cache will hold intermediate code for up to <em>numMaxEntries</em> unique shaders. Programs containing multiple shader stages will consume multiple entries in this cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1c52b97f2667307df5e299c637fa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1c52b97f2667307df5e299c637fa41">&#9670;&nbsp;</a></span>GetTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> nvn::Device::GetTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a combined pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>).</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver.">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6983ea4efc5026a583c6df1aeced9fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6983ea4efc5026a583c6df1aeced9fe0">&#9670;&nbsp;</a></span>GetTexelFetchHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> nvn::Device::GetTexelFetchHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object for use in texel fetches. </p>
<p>A handle produced by this entry point can be used for texel fetches via the texelFetch() GLSL built-in function. Using such handles in texture lookups will use undefined sampler state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e1c4bf2070f7657bea6caf219556836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1c4bf2070f7657bea6caf219556836">&#9670;&nbsp;</a></span>GetImageHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> nvn::Device::GetImageHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imageID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to use for image loads and stores to a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageID</td><td>Registered image ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6e83411cc5edbc861c58f9c34dbb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6e83411cc5edbc861c58f9c34dbb77">&#9670;&nbsp;</a></span>InstallDebugCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::InstallDebugCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__funcptrs.html#gac29ab0f1c39a8a2e75f59f0726263ab2">DebugCallbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install or remove a callback function to be called whenever the debug layer generates a message. </p>
<p>Multiple callback functions (each with separate callback data) are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Pointer to a callback function to call.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Pointer to arbitrary data to pass in each call to the callback function.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the specified callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e3e5dbe332486255a99e42cd232d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e3e5dbe332486255a99e42cd232d69">&#9670;&nbsp;</a></span>GenerateDebugDomainId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a> nvn::Device::GenerateDebugDomainId </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a unique ID by atomically incrementing a global counter on each request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to associate to new domain id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace9b476ebbecf1ccfe30270b088de497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9b476ebbecf1ccfe30270b088de497">&#9670;&nbsp;</a></span>SetWindowOriginMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Applications should set the window origin mode in the device before creating any queues, command buffers, or windows, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, (c) set when creating the queue used to submit rendering commands, (d) set when creating the window used to display rendered frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72a2503d4e94e42d6a800583c27c0205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a2503d4e94e42d6a800583c27c0205">&#9670;&nbsp;</a></span>SetWindowOriginMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetWindowOriginMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Fastpath variant.</p>
<p>Applications should set the window origin mode in the device before creating any queues, command buffers, or windows, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, (c) set when creating the queue used to submit rendering commands, (d) set when creating the window used to display rendered frames.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497" title="Set the global location for window coordinates (0,0).">Device::SetWindowOriginMode</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a7a578db399ec77a9ecccc24fd4695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a7a578db399ec77a9ecccc24fd4695">&#9670;&nbsp;</a></span>SetDepthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetDepthMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb4b16c0700df10288ed92ab6730f3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4b16c0700df10288ed92ab6730f3d3">&#9670;&nbsp;</a></span>SetDepthMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetDepthMode_fastpath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Fastpath variant.</p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_device.html#a11a7a578db399ec77a9ecccc24fd4695" title="Set the global clipping range for normalized depth in clip space.">Device::SetDepthMode</a>, but should be faster in common cases. Not compatible with the NVN debug layer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a738e79b4293d108d8dc311840bfb3cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738e79b4293d108d8dc311840bfb3cd8">&#9670;&nbsp;</a></span>RegisterFastClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::RegisterFastClearColor </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and floating-point or normalized components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ad1a88a3be2802f1ff0b91fe681d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad1a88a3be2802f1ff0b91fe681d40">&#9670;&nbsp;</a></span>RegisterFastClearColori()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::RegisterFastClearColori </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signed integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and signed integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a156ddbeb91f3c434ec521ecee88b7221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156ddbeb91f3c434ec521ecee88b7221">&#9670;&nbsp;</a></span>RegisterFastClearColorui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::RegisterFastClearColorui </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unsigned integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and unsigned integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3c6011bf315852aebffc88f052fee23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c6011bf315852aebffc88f052fee23">&#9670;&nbsp;</a></span>RegisterFastClearDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::RegisterFastClearDepth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear depth value. </p>
<p>Applications can register specific clear values that it expects to use for future depth buffer clears. Clearing the depth buffer using one of these registered clear depth values will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is finite. If a clear value can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned. </p><dl class="section note"><dt>Note</dt><dd>16-bit depth textures (<a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component.">Format::DEPTH16</a>) have limited support for fast clears. See documentation on <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea53256b41d86cf0e10c4aaa29c206a331" title="Favor fast clear over depth compression for DEPTH16 depth textures.">TextureFlags::DEPTH16_PREFER_FAST_CLEAR</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Depth value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56e56b8a6b367fcb7f11621826085521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e56b8a6b367fcb7f11621826085521">&#9670;&nbsp;</a></span>GetWindowOriginMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a> nvn::Device::GetWindowOriginMode_fastpath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the window origin mode for a device. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_device.html#a567d8918ab718054ff724bf25772c28e" title="Query the window origin mode for a device.">Device::GetWindowOriginMode</a>, but should be faster in common cases. Not compatible with the NVN debug layer. </dd></dl>

</div>
</div>
<a id="a5eb4449bdf78ef1c6f27f915cdbed775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb4449bdf78ef1c6f27f915cdbed775">&#9670;&nbsp;</a></span>GetDepthMode_fastpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a> nvn::Device::GetDepthMode_fastpath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth mode for a device. </p>
<p>Fastpath variant.</p>
<dl class="section note"><dt>Note</dt><dd>: This is functionally equivalent to <a class="el" href="classnvn_1_1_device.html#a729521dc2ff483516ce4b2c2ea6104d4" title="Query the depth mode for a device.">Device::GetDepthMode</a>, but should be faster in common cases. Not compatible with the NVN debug layer. </dd></dl>

</div>
</div>
<a id="ac270fbaf6eb5c0fa2ddea450eb743853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac270fbaf6eb5c0fa2ddea450eb743853">&#9670;&nbsp;</a></span>GetTimestampInNanoseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvn::Device::GetTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_counter_data.html">CounterData</a> *&#160;</td>
          <td class="paramname"><em>counterData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counterData</td><td>Pointer to a full <a class="el" href="structnvn_1_1_counter_data.html" title="Data structure describing how counter values are written to buffer memory.">CounterData</a> structure containing the timestamp value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61010691331b790d583d62686eb0ef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61010691331b790d583d62686eb0ef35">&#9670;&nbsp;</a></span>FinalizeCommandHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::FinalizeCommandHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a>&#160;</td>
          <td class="paramname"><em>handles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a command handle. </p>
<p>This command can be used to free any memory associated with a command handle that may have been allocated by the debug layer or other developer tools that track the contents of a command set. If command handles are not explicitly finalized, associated memory will be freed only when the command or control memory associated with the command set is freed or reused. The control memory has a tracking token used to implicit cleanup the memory later even if the application does not call finalize. Overwriting the command set memory before calling FinalizeCommandHandle or implicit clean can corrupt the tracking token and may result in memory leaks. This command has no effect if the debug layer and other developer tools are disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>Command handle to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc4e753408a85ba15e96b4aef57534f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4e753408a85ba15e96b4aef57534f6">&#9670;&nbsp;</a></span>WalkDebugDatabase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::WalkDebugDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_debug_object_type.html">DebugObjectType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__funcptrs.html#ga1e02e3cb3d0921116b9c1a54fc99fa3b">WalkDebugDatabaseCallbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk through the debug layer object database. </p>
<p>Debug layer must be enabled.</p>
<p>Reports the debug layer's list of objects of the given type through the callback function. At least Level 1 debug layer must be enabled, as object tracking is not done at debug layer level 0. See <a class="el" href="nvn_index.html#nvn_guide_api_object_tracking">API Object Tracking</a> for detail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Type of objects to walk through.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Callback function to be called for every object matching the given device and object type.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Value to be passed to the callback holding a 'user pointer' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e764abad3e6e33d4cd0c5e352f4bcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e764abad3e6e33d4cd0c5e352f4bcd9">&#9670;&nbsp;</a></span>GetSeparateTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> nvn::Device::GetSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79589e14ce5376baa5acb751db41950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79589e14ce5376baa5acb751db41950a">&#9670;&nbsp;</a></span>getSeparateTextureHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> nvn::Device::getSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_device.html#a7e764abad3e6e33d4cd0c5e352f4bcd9" title="Get a handle for a separate Texture object.">Device::GetSeparateTextureHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data.">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage.">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27ddc3288d516169a135a2bfc64536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27ddc3288d516169a135a2bfc64536d">&#9670;&nbsp;</a></span>GetSeparateSamplerHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> nvn::Device::GetSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver.">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7522a850ed7058114a6681dfaae07994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7522a850ed7058114a6681dfaae07994">&#9670;&nbsp;</a></span>getSeparateSamplerHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> nvn::Device::getSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_device.html#af27ddc3288d516169a135a2bfc64536d" title="Get a handle for a separate Sampler object.">Device::GetSeparateSamplerHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered.">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver.">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83f953a0c82977cf4a303ef0e22b6a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f953a0c82977cf4a303ef0e22b6a8a">&#9670;&nbsp;</a></span>SetAutomaticCheckpointsEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetAutomaticCheckpointsEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control automatic checkpoint event markers. </p>
<p>If automatic checkpoint event markers are enabled, a checkpoint marker is added automatically for draw, dispatch, or copy commands recorded into a command set. In the case of a GPU crash, the checkpoint event markers that were last processed by the GPU will be included in NVN Aftermath crash dumps to aid in narrowing down the command that has led to the crash. If automatic checkpoints are sucessfully enabled, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when enabling automatic checkpoints, NVN_FALSE is returned and the currently set state remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable automatic checkpoint event markers if true; disable if false. Automatic checkpoint event markers are disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac329ed3baeb7ab1e42838a4c1e25d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac329ed3baeb7ab1e42838a4c1e25d51e">&#9670;&nbsp;</a></span>SetAutomaticCheckpointsMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetAutomaticCheckpointsMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_automatic_checkpoints_mask.html">AutomaticCheckpointsMask</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control for which commands automatic checkpoint event markers are added. </p>
<p>If automatic checkpoint event markers are enabled, the mask set by this function specifies for which subset of the commands automatic checkpoints are added. If the mask is sucessfully set, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the mask, NVN_FALSE is returned and the currently set state remains unchanged. </p><dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitfield indicating for which commands automatic checkpoints should be added. The default is to add automatic checkpoints for all supported commands. See <a class="el" href="structnvn_1_1_automatic_checkpoints_mask.html" title="Flags controlling automatic checkpoint event marker creation.">nvn::AutomaticCheckpointsMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8329f8ab914685b62660ad6f78edde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8329f8ab914685b62660ad6f78edde8">&#9670;&nbsp;</a></span>SetAutomaticCheckpointsSamplingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetAutomaticCheckpointsSamplingInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control how frequently automatic checkpoint event markers are inserted. </p>
<p>If automatic checkpoint event markers are enabled, this function specifies how frequently they are added. If the sampling interval is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the sampling interval, NVN_FALSE is returned and the currently set sampling interval remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>A value of n will insert a checkpoint marker only on every n-th command. A value of n will insert a checkpoint only on every n-th command. The default value for the sampling interval is 1, which means a checkpoint will be inserted on every draw, dispatch, or copy command. Must be greater than zero. Must be less than or equal to 65535 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da833e52b285897377c08b3ebbeb55afa1" title="Maximum supported length of the event sampling interval for automatic checkpoint event markers.">nvn::DeviceInfo::CHECKPOINT_MAXIMUM_SAMPLING_INTERVAL_LENGTH</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dce30d998836c084565626acab5d4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dce30d998836c084565626acab5d4bf">&#9670;&nbsp;</a></span>SetAutomaticCheckpointsByDebugGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetAutomaticCheckpointsByDebugGroup </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>debugGroupName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control automatic checkpoint event markers by debug group. </p>
<p>Specifies that automatic checkpoint event markers should only be added if the name of the debug group at the top of the selected debug group stack matches the provided debug group name. If the debug group name filter is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the debug group name filter, NVN_FALSE is returned and the currently set debug group name filter remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainId</td><td>Debug domain ID. Selects the debug group stack used for filtering.</td></tr>
    <tr><td class="paramname">debugGroupName</td><td>Name of the debug group for which automatic event markers are inserted. Call with nullptr to disable the filtering by debug group name. The default setting is to apply no filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac86458577a6260fb5fab9f22f2010e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86458577a6260fb5fab9f22f2010e0f">&#9670;&nbsp;</a></span>SetCheckpointCallStacksEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetCheckpointCallStacksEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control call stack capture for checkpoint event markers. </p>
<p>If call stack capture for checkpoint event markers is enabled, the CPU call stack for every function call inserting event markers (user or automatic) is captured and is associated as additional payload with the event marker. In the case of a GPU crash this data is also added into the NVN Aftermath crash dump and can provide additional hints about the origin of the problem. If call stack capture is sucessfully enabled, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when enabling call stack capture, NVN_FALSE is returned and the currently set state remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable or disable call stack capture for checkpoint event markers. Call stack capture is disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78937197f9881c6448e21e314da1141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78937197f9881c6448e21e314da1141e">&#9670;&nbsp;</a></span>SetCheckpointMaxCallStacksDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga645eaacf47907468e5df6be7f9f63352">NVNboolean</a> nvn::Device::SetCheckpointMaxCallStacksDepth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control call stack capture depth for checkpoint event markers. </p>
<p>Specify the maximum captured call stack depth for checkpoint event markers. If the call stack capture depth is set sucessfully, NVN_TRUE is returned. If any of the passed in parameters is invalid or a problem occurs when setting the call stack capture depth, NVN_FALSE is returned and the currently set value remains unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the application is not linked with the NVN Aftermath target library. </dd>
<dd>
Calling this function while a command buffer is being recorded on the device will result in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Maximum depth of call stack capture. The default value for the call stack capture depth is 8 levels. Must be greater than zero. Must be less than or equal to 16 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daedc54fda3bb858227c73887986bfcdee" title="Maximum number of call stack entries that can be captured for checkpoint event markers.">nvn::DeviceInfo::CHECKPOINT_MAXIMUM_CALL_STACK_CAPTURE_DEPTH</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
