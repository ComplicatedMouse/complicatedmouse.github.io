<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NvnTutorial/PBRObject.cpp | NintendoSDK API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<script type="text/javascript" src="searchapi.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   &#160;<span id="projectnumber">14.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NvnTutorial/PBRObject.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>For an explanation of the source code, see <a class="el" href="_page_sample_nvn_tutorial_library.html">NVN Tutorial Library</a> and <tt>NvnTutorial/PBRObject.cpp</tt>.</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_p_b_r_object_8h.html">nvntutorial/PBRObject.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_inline_8h.html">nvn/nvn_FuncPtrInline.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_uniform_buffer_manager_8h.html">nvntutorial/UniformBufferManager.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_asset_file_data_holder_8h.html">nvntutorial/AssetFileDataHolder.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_p_b_r_model_binary_file_headers_8h.html">nvntutorial/PBRModelBinaryFileHeaders.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/DeferredGBufferDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/ShadowMapDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nvntutorial/ShaderHeaders/PointShadowMapDataHelper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_util_8h.html">nvntutorial/TutorialUtil.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PBRObject</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Constants for vertex attribute formats/strides, index type, and primitive type. */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> Mesh::g_IndexTypeNVN = <a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6">NVN_INDEX_TYPE_UNSIGNED_INT</a>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> Mesh::g_DrawPrimitiveTypeNVN = <a class="code" href="group__nvn__c__enum.html#ggab22437710b6816a67a1263d0087ded72a18aa4d68281faa9aaba87e6251ecdc24">NVN_DRAW_PRIMITIVE_TRIANGLES</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> Mesh::g_PositionFormatNVN = <a class="code" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecababeba6c57385cda6b11aee8d9986f26db">NVN_FORMAT_RGB32F</a>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> Mesh::g_NormalFormatNVN = <a class="code" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecababeba6c57385cda6b11aee8d9986f26db">NVN_FORMAT_RGB32F</a>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> Mesh::g_TexCoordFormatNVN = <a class="code" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba282f468096b9b50cba1b5d85adae7bb9">NVN_FORMAT_RG32F</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> uint32_t Mesh::g_PositionStride = 12;</div>
<div class="line"><span class="keyword">const</span> uint32_t Mesh::g_NormalStride = 12;</div>
<div class="line"><span class="keyword">const</span> uint32_t Mesh::g_TexCoordStride = 8;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::SetupMaterialUniformBuffers</span></div>
<div class="line"><span class="comment"> * --------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the uniform buffers of a mesh for a given</span></div>
<div class="line"><span class="comment"> * shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> SetupMaterialUniformBuffers(<span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                                 UniformBufferManager* pUniformBufferManager,</div>
<div class="line">                                 <span class="keyword">const</span> std::map&lt;std::string, AssetFileDataHolder*&gt;&amp; textures,</div>
<div class="line">                                 <span class="keyword">const</span> PBRModelData::MaterialData&amp; material,</div>
<div class="line">                                 std::map&lt;std::string,</div>
<div class="line">                                          std::vector&lt;PBRModelData::UniformBufferData&gt; &gt;&amp; uniforms,</div>
<div class="line">                                 std::map&lt;std::string, int&gt;&amp; specializedIndices,</div>
<div class="line">                                 <span class="keywordtype">int</span> useLod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;DeferredGBuffer&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        uniforms[programName].resize(3);</div>
<div class="line"> </div>
<div class="line">        PBRModelData::UniformBufferData&amp; textureHandle = uniforms[programName][0];</div>
<div class="line">        textureHandle.m_BindingLocation = DeferredGBuffer::TextureHandlesUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        textureHandle.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">        textureHandle.m_Size = <span class="keyword">sizeof</span>(DeferredGBuffer::TextureHandlesUniformBlockData);</div>
<div class="line">        textureHandle.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(textureHandle.m_Size);</div>
<div class="line"> </div>
<div class="line">        PBRModelData::UniformBufferData&amp; materialData = uniforms[programName][1];</div>
<div class="line">        materialData.m_BindingLocation = DeferredGBuffer::MaterialDataUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        materialData.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">        materialData.m_Size = <span class="keyword">sizeof</span>(DeferredGBuffer::MaterialDataUniformBlockData);</div>
<div class="line">        materialData.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(materialData.m_Size);</div>
<div class="line"> </div>
<div class="line">        PBRModelData::UniformBufferData&amp; mapModifiers = uniforms[programName][2];</div>
<div class="line">        mapModifiers.m_BindingLocation = DeferredGBuffer::MapModifiersUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        mapModifiers.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">        mapModifiers.m_Size = <span class="keyword">sizeof</span>(DeferredGBuffer::MapModifiersUniformBlockData);</div>
<div class="line">        mapModifiers.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(mapModifiers.m_Size);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Map the uniform buffers */</span></div>
<div class="line">        DeferredGBuffer::TextureHandlesUniformBlockData* uniformMapTextureHandles = <span class="keyword">reinterpret_cast&lt;</span>DeferredGBuffer::TextureHandlesUniformBlockData*<span class="keyword">&gt;</span>(textureHandle.m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line">        DeferredGBuffer::MaterialDataUniformBlockData* uniformMapMaterialData = <span class="keyword">reinterpret_cast&lt;</span>DeferredGBuffer::MaterialDataUniformBlockData*<span class="keyword">&gt;</span>(materialData.m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line">        DeferredGBuffer::MapModifiersUniformBlockData* uniformMapMapModifiers = <span class="keyword">reinterpret_cast&lt;</span>DeferredGBuffer::MapModifiersUniformBlockData*<span class="keyword">&gt;</span>(mapModifiers.m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Specialized variables. Used to grab the correct shader specialization. */</span></div>
<div class="line">        <span class="keywordtype">int</span> useDiffuseMap = 0;</div>
<div class="line">        <span class="keywordtype">int</span> useSpecularMap = 0;</div>
<div class="line">        <span class="keywordtype">int</span> useRoughnessMap = 0;</div>
<div class="line">        <span class="keywordtype">int</span> useMetallicMap = 0;</div>
<div class="line">        <span class="keywordtype">int</span> useNormalMap = 0;</div>
<div class="line">        <span class="keywordtype">int</span> useAlphaMask = 0;</div>
<div class="line">        <span class="keywordtype">int</span> lit = 1;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for a diffuse map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_DiffuseMap.size())</div>
<div class="line">        {</div>
<div class="line">            useDiffuseMap = 1;</div>
<div class="line"> </div>
<div class="line">            std::string diffuseTexName = material.m_DiffuseMap;</div>
<div class="line">            ExtractFileName(diffuseTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_diffuseMap(textures.at(diffuseTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for a specular map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_SpecularMap.size())</div>
<div class="line">        {</div>
<div class="line">            useSpecularMap = 1;</div>
<div class="line"> </div>
<div class="line">            std::string specularTexName = material.m_SpecularMap;</div>
<div class="line">            ExtractFileName(specularTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_specularMap(textures.at(specularTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for a roughness map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_RoughnessMap.size())</div>
<div class="line">        {</div>
<div class="line">            useRoughnessMap = 1;</div>
<div class="line"> </div>
<div class="line">            std::string roughnessTexName = material.m_RoughnessMap;</div>
<div class="line">            ExtractFileName(roughnessTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_roughnessMap(textures.at(roughnessTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for a metallic map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_MetallicMap.size())</div>
<div class="line">        {</div>
<div class="line">            useMetallicMap = 1;</div>
<div class="line"> </div>
<div class="line">            std::string metallicTexName = material.m_MetallicMap;</div>
<div class="line">            ExtractFileName(metallicTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_metallicMap(textures.at(metallicTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for a normal map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_NormalMap.size())</div>
<div class="line">        {</div>
<div class="line">            useNormalMap = 1;</div>
<div class="line"> </div>
<div class="line">            std::string normalTexName = material.m_NormalMap;</div>
<div class="line">            ExtractFileName(normalTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_normalMap(textures.at(normalTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for an alpha mask */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_AlphaMask.size())</div>
<div class="line">        {</div>
<div class="line">            useAlphaMask = 1;</div>
<div class="line"> </div>
<div class="line">            std::string alphaTexName = material.m_AlphaMask;</div>
<div class="line">            ExtractFileName(alphaTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_alphaMask(textures.at(alphaTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for an emissive map */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_EmissiveMap.size())</div>
<div class="line">        {</div>
<div class="line">            useDiffuseMap = 1;</div>
<div class="line">            lit = 0;</div>
<div class="line"> </div>
<div class="line">            std::string emissiveTexName = material.m_EmissiveMap;</div>
<div class="line">            ExtractFileName(emissiveTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_diffuseMap(textures.at(emissiveTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Objects with an emissive value are counted as unlit */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_Emissive.GetX() != 0.0f &amp;&amp; material.m_Emissive.GetY() != 0.0f &amp;&amp; material.m_Emissive.GetZ() != 0.0f)</div>
<div class="line">        {</div>
<div class="line">            lit = 0;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> diffuseVal[4];</div>
<div class="line">        memset(diffuseVal, 0, <span class="keyword">sizeof</span>(diffuseVal));</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If the object is unlit, use the emissive in place of diffuse */</span></div>
<div class="line">        <span class="keywordflow">if</span> (lit == 1)</div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(diffuseVal, material.m_Diffuse);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(diffuseVal, material.m_Emissive);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        uniformMapMaterialData-&gt;SetUniform_u_diffuse(diffuseVal);</div>
<div class="line"> </div>
<div class="line">        uniformMapMaterialData-&gt;SetUniform_u_specular(material.m_Specular);</div>
<div class="line">        uniformMapMaterialData-&gt;SetUniform_u_roughness(material.m_Roughness);</div>
<div class="line">        uniformMapMaterialData-&gt;SetUniform_u_metallic(material.m_Metallic);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> tempVec2[2];</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (lit == 1)</div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(tempVec2, material.m_DiffuseMapMod);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(tempVec2, material.m_EmissiveMapMod);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_diffuseMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec2, material.m_SpecularMapMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_specularMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec2, material.m_RoughnessMapMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_roughnessMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec2, material.m_MetallicMapMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_metallicMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec2, material.m_NormalMapMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_normalMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec2, material.m_AlphaMapMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_alphaMapMod(tempVec2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> tempVec3[3];</div>
<div class="line">        <span class="keywordflow">if</span> (lit == 1)</div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(tempVec3, material.m_DiffuseValMod);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            nn::util::VectorStore(tempVec3, material.m_EmissiveValMod);</div>
<div class="line">        }</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_diffuseValMod(tempVec3);</div>
<div class="line"> </div>
<div class="line">        nn::util::VectorStore(tempVec3, material.m_NormalValMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_normalValMod(tempVec3);</div>
<div class="line"> </div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_specularValMod(material.m_SpecularValMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_roughnessValMod(material.m_RoughnessValMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_metallicValMod(material.m_MetallicValMod);</div>
<div class="line">        uniformMapMapModifiers-&gt;SetUniform_u_alphaValMod(material.m_AlphaValMod);</div>
<div class="line"> </div>
<div class="line">        uniformMapMaterialData-&gt;SetUniform_u_lit(lit);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the index of the correct shader variation based on which maps are present */</span></div>
<div class="line">        specializedIndices[programName] = DeferredGBuffer::GetVariationIndex(useDiffuseMap, useSpecularMap, useRoughnessMap, useMetallicMap, useNormalMap, useAlphaMask, useLod);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;ShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        uniforms[programName].resize(1);</div>
<div class="line"> </div>
<div class="line">        PBRModelData::UniformBufferData&amp; textureHandles = uniforms[programName][0];</div>
<div class="line">        textureHandles.m_BindingLocation = ShadowMap::TextureHandlesUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        textureHandles.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">        textureHandles.m_Size = <span class="keyword">sizeof</span>(ShadowMap::TextureHandlesUniformBlockData);</div>
<div class="line">        textureHandles.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(textureHandles.m_Size);</div>
<div class="line"> </div>
<div class="line">        ShadowMap::TextureHandlesUniformBlockData* uniformMapTextureHandles = <span class="keyword">reinterpret_cast&lt;</span>ShadowMap::TextureHandlesUniformBlockData*<span class="keyword">&gt;</span>(textureHandles.m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> useAlphaMask = 0;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for an alpha mask */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_AlphaMask.size())</div>
<div class="line">        {</div>
<div class="line">            useAlphaMask = 1;</div>
<div class="line"> </div>
<div class="line">            std::string alphaTexName = material.m_AlphaMask;</div>
<div class="line">            ExtractFileName(alphaTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_alphaMask(textures.at(alphaTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the variation index */</span></div>
<div class="line">        specializedIndices[programName] = ShadowMap::GetVariationIndex(useAlphaMask);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;PointShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        uniforms[programName].resize(1);</div>
<div class="line"> </div>
<div class="line">        PBRModelData::UniformBufferData&amp; textureHandles = uniforms[programName][0];</div>
<div class="line">        textureHandles.m_BindingLocation = PointShadowMap::TextureHandlesUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        textureHandles.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">        textureHandles.m_Size = <span class="keyword">sizeof</span>(PointShadowMap::TextureHandlesUniformBlockData);</div>
<div class="line">        textureHandles.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(textureHandles.m_Size);</div>
<div class="line"> </div>
<div class="line">        PointShadowMap::TextureHandlesUniformBlockData* uniformMapTextureHandles = <span class="keyword">reinterpret_cast&lt;</span>PointShadowMap::TextureHandlesUniformBlockData*<span class="keyword">&gt;</span>(textureHandles.m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> useAlphaMask = 0;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Check for an alpha mask */</span></div>
<div class="line">        <span class="keywordflow">if</span> (material.m_AlphaMask.size())</div>
<div class="line">        {</div>
<div class="line">            useAlphaMask = 1;</div>
<div class="line"> </div>
<div class="line">            std::string alphaTexName = material.m_AlphaMask;</div>
<div class="line">            ExtractFileName(alphaTexName);</div>
<div class="line"> </div>
<div class="line">            uniformMapTextureHandles-&gt;SetUniform_u_alphaMask(textures.at(alphaTexName)-&gt;GetTextureData()[0]-&gt;m_TextureHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the variation index */</span></div>
<div class="line">        specializedIndices[programName] = PointShadowMap::GetVariationIndex(useAlphaMask);</div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh Constructor</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * Sets default member data values.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Mesh::Mesh() : m_NumIndices(0),</div>
<div class="line">               m_IndexBufferSize(0),</div>
<div class="line">               m_VertexBufferSize(0),</div>
<div class="line">               m_MaterialIndex(uint32_t(-1)),</div>
<div class="line">               m_IndexBufferOffset(uint32_t(-1)),</div>
<div class="line">               m_VertexBufferOffset(uint32_t(-1))</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh Destructor</span></div>
<div class="line"><span class="comment"> * --------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Mesh::~Mesh()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh::SetupFromBinaryFile</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the mesh data from a loaded model binary file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Mesh::SetupFromBinaryFile(<span class="keywordtype">void</span>* pBinaryFile, <span class="keyword">const</span> uint64_t&amp; meshHeaderOffset, uint32_t&amp; totalPoolSize)</div>
<div class="line">{</div>
<div class="line">    PBRModelBinary::MeshHeader* meshHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MeshHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeaderOffset);</div>
<div class="line"> </div>
<div class="line">    m_MaterialIndex = meshHeader-&gt;m_MaterialIndex;</div>
<div class="line"> </div>
<div class="line">    m_NumIndices = meshHeader-&gt;m_NumIndices;</div>
<div class="line"> </div>
<div class="line">    m_VertexBufferOffset = totalPoolSize;</div>
<div class="line"> </div>
<div class="line">    PBRModelBinary::DataHeader* positionHeader = <span class="keyword">nullptr</span>;</div>
<div class="line">    PBRModelBinary::DataHeader* normalHeader = <span class="keyword">nullptr</span>;</div>
<div class="line">    PBRModelBinary::DataHeader* texcoordHeader = <span class="keyword">nullptr</span>;</div>
<div class="line">    PBRModelBinary::DataHeader* tangentHeader = <span class="keyword">nullptr</span>;</div>
<div class="line">    PBRModelBinary::DataHeader* binormalHeader = <span class="keyword">nullptr</span>;</div>
<div class="line">    PBRModelBinary::DataHeader* indexHeader = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">    uint32_t bufferPoolSize = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for position data */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_PositionOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        positionHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_PositionOffset);</div>
<div class="line">        bufferPoolSize += <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(positionHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for normal data */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_NormalOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        normalHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_NormalOffset);</div>
<div class="line">        bufferPoolSize += <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(normalHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for texture coordinates */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_TexCoordOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        texcoordHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_TexCoordOffset);</div>
<div class="line">        bufferPoolSize += <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(texcoordHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for tangent data */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_TangentOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        tangentHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_TangentOffset);</div>
<div class="line">        bufferPoolSize += <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(tangentHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for binormal data */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_BinormalOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        binormalHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_BinormalOffset);</div>
<div class="line">        bufferPoolSize += <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(binormalHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Check for index data */</span></div>
<div class="line">    <span class="keywordflow">if</span> (meshHeader-&gt;m_IndexOffset != 0)</div>
<div class="line">    {</div>
<div class="line">        indexHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_IndexOffset);</div>
<div class="line"> </div>
<div class="line">        m_IndexBufferSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(indexHeader-&gt;m_DataSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_VertexBufferSize = bufferPoolSize;</div>
<div class="line"> </div>
<div class="line">    bufferPoolSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Align(bufferPoolSize, <span class="keyword">sizeof</span>(uint32_t)));</div>
<div class="line">    <span class="keywordtype">size_t</span> indexBufferAlignedLocation = bufferPoolSize;</div>
<div class="line">    bufferPoolSize += m_IndexBufferSize;</div>
<div class="line"> </div>
<div class="line">    uint32_t currentBufferOffset = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the position attribute info */</span></div>
<div class="line">    <span class="keywordflow">if</span> (positionHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::VertexAttributeModelData attribute;</div>
<div class="line"> </div>
<div class="line">        attribute.m_BufferOffset = currentBufferOffset;</div>
<div class="line">        attribute.m_DataSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(positionHeader-&gt;m_DataSize);</div>
<div class="line">        attribute.m_Name = <span class="stringliteral">&quot;a_position&quot;</span>;</div>
<div class="line">        attribute.m_Stride = g_PositionStride;</div>
<div class="line">        attribute.m_FormatNVN = g_PositionFormatNVN;</div>
<div class="line"> </div>
<div class="line">        m_VertexAttributeData[attribute.m_Name] = attribute;</div>
<div class="line"> </div>
<div class="line">        currentBufferOffset += attribute.m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the normal attribute info */</span></div>
<div class="line">    <span class="keywordflow">if</span> (normalHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::VertexAttributeModelData attribute;</div>
<div class="line"> </div>
<div class="line">        attribute.m_BufferOffset = currentBufferOffset;</div>
<div class="line">        attribute.m_DataSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(normalHeader-&gt;m_DataSize);</div>
<div class="line">        attribute.m_Name = <span class="stringliteral">&quot;a_normal&quot;</span>;</div>
<div class="line">        attribute.m_Stride = g_NormalStride;</div>
<div class="line">        attribute.m_FormatNVN = g_NormalFormatNVN;</div>
<div class="line"> </div>
<div class="line">        m_VertexAttributeData[attribute.m_Name] = attribute;</div>
<div class="line"> </div>
<div class="line">        currentBufferOffset += attribute.m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the texture coordinate attribute info */</span></div>
<div class="line">    <span class="keywordflow">if</span> (texcoordHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::VertexAttributeModelData attribute;</div>
<div class="line"> </div>
<div class="line">        attribute.m_BufferOffset = currentBufferOffset;</div>
<div class="line">        attribute.m_DataSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(texcoordHeader-&gt;m_DataSize);</div>
<div class="line">        attribute.m_Name = <span class="stringliteral">&quot;a_texCoord&quot;</span>;</div>
<div class="line">        attribute.m_Stride = g_TexCoordStride;</div>
<div class="line">        attribute.m_FormatNVN = g_TexCoordFormatNVN;</div>
<div class="line"> </div>
<div class="line">        m_VertexAttributeData[attribute.m_Name] = attribute;</div>
<div class="line"> </div>
<div class="line">        currentBufferOffset += attribute.m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the tangent attribute info */</span></div>
<div class="line">    <span class="keywordflow">if</span> (tangentHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::VertexAttributeModelData attribute;</div>
<div class="line"> </div>
<div class="line">        attribute.m_BufferOffset = currentBufferOffset;</div>
<div class="line">        attribute.m_DataSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(tangentHeader-&gt;m_DataSize);</div>
<div class="line">        attribute.m_Name = <span class="stringliteral">&quot;a_tangent&quot;</span>;</div>
<div class="line">        attribute.m_Stride = g_NormalStride;</div>
<div class="line">        attribute.m_FormatNVN = g_NormalFormatNVN;</div>
<div class="line"> </div>
<div class="line">        m_VertexAttributeData[attribute.m_Name] = attribute;</div>
<div class="line"> </div>
<div class="line">        currentBufferOffset += attribute.m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup the binormal attribute info */</span></div>
<div class="line">    <span class="keywordflow">if</span> (binormalHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::VertexAttributeModelData attribute;</div>
<div class="line"> </div>
<div class="line">        attribute.m_BufferOffset = currentBufferOffset;</div>
<div class="line">        attribute.m_DataSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(binormalHeader-&gt;m_DataSize);</div>
<div class="line">        attribute.m_Name = <span class="stringliteral">&quot;a_binormal&quot;</span>;</div>
<div class="line">        attribute.m_Stride = g_NormalStride;</div>
<div class="line">        attribute.m_FormatNVN = g_NormalFormatNVN;</div>
<div class="line"> </div>
<div class="line">        m_VertexAttributeData[attribute.m_Name] = attribute;</div>
<div class="line"> </div>
<div class="line">        currentBufferOffset += attribute.m_DataSize;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_IndexBufferOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(indexBufferAlignedLocation) + totalPoolSize;</div>
<div class="line"> </div>
<div class="line">    totalPoolSize += bufferPoolSize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (positionHeader != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        m_Positions.resize(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(positionHeader-&gt;m_DataSize / <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        memcpy(&amp;m_Positions[0], (<span class="keywordtype">void</span>*)(&amp;(positionHeader-&gt;m_pData)), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(positionHeader-&gt;m_DataSize));</div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh::GetNumAttributes</span></div>
<div class="line"><span class="comment"> * ---------------------------------</span></div>
<div class="line"><span class="comment"> * Gets the number of vertex attributes.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">uint32_t Mesh::GetNumAttributes()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_VertexAttributeData.size());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh::GetAttributes</span></div>
<div class="line"><span class="comment"> * ------------------------------</span></div>
<div class="line"><span class="comment"> * Gets a reference to the map of vertex attributes.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::map&lt;std::string, PBRModelData::VertexAttributeModelData&gt;&amp; Mesh::GetAttributes()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_VertexAttributeData;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh::SetupUniforms</span></div>
<div class="line"><span class="comment"> * ------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the uniforms for the mesh.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Mesh::SetupUniforms(std::string programName,</div>
<div class="line">                         UniformBufferManager* pUniformBufferManager,</div>
<div class="line">                         <span class="keyword">const</span> std::map&lt;std::string, AssetFileDataHolder*&gt;&amp; textures,</div>
<div class="line">                         <span class="keyword">const</span> std::vector&lt;PBRModelData::MaterialData&gt;&amp; materials,</div>
<div class="line">                         <span class="keywordtype">int</span> useLod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_UniformBuffers.find(programName) != m_UniformBuffers.end())</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> PBRModelData::MaterialData&amp; material = materials[m_MaterialIndex];</div>
<div class="line"> </div>
<div class="line">    SetupMaterialUniformBuffers(programName,</div>
<div class="line">                                pUniformBufferManager,</div>
<div class="line">                                textures,</div>
<div class="line">                                material,</div>
<div class="line">                                m_UniformBuffers,</div>
<div class="line">                                m_SpecializeShaderIndices,</div>
<div class="line">                                useLod);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Mesh::BindUniforms</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * Binds the mesh uniforms to a given command buffer.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Mesh::BindUniforms(<a name="_a0"></a><a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer, <span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    std::map&lt;std::string, std::vector&lt;PBRModelData::UniformBufferData&gt; &gt;::iterator itr = m_UniformBuffers.find(programName);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (itr != m_UniformBuffers.end())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_UniformBuffers[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                              m_UniformBuffers[programName][i].m_ShaderStage,</div>
<div class="line">                                              m_UniformBuffers[programName][i].m_BindingLocation,</div>
<div class="line">                                              m_UniformBuffers[programName][i].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                              m_UniformBuffers[programName][i].m_Size);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model Constructor</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Sets up default member data values.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Model::Model() : m_ModelName(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                 m_VertexIndexMemoryPoolSize(0)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model Destructor</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Cleans up NVN objects and dynamically allocated memory.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Model::~Model()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Clean up command buffer memory and objects */</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::map&lt;std::string, PBRModelData::CommandBufferData&gt;::iterator itr = m_ModelCommandBuffers.begin(); itr != m_ModelCommandBuffers.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        nvnCommandBufferFinalize(&amp;itr-&gt;second.m_CommandBuffer);</div>
<div class="line">        itr-&gt;second.m_pCommandMemoryPool-&gt;Shutdown();</div>
<div class="line"> </div>
<div class="line">        AlignedDeallocate(itr-&gt;second.m_pControlPool);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    m_ModelCommandBuffers.clear();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Clean up the vertex and index buffers */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        nvnBufferFinalize(&amp;m_Meshes[i]-&gt;m_VertexBuffer);</div>
<div class="line">        nvnBufferFinalize(&amp;m_Meshes[i]-&gt;m_IndexBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">delete</span> m_Meshes[i];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Shutdown the vertex/index buffer memory pool */</span></div>
<div class="line">    m_VertexIndexBufferPool.Shutdown();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetModelFileName</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Set the name of the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::SetModelFileName(<span class="keyword">const</span> std::string&amp; name)</div>
<div class="line">{</div>
<div class="line">    m_ModelName = name;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::CreateMeshes</span></div>
<div class="line"><span class="comment"> * ------------------------------</span></div>
<div class="line"><span class="comment"> * Creates the meshes for the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::CreateMeshes(<span class="keywordtype">void</span>* pBinaryFile)</div>
<div class="line">{</div>
<div class="line">    PBRModelBinary::FileHeader* pFileHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::FileHeader*<span class="keyword">&gt;</span>(pBinaryFile);</div>
<div class="line">    uint64_t meshBlockOffset = pFileHeader-&gt;m_MeshBlockOffset;</div>
<div class="line">    PBRModelBinary::MeshBlockHeader* pMeshBlockHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MeshBlockHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshBlockOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Create the meshes that make up the model */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pMeshBlockHeader-&gt;m_NumMeshes; ++i)</div>
<div class="line">    {</div>
<div class="line">        Mesh* mesh = <span class="keyword">new</span> Mesh();</div>
<div class="line">        mesh-&gt;SetupFromBinaryFile(pBinaryFile, <span class="keyword">reinterpret_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>((&amp;(pMeshBlockHeader-&gt;m_pMeshOffsets))[i]), m_VertexIndexMemoryPoolSize);</div>
<div class="line">        m_Meshes.push_back(mesh);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetupFromBinaryFile</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the model data from a load binary model file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::SetupFromBinaryFile(<span class="keywordtype">void</span>* pBinaryFile, <a name="_a1"></a><a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>* pDevice)</div>
<div class="line">{</div>
<div class="line">    PBRModelBinary::FileHeader* pFileHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::FileHeader*<span class="keyword">&gt;</span>(pBinaryFile);</div>
<div class="line"> </div>
<div class="line">    uint64_t meshBlockOffset = pFileHeader-&gt;m_MeshBlockOffset;</div>
<div class="line">    uint64_t materialBlockOffset = pFileHeader-&gt;m_MaterialBlockOffset;</div>
<div class="line"> </div>
<div class="line">    PBRModelBinary::MeshBlockHeader* pMeshBlockHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MeshBlockHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshBlockOffset);</div>
<div class="line">    PBRModelBinary::MaterialBlockHeader* pMaterialBlockHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MaterialBlockHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + materialBlockOffset);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Setup each material used by the model */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pMaterialBlockHeader-&gt;m_NumMaterials; ++i)</div>
<div class="line">    {</div>
<div class="line">        m_Materials.push_back(PBRModelData::MaterialData());</div>
<div class="line"> </div>
<div class="line">        PBRModelData::MaterialData&amp; mat = m_Materials.back();</div>
<div class="line"> </div>
<div class="line">        PBRModelBinary::MaterialHeader* pMaterialHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MaterialHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + <span class="keyword">reinterpret_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>((&amp;(pMaterialBlockHeader-&gt;m_pMaterialOffsets))[i]));</div>
<div class="line"> </div>
<div class="line">        mat.m_Diffuse.Set(pMaterialHeader-&gt;m_Diffuse[0], pMaterialHeader-&gt;m_Diffuse[1], pMaterialHeader-&gt;m_Diffuse[2]);</div>
<div class="line">        mat.m_Specular = pMaterialHeader-&gt;m_Specular;</div>
<div class="line">        mat.m_Emissive.Set(pMaterialHeader-&gt;m_Emissive[0], pMaterialHeader-&gt;m_Emissive[1], pMaterialHeader-&gt;m_Emissive[2]);</div>
<div class="line">        mat.m_Roughness = pMaterialHeader-&gt;m_Roughness;</div>
<div class="line">        mat.m_Metallic = pMaterialHeader-&gt;m_Metallic;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Multipliers applied to the texture coordinate of a map */</span></div>
<div class="line">        mat.m_DiffuseMapMod.Set(pMaterialHeader-&gt;m_DiffuseMapMod[0], pMaterialHeader-&gt;m_DiffuseMapMod[1]);</div>
<div class="line">        mat.m_SpecularMapMod.Set(pMaterialHeader-&gt;m_SpecularMapMod[0], pMaterialHeader-&gt;m_SpecularMapMod[1]);</div>
<div class="line">        mat.m_EmissiveMapMod.Set(pMaterialHeader-&gt;m_EmissiveMapMod[0], pMaterialHeader-&gt;m_EmissiveMapMod[1]);</div>
<div class="line">        mat.m_RoughnessMapMod.Set(pMaterialHeader-&gt;m_RoughnessMapMod[0], pMaterialHeader-&gt;m_RoughnessMapMod[1]);</div>
<div class="line">        mat.m_MetallicMapMod.Set(pMaterialHeader-&gt;m_MetallicMapMod[0], pMaterialHeader-&gt;m_MetallicMapMod[1]);</div>
<div class="line">        mat.m_NormalMapMod.Set(pMaterialHeader-&gt;m_NormalMapMod[0], pMaterialHeader-&gt;m_NormalMapMod[1]);</div>
<div class="line">        mat.m_AlphaMapMod.Set(pMaterialHeader-&gt;m_AlphaMapMod[0], pMaterialHeader-&gt;m_AlphaMapMod[1]);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Multipliers applied to the value read from a map */</span></div>
<div class="line">        mat.m_DiffuseValMod.Set(pMaterialHeader-&gt;m_DiffuseValMod[0], pMaterialHeader-&gt;m_DiffuseValMod[1], pMaterialHeader-&gt;m_DiffuseValMod[2]);</div>
<div class="line">        mat.m_SpecularValMod = pMaterialHeader-&gt;m_SpecularValMod;</div>
<div class="line">        mat.m_EmissiveValMod.Set(pMaterialHeader-&gt;m_EmissiveValMod[0], pMaterialHeader-&gt;m_EmissiveValMod[1], pMaterialHeader-&gt;m_EmissiveValMod[2]);</div>
<div class="line">        mat.m_RoughnessValMod = pMaterialHeader-&gt;m_RoughnessValMod;</div>
<div class="line">        mat.m_MetallicValMod = pMaterialHeader-&gt;m_MetallicValMod;</div>
<div class="line">        mat.m_NormalValMod.Set(pMaterialHeader-&gt;m_NormalValMod[0], pMaterialHeader-&gt;m_NormalValMod[1], pMaterialHeader-&gt;m_NormalValMod[2]);</div>
<div class="line">        mat.m_AlphaValMod = pMaterialHeader-&gt;m_AlphaValMod;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the diffuse map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_DiffuseTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_DiffuseTexNameOffset);</div>
<div class="line">            mat.m_DiffuseMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the specular map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_SpecularTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_SpecularTexNameOffset);</div>
<div class="line">            mat.m_SpecularMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the emissive map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_EmissiveTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_EmissiveTexNameOffset);</div>
<div class="line">            mat.m_EmissiveMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the roughness map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_RoughnessTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_RoughnessTexNameOffset);</div>
<div class="line">            mat.m_RoughnessMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the metallic map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_MetallicTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_MetallicTexNameOffset);</div>
<div class="line">            mat.m_MetallicMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the normal map name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_NormalTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_NormalTexNameOffset);</div>
<div class="line">            mat.m_NormalMap.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Get the alp-ha mask name */</span></div>
<div class="line">        <span class="keywordflow">if</span> (pMaterialHeader-&gt;m_AlphaTexNameOffset != 0)</div>
<div class="line">        {</div>
<div class="line">            PBRModelBinary::DataHeader* pDataHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + pMaterialHeader-&gt;m_AlphaTexNameOffset);</div>
<div class="line">            mat.m_AlphaMask.append((<span class="keywordtype">char</span>*)(&amp;pDataHeader-&gt;m_pData), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pDataHeader-&gt;m_DataSize));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the meshes that make up the model */</span></div>
<div class="line">    CreateMeshes(pBinaryFile);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Align the size of the memory pool */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_VertexIndexMemoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        m_VertexIndexMemoryPoolSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        m_VertexIndexMemoryPoolSize = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Align(m_VertexIndexMemoryPoolSize, <a name="a2"></a><a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Allocate the memory for the vertex/index buffer pool */</span></div>
<div class="line">    <span class="keywordtype">char</span>* modelDataBuffer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(m_VertexIndexMemoryPoolSize, <a name="a3"></a><a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line">    memset(modelDataBuffer, 0, m_VertexIndexMemoryPoolSize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        PBRModelBinary::MeshHeader* meshHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::MeshHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + <span class="keyword">reinterpret_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>((&amp;(pMeshBlockHeader-&gt;m_pMeshOffsets))[i]));</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Grab the data for each vertex attribute and copy it into the pool memory */</span></div>
<div class="line">        <span class="keywordflow">for</span> (std::map&lt;std::string, PBRModelData::VertexAttributeModelData&gt;::iterator itr = m_Meshes[i]-&gt;m_VertexAttributeData.begin(); itr != m_Meshes[i]-&gt;m_VertexAttributeData.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">void</span>* source = NULL;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (itr-&gt;first == <span class="stringliteral">&quot;a_position&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                PBRModelBinary::DataHeader* positionHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_PositionOffset);</div>
<div class="line">                source = (<span class="keywordtype">void</span>*)(&amp;(positionHeader-&gt;m_pData));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;first == <span class="stringliteral">&quot;a_normal&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                PBRModelBinary::DataHeader* normalHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_NormalOffset);</div>
<div class="line">                source = (<span class="keywordtype">void</span>*)(&amp;(normalHeader-&gt;m_pData));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;first == <span class="stringliteral">&quot;a_texCoord&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                PBRModelBinary::DataHeader* texCoordHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_TexCoordOffset);</div>
<div class="line">                source = (<span class="keywordtype">void</span>*)(&amp;(texCoordHeader-&gt;m_pData));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;first == <span class="stringliteral">&quot;a_tangent&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                PBRModelBinary::DataHeader* tangentHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_TangentOffset);</div>
<div class="line">                source = (<span class="keywordtype">void</span>*)(&amp;(tangentHeader-&gt;m_pData));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (itr-&gt;first == <span class="stringliteral">&quot;a_binormal&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                PBRModelBinary::DataHeader* binormalHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_BinormalOffset);</div>
<div class="line">                source = (<span class="keywordtype">void</span>*)(&amp;(binormalHeader-&gt;m_pData));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <a name="a4"></a><a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Unknown Vertex Attribute&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            memcpy(modelDataBuffer + itr-&gt;second.m_BufferOffset + m_Meshes[i]-&gt;m_VertexBufferOffset, source, itr-&gt;second.m_DataSize);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Copy the index buffer into the pool memory */</span></div>
<div class="line">        PBRModelBinary::DataHeader* indexHeader = <span class="keyword">reinterpret_cast&lt;</span>PBRModelBinary::DataHeader*<span class="keyword">&gt;</span>((<span class="keywordtype">char</span>*)pBinaryFile + meshHeader-&gt;m_IndexOffset);</div>
<div class="line">        memcpy(modelDataBuffer + m_Meshes[i]-&gt;m_IndexBufferOffset,</div>
<div class="line">               (<span class="keywordtype">void</span>*)(&amp;(indexHeader-&gt;m_pData)),</div>
<div class="line">               m_Meshes[i]-&gt;m_IndexBufferSize);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Wrap the memory pool around the allocated vertex/index memory */</span></div>
<div class="line">    m_VertexIndexBufferPool.Init(modelDataBuffer,</div>
<div class="line">                                 m_VertexIndexMemoryPoolSize,</div>
<div class="line">                                 <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                 pDevice);</div>
<div class="line"> </div>
<div class="line">    <a name="_a5"></a><a class="code" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> bufferBuilder;</div>
<div class="line">    nvnBufferBuilderSetDevice(&amp;bufferBuilder, pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create the NVN vertex and index buffers for each mesh */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        nvnBufferBuilderSetDefaults(&amp;bufferBuilder);</div>
<div class="line">        nvnBufferBuilderSetStorage(&amp;bufferBuilder, m_VertexIndexBufferPool.GetMemoryPool(), m_Meshes[i]-&gt;m_VertexBufferOffset, m_Meshes[i]-&gt;m_VertexBufferSize);</div>
<div class="line">        <span class="keywordflow">if</span> (!nvnBufferInitialize(&amp;m_Meshes[i]-&gt;m_VertexBuffer, &amp;bufferBuilder))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize vertex buffer storage&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        nvnBufferBuilderSetDefaults(&amp;bufferBuilder);</div>
<div class="line">        nvnBufferBuilderSetStorage(&amp;bufferBuilder, m_VertexIndexBufferPool.GetMemoryPool(), m_Meshes[i]-&gt;m_IndexBufferOffset, m_Meshes[i]-&gt;m_IndexBufferSize);</div>
<div class="line">        <span class="keywordflow">if</span> (!nvnBufferInitialize(&amp;m_Meshes[i]-&gt;m_IndexBuffer, &amp;bufferBuilder))</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize index buffer storage&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// NOLINT(impl/function_size)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::GetName</span></div>
<div class="line"><span class="comment"> * -------------------------</span></div>
<div class="line"><span class="comment"> * Get the model&#39;s name.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::string&amp; Model::GetName()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_ModelName;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::GetMeshes</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * Returns the mesh list that is used to draw the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;Mesh*&gt;&amp; Model::GetMeshes()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_Meshes;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetupShaderAttribute</span></div>
<div class="line"><span class="comment"> * --------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the model&#39;s vertex attribute and stream states for a given shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::SetupShaderAttribute(<span class="keyword">const</span> std::string&amp; programName, int32_t(*GetLocation)(<span class="keyword">const</span> std::string&amp;))</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Return if there are no shader attributes */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_VertexAttributeShaderData.find(programName) != m_VertexAttributeShaderData.end())</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    PBRModelData::VertexAttributeShaderData&amp; data = m_VertexAttributeShaderData[programName];</div>
<div class="line"> </div>
<div class="line">    uint32_t numAttributes = m_Meshes[0]-&gt;GetNumAttributes();</div>
<div class="line"> </div>
<div class="line">    data.m_VertexAttributeStates.resize(numAttributes);</div>
<div class="line">    data.m_VertexStreamStates.resize(numAttributes);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Setup the atrribute and stream states for each attribute.</span></div>
<div class="line"><span class="comment">         * If the model has multiple meshes, it is assumed that they have the</span></div>
<div class="line"><span class="comment">         * number/types of attributes.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::map&lt;std::string, PBRModelData::VertexAttributeModelData&gt;::iterator itr = m_Meshes[0]-&gt;m_VertexAttributeData.begin(); itr != m_Meshes[0]-&gt;m_VertexAttributeData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        int32_t location = GetLocation(itr-&gt;second.m_Name);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (location &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(numAttributes) || location == -1)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        data.m_AttributeLocations[itr-&gt;second.m_Name] = location;</div>
<div class="line"> </div>
<div class="line">        <a name="_a6"></a><a class="code" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a>* pAttributeState = &amp;data.m_VertexAttributeStates[location];</div>
<div class="line"> </div>
<div class="line">        nvnVertexAttribStateSetDefaults(pAttributeState);</div>
<div class="line">        nvnVertexAttribStateSetStreamIndex(pAttributeState, location);</div>
<div class="line">        nvnVertexAttribStateSetFormat(pAttributeState, itr-&gt;second.m_FormatNVN, 0);</div>
<div class="line"> </div>
<div class="line">        <a name="_a7"></a><a class="code" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a>* pStreamState = &amp;data.m_VertexStreamStates[location];</div>
<div class="line">        nvnVertexStreamStateSetDefaults(pStreamState);</div>
<div class="line">        nvnVertexStreamStateSetStride(pStreamState, itr-&gt;second.m_Stride);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetupModelCommandBuffer</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Creates and records the command buffer for drawing the</span></div>
<div class="line"><span class="comment"> * model with a with a given shader program. This command</span></div>
<div class="line"><span class="comment"> * buffer will be used via nvnCommandBufferCallCommands any</span></div>
<div class="line"><span class="comment"> * time the model would be drawn with that shader.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::SetupModelCommandBuffer(AssetFileDataHolder* shaderProgramData, <a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>* pDevice, uint32_t commandMemorySize, uint32_t controlMemorySize, <span class="keywordtype">bool</span> bindShader <span class="comment">/* = true */</span>)</div>
<div class="line">{</div>
<div class="line">    std::string programName;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grabs the shader program name */</span></div>
<div class="line">    <span class="keywordflow">if</span> (shaderProgramData-&gt;GetProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderProgramData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetSpecializedProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(<span class="keyword">false</span>, <span class="stringliteral">&quot;No shader in asset data holder.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Return if the command buffer has already been setup */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_ModelCommandBuffers.find(programName) != m_ModelCommandBuffers.end())</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create a new command buffer */</span></div>
<div class="line">    nvnCommandBufferInitialize(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer, pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Grab the command and control alignment values */</span></div>
<div class="line">    <span class="keywordtype">int</span> commandBufferCommandAlignment = 0;</div>
<div class="line">    <span class="keywordtype">int</span> commandBufferControlAlignment = 0;</div>
<div class="line">    nvnDeviceGetInteger(pDevice, <a class="code" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>, &amp;commandBufferCommandAlignment);</div>
<div class="line">    nvnDeviceGetInteger(pDevice, <a class="code" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>, &amp;commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Create a memory pool for the command buffer */</span></div>
<div class="line">    m_ModelCommandBuffers[programName].m_pCommandMemoryPool = <span class="keyword">new</span> <a class="code" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">MemoryPool</a>();</div>
<div class="line">    m_ModelCommandBuffers[programName].m_pCommandMemoryPool-&gt;Init(NULL,</div>
<div class="line">                                                                  Align(commandMemorySize, commandBufferCommandAlignment),</div>
<div class="line">                                                                  <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                                                  pDevice);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Allocate the control memory */</span></div>
<div class="line">    m_ModelCommandBuffers[programName].m_pControlPool = AlignedAllocate(controlMemorySize, commandBufferControlAlignment);</div>
<div class="line"> </div>
<div class="line">    ptrdiff_t offset = m_ModelCommandBuffers[programName].m_pCommandMemoryPool-&gt;GetNewMemoryChunkOffset(commandMemorySize, commandBufferCommandAlignment);</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferAddCommandMemory(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer,</div>
<div class="line">                                     m_ModelCommandBuffers[programName].m_pCommandMemoryPool-&gt;GetMemoryPool(),</div>
<div class="line">                                     offset,</div>
<div class="line">                                     Align(commandMemorySize, commandBufferCommandAlignment));</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferAddControlMemory(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer,</div>
<div class="line">                                     m_ModelCommandBuffers[programName].m_pControlPool,</div>
<div class="line">                                     Align(controlMemorySize, commandBufferControlAlignment));</div>
<div class="line"> </div>
<div class="line">    nvnCommandBufferBeginRecording(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Records the commands for drawing the model */</span></div>
<div class="line">    DrawModel(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer, shaderProgramData, bindShader);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Hold onto the command buffer handle to be used later with nvnCommandBufferCallCommands */</span></div>
<div class="line">    m_ModelCommandBuffers[programName].m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_ModelCommandBuffers[programName].m_CommandBuffer);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::GetCommandHandle</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Gets the command handle for the command buffer to draw</span></div>
<div class="line"><span class="comment"> * the model with the given shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> Model::GetCommandHandle(<span class="keyword">const</span> std::string&amp; programName)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_ModelCommandBuffers.at(programName).m_CommandHandle;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::DrawModel</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * Records the commands for drawing the model with the given</span></div>
<div class="line"><span class="comment"> * shader program into the given command buffer.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::DrawModel(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer, AssetFileDataHolder* shaderProgramData, <span class="keywordtype">bool</span> bindShader)</div>
<div class="line">{</div>
<div class="line">    std::string programName;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Get the shader program name */</span></div>
<div class="line">    <span class="keywordflow">if</span> (shaderProgramData-&gt;GetProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderProgramData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">    {</div>
<div class="line">        programName = shaderProgramData-&gt;GetSpecializedProgramData()[0]-&gt;m_pProgramName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(<span class="keyword">false</span>, <span class="stringliteral">&quot;No shader in asset data holder.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    PBRModelData::VertexAttributeShaderData&amp; shaderData = m_VertexAttributeShaderData.at(programName);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Draw each mesh held by the model */</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> vboAddr = nvnBufferGetAddress(&amp;m_Meshes[i]-&gt;m_VertexBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (std::map&lt;std::string, uint32_t&gt;::iterator itr = shaderData.m_AttributeLocations.begin(); itr != shaderData.m_AttributeLocations.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            PBRModelData::VertexAttributeModelData&amp; attr = m_Meshes[i]-&gt;m_VertexAttributeData.at(itr-&gt;first);</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBindVertexBuffer(pCommandBuffer, itr-&gt;second, vboAddr + attr.m_BufferOffset, attr.m_DataSize);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        m_Meshes[i]-&gt;BindUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Bind the vertex attribute states and vertex stream states. */</span></div>
<div class="line">        nvnCommandBufferBindVertexAttribState(pCommandBuffer, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(shaderData.m_AttributeLocations.size()), &amp;shaderData.m_VertexAttributeStates[0]);</div>
<div class="line">        nvnCommandBufferBindVertexStreamState(pCommandBuffer, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(shaderData.m_AttributeLocations.size()), &amp;shaderData.m_VertexStreamStates[0]);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Bind the shader program. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (bindShader == <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (shaderProgramData-&gt;GetProgramData().size())</div>
<div class="line">            {</div>
<div class="line">                shaderProgramData-&gt;GetProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderProgramData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">            {</div>
<div class="line">                shaderProgramData-&gt;GetSpecializedProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer, m_Meshes[i]-&gt;m_SpecializeShaderIndices.at(programName));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Draw the model. */</span></div>
<div class="line">        <a class="code" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> indexType = Mesh::g_IndexTypeNVN;</div>
<div class="line">        <span class="keywordtype">int</span> numIndices = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(m_Meshes[i]-&gt;m_NumIndices);</div>
<div class="line">        nvnCommandBufferDrawElements(pCommandBuffer,</div>
<div class="line">                                     Mesh::g_DrawPrimitiveTypeNVN,</div>
<div class="line">                                     indexType,</div>
<div class="line">                                     numIndices,</div>
<div class="line">                                     nvnBufferGetAddress(&amp;m_Meshes[i]-&gt;m_IndexBuffer));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Model::SetupMeshUniforms</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the uniforms for each mesh contained by the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Model::SetupMeshUniforms(<span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                              UniformBufferManager* pUniformBufferManager,</div>
<div class="line">                              <span class="keyword">const</span> std::map&lt;std::string, AssetFileDataHolder*&gt;&amp; textures,</div>
<div class="line">                              <span class="keywordtype">int</span> useLod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_Meshes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        m_Meshes[i]-&gt;SetupUniforms(programName, pUniformBufferManager, textures, m_Materials, useLod);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object Constructor</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * Sets up default member data values.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Object::Object() : m_ObjectName(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                   m_ModelName(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">                   m_BackFaceCull(1),</div>
<div class="line">                   m_PolygonMode(<a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a>)</div>
<div class="line">{</div>
<div class="line">    m_Scale.Set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    m_Translation.Set(1.0f, 1.0f, 1.0f);</div>
<div class="line">    m_Rotation.Set(1.0f, 1.0f, 1.0f);</div>
<div class="line"> </div>
<div class="line">    nn::util::MatrixIdentity(&amp;m_ProjectionMatrix);</div>
<div class="line">    nn::util::MatrixIdentity(&amp;m_CameraMatrix);</div>
<div class="line">    nn::util::MatrixIdentity(&amp;m_WorldMatrix);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object Destructor</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Empty destructor.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">Object::~Object()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetModel</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Sets the name of the model that the object will draw.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetModel(<span class="keyword">const</span> std::string&amp; model)</div>
<div class="line">{</div>
<div class="line">    m_ModelName = model;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::GetModel</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Gets the name of the object&#39;s model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::string&amp; Object::GetModel()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> m_ModelName;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetDefaultState</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the default render state options.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetDefaultState()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Polygon state */</span></div>
<div class="line">    nvnPolygonStateSetDefaults(&amp;m_PolygonState);</div>
<div class="line">    nvnPolygonStateSetFrontFace(&amp;m_PolygonState, NVNfrontFace::NVN_FRONT_FACE_CCW);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Back face culling off is used for alpha masked objects that need to still</span></div>
<div class="line"><span class="comment">         * to be visible.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_BackFaceCull == 1)</div>
<div class="line">    {</div>
<div class="line">        nvnPolygonStateSetCullFace(&amp;m_PolygonState, NVNface::NVN_FACE_BACK);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        nvnPolygonStateSetCullFace(&amp;m_PolygonState, NVNface::NVN_FACE_NONE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    nvnPolygonStateSetPolygonMode(&amp;m_PolygonState, m_PolygonMode);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetShadowState</span></div>
<div class="line"><span class="comment"> * ---------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the render state for drawing to a shadow map.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetShadowState()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Polygon state */</span></div>
<div class="line">    nvnPolygonStateSetDefaults(&amp;m_PolygonState);</div>
<div class="line">    nvnPolygonStateSetFrontFace(&amp;m_PolygonState, NVNfrontFace::NVN_FRONT_FACE_CCW);</div>
<div class="line">    nvnPolygonStateSetCullFace(&amp;m_PolygonState, NVNface::NVN_FACE_NONE);</div>
<div class="line">    nvnPolygonStateSetPolygonMode(&amp;m_PolygonState, <a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetBackFaceCull</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets whether the object should use back face culling.</span></div>
<div class="line"><span class="comment"> * This is primarily used for alpha masked geometry where</span></div>
<div class="line"><span class="comment"> * both sides should be visible (like foliage).</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetBackFaceCull(<span class="keywordtype">int</span> cull)</div>
<div class="line">{</div>
<div class="line">    m_BackFaceCull = cull;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::BindState</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Binds the render state for drawing the object.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::BindState(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    nvnCommandBufferBindPolygonState(pCommandBuffer, &amp;m_PolygonState);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetScale</span></div>
<div class="line"><span class="comment"> * ---------------------------</span></div>
<div class="line"><span class="comment"> * Sets the object&#39;s scale.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetScale(<span class="keyword">const</span> <a name="_a8"></a><a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>&amp; scale)</div>
<div class="line">{</div>
<div class="line">    m_Scale = scale;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetTranslate</span></div>
<div class="line"><span class="comment"> * -------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the object&#39;s world space position.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetTranslate(<span class="keyword">const</span> <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>&amp; translate)</div>
<div class="line">{</div>
<div class="line">    m_Translation = translate;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetRotate</span></div>
<div class="line"><span class="comment"> * ----------------------------</span></div>
<div class="line"><span class="comment"> * Sets the object&#39;s rotation.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetRotate(<span class="keyword">const</span> <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>&amp; rotate)</div>
<div class="line">{</div>
<div class="line">    m_Rotation = rotate;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::GetWorldMatrix</span></div>
<div class="line"><span class="comment"> * ---------------------------------</span></div>
<div class="line"><span class="comment"> * Returns the world matrix.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> <a name="_a9"></a><a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a>&amp; Object::GetWorldMatrix()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_WorldMatrix;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetCameraMatrix</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the camera matrix.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetCameraMatrix(<span class="keyword">const</span> <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a>&amp; matrix)</div>
<div class="line">{</div>
<div class="line">    m_CameraMatrix = matrix;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetProjectionMatrix</span></div>
<div class="line"><span class="comment"> * --------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets the projection matrix.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetProjectionMatrix(<span class="keyword">const</span> <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a>&amp; matrix)</div>
<div class="line">{</div>
<div class="line">    m_ProjectionMatrix = matrix;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetupModelUniforms</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the per model uniforms for the given shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetupModelUniforms(<span class="keyword">const</span> std::string&amp; programName, UniformBufferManager* pUniformBufferManager)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_ModelUniformBuffers.find(programName) != m_ModelUniformBuffers.end())</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;DeferredGBuffer&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::UniformBufferData blockVS;</div>
<div class="line">        blockVS.m_Size = <span class="keyword">sizeof</span>(DeferredGBuffer::BlockVSUniformBlockData);</div>
<div class="line">        blockVS.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>;</div>
<div class="line">        blockVS.m_BindingLocation = DeferredGBuffer::BlockVSUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>);</div>
<div class="line"> </div>
<div class="line">        blockVS.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(<span class="keyword">sizeof</span>(DeferredGBuffer::BlockVSUniformBlockData));</div>
<div class="line"> </div>
<div class="line">        m_ModelUniformBuffers[programName].push_back(blockVS);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (m_LodInfo.size())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodInfo.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                PBRModelData::UniformBufferData lodBlock;</div>
<div class="line">                lodBlock.m_Size = <span class="keyword">sizeof</span>(DeferredGBuffer::LODThresholdUniformBlockData);</div>
<div class="line">                lodBlock.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>;</div>
<div class="line">                lodBlock.m_BindingLocation = DeferredGBuffer::LODThresholdUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line"> </div>
<div class="line">                lodBlock.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(<span class="keyword">sizeof</span>(DeferredGBuffer::LODThresholdUniformBlockData));</div>
<div class="line"> </div>
<div class="line">                m_LodUniforms[programName].push_back(lodBlock);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;ShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::UniformBufferData blockVS;</div>
<div class="line">        blockVS.m_Size = <span class="keyword">sizeof</span>(ShadowMap::BlockVSUniformBlockData);</div>
<div class="line">        blockVS.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>;</div>
<div class="line">        blockVS.m_BindingLocation = ShadowMap::BlockVSUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>);</div>
<div class="line"> </div>
<div class="line">        blockVS.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(<span class="keyword">sizeof</span>(ShadowMap::BlockVSUniformBlockData));</div>
<div class="line"> </div>
<div class="line">        m_ModelUniformBuffers[programName].push_back(blockVS);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;PointShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        PBRModelData::UniformBufferData blockVS;</div>
<div class="line">        blockVS.m_Size = <span class="keyword">sizeof</span>(PointShadowMap::BlockVSUniformBlockData);</div>
<div class="line">        blockVS.m_ShaderStage = <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>;</div>
<div class="line">        blockVS.m_BindingLocation = PointShadowMap::BlockVSUniformBlockData::GetBinding(<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>);</div>
<div class="line"> </div>
<div class="line">        blockVS.m_pUniformBuffer = pUniformBufferManager-&gt;CreateUniformBuffer(<span class="keyword">sizeof</span>(PointShadowMap::BlockVSUniformBlockData));</div>
<div class="line"> </div>
<div class="line">        m_ModelUniformBuffers[programName].push_back(blockVS);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::UpdateModelUniforms</span></div>
<div class="line"><span class="comment"> * --------------------------------------</span></div>
<div class="line"><span class="comment"> * Updates the model uniforms for the given shader program</span></div>
<div class="line"><span class="comment"> * with the current values of the internal world, camera, and</span></div>
<div class="line"><span class="comment"> * projection matrices.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::UpdateModelUniforms(<span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    <a name="_a10"></a><a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> scale;</div>
<div class="line">    nn::util::MatrixIdentity(&amp;scale);</div>
<div class="line">    nn::util::MatrixSetScale(&amp;scale, m_Scale);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> rotate;</div>
<div class="line">    nn::util::MatrixIdentity(&amp;rotate);</div>
<div class="line">    <a name="_a11"></a><a class="code" href="structnn_1_1util_1_1_vector3f_type.html">nn::util::Vector3fType</a> rotateVector;</div>
<div class="line">    nn::util::VectorSet(&amp;rotateVector, m_Rotation.GetX() * DEG_TO_RAD, m_Rotation.GetY() * DEG_TO_RAD, m_Rotation.GetZ() * DEG_TO_RAD);</div>
<div class="line">    nn::util::MatrixSetRotateXyz(&amp;rotate, rotateVector);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> translate;</div>
<div class="line">    nn::util::MatrixIdentity(&amp;translate);</div>
<div class="line">    nn::util::MatrixSetTranslate(&amp;translate, m_Translation);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> tempMat1;</div>
<div class="line">    <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> tempMat2;</div>
<div class="line"> </div>
<div class="line">    nn::util::MatrixMultiply(&amp;tempMat1, scale, rotate);</div>
<div class="line">    nn::util::MatrixMultiply(&amp;tempMat2, tempMat1, translate);</div>
<div class="line">    nn::util::MatrixConvert(&amp;m_WorldMatrix, tempMat2);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::Matrix4x3fType</a> tempNormalIT;</div>
<div class="line">    nn::util::MatrixInverseTranspose(&amp;tempNormalIT, tempMat2);</div>
<div class="line">    nn::util::MatrixConvert(&amp;m_NormalMatrix, tempNormalIT);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;DeferredGBuffer&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        DeferredGBuffer::BlockVSUniformBlockData* uniformMapVS = <span class="keyword">reinterpret_cast&lt;</span>DeferredGBuffer::BlockVSUniformBlockData*<span class="keyword">&gt;</span>(m_ModelUniformBuffers[programName][0].m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a> tempMVP1;</div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a> tempMVP2;</div>
<div class="line">        <a name="_a12"></a><a class="code" href="structnn_1_1util_1_1_float_row_major4x4.html">nn::util::Float4x4</a> temp;</div>
<div class="line"> </div>
<div class="line">        nn::util::MatrixMultiply(&amp;tempMVP1, m_WorldMatrix, m_CameraMatrix);</div>
<div class="line">        nn::util::MatrixMultiply(&amp;tempMVP2, tempMVP1, m_ProjectionMatrix);</div>
<div class="line"> </div>
<div class="line">        nn::util::MatrixStore(&amp;temp, tempMVP2);</div>
<div class="line">        uniformMapVS-&gt;SetUniform_u_MVP(*<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>(*)[16]<span class="keyword">&gt;</span>(&amp;temp));</div>
<div class="line"> </div>
<div class="line">        nn::util::MatrixStore(&amp;temp, m_NormalMatrix);</div>
<div class="line">        uniformMapVS-&gt;SetUniform_u_normalMtx(*<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>(*)[16]<span class="keyword">&gt;</span>(&amp;temp));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;ShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        ShadowMap::BlockVSUniformBlockData* uniformMapVS = <span class="keyword">reinterpret_cast&lt;</span>ShadowMap::BlockVSUniformBlockData*<span class="keyword">&gt;</span>(m_ModelUniformBuffers[programName][0].m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a> tempMVP1;</div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a> tempMVP2;</div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_float_row_major4x4.html">nn::util::Float4x4</a> temp;</div>
<div class="line"> </div>
<div class="line">        nn::util::MatrixMultiply(&amp;tempMVP1, m_WorldMatrix, m_CameraMatrix);</div>
<div class="line">        nn::util::MatrixMultiply(&amp;tempMVP2, tempMVP1, m_ProjectionMatrix);</div>
<div class="line"> </div>
<div class="line">        nn::util::MatrixStore(&amp;temp, tempMVP2);</div>
<div class="line">        uniformMapVS-&gt;SetUniform_u_MVP(*<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>(*)[16]<span class="keyword">&gt;</span>(&amp;temp));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;PointShadowMap&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        PointShadowMap::BlockVSUniformBlockData* uniformMapVS = <span class="keyword">reinterpret_cast&lt;</span>PointShadowMap::BlockVSUniformBlockData*<span class="keyword">&gt;</span>(m_ModelUniformBuffers[programName][0].m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_float_row_major4x4.html">nn::util::Float4x4</a> temp;</div>
<div class="line">        nn::util::MatrixStore(&amp;temp, m_WorldMatrix);</div>
<div class="line">        uniformMapVS-&gt;SetUniform_u_modelMtx(*<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>(*)[16]<span class="keyword">&gt;</span>(&amp;temp));</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::Matrix4x4fType</a> tempVP;</div>
<div class="line">        nn::util::MatrixMultiply(&amp;tempVP, m_CameraMatrix, m_ProjectionMatrix);</div>
<div class="line">        nn::util::MatrixStore(&amp;temp, tempVP);</div>
<div class="line"> </div>
<div class="line">        uniformMapVS-&gt;SetUniform_u_viewProjMtx(*<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>(*)[16]<span class="keyword">&gt;</span>(&amp;temp));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::BindModelUniforms</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Binds the per model uniforms for the given shader program</span></div>
<div class="line"><span class="comment"> * to the given command buffer.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::BindModelUniforms(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer, <span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_ModelUniformBuffers[programName].size(); ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Bind the model uniforms */</span></div>
<div class="line">        nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                          m_ModelUniformBuffers[programName][i].m_ShaderStage,</div>
<div class="line">                                          m_ModelUniformBuffers[programName][i].m_BindingLocation,</div>
<div class="line">                                          m_ModelUniformBuffers[programName][i].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                          m_ModelUniformBuffers[programName][i].m_Size);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::Draw</span></div>
<div class="line"><span class="comment"> * -----------------------</span></div>
<div class="line"><span class="comment"> * Binds render state, uniforms, shader program (if needed),</span></div>
<div class="line"><span class="comment"> * and draws the model. If the model has LODs, the appropriate</span></div>
<div class="line"><span class="comment"> * uniforms are bound and LODs are drawn.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::Draw(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer,</div>
<div class="line">                  <span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                  <span class="keyword">const</span> std::map&lt;std::string, PBRObject::Model&gt;&amp; models,</div>
<div class="line">                  AssetFileDataHolder* shaderData)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Bind the render state */</span></div>
<div class="line">    BindState(pCommandBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Bind the per model uniforms */</span></div>
<div class="line">    BindModelUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* If needed, bind the material uniforms held by the object */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_MaterialUniformBuffers.find(programName) != m_MaterialUniformBuffers.end())</div>
<div class="line">    {</div>
<div class="line">        BindMaterialUniforms(pCommandBuffer, programName);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (shaderData-&gt;GetProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shaderData-&gt;GetSpecializedProgramData().size())</div>
<div class="line">        {</div>
<div class="line">            shaderData-&gt;GetSpecializedProgramData()[0]-&gt;BindShaderProgram(pCommandBuffer, m_SpecializeShaderIndices.at(programName));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Draw the model via call commands */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_LodsToDraw[programName].size())</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If the model has LODs, draw the chosen LOD(s) and blend if needed */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodsToDraw[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            std::string modelName = m_LodInfo[m_LodsToDraw[programName][i].m_Index].m_Name;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * If the model name is blank that means that the &quot;cull&quot; detail level</span></div>
<div class="line"><span class="comment">                 * has been hit and no mesh needs to be drawn.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">if</span> (modelName == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            uint32_t lodIndex = m_LodsToDraw[programName][i].m_Index;</div>
<div class="line"> </div>
<div class="line">            nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_ShaderStage,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_BindingLocation,</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                              m_LodUniforms[programName][lodIndex].m_Size);</div>
<div class="line"> </div>
<div class="line">            <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = models.at(modelName).GetCommandHandle(programName);</div>
<div class="line">            nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* If no LODs, just draw the base model */</span></div>
<div class="line">        <a class="code" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> drawHandle = models.at(GetModel()).GetCommandHandle(programName);</div>
<div class="line">        nvnCommandBufferCallCommands(pCommandBuffer, 1, &amp;drawHandle);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetupMaterialUniforms</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the material uniforms. This is used for models</span></div>
<div class="line"><span class="comment"> * that need to be drawn with multiple different material</span></div>
<div class="line"><span class="comment"> * sets in the scene. Primarily used for testing purposes.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetupMaterialUniforms(<span class="keyword">const</span> std::string&amp; programName,</div>
<div class="line">                                   UniformBufferManager* pUniformBufferManager,</div>
<div class="line">                                   <span class="keyword">const</span> std::map&lt;std::string, AssetFileDataHolder*&gt;&amp; textures,</div>
<div class="line">                                   <span class="keyword">const</span> PBRModelData::MaterialData&amp; material,</div>
<div class="line">                                   <span class="keywordtype">int</span> useLod)</div>
<div class="line">{</div>
<div class="line">    SetupMaterialUniformBuffers(programName,</div>
<div class="line">                                pUniformBufferManager,</div>
<div class="line">                                textures,</div>
<div class="line">                                material,</div>
<div class="line">                                m_MaterialUniformBuffers,</div>
<div class="line">                                m_SpecializeShaderIndices,</div>
<div class="line">                                useLod);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::BindMaterialUniforms</span></div>
<div class="line"><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><span class="comment"> * Binds the object&#39;s material uniforms to the given</span></div>
<div class="line"><span class="comment"> * command buffer.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::BindMaterialUniforms(<a class="code" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a>* pCommandBuffer, <span class="keyword">const</span> std::string&amp; programName)</div>
<div class="line">{</div>
<div class="line">    std::map&lt;std::string, std::vector&lt;PBRModelData::UniformBufferData&gt; &gt;::iterator itr = m_MaterialUniformBuffers.find(programName);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (itr != m_MaterialUniformBuffers.end())</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Bind each material uniform buffer for the shader program */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_MaterialUniformBuffers[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            nvnCommandBufferBindUniformBuffer(pCommandBuffer,</div>
<div class="line">                                              m_MaterialUniformBuffers[programName][i].m_ShaderStage,</div>
<div class="line">                                              m_MaterialUniformBuffers[programName][i].m_BindingLocation,</div>
<div class="line">                                              m_MaterialUniformBuffers[programName][i].m_pUniformBuffer-&gt;GetCurrentBufferAddress(),</div>
<div class="line">                                              m_MaterialUniformBuffers[programName][i].m_Size);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetName</span></div>
<div class="line"><span class="comment"> * --------------------------</span></div>
<div class="line"><span class="comment"> * Set the object&#39;s name.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetName(<span class="keyword">const</span> std::string&amp; name)</div>
<div class="line">{</div>
<div class="line">    m_ObjectName = name;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::GetName</span></div>
<div class="line"><span class="comment"> * --------------------------</span></div>
<div class="line"><span class="comment"> * Get the object&#39;s name.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::string&amp; Object::GetName()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> m_ObjectName;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::AddLod</span></div>
<div class="line"><span class="comment"> * -------------------------</span></div>
<div class="line"><span class="comment"> * Adds an LOD at a specific level.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::AddLod(<span class="keyword">const</span> PBRModelData::LodInfo&amp; lod, <span class="keywordtype">int</span> level)</div>
<div class="line">{</div>
<div class="line">    m_LodInfo[level] = lod;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::GetLodInfo</span></div>
<div class="line"><span class="comment"> * -----------------------------</span></div>
<div class="line"><span class="comment"> * Get the vector of LODInfo structs.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;PBRModelData::LodInfo&gt;&amp; Object::GetLodInfo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> m_LodInfo;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::UpdateLODInfo</span></div>
<div class="line"><span class="comment"> * --------------------------------</span></div>
<div class="line"><span class="comment"> * Figures out which LOD should be drawn. If the camera is at</span></div>
<div class="line"><span class="comment"> * such a distance that we need to interpolate between two, then</span></div>
<div class="line"><span class="comment"> * both are drawn dithered based on the distance to the camera.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * LOD Data</span></div>
<div class="line"><span class="comment"> * --------</span></div>
<div class="line"><span class="comment"> * Index           - Index of the LOD with 0 being the base model</span></div>
<div class="line"><span class="comment"> * Name            - Name of the model to be draw for the particular level</span></div>
<div class="line"><span class="comment"> * Distance        - Distance at which the LOD should be switched to</span></div>
<div class="line"><span class="comment"> * Transition Area - Area over which two LODs should be blended</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::UpdateLodInfo(<span class="keyword">const</span> std::string&amp; programName, <span class="keyword">const</span> <a class="code" href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a>&amp; eyePos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (programName == <span class="stringliteral">&quot;DeferredGBuffer&quot;</span> &amp;&amp; m_LodInfo.size() != 0)</div>
<div class="line">    {</div>
<div class="line">        m_LodsToDraw[programName].clear();</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Get the distance between the object and the camera. This</span></div>
<div class="line"><span class="comment">             * version is a simple distance between the object&#39;s location</span></div>
<div class="line"><span class="comment">             * and the camera as opposed to finding the closest point on the</span></div>
<div class="line"><span class="comment">             * object (or representative bounding volume) and testing with that.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordtype">float</span> distance = nn::util::VectorDistance(m_Translation, eyePos);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Indices for which LODs to draw. If the camera is in a</span></div>
<div class="line"><span class="comment">             * transition area, then both LODs will be drawn.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordtype">int</span> lodIdx = -1;</div>
<div class="line">        <span class="keywordtype">int</span> lodIdx2 = -1;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodInfo.size() - 1; ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * If the distance to the camera is within the bounds of a single LOD</span></div>
<div class="line"><span class="comment">                 * hold onto that index and set the blend t-value to 1.0f.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <span class="keywordflow">if</span> (distance &gt;= m_LodInfo[i].m_StartDistance &amp;&amp; distance &lt; (m_LodInfo[i + 1].m_StartDistance - m_LodInfo[i + 1].m_TransitionArea))</div>
<div class="line">            {</div>
<div class="line">                lodIdx = i;</div>
<div class="line">                m_LodsToDraw[programName].push_back(PBRModelData::LodDrawData(lodIdx, 1.0f, 1.0f));</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">                <span class="comment">/* Otherwise if the camera is within a transition area between two LODs */</span></div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (distance &gt;= (m_LodInfo[i + 1].m_StartDistance - m_LodInfo[i + 1].m_TransitionArea) &amp;&amp; distance &lt; m_LodInfo[i + 1].m_StartDistance)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">/* Save both indices */</span></div>
<div class="line">                lodIdx = i;</div>
<div class="line">                lodIdx2 = i + 1;</div>
<div class="line"> </div>
<div class="line">                <span class="keywordtype">float</span> dist1 = m_LodInfo[i + 1].m_StartDistance - m_LodInfo[i + 1].m_TransitionArea;</div>
<div class="line">                <span class="keywordtype">float</span> dist2 = m_LodInfo[i + 1].m_StartDistance;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/* Value used to check aginst the dither threshold */</span></div>
<div class="line">                <span class="keywordtype">float</span> tVal = 1.0f - (distance - dist1) / (dist2 - dist1);</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Save the indices and t values for each LOD. One LOD has a positive</span></div>
<div class="line"><span class="comment">                     * modifier and one with a negative. This causes them to have the exact</span></div>
<div class="line"><span class="comment">                     * opposite dither pattern so that the line up precisely.</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                m_LodsToDraw[programName].push_back(PBRModelData::LodDrawData(lodIdx, tVal, 1.0f));</div>
<div class="line">                m_LodsToDraw[programName].push_back(PBRModelData::LodDrawData(lodIdx2, tVal, -1.0f));</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* If an LOD index hasn&#39;t been set yet, use the lowest level */</span></div>
<div class="line">        <span class="keywordflow">if</span> (lodIdx == -1 &amp;&amp; lodIdx2 == -1)</div>
<div class="line">        {</div>
<div class="line">            m_LodsToDraw[programName].push_back(PBRModelData::LodDrawData(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_LodInfo.size() - 1), 1.0f, 1.0f));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">/* Setup the uniform values for each of the LODs to be drawn */</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; m_LodsToDraw[programName].size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            DeferredGBuffer::LODThresholdUniformBlockData* lodUniformMap = <span class="keyword">reinterpret_cast&lt;</span>DeferredGBuffer::LODThresholdUniformBlockData*<span class="keyword">&gt;</span>(m_LodUniforms[programName][m_LodsToDraw[programName][i].m_Index].m_pUniformBuffer-&gt;GetMappedPointer());</div>
<div class="line"> </div>
<div class="line">            lodUniformMap-&gt;SetUniform_u_lodThreshold(m_LodsToDraw[programName][i].m_Threshold);</div>
<div class="line">            lodUniformMap-&gt;SetUniform_u_lodMod(m_LodsToDraw[programName][i].m_Modifier);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::SetNumLODLevels</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Set the number of levels of detail.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::SetNumLodLevels(<span class="keywordtype">int</span> num)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(m_LodInfo.size() == 0, <span class="stringliteral">&quot;Resizing non-empty level of detail list&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    m_LodInfo.resize(num);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PBRObject::Object::TogglePolygonMode</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Toggles the polygon mode between solid polygons and</span></div>
<div class="line"><span class="comment"> * wire frame.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> Object::TogglePolygonMode()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_PolygonMode == <a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a>)</div>
<div class="line">    {</div>
<div class="line">        m_PolygonMode = <a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6af3cd1447b82255b8da2634591c040ed3">NVN_POLYGON_MODE_LINE</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        m_PolygonMode = <a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace PBRObject</span></div>
<div class="ttc" id="a_asset_file_data_holder_8h_html"><div class="ttname"><a href="_asset_file_data_holder_8h.html">AssetFileDataHolder.h</a></div><div class="ttdoc">This files defines some structures that hold the data provided by an asset file created by Tutorial02...</div></div>
<div class="ttc" id="a_p_b_r_model_binary_file_headers_8h_html"><div class="ttname"><a href="_p_b_r_model_binary_file_headers_8h.html">PBRModelBinaryFileHeaders.h</a></div><div class="ttdoc">This file defines the structure of the converted binary model files.</div></div>
<div class="ttc" id="a_p_b_r_object_8h_html"><div class="ttname"><a href="_p_b_r_object_8h.html">PBRObject.h</a></div><div class="ttdoc">This file defines some classes that handle the model and material data, uniform updating,...</div></div>
<div class="ttc" id="a_tutorial_util_8h_html"><div class="ttname"><a href="_tutorial_util_8h.html">TutorialUtil.h</a></div><div class="ttdoc">This file defines the interface for utility functions used in the tutorials.</div></div>
<div class="ttc" id="a_uniform_buffer_manager_8h_html"><div class="ttname"><a href="_uniform_buffer_manager_8h.html">UniformBufferManager.h</a></div><div class="ttdoc">This file defines a class that manages memory for uniform buffers by using multiple chunks of of GPU ...</div></div>
<div class="ttc" id="aclassnn_1_1util_1_1_vector3f_html"><div class="ttname"><a href="classnn_1_1util_1_1_vector3f.html">nn::util::Vector3f</a></div><div class="ttdoc">Class that expresses three-dimensional vectors using a single precision floating number type.</div><div class="ttdef"><b>Definition:</b> util_Vector.h:296</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gace820e752b400cf7aa36e9684a7f45cb"><div class="ttname"><a href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_ALIGNMENT</div><div class="ttdoc">Required base address alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4578</div></div>
<div class="ttc" id="agroup__nvn__c__defines_html_gadfd69601d2d9f953c55808127ba60853"><div class="ttname"><a href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a></div><div class="ttdeci">#define NVN_MEMORY_POOL_STORAGE_GRANULARITY</div><div class="ttdoc">Required size alignment for app-specified memory used to back memory pools.</div><div class="ttdef"><b>Definition:</b> nvn.h:4582</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ga99463f5b9af6151e604b01dfdd5fecab"><div class="ttname"><a href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a></div><div class="ttdeci">NVNformat</div><div class="ttdoc">Identifies how data elements stored in texture or buffer objects are encoded.</div><div class="ttdef"><b>Definition:</b> nvn.h:1175</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gaaf90e0c2dbdc1e42db8192f0c0cb1522"><div class="ttname"><a href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a></div><div class="ttdeci">NVNindexType</div><div class="ttdoc">Specifies a data type used for index values in DrawElements commands.</div><div class="ttdef"><b>Definition:</b> nvn.h:2232</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gab22437710b6816a67a1263d0087ded72"><div class="ttname"><a href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a></div><div class="ttdeci">NVNdrawPrimitive</div><div class="ttdoc">Specifies the type of primitive to render in draw calls.</div><div class="ttdef"><b>Definition:</b> nvn.h:2120</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gga99463f5b9af6151e604b01dfdd5fecaba282f468096b9b50cba1b5d85adae7bb9"><div class="ttname"><a href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba282f468096b9b50cba1b5d85adae7bb9">NVN_FORMAT_RG32F</a></div><div class="ttdeci">@ NVN_FORMAT_RG32F</div><div class="ttdoc">Two 32-bit floating-point components.</div><div class="ttdef"><b>Definition:</b> nvn.h:1244</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_gga99463f5b9af6151e604b01dfdd5fecababeba6c57385cda6b11aee8d9986f26db"><div class="ttname"><a href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecababeba6c57385cda6b11aee8d9986f26db">NVN_FORMAT_RGB32F</a></div><div class="ttdeci">@ NVN_FORMAT_RGB32F</div><div class="ttdoc">Three 32-bit floating-point components.</div><div class="ttdef"><b>Definition:</b> nvn.h:1280</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e"><div class="ttname"><a href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a></div><div class="ttdeci">@ NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</div><div class="ttdoc">Indicates that the memory pool will be accessed by the GPU with caching.</div><div class="ttdef"><b>Definition:</b> nvn.h:3069</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1"><div class="ttname"><a href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a></div><div class="ttdeci">@ NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</div><div class="ttdoc">Indicates that the memory pool will be accessed by the CPU without caching.</div><div class="ttdef"><b>Definition:</b> nvn.h:3008</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369"><div class="ttname"><a href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a></div><div class="ttdeci">@ NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</div><div class="ttdoc">Indicates that the memory pool will not be accessed by the CPU.</div><div class="ttdef"><b>Definition:</b> nvn.h:2992</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6"><div class="ttname"><a href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6">NVN_INDEX_TYPE_UNSIGNED_INT</a></div><div class="ttdeci">@ NVN_INDEX_TYPE_UNSIGNED_INT</div><div class="ttdoc">Index values are specified as 32-bit unsigned integers.</div><div class="ttdef"><b>Definition:</b> nvn.h:2241</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggab22437710b6816a67a1263d0087ded72a18aa4d68281faa9aaba87e6251ecdc24"><div class="ttname"><a href="group__nvn__c__enum.html#ggab22437710b6816a67a1263d0087ded72a18aa4d68281faa9aaba87e6251ecdc24">NVN_DRAW_PRIMITIVE_TRIANGLES</a></div><div class="ttdeci">@ NVN_DRAW_PRIMITIVE_TRIANGLES</div><div class="ttdoc">Renders a collection of independent triangles specified by groups of three vertices.</div><div class="ttdef"><b>Definition:</b> nvn.h:2140</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e"><div class="ttname"><a href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a></div><div class="ttdeci">@ NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</div><div class="ttdoc">Minimum alignment for control data in a command builder.</div><div class="ttdef"><b>Definition:</b> nvn.h:567</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c"><div class="ttname"><a href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a></div><div class="ttdeci">@ NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</div><div class="ttdoc">Minimum alignment for command data in a command builder.</div><div class="ttdef"><b>Definition:</b> nvn.h:564</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7"><div class="ttname"><a href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a></div><div class="ttdeci">@ NVN_SHADER_STAGE_VERTEX</div><div class="ttdoc">Specifies the vertex shader stage.</div><div class="ttdef"><b>Definition:</b> nvn.h:2688</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06"><div class="ttname"><a href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a></div><div class="ttdeci">@ NVN_SHADER_STAGE_FRAGMENT</div><div class="ttdoc">Specifies the fragment shader stage.</div><div class="ttdef"><b>Definition:</b> nvn.h:2691</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggae34b6e4f02d0dae7198337f940340ec6af3cd1447b82255b8da2634591c040ed3"><div class="ttname"><a href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6af3cd1447b82255b8da2634591c040ed3">NVN_POLYGON_MODE_LINE</a></div><div class="ttdeci">@ NVN_POLYGON_MODE_LINE</div><div class="ttdoc">Polygon primitives should be rasterized as outlines.</div><div class="ttdef"><b>Definition:</b> nvn.h:2599</div></div>
<div class="ttc" id="agroup__nvn__c__enum_html_ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91"><div class="ttname"><a href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a></div><div class="ttdeci">@ NVN_POLYGON_MODE_FILL</div><div class="ttdoc">Polygon primitives should be rasterized as filled polygons.</div><div class="ttdef"><b>Definition:</b> nvn.h:2602</div></div>
<div class="ttc" id="agroup__nvn__c__handle_html_ga067da3a838f115226c89fad655278f80"><div class="ttname"><a href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a></div><div class="ttdeci">uint64_t NVNbufferAddress</div><div class="ttdoc">GPU address of memory inside a buffer object.</div><div class="ttdef"><b>Definition:</b> nvn.h:434</div></div>
<div class="ttc" id="agroup__nvn__c__handle_html_gab7f10945ffe1f6161c87238c75ae411d"><div class="ttname"><a href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a></div><div class="ttdeci">uint64_t NVNcommandHandle</div><div class="ttdoc">GPU handle used to refer to a command buffer object.</div><div class="ttdef"><b>Definition:</b> nvn.h:437</div></div>
<div class="ttc" id="anamespacenn_1_1gfx_html_ad620d8208dd309eb7c4dd5973a6aeee5"><div class="ttname"><a href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a></div><div class="ttdeci">TMemoryPool&lt; TargetConfig::Variation &gt; MemoryPool</div><div class="ttdoc">The type definition representing a memory pool.</div><div class="ttdef"><b>Definition:</b> gfx_Types.h:116</div></div>
<div class="ttc" id="ann___assert_8h_html_ade59d1d911907a16c0241f8fe3b31542"><div class="ttname"><a href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a></div><div class="ttdeci">#define NN_ASSERT(condition,...)</div><div class="ttdoc">Tests whether a condition is satisfied.</div><div class="ttdef"><b>Definition:</b> nn_Assert.h:124</div></div>
<div class="ttc" id="anvn___func_ptr_inline_8h_html"><div class="ttname"><a href="nvn___func_ptr_inline_8h.html">nvn_FuncPtrInline.h</a></div><div class="ttdoc">Implementation of the NVN C interface entry points as inline functions that call through global funct...</div></div>
<div class="ttc" id="astruct_n_v_nbuffer_builder_html"><div class="ttname"><a href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a></div><div class="ttdoc">Object specifying state used to construct new buffer objects.</div><div class="ttdef"><b>Definition:</b> nvn.h:313</div></div>
<div class="ttc" id="astruct_n_v_ncommand_buffer_html"><div class="ttname"><a href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a></div><div class="ttdoc">Collection of commands to send to the GPU via queues.</div><div class="ttdef"><b>Definition:</b> nvn.h:236</div></div>
<div class="ttc" id="astruct_n_v_ndevice_html"><div class="ttname"><a href="struct_n_v_ndevice.html">NVNdevice</a></div><div class="ttdoc">API class used to represent a specific GPU/device.</div><div class="ttdef"><b>Definition:</b> nvn.h:221</div></div>
<div class="ttc" id="astruct_n_v_nvertex_attrib_state_html"><div class="ttname"><a href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a></div><div class="ttdoc">API state object controlling vertex attrib state.</div><div class="ttdef"><b>Definition:</b> nvn.h:274</div></div>
<div class="ttc" id="astruct_n_v_nvertex_stream_state_html"><div class="ttname"><a href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a></div><div class="ttdoc">API state object controlling vertex stream state.</div><div class="ttdef"><b>Definition:</b> nvn.h:279</div></div>
<div class="ttc" id="astructnn_1_1util_1_1_float_row_major4x4_html"><div class="ttname"><a href="structnn_1_1util_1_1_float_row_major4x4.html">nn::util::FloatRowMajor4x4</a></div><div class="ttdoc">Represents a four-row, four-column, row-major matrix using a single precision floating point array.</div><div class="ttdef"><b>Definition:</b> util_MathTypes.h:198</div></div>
<div class="ttc" id="astructnn_1_1util_1_1_matrix_row_major4x3f_type_html"><div class="ttname"><a href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">nn::util::MatrixRowMajor4x3fType</a></div><div class="ttdoc">Represents a four-row, three-column, row-major matrix using a single precision floating point data ty...</div><div class="ttdef"><b>Definition:</b> util_MathTypes.h:394</div></div>
<div class="ttc" id="astructnn_1_1util_1_1_matrix_row_major4x4f_type_html"><div class="ttname"><a href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">nn::util::MatrixRowMajor4x4fType</a></div><div class="ttdoc">Represents a four-row, four-column, row-major matrix using a single precision floating point data typ...</div><div class="ttdef"><b>Definition:</b> util_MathTypes.h:422</div></div>
<div class="ttc" id="astructnn_1_1util_1_1_vector3f_type_html"><div class="ttname"><a href="structnn_1_1util_1_1_vector3f_type.html">nn::util::Vector3fType</a></div><div class="ttdoc">Represents a three-dimensional vector using a single precision floating point data type.</div><div class="ttdef"><b>Definition:</b> util_MathTypes.h:306</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
