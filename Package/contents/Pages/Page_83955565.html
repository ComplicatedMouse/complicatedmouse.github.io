<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Semaphores | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Semaphores -->
<div class="pagetitle" id="PageId_83955565">Semaphores</div>
<div class="text_separate">
<h1 id="Anchor_83955565_h1_1">Semaphores</h1>
<h2 id="Anchor_83955565_h2_1">Overview</h2>
<p>A semaphore provides a feature to synchronize the different queues in the GPU in command buffer units.</p>
<p>Whether different queues can be used depends on the platform and the low level graphics API.  When use is not possible, the semaphore will not display this effect because the commands are executed in series.<br />For example, a semaphore is used to synchronize between queues when different queues can be used such as when a graphics queue starts rendering after a copy queue finishes copying data.</p>
<h2 id="Anchor_83955565_h2_2"> Information</h2>
<p>Semaphore information is defined as <span class="ApiLink_nn__gfx__SemaphoreInfo"><code>nn::gfx::SemaphoreInfo</code></span>.</p>
<h2 id="Anchor_83955565_h2_3">Object</h2>
<p>The semaphore object is defined as <span class="ApiLink_nn__gfx__Semaphore"><code>nn::gfx::Semaphore</code></span>.</p>
<h3 id="Anchor_83955565_h3_1">Initialization and Destruction</h3>
<p>Initializing and freeing the semaphore follows the method for ordinary <a href="../Pages/Page_83955654.html">objects</a>.</p>
<h2 id="Anchor_83955565_h2_4">Synchronizing With Semaphores</h2>
<p>Synchronization with semaphores is performed by a semaphore being set by the side that wants to have other queues wait for the command executed by the queue, and then the side that wants the other queues to wait for the executed command synchronizes the semaphores.</p>
<h3 id="Anchor_83955565_h3_2">Setting Side</h3>
<p>After submitting a command that the synchronization side is waiting to be executed to all queues, the command to set a semaphore is submitted to the queue by calling <span class="ApiLink_nn__gfx__Queue"><code>SetSemaphore</code></span> of the <span class="ApiLink_void_nn__gfx__TQueue__SetSemaphore(TSemaphore__Target___*pSemaphore)_NN_NOEXCEPT"><code>nn::gfx::Queue</code></span>. Standby for this semaphore means standing by until all these commands are executed by the GPU.</p>
<h3 id="Anchor_83955565_h3_3">Synchronization Side</h3>
<p>The command to wait for a semaphore is submitted to the queue by calling <span class="ApiLink_nn__gfx__Queue"><code>SyncSemaphore</code></span> of the <span class="ApiLink_void_nn__gfx__TQueue__SyncSemaphore(const_TSemaphore__Target___*pSemaphore)_NN_NOEXCEPT"><code>nn::gfx::Queue</code></span> with the semaphore to wait for set as an argument.</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__gfx__SemaphoreInfo', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_semaphore_info.html' )
SetUrl( 'ApiLink_nn__gfx__Semaphore', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#a03469e863b0fe9185e881eab4038ec36' )
SetUrl( 'ApiLink_nn__gfx__Queue', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#afceb1f20a49ed58f99e33f2324312e1b' )
SetUrl( 'ApiLink_void_nn__gfx__TQueue__SetSemaphore(TSemaphore__Target___*pSemaphore)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_queue.html#addd3611692651baf845e59aea793ad43' )
SetUrl( 'ApiLink_void_nn__gfx__TQueue__SyncSemaphore(const_TSemaphore__Target___*pSemaphore)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_queue.html#a1da4acc26498816ec0e2da483e8017b9' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
