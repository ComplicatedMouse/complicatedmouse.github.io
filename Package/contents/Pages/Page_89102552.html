<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>StandardAllocator | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- StandardAllocator -->
<div class="pagetitle" id="PageId_89102552">StandardAllocator</div>
<div class="text_separate">
<h1 id="Anchor_89102552_h1_1">StandardAllocator Class</h1>
<h2 id="Anchor_89102552_h2_1">Feature Overview</h2>
<p>The <span class="ApiLink_nn__mem__StandardAllocator"><code>StandardAllocator</code></span> class allocates and deallocates memory space.<br />It can allocate and deallocate memory much faster than a traditional heap. </p>
<p>The <span class="ApiLink_nn__mem__StandardAllocator"><code>StandardAllocator</code></span> class has the following member functions. For more information, see the API reference.</p>
<table class="wrapped" style="margin-left: 1.5em;">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_nn__mem__StandardAllocator__StandardAllocator(void_*addr|_size_t_size)_NN_NOEXCEPT">
          <code>StandardAllocator</code>
        </span>
      </td>
      <td>Constructor.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_nn__mem__StandardAllocator__~StandardAllocator()_NN_NOEXCEPT">
          <code>~StandardAllocator</code>
        </span>
      </td>
      <td>Destructor.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__Initialize(void_*addr|_size_t_size)_NN_NOEXCEPT">
          <code>Initialize</code>
        </span>
      </td>
      <td>Initializes the specified memory space to be managed by <code>StandardAllocator</code>.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__Finalize()_NN_NOEXCEPT">
          <code>Finalize</code>
        </span>
      </td>
      <td>Destroys the allocator.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_*_nn__mem__StandardAllocator__Allocate(size_t_size)_NN_NOEXCEPT">
          <code>Allocate</code>
        </span>
      </td>
      <td>Allocates memory space.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__Free(void_*addr)_NN_NOEXCEPT">
          <code>Free</code>
        </span>
      </td>
      <td>Frees memory space.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_*_nn__mem__StandardAllocator__Reallocate(void_*addr|_size_t_newSize)_NN_NOEXCEPT">
          <code>Reallocate</code>
        </span>
      </td>
      <td>Reallocates memory space of the specified size.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__ClearThreadCache()_const_NN_NOEXCEPT">
          <code>ClearThreadCache</code>
        </span>
      </td>
      <td>Clears empty regions cached for specific threads so the regions are available to all threads.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_size_t_nn__mem__StandardAllocator__GetSizeOf(const_void_*addr)_const_NN_NOEXCEPT">
          <code>GetSizeOf</code>
        </span>
      </td>
      <td>Gets the size of the specified allocated memory space.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_size_t_nn__mem__StandardAllocator__GetTotalFreeSize()_const_NN_NOEXCEPT">
          <code>GetTotalFreeSize</code>
        </span>
      </td>
      <td>
        <span style="color: rgb(85,85,85);">Gets the total amount of free space that exists in the allocator.</span>
      </td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_size_t_nn__mem__StandardAllocator__GetAllocatableSize()_const_NN_NOEXCEPT">
          <code>GetAllocatableSize</code>
        </span>
      </td>
      <td>
        <span style="color: rgb(85,85,85);">Gets the largest size that can be allocated from the allocator.</span>
      </td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__WalkAllocatedBlocks(WalkCallback_callback|_void_*userPtr)_const_NN_NOEXCEPT">
          <code>WalkAllocatedBlocks</code>
        </span>
      </td>
      <td>Invokes the callback functions of the allocated memory spaces in order.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_void_nn__mem__StandardAllocator__Dump()_const_NN_NOEXCEPT">
          <code>Dump</code>
        </span>
      </td>
      <td>Displays internal allocator data.</td>
    </tr>
    <tr>
      <td>
        <span class="ApiLink_AllocatorHash_nn__mem__StandardAllocator__Hash()_const_NN_NOEXCEPT">
          <code>Hash</code>
        </span>
      </td>
      <td>Generates a hash based on the internal allocator data.</td>
    </tr>
  </tbody>
</table>
<h2 id="Anchor_89102552_h2_2">Using StandardAllocator</h2>
<p>To begin, initialize <span class="ApiLink_nn__mem__StandardAllocator"><code>StandardAllocator</code></span>.<br />By passing memory regions that have already been allocated from a static array or operating system, and then initializing, you can manage the memory region provided with <code>StandardAllocator</code>.</p>
<p>In the following example, a static array is passed as the memory space.<br />By passing a static array to <code>StandardAllocator</code> and using the <code><span class="ApiLink_NN_ALIGNAS">NN_ALIGNAS</span></code> macro to set the alignment to 4 kibibytes (KiB) , you can use the entire space without any waste in <code>StandardAllocator</code>.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="cp">#include &lt;nn/mem.h&gt;
</span>
<span class="c1">// This example allocates a memory space of 32 MiB for StandardAllocator.
</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">MemoryHeapSize</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="c1">// By setting the alignment to 4 KiB, the entire space can be used in StandardAllocator without waste.
</span><span class="n">NN_ALIGNAS</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span> <span class="k">static</span> <span class="kt">char</span> <span class="n">heap</span><span class="p">[</span><span class="n">MemoryHeapSize</span><span class="p">];</span>
&nbsp;
<span class="nn">nn::mem::</span><span class="n">StandardAllocator</span> <span class="n">allocator</span><span class="p">;</span>
<span class="n">allocator</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">heap</span><span class="p">),</span> <span class="n">MemoryHeapSize</span><span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>The following example uses the virtual address memory management feature.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="cp">#include &lt;nn/mem.h&gt;
</span>
<span class="c1">// For example, use a virtual address space of 60 GiB.
</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">HeapRegisonSize</span> <span class="o">=</span> <span class="mi">60ull</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
&nbsp;
<span class="nn">nn::mem::</span><span class="n">StandardAllocator</span> <span class="n">allocator</span><span class="p">;</span>
<span class="n">allocator</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">HeapRegisonSize</span><span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>In cases where you use the virtual address memory management feature, note that the size to specify for the <code><em>size</em></code> parameter is the size of the virtual address space. As a result, it is possible to specify a size larger than the physical memory size.</p>
<p>For more information, see Virtual Address Memory Management Feature.</p>
<p>
  <br />
</p>
<p>After initialization, you can perform memory operations such as allocation and deallocation.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// This example allocates 64 bytes.
</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">Allocate</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// Allocation of the memory fails.
</span><span class="p">}</span>
&nbsp;
<span class="c1">// This example allocates 64 bytes with 4-KiB alignment.
</span><span class="kt">void</span><span class="o">*</span> <span class="n">alignedAddress</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">Allocate</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">address</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// Allocation of the memory fails.
</span><span class="p">}</span>
&nbsp;
<span class="c1">// Free the memory.
</span><span class="n">allocator</span><span class="p">.</span><span class="n">Free</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="n">allocator</span><span class="p">.</span><span class="n">Free</span><span class="p">(</span><span class="n">alignedAddress</span><span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>To stop using <code>StandardAllocator</code>, call <span class="ApiLink_void_nn__mem__StandardAllocator__Finalize()_NN_NOEXCEPT"><code>Finalize</code></span> to destroy the allocator.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">allocator</span><span class="p">.</span><span class="n">Finalize</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>For more information about other functions, see the API reference for each.</p>
<h2 id="Anchor_89102552_h2_3">Dump Format</h2>
<p>When the <span class="ApiLink_void_nn__mem__StandardAllocator__Dump()_const_NN_NOEXCEPT">Dump()</span> function is called, the allocator's internal data is displayed in the following XML format.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nt">&lt;heapinfo&gt;</span>
&nbsp;<span class="nt">&lt;total_pages&gt;</span>65536<span class="nt">&lt;/total_pages&gt;</span>
&nbsp;<span class="nt">&lt;pagesize&gt;</span>4096<span class="nt">&lt;/pagesize&gt;</span>
&nbsp;<span class="nt">&lt;max_allocatable_size&gt;</span>266780672<span class="nt">&lt;/max_allocatable_size&gt;</span>
&nbsp;<span class="nt">&lt;free_memory&gt;</span>266784760<span class="nt">&lt;/free_memory&gt;</span>
&nbsp;<span class="nt">&lt;system_memory&gt;</span>602112<span class="nt">&lt;/system_memory&gt;</span>
&nbsp;<span class="nt">&lt;allocated_memory&gt;</span>1048584<span class="nt">&lt;/allocated_memory&gt;</span>
&nbsp;<span class="nt">&lt;page_summary&gt;</span>+______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________@<span class="nt">&lt;/page_summary&gt;</span>
&nbsp;<span class="nt">&lt;spans&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252c2800000'</span> <span class="na">numPages=</span><span class="s">'145'</span> <span class="na">cls=</span><span class="s">'0'</span> <span class="na">status=</span><span class="s">'in_use_sys'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252c2891000'</span> <span class="na">numPages=</span><span class="s">'1'</span> <span class="na">cls=</span><span class="s">'0'</span> <span class="na">status=</span><span class="s">'in_use_sys'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252c2892000'</span> <span class="na">numPages=</span><span class="s">'1'</span> <span class="na">cls=</span><span class="s">'0'</span> <span class="na">status=</span><span class="s">'in_use_sys'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252c2893000'</span> <span class="na">numPages=</span><span class="s">'1'</span> <span class="na">cls=</span><span class="s">'1'</span> <span class="na">status=</span><span class="s">'in_use'</span> <span class="na">objects_count=</span><span class="s">'1'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252c2894000'</span> <span class="na">numPages=</span><span class="s">'65132'</span> <span class="na">cls=</span><span class="s">'0'</span> <span class="na">status=</span><span class="s">'on_freelist'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;span</span> <span class="na">start=</span><span class="s">'252d2700000'</span> <span class="na">numPages=</span><span class="s">'256'</span> <span class="na">cls=</span><span class="s">'0'</span> <span class="na">status=</span><span class="s">'in_use'</span> <span class="na">color=</span><span class="s">'#000000'</span> <span class="na">name=</span><span class="s">''</span><span class="nt">/&gt;</span>
&nbsp;<span class="nt">&lt;/spans&gt;</span>
&nbsp;<span class="nt">&lt;allocs&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;alloc</span> <span class="na">ptr=</span><span class="s">'252c2893000'</span> <span class="na">size=</span><span class="s">'8'</span><span class="nt">/&gt;</span>
&nbsp;&nbsp;<span class="nt">&lt;alloc</span> <span class="na">ptr=</span><span class="s">'252d2700000'</span> <span class="na">size=</span><span class="s">'1048576'</span><span class="nt">/&gt;</span>
&nbsp;<span class="nt">&lt;/allocs&gt;</span>
<span class="nt">&lt;/heapinfo&gt;</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>When the feature that provides a cache for every thread is used, more memory is allocated than would be expected for the actual number of times that space is allocated for cache, so when <code>Dump</code> is called, the allocated region shown in the <code>alloc</code> tag may be larger.</p>
<p>The following table shows the various elements.</p>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Tags</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>heapinfo</td>
      <td>Tag for the largest XML frame exported by <span class="ApiLink_void_nn__mem__NumberLineAllocator__Dump(uint64_t_offset|_int_factor)_const_NN_NOEXCEPT"><code>Dump()</code></span>.</td>
    </tr>
    <tr>
      <td>pagesize</td>
      <td>The unit used to manage memory in <code>StandardAllocator</code>.</td>
    </tr>
    <tr>
      <td>max_allocatable_size</td>
      <td>The maximum allocatable size. The same value as obtained from <span class="ApiLink_size_t_nn__mem__StandardAllocator__GetAllocatableSize()_const_NN_NOEXCEPT"><code>GetAllocatableSize()</code></span>.</td>
    </tr>
    <tr>
      <td>free_memory</td>
      <td>
        <span style="color: rgb(85,85,85);">The total amount of free memory.</span> The same value as obtained from <span class="ApiLink_size_t_nn__mem__StandardAllocator__GetTotalFreeSize()_const_NN_NOEXCEPT"><span style="color: rgb(85,85,85);"><code>GetTotalFreeSize()</code></span></span><span style="color: rgb(85,85,85);">.</span> </td>
    </tr>
    <tr>
      <td>system_memory</td>
      <td>The size of the memory managed by the allocator.</td>
    </tr>
    <tr>
      <td>allocated_memory</td>
      <td>The total size of allocated memory.</td>
    </tr>
    <tr>
      <td>page_summary</td>
      <td>
        <p>A string representing the state of the memory space being handled by the allocator, providing an easy way to check the state.</p>
        <p>Each character represents 1 MiB, and the type of the character indicates what percentage of the 1 MiB is being used as allocated space.</p>
      </td>
    </tr>
    <tr>
      <td>spans</td>
      <td>The tag that indicates the set of the various memory blocks within the allocator.</td>
    </tr>
    <tr>
      <td>span</td>
      <td>
        <p>Indicates the allocator state in <code>pagesize</code> units. Memory broken into a <code>pagesize</code> unit in <code>StandardAllocator</code> is called a <code>span</code>.</p>
        <p>The <code>span</code> start address is <code>start</code>.</p>
        <p>
          <code>numPages</code> is the size of <code>span</code>, divided by <code>pagesize</code>.</p>
        <p>
          <code>in_use</code> indicates whether the allocator is using memory. <code>span</code> becomes <code>yes</code> under the following states. It is <code>no</code> when the memory is free.</p>
        <ul>
          <li>It is managed memory.</li>
          <li>It is allocated.</li>
          <li>
            <code>StandardAllocator</code> is reserved as memory for allocation.</li>
        </ul>
        <p>
          <code>cls</code> is the class index, broken down by the <code>span</code> size. Under normal circumstances, users do not need to keep track of this information.</p>
        <p>
          <code>objects_count</code> is the number of memory blocks actually allocated to the user within <code>span</code>.</p>
        <p>
          <code>sys</code> indicates whether the memory is managed. When <code>yes</code>, memory is managed.</p>
        <p>
          <code>status</code> indicates which of the following states <code>span</code> is in.</p>
        <ul>
          <li>
            <code>in_use</code>: <code>span</code> is in use.</li>
          <li>
            <code>on_freelist</code>: Allocatable.</li>
          <li>
            <code>not_used</code>: Allocatable.</li>
          <li>
            <code>in_use_sys</code>: Already in use as a management space.</li>
        </ul>
        <p>The <code>on_freelist</code> and <code>not_used</code> managed states are different in <code>StandardAllocator</code>, but the user does not need to know.</p>
        <p>This information is not used by <code>color</code> and <code>name</code>. Under normal circumstances, users do not need to keep track of this information.</p>
      </td>
    </tr>
    <tr>
      <td>allocs</td>
      <td>This tag represents the collection of allocated memory blocks. If the cache feature is enabled for each thread, cached memory blocks are also represented by this tag.</td>
    </tr>
    <tr>
      <td>alloc</td>
      <td>
        <p>An allocated memory block.</p>
        <p>
          <code>ptr</code> points to the starting address for the allocation memory.</p>
        <p>
          <code>size</code> is the allocated size.</p>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code>page_summary</code> symbols represent the following states.</p>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Symbol</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>
        <p>_</p>
      </td>
      <td>No memory space has been allocated.</td>
    </tr>
    <tr>
      <td>.</td>
      <td>More than 0% but less than 12.5% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>:</td>
      <td>More than 12.5% but less than 25% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>-</td>
      <td>More than 25% but less than 37.5% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>=</td>
      <td>More than 37.5% but less than 50% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>+</td>
      <td>More than 50% but less than 62.5% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>*</td>
      <td>More than 62.5% but less than 75% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>#</td>
      <td>More than 75% but less than 87.5% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>%</td>
      <td>More than 87.5% but less than 100% of the space has been allocated.</td>
    </tr>
    <tr>
      <td>@</td>
      <td>The entire memory space has been allocated.</td>
    </tr>
  </tbody>
</table>
<h2 id="Anchor_89102552_h2_4">Cache For Every Thread</h2>
<p>
  <code>
    <span class="ApiLink_nn__mem__StandardAllocator">StandardAllocator</span>
  </code> can use the feature that provides a cache to every thread if <code>true</code> was specified for the <code><em>isCacheEnable</em></code> parameter when the <code><span class="ApiLink_void_nn__mem__StandardAllocator__Initialize(void_*addr|_size_t_size)_NN_NOEXCEPT">Initialize()</span></code> function or the constructor was called.</p>
<p>This feature provides a cache for every thread, which speeds things up when <code>StandardAllocator</code> is being used in multiple threads because allocation and deallocation of memory blocks is lock-free.</p>
<p>One TLS slot is consumed to manage the cache for every thread.</p>
<p>When the feature that provides a cache to every thread has been enabled, memory blocks are allocated and freed some 2 to 10 times faster during multithreading. The actual speed depends on the pattern of memory allocation and deallocation.</p>
<h3 id="Anchor_89102552_h3_1">Detailed Specifications</h3>
<p>The following specific numbers and behaviors may change in future updates. Take note of this.</p>
<p>When <span class="ApiLink_void_*_nn__mem__StandardAllocator__Allocate(size_t_size)_NN_NOEXCEPT"><code>Allocate()</code></span> is called from a thread, if the size of the allocation request is less than the standard size defined by <span class="ApiLink_nn__mem__StandardAllocator"><code>StandardAllocator</code></span>, a prescribed number of memory blocks of the same total size are cached.</p>
<p>When <code><span class="ApiLink_void_nn__mem__StandardAllocator__Free(void_*addr)_NN_NOEXCEPT">Free()</span></code> is called, if the size of the memory blocks being freed is less than or equal to 1752 bytes, the freed memory blocks are temporarily cached and can only be allocated from that thread. Depending on the platform and the size of the address space, regions larger than 1,752 bytes may also potentially be cached in this space when freed, but the maximum cache size (described later) will never be exceeded.</p>
<p>
  <span class="ApiLink_void_*_nn__mem__StandardAllocator__Allocate(size_t_size)_NN_NOEXCEPT">When <code>Allocate()</code></span> is called, memory is allocated preferentially from those cached memory blocks.</p>
<p>This cached memory appears in the <code>allocs</code> tag when <span class="ApiLink_void_nn__mem__StandardAllocator__Dump()_const_NN_NOEXCEPT"><code>Dump()</code></span> is called. As a result, when the caching feature is enabled, the number of allocated memory blocks displayed when <span class="ApiLink_void_nn__mem__StandardAllocator__Dump()_const_NN_NOEXCEPT"><code>Dump()</code></span> is called may appear to be larger than the number corresponding to the actual number of calls to <span class="ApiLink_void_*_nn__mem__StandardAllocator__Allocate(size_t_size)_NN_NOEXCEPT"><code>Allocate()</code></span>.</p>
<p>There is a limit on the total size of the memory blocks cached by all of the threads. The limit changes dynamically depending on the number of running threads and size of the memory space allocated to <code>StandardAllocator</code>, but it never exceeds 2 MiB.</p>
<p>In addition, the total size of memory cached by any one thread never exceeds 12.5 percent of the size of the memory space allocated to <code>StandardAllocator</code>.</p>
<p>If the total size of the cached memory blocks exceeds this limit, the memory blocks of the size occupying the most space will be freed to become allocatable by any of the threads.</p>
<p>Consider the case where ten 16-byte memory blocks, three 64-byte memory blocks, and one 128-byte memory block are cached, exceeding the upper limit. The three 64-byte memory blocks are occupying the most space (because 16 * 10 = 160, 64 * 3 = 192, and 128 * 1 = 128) so they will be freed to become allocatable by any of the threads.</p>
<p>An alternate approach is to call <code><span class="ApiLink_void_nn__mem__StandardAllocator__ClearThreadCache()_const_NN_NOEXCEPT">ClearThreadCache()</span></code> to free all memory blocks so they all become available to all of the threads.</p>
<p>When a thread ends, the memory blocks cached by that thread are freed and become available to all of the other threads.</p>
<h2 id="Anchor_89102552_h2_5">Virtual Address Memory Management Feature</h2>
<div class="platform_nx">
  <div class="info_new">
    <div class="info_new_left">Info</div>
    <div class="info_new_right">
      <p>You must configure the NMETA settings to use virtual address memory. For more information, see <a href="../Pages/Page_83956147.html#Anchor_83956147_platform_info">NX Platform-Specific Information</a> in <a href="../Pages/Page_83956147.html">Memory Management</a>.</p>
    </div>
  </div>
</div>
<p>When <code>nullptr</code> is passed to the <code><em>addr</em></code> parameter of <span class="ApiLink_void_nn__mem__StandardAllocator__Initialize(void_*addr|_size_t_size)_NN_NOEXCEPT">Initialize()</span> and initialization is performed, the virtual address memory management feature is used inside <code>StandardAllocator</code> to dynamically allocate and free the required physical memory.</p>
<p>In such cases, take note that the size to specify to the <code><em>size</em></code> parameter is the size of the virtual address space. As a result, it is possible to specify a size larger than the physical memory size.</p>
<div class="platform_nx">
  <div class="info_new">
    <div class="info_new_left">Info</div>
    <div class="info_new_right">
      <p>The larger the size specified, the larger the allocatable space will be, which may result in the restriction of allocation fails due to memory fragmentation. However, for the NX platform, the region consumed by the operating system as system resources also increases by that amount. For more information, see <a href="../Pages/Page_83956147.html">Memory Management</a>.</p>
    </div>
  </div>
</div>
<p>For more information about the maximum size that can actually be specified, see the description in the <span class="ApiLink_nn__Result_nn__os__AllocateAddressRegion(uintptr_t_*pOutAddress|_size_t_size)_NN_NOEXCEPT"><code>nn::os::AllocateAddressRegion()</code></span> API reference.</p>
<p>When the virtual address memory management feature is enabled, although it may be possible to restrict allocation failures due to memory fragmentation, execution efficiency might be reduced because <code>os</code> library functions are called during allocation as needed.</p>
<p>
  <br />
</p>
<p>In <code>StandardAllocator</code>, assigning and removing physical memory for the virtual address space is performed for regions split into 4 MB each. This specification could be changed in a future update.</p>
<h2 id="Anchor_89102552_h2_6">Notes About Using StandardAllocator</h2>
<h3 id="Anchor_89102552_h3_2">Using ExpHeap</h3>
<p>From the perspective of the speed of allocation and deallocation, we generally recommend using <code>StandardAllocator</code> over <a href="../Pages/Page_89098776.html">ExpHeap</a>. In the following cases, however, we recommend using <a href="../Pages/Page_89098776.html">ExpHeap</a>.</p>
<ul>
  <li>The allocated region is nearly completely used, except for a few kibibytes.</li>
  <li>The heap experiences very few allocations and deallocations (less than ten) after it is created.</li>
</ul>
<h3 id="Anchor_89102552_h3_3">Management Space Size</h3>
<p>
  <span class="ApiLink_nn__mem__StandardAllocator">
    <code>StandardAllocator</code>
  </span> requires a management space of at least 16 KiB for overall management of the allocator.<br />The management space grows along with the size of the memory space being managed, but the percentage used by the management space decreases as the size grows larger.</p>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Size of Memory Space</th>
      <th>Size of Management Space (64-Bit)</th>
      <th>Percentage Used by Management Space</th>
    </tr>
    <tr>
      <td>64 KiB</td>
      <td>16 KiB</td>
      <td>25%</td>
    </tr>
    <tr>
      <td>2 MiB</td>
      <td>20 KiB</td>
      <td>0.97%</td>
    </tr>
    <tr>
      <td>1 GiB</td>
      <td>2 MiB</td>
      <td>
        <p>0.22%</p>
      </td>
    </tr>
  </tbody>
</table>
<p>As a general guide, the following expressions are for calculating a management space approximately the size of the space used when the Windows <code>StandardAllocator</code> class is initialized.</p>
<ul>
  <li>32-bit environment:<ul><li>A = 1456 + 5 * (size of memory space to manage / 4096)</li><li>Size of memory space to manage (initial state) = A (rounded up to multiple of 4096) + 8192</li></ul></li>
  <li style="list-style-type: none;">64-bit environment:<ul><li>B = 2840 + 9 * (size of memory space to manage / 4096)</li><li>Size of memory space to manage (initial state) = B (rounded up to multiple of 4096) + 8192</li></ul></li>
</ul>
<p>These sizes are approximate. The management space is larger or smaller, depending on the platform, the state of memory allocation, and whether the feature that provides a cache for every thread is enabled.</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__mem__StandardAllocator', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html' )
SetUrl( 'ApiLink_nn__mem__StandardAllocator__StandardAllocator(void_*addr|_size_t_size)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a1e3efc1b684befdaa9d3ea4c08fc8c23' )
SetUrl( 'ApiLink_nn__mem__StandardAllocator__~StandardAllocator()_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a254da7aa9f98eb4947ce540c28727644' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__Initialize(void_*addr|_size_t_size)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__Finalize()_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419' )
SetUrl( 'ApiLink_void_*_nn__mem__StandardAllocator__Allocate(size_t_size)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__Free(void_*addr)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318' )
SetUrl( 'ApiLink_void_*_nn__mem__StandardAllocator__Reallocate(void_*addr|_size_t_newSize)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a83b6984b5dac190453d450e819041633' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__ClearThreadCache()_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08' )
SetUrl( 'ApiLink_size_t_nn__mem__StandardAllocator__GetSizeOf(const_void_*addr)_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a45744a752336aa336842674bdccb4210' )
SetUrl( 'ApiLink_size_t_nn__mem__StandardAllocator__GetTotalFreeSize()_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#ad236cc9a53ffcaa18e94ec1432fa5c68' )
SetUrl( 'ApiLink_size_t_nn__mem__StandardAllocator__GetAllocatableSize()_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__WalkAllocatedBlocks(WalkCallback_callback|_void_*userPtr)_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b' )
SetUrl( 'ApiLink_void_nn__mem__StandardAllocator__Dump()_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#a644b9a162b9b8bf22a3e429966e53c9f' )
SetUrl( 'ApiLink_AllocatorHash_nn__mem__StandardAllocator__Hash()_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_standard_allocator.html#af6de9d17a7aaa6f54e95a3125a96dbda' )
SetUrl( 'ApiLink_NN_ALIGNAS', '../../../Api/HtmlNX/nn___macro_8h.html#a6ce9d4b07ab8bec971ac8875873615b5' )
SetUrl( 'ApiLink_void_nn__mem__NumberLineAllocator__Dump(uint64_t_offset|_int_factor)_const_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1mem_1_1_number_line_allocator.html#ad1aac471cf6647dda3771c2149ff8e6a' )
SetUrl( 'ApiLink_nn__Result_nn__os__AllocateAddressRegion(uintptr_t_*pOutAddress|_size_t_size)_NN_NOEXCEPT', '../../../Api/HtmlNX/namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
