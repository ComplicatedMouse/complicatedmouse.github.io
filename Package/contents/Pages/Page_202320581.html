<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Tool Manual | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Tool Manual -->
<div class="pagetitle" id="PageId_202320581">Tool Manual</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_202320581_h1_1">Introduction</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_202320581_h2_1">Overview</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_202320581_h1_2">How to Use</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_202320581_h2_2">How to Run</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_3">Command Options</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_202320581_h1_3">Notes When Converting Shaders for NX</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_202320581_h2_4">Differences in Matrix Definitions</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_5">Support for DirectX Effect Files</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_6">Passing Parameters Between Shaders</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_7">Uniform Variable Binding</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_8">Attribute Binding and the Config File</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_9">Batch Processing</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_10">Batch Processing of Effect Files</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_11">Binding to Locations Inside UniformBlock</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_12">UniformBlock Binding and the Config File</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_13">Specifying the Sampler Type in the Config File</a>
      </li>
      <li>
        <a href="#Anchor_202320581_h2_14">GLSL Texture Samplers</a>
      </li>
    </ul>
  </ul>
</p>
<h1 id="Anchor_202320581_h1_1">Introduction</h1>
<h2 id="Anchor_202320581_h2_1">Overview</h2>
<p>This section describes how to use SLConverter.</p>
<h1 id="Anchor_202320581_h1_2">How to Use</h1>
<h2 id="Anchor_202320581_h2_2">How to Run</h2>
<p>Run the tool as follows.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter.exe [options] input-filename</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<ul style="list-style-type: square;">
  <li>
    <code>input-filename</code> is the HLSL shader file that will be converted.</li>
  <li>You can use a wildcard character (like the * in <code>*.fx</code> or <code>*.hlsl</code>) to specify this file.</li>
  <li>The options are case-sensitive.</li>
</ul>
<p>
  <br />
</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>
      <code>SlConverter.exe</code> is located in the following directory.</p>
    <p>
      <code>$NINTENDO_SDK_ROOT/Tools/Graphics/GraphicsTools/SlConverter.exe</code>
    </p>
  </div>
</div>
<h2 id="Anchor_202320581_h2_3">
  <br />Command Options</h2>
<p>You can run the tool with one or more of the following options.</p>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Option</th>
      <th>
        <p>Description</p>
      </th>
    </tr>
    <tr>
      <td>-b</td>
      <td>Disables the GLSL feature to bind uniforms. (Enabled by default.)</td>
    </tr>
    <tr>
      <td>-c &lt;config filename&gt;</td>
      <td>Specifies the config filename. (In the default setting, a config file is not used.)</td>
    </tr>
    <tr>
      <td>-D &lt;macro name&gt;</td>
      <td>
        <p>Defines a preprocessor macro. You can also pass a value in this option.</p>
        <p>
          <br />
        </p>
        <ul style="list-style-type: square;">
          <li>Example without a value: <code>-D MYDEFINE</code></li>
          <li>Example with a value: <code>-D MYDEFINE=10</code></li>
        </ul>
        <p>
          <br />
        </p>
        <p>To define multiple macros, you must use a separate <code>-D</code> option for each.</p>
        <p>Example: <code>-D MYDEFINE1 -D MYDEFINE2=3</code>.</p>
      </td>
    </tr>
    <tr>
      <td>-e &lt;main function name&gt;</td>
      <td>Specifies the name for the main function of the shader.</td>
    </tr>
    <tr>
      <td>-s &lt;vs, ps&gt;</td>
      <td>
        <p>Specifies the shader type. Specify one of the following.</p>
        <ul style="list-style-type: square;">
          <li>
            <code>vs</code>: Vertex shader</li>
          <li>
            <code>ps</code>: Pixel shader</li>
        </ul>
        <p>The default is a <code>vs</code> type shader.</p>
        <p>
          <br />
        </p>
        <p>You can also specify the shader model, as follows.</p>
        <ul style="list-style-type: square;">
          <li>vs_3_0: Vertex shader (Shader Model 3.0)</li>
          <li>vs_4_0: Vertex shader (Shader Model 4.0)</li>
          <li>vs_5_0: Vertex shader (Shader Model 5.0)</li>
          <li>ps_3_0: Pixel shader (Shader Model 3.0)</li>
          <li>ps_4_0: Pixel shader (Shader Model 4.0)</li>
          <li>ps_5_0: Pixel shader (Shader Model 5.0)</li>
        </ul>
        <p>Shader Model 3.0 is used by default for the conversion if nothing is specified.</p>
      </td>
    </tr>
    <tr>
      <td>-i</td>
      <td>Specifies the use of the HLSL shader's original <code>semantic</code> names for the <code>varying</code> variables that are passed from the vertex shader to the pixel shader.</td>
    </tr>
    <tr>
      <td>-I &lt;name of include directory&gt;</td>
      <td>
        <p>Specifies the name of the directory or directories with the files that will be included when the shader is compiled.</p>
        <p>To specify more than one directory, separate the names using semicolons (;).</p>
      </td>
    </tr>
    <tr>
      <td>-h</td>
      <td>Displays Help messages.</td>
    </tr>
    <tr>
      <td>-l</td>
      <td>Disables the specification of location for <code>varying</code> variables. (Enabled by default.)</td>
    </tr>
    <tr>
      <td>-m</td>
      <td>Disables the reversal of the order of matrix multiplication operations. (Enabled by default.)</td>
    </tr>
    <tr>
      <td>-o &lt;name of the output GLSL file&gt;</td>
      <td>
        <p>Specifies the name of the file that will be output. (By default, the file is output with the same name as the file that was input, but with the filename extension changed to <code>.glsl</code>)</p>
        <p>
          <br />
        </p>
        <p>You can also specify a pattern for the output file.</p>
        <p>$0 = Input hlsl filename without extension.</p>
        <p>$1 = Shader method name</p>
        <p>$2 = Directory of input HLSL file</p>
        <p>
          <br />
        </p>
        <p>For example, if you specify <code>$0_$1.glsl</code> and then convert the shader named <code>MainVS</code> in <code>sample.fx</code>, the output file will be named <code>sample_MainVS.glsl</code>.</p>
        <p />
      </td>
    </tr>
    <tr>
      <td>-p</td>
      <td>Uses the texture coordinates in the pixel shader (the semantic is <code>TEXCOORD</code>) for the <code>gl_PointCoord</code> variable.</td>
    </tr>
    <tr>
      <td>-v &lt;GL,None&gt;</td>
      <td>
        <p>Compiles the converted shader for validation. Specify one of the following.</p>
        <ul style="list-style-type: square;">
          <li>
            <code>GL</code>: Use the standard GLSL compiler.</li>
          <li>
            <code>NONE</code>: Do not compile for validation.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>-t</td>
      <td>
        <p>Use multithreading for parallel compilation of multiple shaders. (Disabled by default.)</p>
      </td>
    </tr>
    <tr>
      <td>-V &lt;true,false&gt;</td>
      <td>Specifies whether to display log messages. (Enabled by default.)</td>
    </tr>
    <tr>
      <td>-r</td>
      <td>Searches for files recursively. (Disabled by default.)</td>
    </tr>
    <tr>
      <td>-n</td>
      <td>Converted shaders are not compiled.</td>
    </tr>
    <tr>
      <td>-z</td>
      <td>Generates code to convert the z-coordinate of projection space from [-1,1] to [0,1] in the vertex shader.</td>
    </tr>
    <tr>
      <td>--builtin &lt;VALUE&gt;</td>
      <td>
        <p>The specified function name is output without any change when HLSL is converted to GLSL.</p>
        <p>
          <br />
        </p>
        <p>Example: <code>--builtin &quot;float4 texture4(sampler xxx,float2 pos);&quot;</code></p>
        <p>In the preceding example, the function defined with the name <code>texture4</code> in HLSL is ignored when the HLSL is converted to GLSL.</p>
        <p>The function is output as a function already in the GLSL.</p>
      </td>
    </tr>
    <tr>
      <td>@ &lt;list file&gt;</td>
      <td>
        <div class="content-wrapper">
          <p>Specifies a file that contains a list of the files you want to convert.</p>
          <p>
            <br />
          </p>
          <p>For example, say that you enter the following command.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>SlConverter.exe @listfile.txt</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            <br />
          </p>
          <p>In addition, assume that <code>listfile.txt</code> has the following content.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>MyShader1.hlsl#main#vs#MyShader.glsl
MyEffect.fx</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>In this case, the option would have the same effect as running the following commands. But it can be faster because it eliminates superfluous processes.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>SlConverter.exe MyShader1.hlsl -e main -s vs -o MyShader.glsl
SlConverter.exe MyEffect.fx</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </td>
    </tr>
    <tr>
      <td>--maptype NAME=TYPE</td>
      <td>
        <p>Forcibly converts the sampler specified by <code>NAME</code> to a specific sampler type.</p>
        <p>
          <br />
        </p>
        <p>Example: <code>--maptype ShadowSampler=sampler2DShadow</code>.</p>
        <p>
          <br />
        </p>
        <p>When the HLSL is converted to GLSL with this option and this specification, the sampler named ShadowSampler is converted to <code>uniform sampler2DShadow ShadowSampler</code>;.</p>
        <p />
        <p> (Normally it would be converted as <code>sampler2D</code>.)</p>
      </td>
    </tr>
    <tr>
      <td>-savegsh</td>
      <td>Outputs the compiled binary to a GSH file.</td>
    </tr>
  </tbody>
</table>
<h1 id="Anchor_202320581_h1_3">
  <br />Notes When Converting Shaders for NX</h1>
<h2 id="Anchor_202320581_h2_4">Differences in Matrix Definitions</h2>
<p>Matrix definitions like <code>float4x4</code> are row-major in HLSL, but column-major in GLSL.</p>
<p>If you were to simply change how rows and columns are written, binding indexes would become misaligned when you use features like explicit uniform binding.</p>
<p>When SLConverter converts HLSL to GLSL, it reverses the order of matrix and vector calculations, so the matrix settings do not need to be changed in the application.</p>
<p>You can disable this process of reversing the order using the <code>-m</code> option.</p>
<h2 id="Anchor_202320581_h2_5">Support for DirectX Effect Files</h2>
<p>DirectX has a file known as an <em>effect file</em> that can change the compilation, the techniques, and the shader used for each render pass.</p>
<p>OpenGL basically has no such system.</p>
<p>SLConverter supports DirectX effect files. If the input file is an FX file (with the <code>.fx</code> filename extension), the data in that file for various techniques and for the shader to use for each pass are written out to separate files and converted.</p>
<h2 id="Anchor_202320581_h2_6">Passing Parameters Between Shaders</h2>
<p>In HLSL, parameters are passed between shaders using semantics.</p>
<p>GLSL does not have a feature comparable to semantics and parses the parameters using their names.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>struct VSOut
{
&nbsp;&nbsp;&nbsp;&nbsp;float2 texCoord : TEXCOORD0;
};

VSOut VS_Main(...)
{
&nbsp;&nbsp;&nbsp;&nbsp;VSOut Out;
&nbsp;&nbsp;&nbsp;&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;return Out;
}

struct PSIn
{
&nbsp;&nbsp;&nbsp;&nbsp;float2 uv : TEXCOORD0;
};

float4 PS_Main( PSIn In ) : COLOR
{
&nbsp;&nbsp;&nbsp;&nbsp;:
&nbsp;&nbsp;&nbsp;&nbsp;:
}</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>In this sample of HLSL code, the <code>VSOut</code> variable <code>texCoord</code> and the <code>PSIn</code> variable <code>uv</code> are named differently but they have the same semantic, so the passing can be parsed.</p>
<p>GLSL does not have anything comparable to semantics, so the names of <code>varying</code> variables (or <code>in</code>, <code>out</code> variables) must match.</p>
<p>With SLConverter, you can use the <code>-i</code> option to assign locations to variables based on the semantics in the original HLSL.</p>
<p>As a result, even if a name is different in the <code>VertexShader</code> and <code>PixelShader</code> classes, if the semantic is the same the variable will be passed correctly between shaders when output in GLSL.</p>
<h2 id="Anchor_202320581_h2_7">Uniform Variable Binding</h2>
<p>In HLSL, uniform variables can be allocated explicitly.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>float4x4 u_modelMtx : WORLD : register(c0)</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>GLSL does not have this kind of feature, but there is an extension for explicitly specifying the locations of uniforms.</p>
<p>SLConverter uses this extension by default when it converts shaders.</p>
<p>You can disable this feature with the <code>-b</code> option.</p>
<p>With HLSL, it is all right to allocate uniforms for only some variables, but in GLSL for the NX, if you are allocating uniforms, you must allocate all uniforms.</p>
<p>When SLConverter converts HLSL to GLSL, any variables in the original HLSL that have not been explicitly allocated register numbers will be allocated registers automatically from the available numbers.</p>
<h2 id="Anchor_202320581_h2_8">Attribute Binding and the Config File</h2>
<p>In HLSL, <code>VertexShader</code> input with vertex data set by the application is bound using semantics. GLSL does not have this kind of system.</p>
<p>With SLConverter, you can use the config file to explicitly specify which attribute to assign to the original HLSL vertex data in the converted GLSL.</p>
<p>The config file is an XML file with the following format.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;? &gt;
&lt;config&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;layout semantic=&quot;POSITION&quot; name=&quot;a_Position&quot; location=&quot;0&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;layout semantic=&quot;POSITION0&quot; name=&quot;a_Position0&quot; location=&quot;0&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;layout semantic=&quot;TEXCOORD&quot; name=&quot;a_TexCoord&quot; location=&quot;5&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;layout semantic=&quot;TEXCOORD0&quot; name=&quot;a_TexCoord0&quot; location=&quot;5&quot; /&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;layout semantic=&quot;TEXCOORD1&quot; name=&quot;a_TexCoord1&quot; location=&quot;6&quot; /&gt;
&lt;/config&gt;</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code>&lt;config&gt;</code> element is the root, and below that you can place <code>&lt;layout&gt;</code> elements. (You can specify one or multiple elements.)</p>
<p>You can specify the following attributes for these <code>&lt;layout&gt;</code> elements.</p>
<table class="wrapped">
  <tbody>
    <tr>
      <th>Attribute Name</th>
      <th>
        <p>Description</p>
      </th>
    </tr>
    <tr>
      <td>semantic</td>
      <td>The semantic for the vertex input in the original HLSL.</td>
    </tr>
    <tr>
      <td>name</td>
      <td>The name of the attribute in GLSL after conversion.</td>
    </tr>
    <tr>
      <td>
        <p>location</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>The location of the attribute in GLSL after conversion.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>&lt;layout semantic=&quot;POSITION&quot; name=&quot;a_Position&quot; location=&quot;0&quot; /&gt;</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>When the config file is set this way, the vertex input for which the <code>POSITION</code> semantic was specified in the original HLSL takes the attribute named <code>a_Position</code> bound to location 0 after conversion to GLSL.</p>
          <p />
        </div>
      </td>
    </tr>
    <tr>
      <td>locationString</td>
      <td>
        <div class="content-wrapper">
          <p>The location of the attribute in GLSL after conversion.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>&lt;layout semantic=&quot;POSITION&quot; name=&quot;a_Position&quot; locationString=&quot;LOCATION_POSITION&quot; /&gt;</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>When the config file is set this way, the converted shader is output as follows.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>layout(location = LOCATION_POSITION) in vec4 a_Position;</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>If a string has been specified for <code>locationString</code>, the GLSL compilation check generates an error when SLConverter runs.</p>
          <p>The conversion to GLSL will proceed, but the specified string will not be parsed.</p>
          <p>
            <br />
          </p>
          <p>The assumption is that the use will code something like the following after <code>#version</code> or <code>#extension</code>.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>#define LOCATION_POSITION 0</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>In this way, the user's C++ code will be consistent with the location in the shader.</p>
        </div>
      </td>
    </tr>
  </tbody>
</table>
<h2 id="Anchor_202320581_h2_9">Batch Processing</h2>
<p>Depending on the project, there may be thousands of HLSL files to convert to GLSL.</p>
<p>It would be extremely time-consuming to enter commands and convert each file individually, but SLConverter supports using a wildcard character to input filenames for batch processing.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter *.hlsl</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>By calling the tool in this way, all files with the <code>.hlsl</code> filename extension can be converted.</p>
<p>To shorten the time it takes to convert a large number of files, you can use the <code>-t</code> option as follows to use multithreading for parallel processing. This can shave a considerable amount of time off the task.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter -t *.hlsl</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>To search directories recursively for files to convert, use the <code>-r</code> option.</p>
<p>You can also do this by using <code>**</code> for the filename.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter -r *.hlsl
SlConverter **.hlsl</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>In these examples, a recursive search if made for any file with the <code>.hlsl</code> filename extension and all files that are found are converted.</p>
<h2 id="Anchor_202320581_h2_10">Batch Processing of Effect Files</h2>
<p>When the main entry-point function has not been specified or the input file is a DirectX effect file, the data in that file for the various techniques and for the shaders to use for each pass are written out to separate files and converted.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>// sample.fx
Technique Tech0
{
&nbsp;&nbsp;&nbsp;&nbsp;Pass Pass0
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VertexShader = compile vs_1_1 Tech0_VS();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelShader  = compile ps_1_1 Tech0_PS();
&nbsp;&nbsp;&nbsp;&nbsp;}
}

Technique Tech1
{
&nbsp;&nbsp;&nbsp;&nbsp;Pass Pass1
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VertexShader = compile vs_1_1 Tech1_VS();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelShader = compile ps_1_1 Tech1_PS();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>When the effect file <code>sample.fx</code> is specified as shown in the preceding sample code, the following files are output.</p>
<ul style="list-style-type: square;">
  <li>Sample_Tech0_VS.glsl</li>
  <li>Sample_Tech0_PS.glsl</li>
  <li>Sample_Tech1_VS.glsl</li>
  <li>Sample_Tech1_PS.glsl</li>
</ul>
<p>
  <br />
</p>
<p>You could also output any single shader in a file to any other file. (You can specify this multiple times.)</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>&lt;Filename&gt;#&lt;entrypoint&gt;#&lt;stage&gt;#&lt;output destination file&gt;</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>You can convert multiple shaders all at the same time as a batch process by writing the commands in this order, separating each with the # symbol.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter.exe sample.fx#SimpleVS#vs#vs.glsl sample.fx#SimplePS#ps#ps.glsl</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>This set of commands has the same result as executing the following commands twice. The batch process is faster.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>SlConverter.exe sample.fx -e SimpleVS -s vs -o vs.glsl
SlConverter.exe sample.fx -e SimplePS -s ps -o ps.glsl</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<h2 id="Anchor_202320581_h2_11">Binding to Locations Inside UniformBlock</h2>
<p>With HLSL, you can explicitly set the offset for each variable in the constant buffer.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>cbuffer cbChangesEveryFrame
{
&nbsp;&nbsp;&nbsp;&nbsp;matrix World : packoffset(c0);
&nbsp;&nbsp;&nbsp;&nbsp;float hoge : packoffset(c4.x);
&nbsp;&nbsp;&nbsp;&nbsp;float4 vMeshColor : packoffset(c5);
};</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The converted GLSL looks like this:</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>uniform cbChangesEveryFrame {
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 0) mat4 World ;
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 64) float hoge ;
&nbsp;&nbsp;&nbsp;&nbsp;layout(location = 80) vec4 vMeshColor ;
};</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>But note that whereas you can specify the middle portion of a single register as follows with HLSL, you cannot do the same with GLSL, so SLConverter does not support it either.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>cbuffer cbChangesEveryFrame
{
&nbsp;&nbsp;&nbsp;&nbsp;matrix World : packoffset(c0);
&nbsp;&nbsp;&nbsp;&nbsp;float hoge : packoffset(c4.y);
&nbsp;&nbsp;&nbsp;&nbsp;float4 vMeshColor : packoffset(c5);
};</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>If your HLSL has coding similar to the preceding example, you must rewrite the HLSL.</p>
<h2 id="Anchor_202320581_h2_12">UniformBlock Binding and the Config File</h2>
<p>With SLConverter, you can use the config file to explicitly specify the location to allocate to the original HLSL ConstantBuffer location in the converted GLSL.</p>
<p>Consider a config file set as follows:</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;? &gt;
&lt;config&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;cbuffer register=&quot;colors&quot; binding=&quot;COLORS&quot; /&gt;
&lt;/config&gt;</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>cbuffer cbColors : register( colors )
{
&nbsp;&nbsp;&nbsp;&nbsp;float4 color0;
&nbsp;&nbsp;&nbsp;&nbsp;float4 color1;
};</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The converted GLSL would look like this:</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>layout(binding = COLORS) uniform cbColors {
&nbsp;&nbsp;&nbsp;&nbsp;vec4 color0;
&nbsp;&nbsp;&nbsp;&nbsp;vec4 color1;
};</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The assumption is that inputs like <code>COLORS</code> are #defined in the user application.</p>
<h2 id="Anchor_202320581_h2_13">Specifying the Sampler Type in the Config File</h2>
<p>If the config file is written as follows, an individual sampler can be forcibly converted to any type.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>&lt;map name=&quot;shadowSampler&quot; type=&quot;sampler2DShadow&quot; /&gt;</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>With these settings, a sampler named <code>shadowSampler</code> in the HLSL will be converted in the GLSL as follows.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>uniform sampler2DShadow shadowSampler;</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>This same setting can be configured using the <code>-maptype</code> command option.</p>
<h2 id="Anchor_202320581_h2_14">GLSL Texture Samplers</h2>
<p>GLSL texture samplers are assigned based on the combinations of texture object and sampler state used in the HLSL.</p>
<p>The name of the texture sampler in GLSL takes the form of <em>&lt;texture object name&gt;</em>_<em>&lt;sample state name&gt;</em> from the HLSL.</p>
<p>If the <code>register</code> keyword was used to give the HLSL texture object a <code>t#</code> texture assignment, <strong>Opaque-Uniform Layout Qualifiers (binding)</strong> is used to assign it to the OpenGL texture unit with the same index.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>Texture2D &lt;float4&gt; tTex2d0;
Texture2D &lt;float4&gt; tTex2d1 : register(t1);
SamplerState sSampler0;
{
&nbsp;&nbsp;float4 col0 = tTex2d0.Sample(sSampler0,texcoord);
&nbsp;&nbsp;float4 col1 = tTex2d1.Sample(sSampler0,texcoord);
}</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>When the HLSL is defined this way, the converted to GLSL looks like this:</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>uniform sampler2D tTex2d0_sSampler0;
layout(binding = 1) uniform sampler2D tTex2d1_sSampler0;
{
&nbsp;&nbsp;vec4 col0 = texture(tTex2d0_sSampler0, texcoord);
&nbsp;&nbsp;vec4 col1 = texture(tTex2d1_sSampler0, texcoord);
}</pre></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
</body>
</html>
