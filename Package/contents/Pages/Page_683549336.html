<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>POSIX Network Socket Functions | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- POSIX Network Socket Functions -->
<div class="pagetitle" id="PageId_683549336">POSIX Network Socket Functions</div>
<div class="text_separate">
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>When using POSIX network socket support, users should include header files from</p>
    <p style="margin-left: 60.0px;">NintendoSDK/Compilers/NX/nx/[platform]/include</p>
    <p>When using SDK network socket functions, whose symbols are in the &quot;nn&quot; namespace, please include the header files from</p>
    <p style="margin-left: 60.0px;">
      <span style="color: rgb(32,31,30);">NintendoSDK/Include/nn/socket</span>
    </p>
    <p>
      <span style="color: rgb(32,31,30);">Intermixing the two sets of header files are not supported.</span>
    </p>
  </div>
</div>
<p>
  <br />
</p>
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_683549336_h1_1">Posix Function Interface</a>
    </li>
    <ul>
      <ul>
        <ul>
          <li>
            <a href="#Anchor_683549336_h4_1">inet_pton()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_2">inet_ntop()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_3">inet_aton()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_4">inet_ntoa()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_5">htons()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_6">ntohs()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_7">htonl()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_8">ntohl()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_9">htonll()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_10">ntohll()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_11">recvfrom()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_12">recv()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_13">sendto()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_14">send()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_15">accept()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_16">bind()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_17">connect()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_18">getpeername()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_19">getsockname()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_20">setsockopt()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_21">getsockopt()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_22">listen()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_23">sockatmark()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_24">shutdown()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_25">socket()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_26">gethostbyname()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_27">gethostbyaddr()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_28">hstrerror()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_29">getaddrinfo()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_30">freeaddrinfo()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_31">gai_strerror()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_32">write()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_33">read()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_34">close()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_35">poll()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_36">fcntl()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_37">select()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_38">ioctl()</a>
          </li>
        </ul>
      </ul>
    </ul>
    <li>
      <a href="#Anchor_683549336_h1_2">Additional Function Support</a>
    </li>
    <ul>
      <ul>
        <ul>
          <li>
            <a href="#Anchor_683549336_h4_39">nx_socket_init()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_40">htonll()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_41">ntohll()</a>
          </li>
        </ul>
      </ul>
    </ul>
    <li>
      <a href="#Anchor_683549336_h1_3">NNMUSL and NATIVE File Descriptors</a>
    </li>
    <ul>
      <ul>
        <ul>
          <li>
            <a href="#Anchor_683549336_h4_42">_nnmusl_socket_IsNnmuslFileDescriptor()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_43">_nnmusl_socket_TranslateFileDescriptorFromNnmuslToNative()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_44">_nnmusl_socket_TranslateFileDescriptorFromNativeToNnmusl()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_45">_nnmusl_socket_AddNativeSocketFileDescriptorToNnmuslTable()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_46">_nnmusl_socket_RemoveNnmuslSocketFileDescriptorFromNnmuslTable()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_47">_nnmusl_socket_RemoveNativeSocketFileDescriptorFromNnmuslTable()</a>
          </li>
          <li>
            <a href="#Anchor_683549336_h4_48">_nnmusl_socket_TranslateNnmuslFileDescriptorOrPassThrough()</a>
          </li>
        </ul>
      </ul>
    </ul>
  </ul>
</p>
<p>
  <br />
  <br />
</p>
<h1 id="Anchor_683549336_h1_1">Posix Function Interface</h1>
<p>
  <br />
</p>
<table class="relative-table wrapped" style="width: 2266.0px;">
  <colgroup>
    <col style="width: 0.0px;" />
    <col style="width: 0.0px;" />
  </colgroup>
  <tbody>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_1">inet_pton()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>inet_pton</strong>(int <em>af</em>, const char *<em>src</em>, void *<em>dst</em>);</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
          </p>
          <p>The function converts a presentation format address (that is, printable form as held in a character string) to network format (internal binary representation, in network byte order). This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <u>
              <strong>
                <span style="color: rgb(68,68,68);">Return</span>
              </strong>
            </u>
          </p>
          <p>Returns 1 if the address was valid for the specified address family, or 0 if the address was not parseable in the specified address family, or -1 if some system error occurred (in which case the global variable errno will have been set). This function is presently valid only for AF_INET.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EAFNOSUPPORT</strong> <em>af</em> was not an AF_INET family address.<strong><br /></strong></p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=inet_pton&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=inet_pton&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_2">inet_ntop()</h4>
        <p>
          <br />
        </p>
        <p>const char *<strong>inet_ntop</strong>(int <em>af</em>, const void *<em>src</em>, char<br />*<em>dst</em>, socklen_t <em>size</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The routine converts an address from network format (usually an binary form, in network byte order) to presentation format (suitable for external display purposes). This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns NULL if a system error occurs (in which case, the global variable errno will have been set), or it returns a pointer to the destination string.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EAFNOSUPPORT</strong> <em>af</em> was not an AF_INET family address.</p>
          <p>
            <strong>ENOSPC</strong> <em>size</em> was not large enough to store the presentation form of the address.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=inet_ntop&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=inet_ntop&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_3">inet_aton()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>inet_aton</strong>(const char *<em>cp</em>, struct in_addr *<em>inp</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <em>inet_aton</em>
            <span style="color: rgb(68,68,68);">() </span>interprets the specified character string as an Internet address, placing the address into the structure provided. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 1 if the string was successfully interpreted, or 0 if the string is invalid</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=inet_aton&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=inet_aton&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_4">inet_ntoa()</h4>
        <p>
          <br />
        </p>
        <p>char *<strong>inet_ntoa</strong>(struct in_addr <em>in</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>inet_ntoa</em>
            <span style="color: rgb(68,68,68);">() function </span>takes an Internet address and returns an ASCII string representing the address in '.' notation. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made. This function is not thread safe so there is a chance for the returned string to not be what is expected if called from another thread at the same time. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns network address in ASCII representation.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=inet_ntoa&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=inet_ntoa&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_5">htons()</h4>
        <p>
          <br />
        </p>
        <p>uint16_t <strong>htons</strong>(uint16_t <em>hostshort</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>htons</em>
            <span style="color: rgb(68,68,68);">() function </span>converts 16-bit unsigned integer from host byte order to network byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns 16-bit unsigned integer in network byte order</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
            <strong>
              <br />
            </strong>
          </p>
          <p>None</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=htons&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=htons&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_6">ntohs()</h4>
        <p>
          <br />
        </p>
        <p>uint16_t <strong>ntohs</strong>(uint16_t <em>netshort</em>);</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>ntohs</em>
            <span style="color: rgb(68,68,68);">
              <em>()</em> function converts </span>16-bit unsigned integer from network byte order to host byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 16-bit unsigned integer in host byte order</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=ntohs&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=ntohs&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_7">htonl()</h4>
        <p>
          <br />
        </p>
        <p>uint32_t <strong>htonl</strong>(uint32_t <em>hostlong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>htonl</em>
            <span style="color: rgb(68,68,68);">
              <em>()</em> function converts </span>32-bit unsigned integer from host byte order to network byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 32-bit unsigned integer in network byte order.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=htonl&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=htonl&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_8">ntohl()</h4>
        <p>
          <br />
        </p>
        <p>uint32_t <strong>ntohl</strong>(uint32_t <em>netlong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>ntohl</em>
            <span style="color: rgb(68,68,68);">
              <em>()</em> function converts </span>32-bit unsigned integer from network byte order to host byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 32-bit unsigned integer in host byte order.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=ntohl&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=ntohl&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_9">htonll()</h4>
        <p>
          <br />
        </p>
        <p>uint64_t <strong>htonll</strong>(uint64_t <em>hostlong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>htonll</em>
            <span style="color: rgb(68,68,68);">
              <em>()</em> function converts </span>64-bit unsigned integer from host byte order to network byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 64-bit unsigned integer in network byte order.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_10">ntohll()</h4>
        <p>
          <br />
        </p>
        <p>uint64_t <strong>ntohl</strong>(uint64_t <em>netlong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>ntohll</em>
            <span style="color: rgb(68,68,68);">
              <em>()</em> function converts </span>64-bit unsigned integer from network byte order to host byte order. This function can be used without calling <em>__nnmusl_socket_socket_init()</em> first.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns 64-bit unsigned integer in host byte order.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_11">recvfrom()</h4>
        <p>
          <br />
        </p>
        <p>ssize_t <strong>recvfrom</strong>(int <em>socket</em>, void *restrict <em>buffer</em>, size_t <em>length</em>,<br />int <em>flags</em>, struct sockaddr *restrict <em>address</em>,<br />socklen_t *restrict <em>address_len</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The <em>recvfrom()</em> routine is used to receive messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented. If <em>address</em> is not a null pointer and the socket is not connection-oriented, the source address of the message is filled in. The <em>length</em> argument is a value-result argument, initialized to the size of the buffer associated with <em>address</em>, and modified on return to indicate the actual size of the address stored there. If the actual length of the address is greater than the length of the supplied <em>sockaddr</em> structure, the stored address will be truncated. If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is non-blocking (see <em>fcntl()</em>) in which case the value -1 is returned and the global variable <em>errno</em> is set to <em>EAgain</em>. The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the socket-level options </span>
            <span style="color: rgb(68,68,68);">
              <em>SO_RCVLOWAT</em> and <em>SO_RCVTIMEO</em> described in <em>getsockopt()</em>.</span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The <em>select()</em> function call may be used to determine when more data arrives. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The <em>flags</em> argument is formed by or'ing one or more of the values: </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>
                <br />
              </strong>
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>MSG_OOB</strong> Process out-of-band data.</span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>MSG_PEEK</strong> Peek at incoming message. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>MSG_WAITALL</strong> Wait for full request or error.</span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>MSG_DONTWAIT</strong> Do not block. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The </span>
            <em>MSG_OOB</em>
            <span style="color: rgb(68,68,68);"> requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The </span>
            <em>MSG_PEEK</em>
            <span style="color: rgb(68,68,68);"> flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The </span>
            <em>MSG_WAITALL</em>
            <span style="color: rgb(68,68,68);"> flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The </span>
            <em>MSG_DONTWAIT</em>
            <span style="color: rgb(68,68,68);"> flag requests the call to return when it would block otherwise. If no data is available, the global variable <em>errno</em> is set to <em>EAgain</em>.</span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">This function requires calling </span>
            <em>__nnmusl_socket_socket_init()</em>
            <span style="color: rgb(68,68,68);"> before it can be used. </span>
          </p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>
            <em>recvfrom()</em> with TCP socket sets peer <em>address,</em> but <em>address_len </em>is cleared to 0.<strong><br /></strong></p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, it shall return 0.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument socket is an invalid descriptor.</p>
          <p>
            <strong>EConnReset</strong> The remote socket end is forcibly closed.</p>
          <p>
            <strong>ENetDown</strong> The network interface has been removed and the socket has been shut down.</p>
          <p>
            <strong>ENotConn</strong> The socket is associated with a connection-oriented protocol and has not been connected.</p>
          <p>
            <strong>ENotSock</strong> The argument socket does not refer to a socket.</p>
          <p>
            <strong>EAgain</strong> The socket is marked non-blocking, and the receive operation would block, or a receive timeout had been set, and the timeout expired before data was received.</p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <strong>EInval</strong> A non-zero <em>length</em> was provided with a null <em>buffer</em>.</p>
          <p>
            <strong>EFault</strong> The address range referred to by <em>buffer</em> and <em>length</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=recvfrom&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=recvfrom&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_12">recv()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">ssize_t <strong>recv</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>void<strong> *</strong><em>buffer</em><strong>, </strong>size_t <em>length</em><strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>flags</em><strong>);</strong></p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>recv</em>
            <span style="color: rgb(68,68,68);">() function </span>is similar in behavior to <em>recvfrom()</em> however, it is normally used only on a connected socket.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, <em>recv()</em> shall return 0.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>
            <strong>EBadf</strong> The argument socket is an invalid descriptor.</p>
          <p>
            <strong>EConnReset</strong> The remote socket end is forcibly closed.</p>
          <p>
            <strong>ENetDown</strong> The network interface has been removed and the socket has been shut down.</p>
          <p>
            <strong>ENotConn</strong> The socket is associated with a connection-oriented protocol and has not been connected.</p>
          <p>
            <strong>ENotSock</strong> The argument socket does not refer to a socket.</p>
          <p>
            <strong>EAgain</strong> The socket is marked non-blocking, and the receive operation would block, or a receive timeout had been set, and the timeout expired before data was received.</p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <strong>EInval</strong> A non-zero <em>length</em> was provided with a null <em>buffer</em>.</p>
          <p>
            <strong>EFault</strong> The address range referred to by <em>buffer</em> and <em>length</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <strong>EOPNOTSUPP</strong> Invalid <em>socket</em> is passed.<br /></p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=recv&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=recv&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_13">sendto()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">ssize_t <strong>sendto</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>const void<strong> *</strong><em>message</em><strong>, </strong>size_t<span style="color: rgb(68,68,68);">&nbsp;</span><em>length</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">int&nbsp;</span><em>flags</em><strong>, </strong>const struct sockaddr<strong> *</strong><em>dest_addr</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t&nbsp;</span><em>dest_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The <em>sendto()</em> routine is used to transmit a message to another socket. The address of the target is given by <em>dest_addr</em> with <em>dest_len</em> specifying its size. The length of the message is given by <em>length</em>. If the message is too long to pass atomically through the underlying protocol, the error <em>EMsgSize</em> is returned, and the message is not transmitted. If no message space is available at the socket to hold the message to be transmitted, then <em>sendto()</em> normally blocks, unless the socket has been placed in non-blocking I/O mode. The <em>select()</em> call may be used to determine when it is possible to send more data. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The flags argument may include one or more of the following: </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>
                <br />
              </strong>
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <strong>MSG_OOB</strong> Process out-of-band data.</span>
          </p>
          <p>
            <strong>MSG_DONTROUTE</strong>
            <span style="color: rgb(68,68,68);"> Bypass routing, use direct interface. </span>
          </p>
          <p>
            <strong>MSG_EOR</strong>
            <span style="color: rgb(68,68,68);"> Data completes record. </span>
          </p>
          <p>
            <strong>MSG_EOF</strong>
            <span style="color: rgb(68,68,68);"> Data completes transaction.</span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The flag </span>
            <em>MSG_OOB</em>
            <span style="color: rgb(68,68,68);"> is used to send &quot;out-of-band&quot; data on sockets that support this notion (</span>
            <em>SOCK_STREAM</em>
            <span style="color: rgb(68,68,68);">); the underlying protocol must also support &quot;out-of-band&quot; data. </span>
          </p>
          <p>
            <em>MSG_EOR</em>
            <span style="color: rgb(68,68,68);"> is used to indicate a record mark for protocols which support the concept. </span>
          </p>
          <p>
            <em>MSG_EOF</em>
            <span style="color: rgb(68,68,68);"> requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for </span>
            <em>SOCK_STREAM</em>
            <span style="color: rgb(68,68,68);"> sockets in the </span>
            <em>AF_INET</em>
            <span style="color: rgb(68,68,68);"> protocol family. </span>
          </p>
          <p>
            <em>MSG_DONTROUTE</em>
            <span style="color: rgb(68,68,68);"> is usually used only by diagnostic or routing programs. Note that when sending broadcast messages, limited broadcasts (e.g. 255.255.255.255) are not supported. The correct method is to use directed broadcasts (e.g. 192.168.1.255) instead. </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">This function requires calling </span>
            <em>__nnmusl_socket_socket_init() </em>
            <span style="color: rgb(68,68,68);">before it can be used.</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NOTE</strong>
            </u>
          </p>
          <p>With TCP, it is valid to send <em>message</em> with <em>length</em> larger than <em>IP_MAXPACKET</em>. Such message will be successfully sent with the return value of the the number of character sent. Errno <em>EMsgSize</em> will not be set. The limit of <em>length</em> is 64K.</p>
          <p>With UDP, when <em>length</em> is larger than <em>IP_MAXPACKET</em>, it will return -1 and set <em>EMsgSize</em>.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the number of characters sent, or -1 if an error occurred.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> An invalid descriptor was specified.<br /><strong>EAcces</strong> The destination address is a broadcast address, and <em>Option::So_Broadcast </em>from <em>setsockopt()</em> has not been set on the socket.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>EMsgSize</strong> The socket requires that message be sent atomically, and the size of the message to be sent made this impossible.<br /><strong>EAgain</strong> The socket is marked non-blocking and the requested operation would block.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.<br /><strong>ENoBufs</strong> The system was unable to allocate an internal buffer. The operation may succeed when buffers become available.<br /><strong>EHostUnreach</strong> The remote host was unreachable.<br /><strong>EIsConn</strong> A destination address was specified and the socket is already connected.<br /><strong>EConnRefused</strong> The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port.<br /><strong>EHostDown</strong> The remote host was down.<br /><strong>ENetDown</strong> The local network interface is down.<br /><strong>ENetUnreach</strong> The network is not reachable from this host.<br /><strong>EPipe</strong> The socket is unable to send any more data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected.<br /><strong>EInval</strong> A non-zero <em>length</em> was provided with a null <em>message</em>.<br /><strong>EFault</strong> The address range referred to by <em>message</em> and <em>length</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=sendto&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=sendto&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_14">send()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">ssize_t <strong>send</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>const void<strong> *</strong><em>buffer</em><strong>, </strong>size_t<span style="color: rgb(68,68,68);">&nbsp;</span><em>length</em><strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>flags</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>send()</em> routine is similar in behavior to <em>sendto()</em>; however, it is normally used only on a connected socket (see <em>connect()</em>). <span style="color: rgb(68,68,68);">This function requires calling </span><em>__nnmusl_socket_socket_init() </em><span style="color: rgb(68,68,68);">before it can be used.</span></p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NOTE</strong>
            </u>
          </p>
          <p>With TCP, it is valid to send <em>message</em> with <em>length</em> larger than <em>IP_MAXPACKET</em>. Such message will be successfully sent with the return value of the the number of character sent. Errno <em>EMsgSize</em> will not be set. The limit of <em>length</em> is 64K.</p>
          <p>With UDP, when <em>length</em> is larger than <em>IP_MAXPACKET</em>, it will return -1 and set <em>EMsgSize</em>.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the number of characters sent, or -1 if an error occurred.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>
            <strong>EBadf</strong> An invalid descriptor was specified.<br /><strong>EAcces</strong> The destination address is a broadcast address, and <em>Option::So_Broadcast </em>from <em>setsockopt()</em> has not been set on the socket.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>EMsgSize</strong> The socket requires that message be sent atomically, and the size of the message to be sent made this impossible.<br /><strong>EAgain</strong> The socket is marked non-blocking and the requested operation would block.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.<br /><strong>ENoBufs</strong> The system was unable to allocate an internal buffer. The operation may succeed when buffers become available.<br /><strong>EHostUnreach</strong> The remote host was unreachable.<br /><strong>EIsConn</strong> A destination address was specified and the socket is already connected.<br /><strong>EConnRefused</strong> The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port.<br /><strong>EHostDown</strong> The remote host was down.<br /><strong>ENetDown</strong> The local network interface is down.<br /><strong>ENetUnreach</strong> The network is not reachable from this host.<br /><strong>EPipe</strong> The socket is unable to send any more data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected.<br /><strong>EInval</strong> A non-zero <em>length</em> was provided with a null <em>message</em>.<br /><strong>EFault</strong> The address range referred to by <em>message</em> and <em>length</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=send&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=send&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_15">accept()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>accept</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>struct sockaddr<strong> *</strong>restrict<span style="color: rgb(68,68,68);">&nbsp;</span><em>address</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t *restrict&nbsp;</span><em>address_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
          </p>
          <p>The <em>accept()</em> routine can be used to accept connection on a socket. The argument <em>socket</em> is a socket that has been created with function <em>socket()</em>, bound to an address with function <em>bind()</em>, and is listening for connections after function <em>listen()</em>. The <em>accept()</em> function call extracts the first connection request on the queue of pending connections, creates a new socket, and allocates a new file descriptor for the socket which inherits the state of the <em>O_NONBLOCK</em> property from the original socket.</p>
          <p>
            <br />
          </p>
          <p>If no pending connections are present on the queue, and the original socket is not marked as non-blocking, <em>accept()</em> blocks the caller until a connection is present. If the original socket is marked non-blocking and no pending connections are present on the queue, <em>accept()</em> returns an error as described below. The accepted socket may not be used to accept more connections. The original socket remains open.</p>
          <p>
            <br />
          </p>
          <p>The argument <em>address</em> is a result argument that is filled-in with the address of the connecting entity, as known to the communications layer. The exact format of the <em>address</em> argument is determined by the domain in which the communication is occurring. A null pointer may be specified for <em>address </em>if the address information is not desired; in this case, <em>address_len</em> is not used and should also be null. Otherwise, the <em>address_len</em> argument is a value-result argument; it should initially contain the amount of space pointed to by <em>address</em>; on return it will contain the actual length (in bytes) of the address returned. This call is used with connection-based socket types, currently with <em>SOCK_STREAM</em>.</p>
          <p>
            <br />
          </p>
          <p>It is possible to <em>select()</em> a socket for the purposes of doing an <em>accept()</em> by selecting it for read. When using <em>accept()</em>, portable programs should not rely on the <em>O_NONBLOCK</em> property and the signal destination being inherited, but should set them explicitly using <em>fcntl()</em>.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>
            <strong>EBadf</strong> The descriptor is invalid.<br /><strong>EIntr</strong> The accept operation was interrupted.<br /><strong>EMFile</strong> The per-process descriptor table is full.<br /><strong>ENotSock</strong> The descriptor references a file, not a socket.<br /><strong>EInval</strong> Function <em>listen()</em> has not been called on the socket descriptor.<br /><strong>EInval</strong> A non-zero <em>address_len</em> was passed with a null <em>address</em>.<br /><strong>EWouldBlock</strong> or <strong>EAgain</strong> The socket is marked non-blocking and no connections are present to be accepted.<br /><strong>EConnAborted</strong> A connection arrived, but it was closed while waiting on the listen queue.<br /><strong>EFault</strong> The address range referred to by <em>address</em> and <em>address_len</em> does not refer to a valid part of the process address space.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=accept&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=accept&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_16">bind()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>bind</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>const struct sockaddr<strong> *</strong><em>address</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t&nbsp;</span><em>address_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>bind()</em> routine assigns the local protocol address to a socket. When a socket is created with function <em>socket()</em> it exists in an address family space but has no protocol address assigned. The <em>bind()</em> function call requests that address stored at <em>address</em> be assigned to the socket. For maximum portability, you should always zero the socket address structure before populating it and passing it to <em>bind()</em>. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.<br /><strong>EBadf</strong> The socket argument is not a valid descriptor.<br /><strong>EInval</strong> The socket is already bound to an address, and the protocol does not support binding to a new address; or the socket has been shut down.<br /><strong>EInval</strong> The <em>address_len</em> argument is not a valid length for the address family.<br /><strong>EInval</strong> The <em>address</em> argument is null.<br /><strong>ENotSock</strong> The <em>socket</em> argument is not a socket.<br /><strong>EAddrNotAvail</strong> The specified address is not available from the local machine.<br /><strong>EAddrInUse</strong> The specified address is already in use.<br /><strong>EAfNoSupport</strong> Addresses in the specified address family cannot be used with this socket.<br /><strong>EAcces</strong> The requested address is protected, and the current user has inadequate permission to access it.<br /><strong>EFault</strong> The address range referred to by <em>address</em> and <em>address_len</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">NX provides the following additional errno information:</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EMFILE</strong> Too many file descriptors in use by process.</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <br />
            </span>
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=bind&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=bind&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_17">connect()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>connect</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>const struct sockaddr<strong> *</strong><em>address</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t&nbsp;</span><em>address_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
          </p>
          <p>The <em>connect()</em> routine initiates connection on a socket. If socket is of type <em>SOCK_DGRAM</em>, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type <em>SOCK_STREAM</em>, this call attempts to make a connection to another socket. The other socket is specified by name, which is an address in the communications space of the socket. Each communications space interprets the name argument in its own way. Generally, stream sockets may successfully connect only once; datagram sockets may use connect multiple times to change their association. Datagram sockets may dissolve the association by connecting to an invalid address, such as a null address. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The <em>socket</em> argument is not a valid descriptor.<br /><strong>EInval</strong> The <em>address_len</em> argument is not a valid length for the address family.<br /><strong>EFault</strong> The address range referred to by <em>address</em> and <em>address_len</em> does not refer to a valid part of the process address space.<br /><strong>ENotSock</strong> The <em>socket</em> argument is a descriptor for a file, not a socket.<br /><strong>EAddrNotAvail</strong> The specified address is not available on this machine.<br /><strong>EAfNoSupport</strong> Addresses in the specified address family cannot be used with this socket.<br /><strong>EIsConn</strong> The socket is already connected.<br /><strong>ETimedOut</strong> Connection establishment timed out without establishing a connection.<br /><strong>EConnRefused</strong> The attempt to connect was forcefully rejected.<br /><strong>EConnReset</strong> The connection was reset by the remote host.<br /><strong>ENetUnreach</strong> The network is not reachable from this host.<br /><strong>EHostUnreach</strong> The remote host is not reachable from this host.<br /><strong>EAddrInUse</strong> The address is already in use.<br /><strong>EInProgress</strong> The socket is non-blocking and the connection cannot be completed immediately. It is possible to <em>select()</em> for completion by selecting the socket for writing.<br /><strong>EAlready</strong> A previous connection attempt has not yet been completed.<br /><strong>EAcces</strong> An attempt is made to connect to a broadcast address (obtained through the <em>INADDR_BROADCAST</em> constant or the <em>INADDR_NONE</em> return value) through a socket that does not provide broadcast functionality.<br /><strong>EAgain</strong> An auto-assigned port number was requested but no auto-assigned ports are available.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <span style="color: rgb(153,153,153);">NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=connect&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=connect&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_18">getpeername()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>getpeername</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>struct sockaddr<strong> *</strong>restrict<span style="color: rgb(68,68,68);">&nbsp;</span><em>address</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t *restrict&nbsp;</span><em>address_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
          </p>
          <p>The <em>getpeername()</em> routine returns the name of the peer connected to socket. The <em>address_len</em> argument should be initialized to indicate the<br /> amount of space pointed to by <em>address</em>. On return it contains the actual size of the name returned (in bytes). The name is truncated if the<br /> buffer provided is too small. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>socket</em> is not a valid descriptor.<br /><strong>EConnReset</strong> The connection has been reset by the peer.<br /><strong>EInval</strong> The value of the <em>address_len</em> argument is not valid.<br /><strong>EInval</strong> The <em>address</em> argument or <em>address_len</em> argument are null.<br /><strong>EFault</strong> The address range referred to by <em>address</em> and <em>address_len</em> does not refer to a valid part of the process address space.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>ENotConn</strong> The socket is not connected.<br /><strong>ENoBufs</strong> Insufficient resources were available in the system to perform the operation.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <span style="color: rgb(153,153,153);">NX provides the following additional errno information:</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EMFILE</strong> Too many file descriptors in use by process.</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <br />
            </span>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=getpeername&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=getpeername&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_19">getsockname()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>getsockname</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>struct sockaddr<strong> *</strong>restrict<span style="color: rgb(68,68,68);">&nbsp;</span><em>address</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">socklen_t *restrict&nbsp;</span><em>address_len</em><strong>);</strong></p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>getsockname()</em> routine returns the current name for the specified socket. The <em>address_len</em> argument should be initialized to indicate the amount of space pointed to by <em>address</em>. On return it contains the actual size of the name returned (in bytes). This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>socket</em> is not a valid descriptor.<br /><strong>EConnReset</strong> The connection has been reset by the peer.<br /><strong>EInval</strong> The value of the <em>address_len</em> argument is not valid.<br /><strong>EInval</strong> The <em>address</em> argument or <em>address_len</em> argument are null.<br /><strong>EFault</strong> The address range referred to by <em>address</em> and <em>address_len</em> does not refer to a valid part of the process address space.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>ENoBufs</strong> Insufficient resources were available in the system to perform the operation.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <span style="color: rgb(153,153,153);">NX provides the following additional errno information:</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EMFILE</strong> Too many file descriptors in use by process.</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <br />
            </span>
          </p>
          <p>
            <strong>
              <u>More Info</u>
            </strong>
          </p>
          <a href="https://www.freebsd.org/cgi/man.cgi?query=getsockname&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=getsockname&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          <br />
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_20">setsockopt()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>setsockopt</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>level</em><strong>, </strong>int<strong> </strong><em>option_name</em><strong>,<br /></strong><span style="color: rgb(68,68,68);">const void *</span><em>option_value</em><strong>, </strong>socklen_t<strong> </strong><em>option_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>setsockopt()</em> routine manipulates the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost &quot;socket&quot; level. When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as <em>SOL_SOCKET</em>. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP.</p>
          <p>
            <br />
          </p>
          <p>The following are supported levels:</p>
          <p>
            <em>SOL_IP</em>, <em>SOL_ICMP</em>, <em>SOL_TCP</em>, <em>SOL_UDP</em>, <em>SOL_SOCKET</em></p>
          <p>
            <br />
          </p>
          <p>The <em>option_value</em> and <em>option_len</em> arguments are used to access option values. The <em>option_name</em> argument and any specified options are passed uninterpreted to the appropriate protocol module for interpretation. Most socket-level options utilize an int argument for option value. For <em>setsockopt()</em>, the argument should be non-zero to enable a boolean option, or zero if the option is to be disabled. <em>SO_LINGER</em> uses a <em>Linger </em>argument which specifies the desired state of the option and the linger interval (see below). <em>SO_SNDTIMEO</em> and <em>SO_RCVTIMEO</em> use <em>TimeVal</em> argument.</p>
          <p>
            <br />
          </p>
          <p>The following options are recognized at the socket level.</p>
          <p>
            <strong>SO_REUSEADDR</strong> Enables local address reuse<br /><strong>SO_REUSEPORT</strong> Enables duplicate address and port bindings<br /><strong>SO_KEEPALIVE</strong> Enables keep connections alive<br /><strong>SO_DONTROUTE</strong> Enables routing bypass for outgoing messages<br /><strong>SO_LINGER</strong> Linger on close if data present<br /><strong>SO_NN_LINGER</strong> Upon completion of <em>close()</em>, this version of linger always drops the connection entirely, freeing associated resources<br /><strong>SO_BROADCAST</strong> Enables permission to transmit broadcast messages<br /><strong>SO_OOBINLINE</strong> Enables reception of out-of-band data in band<br /><strong>SO_SNDBUF</strong> Set buffer size for output<br /><strong>SO_RCVBUF</strong> Set buffer size for input<br /><strong>SO_SNDLOWAT</strong> Set minimum count for output (not supported on Windows)<br /><strong>SO_RCVLOWAT</strong> Set minimum count for input (not supported on Windows)<br /><strong>SO_SNDTIMEO</strong> Set timeout value for output<br /><strong>SO_RCVTIMEO</strong> Set timeout value for input<br /><strong>SO_ACCEPTCONN</strong> Get listening status of the socket (get only, not supported on Windows)<br /><strong>SO_TYPE</strong> Get the type of the socket (get only, not supported on Windows)<br /><strong>SO_PROTOCOL</strong> Get the protocol number for the socket (get only)<br /><strong>SO_ERROR</strong> Get and clear error on the socket (get only)<br /><strong>SO_LISTENQLIMIT</strong> Get backlog limit of the socket (get only)<br /><strong>SO_LISTENQLEN</strong> Get complete queue length of the socket (get only)<br /><strong>SO_LISTENINCQLEN</strong> Get incomplete queue length of the socket (get only)</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>SO_REUSEADDR</strong> indicates that the rules used in validating addresses suppliedin a <em>bind()</em> system call should allow reuse of local addresses.</p>
          <p>
            <strong>SO_REUSEPORT</strong> allows completely duplicate bindings by multiple processes if they all set <em>SO_REUSEPORT</em> before binding the port. This option permits multiple instances of a program to each receive UDP/IP multicast or broadcast datagrams destined for the bound port.</p>
          <p>
            <strong>SO_KEEPALIVE</strong> enables the periodic transmission of messages on a connected socket. Should the connected party fail to respond to these messages, the connection is considered broken and processes using the socket are notified via a SIGPIPE signal when attempting to send data.</p>
          <p>
            <strong>SO_DONTROUTE</strong> indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</p>
          <p>
            <strong>SO_LINGER</strong> controls the action taken when unsent messages are queued on socket and a <em>close()</em> is performed. If the socket promises reliable delivery of data and <em>SO_LINGER</em> is set, the system will block the process on the <em>close()</em> attempt until it is able to transmit the data or until it decides it is unable to deliver the information (a timeout period, termed the linger interval, is specified in seconds in the <em>setsockopt()</em> system call when <em>SO_LINGER</em> is requested). If <em>SO_LINGER</em> is disabled and a <em>close()</em> is issued, the system will process the close in a manner that allows the process to continue as quickly as possible.</p>
          <p>
            <strong>SO_BROADCAST</strong> requests permission to send broadcast datagrams on the socket. Note that limited broadcasts (e.g. 255.255.255.255) are not supported. The correct method is to use directed broadcasts (e.g. 192.168.1.255) instead.</p>
          <p>With protocols that support out-of-band data, the <strong>SO_OOBINLINE</strong> option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with <em>recv()</em> or <em>read()</em> calls without the <em>MSG_OOB</em> flag. Some protocols always behave as if this option is set.</p>
          <p>
            <strong>SO_SNDBUF</strong> and <strong>SO_RCVBUF</strong> are options to adjust the normal buffer sizes allocated for output and input buffers, respectively. The buffer size may be increased for high-volume connections, or may be decreased to limit the possible backlog of incoming data.</p>
          <p>
            <strong>SO_SNDLOWAT</strong> is an option to set the minimum count for output operations. Most output operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary for flow control. Nonblocking output operations will process as much data as permitted subject to flow control without blocking, but will process no data if flow control does not allow the smaller of the low water mark value or the entire request to be processed. A <em>select()</em> operation testing the ability to write to a socket will return true only if the low water mark amount could be processed. The default value for <em>SO_SNDLOWAT</em> is set to a convenient size for network efficiency, often 1024.</p>
          <p>
            <strong>SO_RCVLOWAT</strong> is an option to set the minimum count for input operations. In general, receive calls will block until any (non-zero) amount of data is received, then return with the smaller of the amount available or the amount requested. The default value for <em>SO_RCVLOWAT</em> is 1. If <em>SO_RCVLOWAT</em> is set to a larger value, blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount. Receive calls may still return less than the low water mark if an error occurs, or the type of data next in the receive queue is different from that which was returned.</p>
          <p>
            <strong>SO_SNDTIMEO</strong> is an option to set a timeout value for output operations. It accepts a <em>TimeVal</em> argument with the number of seconds and microseconds used to limit waits for output operations to complete. If a send operation has blocked for this much time, it returns with a partial count or with the error <em>EWouldBlock</em> if no data was sent. In the current implementation, this timer is restarted each time additional data are delivered to the protocol, implying that the limit applies to output portions ranging in size from the low water mark to the high water mark for output.</p>
          <p>
            <strong>SO_RCVTIMEO</strong> is an option to set a timeout value for input operations. It accepts a <em>TimeVal</em> argument with the number of seconds and microseconds used to limit waits for input operations to complete. In the current implementation, this timer is restarted each time additional data are received by the protocol, and thus the limit is in effect an<br /> inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error <em>EWouldBlock</em> if no data was received.</p>
          <p>
            <strong>SO_ACCEPTCONN</strong>, <strong>SO_TYPE</strong>, <strong>SO_PROTOCOL</strong> and <strong>SO_ERROR </strong>are options used only with <em>getsockopt()</em>. <em>SO_ACCEPTCONN</em> returns whether the socket is currently accepting connections, that is, whether or not the <em>listen()</em> system call was invoked on the socket. <em>SO_TYPE</em> returns the type of the socket, such as <em>SOCK_STREAM</em>; it is useful for servers that inherit sockets on startup. <em>SO_PROTOCOL</em> returns the protocol number for the socket, for <em>AF_INET</em> family. <em>SO_ERROR </em>returns any pending error on the socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</p>
          <p>
            <strong>SO_LISTENQLIMIT</strong> returns the maximal number of queued connections, as set by <em>listen()</em>.</p>
          <p>
            <strong>SO_LISTENQLEN</strong> returns the number of unaccepted complete connections.</p>
          <p>
            <strong>SO_LISTENINCQLEN</strong> returns the number of unaccepted incomplete connections.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>socket</em> is not a valid descriptor.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>ENoProtoOpt</strong> The <em>option_name</em> is unknown at the level indicated.<br /><strong>EInval</strong> The <em>option_value</em> argument is null or the value of the <em>option_len</em> argument is not valid.<br /><strong>EFault</strong> The address range referred to by <em>option_value</em> and <em>option_len</em> does not refer to a valid part of the process address space.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=setsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=setsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_21">getsockopt()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>getsockopt</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>level</em><strong>, </strong>int<strong> </strong><em>option_name,</em><span style="color: rgb(68,68,68);">&nbsp;</span><strong><br /></strong><span style="color: rgb(68,68,68);">void *restrict&nbsp;</span><em>option_value</em><strong>, </strong>socklen_t<strong> *</strong>restrict<span style="color: rgb(68,68,68);">&nbsp;</span><em>option_len</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>getsockopt()</em> routine obtains socket options, See <em>setsockopt()</em> for supported options and their description. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <p>
            <span class="status_macro_base status_macro_outline_Red">Known Issue</span> NX currently returns a different <strong>SO_RCVTIMEO </strong>value than the one that is set in setsockopt().</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>socket</em> is not a valid descriptor.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>ENoProtoOpt</strong> The <em>option_name</em> is unknown at the level indicated.<br /><strong>EInval</strong> The <em>option_value</em> argument or <em>option_len</em> argument are null.<br /><strong>EInval</strong> The value of the <em>option_len</em> argument is not valid.<br /><strong>EFault</strong> The address range referred to by <em>option_value</em> and the value of <em>option_len</em> does not refer to a valid part of the process address space.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=getsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=getsockopt&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_22">listen()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>listen</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>backlog</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <em>listen</em>
            <span style="color: rgb(68,68,68);">() function </span>can be used to listen for connection on a socket. To accept connections, a socket is first created with <em>socket()</em>, a willingness to accept incoming connections and a queue limit for incoming connections are specified with <em>listen()</em>, and then the connections are accepted with <em>accept()</em>. The <em>listen()</em> applies only to sockets of type <em>SOCK_STREAM</em> or <em>SOCK_SEQPACKET</em>. The <em>backlog</em> argument defines the maximum length the queue of pending connections may grow to. The real maximum queue length will be 1.5 times more than the value specified in the backlog argument. A subsequent listen call on the listening socket allows the caller to change the maximum queue length using a new backlog argument. If a connection request arrives with the queue full the client may receive an error with an indication of <em>EConnRefused</em>, or, in the case of TCP, the connection will be silently dropped. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>socket</em> is not a valid descriptor.<br /><strong>EDestAddrReq</strong> The socket is not bound to a local address, and the protocol does not support listening on an unbound socket.<br /><strong>EInval</strong> The socket is already connected, or in the process of being connected.<br /><strong>ENotSock</strong> The argument <em>socket</em> is not a socket.<br /><strong>EOpNotSupp</strong> The socket is not of a type that supports the operation Listen.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=listen&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=listen&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_23">sockatmark()</h4>
        <p>
          <br />
        </p>
        <p>int<strong> sockatmark(</strong>int&nbsp;<em>sockfd</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>sockatmark()</em> routine can be used to find out if the read pointer is currently pointing at the mark in the data stream. If <em>sockatmark()</em> returns 1, the next read will return data after the mark. Otherwise (assuming out of band data has arrived), the next read will provide data sent by the client prior to transmission of the out of band signal. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>
            <strong>1</strong> Read pointer points at mark.<br /><strong>0</strong> Read pointer does not point at mark.<br /><strong>-1</strong> Error occurred.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The <em>socket</em> argument is not a valid descriptor.<br /><strong>ENotTy</strong> The <em>socket</em> argument is not a socket descriptor<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<br /><strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTSOCK</strong> The&nbsp;socket&nbsp;argument does not refer to a socket.<br /></span>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=sockatmark&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=sockatmark&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_24">shutdown()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>shutdown</strong>(int&nbsp;</span>
          <em>socket</em>
          <strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>how</em><strong>);</strong></p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <br />
          </p>
          <p>The <em>shutdown()</em> routine disables sends or receives on a socket. The <em>how</em> argument specifies the type of shutdown. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>Possible values are:</p>
          <p>
            <strong>SHUT_RD</strong> Further receives will be disallowed.<br /><strong>SHUT_WR </strong>Further sends will be disallowed. This may cause actions specific to the protocol family of the socket to happen.<br /><strong>SHUT_RDWR </strong>Further sends and receives will be disallowed. Implies SHUT_WR.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>If the file descriptor <em>socket</em> is associated with a <em>SOCK_STREAM</em> socket, all or part of the full-duplex connection will be shut down.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>IMPLEMENTATION NOTES:</p>
          <p>
            <br />
          </p>
          <p>The following protocol-specific actions apply to the use of <em>SHUT_WR</em> (and potentially also SHUT_RDWR), based on the properties of the socket associated with the file descriptor socket.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>AF_INET | SOCK_DGRAM | IPPROTO_UDP | Return 0. ICMP messages will not be generated<br />AF_INET | SOCK_STREAM | IPPROTO_TCP | Return 0. Send queued data, wait for ACK, then send FIN</p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The <em>socket</em> argument is not a valid file descriptor.<br /><strong>EInval</strong> The <em>how</em> argument is invalid.<br /><strong>EOpNotSupp</strong> The socket associated with the file descriptor <em>socket</em> does not support this operation.<br /><strong>ENotConn</strong> The <em>socket</em> argument specifies a <em>SOCK_STREAM</em> socket which is not connected.<br /><strong>ENotSock</strong> The <em>socket</em> argument does not refer to a socket.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:<strong><br /></strong></p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=shutdown&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=shutdown&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_25">socket()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>socket</strong>(int&nbsp;</span>
          <em>domain</em>
          <strong>, </strong>
          <em>type</em>
          <strong>, </strong>
          <em>protocol</em>
          <strong>);</strong>
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>socket()</em> routine creates an endpoint for communication and returns a descriptor. The <em>domain</em> argument specifies a communications domain within which communication will take place; this selects the protocol family which should be used.</p>
          <p>
            <br />
          </p>
          <p>The currently understood formats are:</p>
          <p>
            <strong>AF_INET</strong> Internet version 4 protocols<br /><strong>AF_ROUTE</strong> Internal Routing protocol<br /><strong>AF_LINK</strong> Link layer interface</p>
          <p>
            <br />
          </p>
          <p>The socket has the indicated <em>type</em>, which specifies the semantics of communication.</p>
          <p>Currently defined types are:</p>
          <p>
            <strong>SOCK_STREAM</strong> Stream socket,<br /><strong>SOCK_DGRAM</strong> Datagram socket,<br /><strong>SOCK_RAW</strong> Raw-protocol interface<br /><strong>SOCK_SEQPACKET</strong> Sequenced packet stream</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>A <em>SOCK_STREAM</em> type provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism may be supported.</p>
          <p>A <em>SOCK_DGRAM</em> socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length).A</p>
          <p>A <em>SOCK_SEQPACKET</em> socket may provide a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer may be required to read an entire packet with each read system call. This facility is protocol specific, and presently unimplemented.</p>
          <p>
            <em>SOCK_RAW</em> sockets provide access to internal network protocols and interfaces.</p>
          <p>The types <em>SOCK_RAW</em>, which is available only to the super-user, is not described here.</p>
          <p>
            <br />
          </p>
          <p>Additionally, the following flag is allowed in the <em>type</em> argument:</p>
          <p>
            <strong>SOCK_NONBLOCK </strong>Set non-blocking mode on the new socket</p>
          <p>
            <br />
          </p>
          <p>The <em>protocol</em> argument specifies a particular protocol to be used with thesocket. Normally only a single protocol exists to support a particular socket type within a given protocol family. However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner. The <em>protocol</em> number to use is particular to the &quot;communication domain&quot; in which communication is to take place.</p>
          <p>
            <br />
          </p>
          <p>The <em>protocol</em> argument may be set to zero (0) to request the default implementation of a socket type for the protocol, if any.</p>
          <p>
            <br />
          </p>
          <p>Sockets of <em>type SOCK_STREAM</em> are full-duplex byte streams, similar to pipes. A stream socket must be in a connected state before any data may be sent or received on it. A connection to another socket is created with a <em>connect()</em> system call. Once connected, data may be transferred using <em>read()</em> and <em>write()</em> calls or some variant of the <em>send()</em> and <em>recv()</em> functions. (Some protocol families, such as the Internet family, support the notion of an &quot;implied connect&quot;, which permits data to be sent piggybacked onto a connect operation by using the <em>sendto()</em> system call.) When a session has been completed a <em>close()</em> may be performed. Out-of-band data may also be transmitted as described in <em>send()</em> and received as described in <em>recv()</em>.</p>
          <p>
            <br />
          </p>
          <p>The communications protocols used to implement <em>SOCK_STREAM</em> ensure that data is not lost or duplicated. If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered broken and calls will indicate an error with -1 returns and with <em>ETimedOut</em> as the specific code in the global variable <em>errno</em>. The protocols optionally keep sockets &quot;warm&quot; by forcing transmissions roughly every minute in the absence of other activity. An error is then indicated if no response can be elicited on an otherwise idle connection for an extended period (e.g. 5 minutes).</p>
          <p>
            <br />
          </p>
          <p>
            <em>SOCK_SEQPACKET</em> sockets employ the same system calls as <em>SOCK_STREAM</em> sockets. The only difference is that <em>read()</em> calls will return only the amount of data requested, and any remaining in the arriving packet will be discarded.</p>
          <p>
            <em>
              <br />
            </em>
          </p>
          <p>
            <em>SOCK_DGRAM</em> and <em>SOCK_RAW</em> sockets allow sending of datagrams to correspondents named in send() calls. Datagrams are generally received with <em>recvfrom()</em>, which returns the next datagram with its return address. The operation of sockets is controlled by socket level options with <em>setsockopt()</em> and <em>getsockppt()</em>.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the created socket</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EAcces</strong> Permission to create a socket of the specified type and/or protocol is denied.</p>
          <p>
            <strong>EAfNoSupport</strong> The address family (domain) is not supported or the specified domain is not supported by this protocol family.<br /><strong>EMFile</strong> The per-process descriptor table is full.<br /><strong>ENoBufs</strong> Insufficient buffer space is available. The socket cannot be created until sufficient resources are freed.<br /><strong>EPerm</strong> User has insufficient privileges to carry out the requested operation.<br /><strong>EProtoNoSupport</strong> The protocol type or the specified protocol is not supported within this domain.<br /><strong>EPrototype</strong> The socket type is not supported by the protocol.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EBADF</strong> The&nbsp;<em>domain</em> argument is invalid.</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=socket&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=socket&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_26">gethostbyname()</h4>
        <p>
          <br />
        </p>
        <p>struct hostent *<strong>gethostbyname</strong>(const char *<em>name</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>Look up AF_INET host IP address by <em>name</em>. The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>In NX, the member <em>h_addrtype</em> of <em>struct hostent </em>is of a different type and size than in Posix. <em>h_addrtype</em> in NX is of type <em>Family</em> and size 1, while in Posix it is of type <em>int</em> and size 4.</p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=gethostbyname&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=gethostbyname&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_27">gethostbyaddr()</h4>
        <p>
          <br />
        </p>
        <p>struct hostent *<strong>gethostbyaddr</strong>(const void *<em>addr</em>, socklen_t<em> len</em>, int <em>type</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>Look up the address value for a host for AF_INET. The return value of this function is thread-localized, which deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>In NX, the member <em>h_addrtype</em> of <em>struct hostent</em> is of a different type and size than in Posix. <em>h_addrtype</em> in NX is of type <em>Family</em> and size 1, while in Posix it is of type <em>int</em> and size 4.</p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns a pointer to a <em>hostent</em> structure or NULL on error with error detail in @ref GetHError().</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=gethostbyaddr&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=gethostbyaddr&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_28">hstrerror()</h4>
        <p>
          <br />
        </p>
        <p>const char *<strong>hstrerror</strong>(int <em>err</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The hstrerror() function returns a human-readable version of h_error. The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns a string representing the error number or NULL if out-of-memory.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=hstrerror&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=hstrerror&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_29">getaddrinfo()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>getaddrinfo</strong>(const char *<em>node</em>, const char *<em>service</em>, const struct addrinfo *<em>hints</em>, struct addrinfo **<em>res</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <em>getaddrinfo</em>() routine can be used to obtain list of IP addresses and port numbers for host <em>node</em> and <em>service</em>. It provides more flexibility than <em>gethostentbyname()</em>. Please note that <em>node</em> and <em>service</em> cannot both be NULL at the same time. The <em>addrinfo</em> result <em>res</em> returned by this function can be deallocated via <em>freeaddrinfo()</em>. The optional <em>hints</em> can be used to provide hints concerning the type of socket that the caller supports or wishes to use. The caller can supply the following structure elements in <em>hints</em>:</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>In NX, the members <em>ai_flags</em> and <em>ai_socktype</em> of <em>struct addrinfo</em> are unsigned, while in Posix they're signed.</p>
          <p>In NX, the member <em>ai_family</em> of <em>struct addrinfo</em> is of a different type and size than in Posix. <em>ai_family</em> in NX is of type<em> Family</em> and size 1, while in Posix it is of type <em>int</em> and size 4.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>ai_family</strong> The protocol family that should be used. When <em>ai_family</em> is set to <em>AF_UNSPEC</em>, it means the caller will accept any protocol family supported by the operating system.<br /><strong>ai_socktype </strong>Denotes the type of socket that is wanted: <em>SOCK_STREAM</em>, <em>SOCK_DGRAM</em>, or <em>SOCK_RAW</em>. When <em>ai_socktype</em> is zero the caller will accept any socket type.<br /><strong>ai_protocol </strong>Indicates which transport protocol is desired, <em>IPPROTO_UDP</em> or <em>IPPROTO_TCP</em>. If <em>ai_protocol</em> is zero the caller will accept any protocol.<br /><strong>ai_flags </strong>The <em>ai_flags</em> field to which the <em>hints</em> parameter points shall be set to zero or be the bitwise-inclusive OR of one or more of the values:</p>
          <p style="margin-left: 60.0px;">
            <strong>AI_ADDRCONFIG</strong> If <em>AI_ADDRCONFIG</em> bit is set, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system.<br /><strong>AI_CANONNAME</strong> If <em>AI_CANONNAME</em> bit is set, a successful call to <em>getaddrinfo()</em> will return a NULL-terminated string containing the canonical name of the specified hostname in the <em>AI_CANONNAME </em>element of the first <em>addrinfo</em> structure returned.<br /><strong>AI_NUMERICHOST</strong> If <em>AI_NUMERICHOST</em> bit is set, it indicates that hostname should be treated as a numeric string defining an IPv4 or IPv6 address and resolution should be attempted.</p>
          <p style="margin-left: 60.0px;">
            <strong>AI_NUMERICSERV</strong> If <em>AI_NUMERICSERV</em> bit is set, then a non-NULL servname string supplied shall be a numeric port string. Otherwise, an <em>EAi_NoName</em> error shall be returned. This bit shall prevent any type of name resolution service (for example, NIS+) from being invoked.</p>
          <p style="margin-left: 60.0px;">
            <strong>AI_PASSIVE</strong> If the <em>AI_PASSIVE</em> bit is set it indicates that the returned socket address structure is intended for use in a call to <em>bind(). </em>In this case, if the hostname argument is the null pointer, then the IP address portion of the socket address structure will be set to <em>INADDR_ANY</em> for an IPv4 address. If the <em>AI_PASSIVE</em> bit is not set, the returned socket address structure will be ready for use in a call to <em>connect()</em> for a connection-oriented protocol or <em>connect()</em> or <em>sendto()</em> if a connectionless protocol was chosen. The IP address portion of the socket address structure will be set to the loopback address if hostname is the null pointer and <em>AI_PASSIVE</em> is not set.<br /><br /></p>
          <p>All other elements of the <em>addrinfo</em> structure passed via <em>hints</em> must be zero or the null pointer.</p>
          <p>
            <br />
          </p>
          <p>If <em>hints</em> is the null pointer, <em>getaddrinfo()</em> behaves as if the caller provided an <em>addrinfo</em> structure with <em>ai_family</em> set to <em>AF_UNSPEC</em> and all other elements set to zero or NULL.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns <em>EAi_Success</em> on success or one of the error codes listed in <em>gai_strerror()</em> if an error occurs.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_30">freeaddrinfo()</h4>
        <p>
          <br />
        </p>
        <p>void <strong>freeaddrinfo</strong>(struct addrinfo *<em>res</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The freeaddrinfo() routine can be used to free structured returned by getaddrinfo()</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>In NX, the members <em>ai_flags</em> and <em>ai_socktype</em> of <em>struct addrinfo</em> are unsigned, while in Posix they're signed.</p>
          <p>In NX, the member <em>ai_family</em> of <em>struct addrinfo</em> is of a different type and size than in Posix. <em>ai_family</em> in NX is of type<em> Family</em> and size 1, while in Posix it is of type <em>int</em> and size 4.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=freeaddrinfo&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=freeaddrinfo&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_31">gai_strerror()</h4>
        <p>
          <br />
        </p>
        <p>const char *<strong>gai_strerror</strong>(int <em>errcode</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>gai_strerror()</em> routine is used to obtain human readable version of the return value from <em>getaddrinfo()</em> and <em>getnameinfo()</em>. The return value of this function is thread-localized, which deviates from some POSIX implementations. The return value is managed internally, so if you wish to maintain the value between calls a copy must be made.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns a c-string human readable representation of the error code provided.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>None</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=gai_strerror&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=gai_strerror&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_32">write()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">ssize_t <strong>write</strong>(int&nbsp;</span>
          <em>fildes</em>
          <strong>, </strong>const void<strong> *</strong><em>buf</em><strong>, </strong>size_t<strong> </strong><em>nbyte</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>write()</em> routine attempts to write <em>nbyte</em> bytes of data to the socket referenced by the descriptor <em>fildes</em> from the buffer pointed to by <em>buf</em>.</p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the number of characters written, or -1 if an error occurred.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> An invalid descriptor was specified.<br /><strong>ENotSock</strong> The argument <em>fildes</em> is not a socket.<br /><strong>EMsgSize</strong> The socket requires that message be sent atomically, and the size of the message to be sent made this impossible.<br /><strong>EAgain</strong> The socket is marked non-blocking and the requested operation would block.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.<br /><strong>EAcces</strong> The destination address is a broadcast address, and <em>SO_BROADCAST</em> has not been set on the socket.<br /><strong>ENoBufs</strong> The system was unable to allocate an internal buffer. The operation may succeed when buffers become available.<br /><strong>EHostUnreach</strong> The remote host was unreachable.<br /><strong>EIsConn</strong> A destination address was specified and the socket is already connected.<br /><strong>EConnRefused</strong> The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port.<br /><strong>EHostDown</strong> The remote host was down.<br /><strong>ENetDown</strong> The local network interface is down.<br /><strong>ENetUnreach</strong> The network is not reachable from this host.<br /><strong>EPipe</strong> The socket is unable to send anymore data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected.<br /><strong>EInval</strong> The <em>buf</em> argument is null with non-zero <em>nbyte</em> argument.<br /><strong>EFault</strong> The address range referred to by <em>buf</em> and <em>nbyte</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=write&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=write&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_33">read()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">ssize_t <strong>read</strong>(int&nbsp;</span>
          <em>fildes</em>
          <strong>, </strong>void<strong> *</strong><em>buf</em><strong>, </strong>size_t<strong> </strong><em>nbyte</em><strong>);</strong></p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The<em> read()</em> routine attempts to read <em>nbyte</em> bytes of data from the object referenced by the descriptor <em>fildes</em> into the buffer pointed to by <em>buf</em>. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>If successful, the number of bytes actually read is returned. Upon reading end-of-file, zero is returned. A -1 is returned if an error occurred.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument <em>fildes</em> is an invalid descriptor.<br /><strong>EConnReset</strong> The remote socket end is forcibly closed.<br /><strong>ENetDown</strong> The network interface has been removed and the socket has been shut down.<br /><strong>ENotConn</strong> The socket is associated with a connection-oriented protocol and has not been connected (<em>connect()</em> and <em>accept()</em>).<br /><strong>ENotSock</strong> The argument <em>fildes</em> does not refer to a socket.<br /><strong>EAgain</strong> The socket is marked non-blocking, and the receive operation would block.<br /><strong>EAgain</strong> A receive timeout had been set, and the timeout expired before data was received.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.<br /><strong>EInval</strong> The <em>buf</em> argument is null with non-zero <em>nbyte</em> argument.<br /><strong>EFault</strong> The address range referred to by <em>buf</em> and <em>nbyte</em> does not refer to a valid part of the process address space.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=read&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=read&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_34">close()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>close</strong>(int&nbsp;</span>
          <em>fildes</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>close()</em> routine deletes a descriptor from the per-process object reference table. The underlying object is deleted on the first close call. All subsequent calls to the same object from other processes/threads after the first close will return an error. This behavior deviates from POSIX standard. When a process exists, all associated descriptors are freed and all objects created by that process are destroyed. This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The <em>fildes</em> argument is not an active descriptor.<br /><strong>EConnReset</strong> The underlying object was a stream socket that was shut down by the peer before all pending data was delivered.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <strong>ENOTSOCK</strong> The&nbsp;<em>fildes</em> argument does not refer to a socket.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=close&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=close&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_35">poll()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>poll</strong>(struct pollfd&nbsp;</span>
          <em>fds</em>[]<strong>, </strong>nfds_t<span style="color: rgb(68,68,68);">&nbsp;</span><em>nfds</em><strong>, </strong>int <em>timeout</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The poll() system call examines a set of file descriptors to see if some of them are ready for I/O. The <em>fds</em> argument is a pointer to an array of <em>pollfd</em> structures). The <em>nfds</em> argument determines the size of the array.</p>
          <p>
            <br />
          </p>
          <p>The event bitmasks in events and revents have the following bits:</p>
          <p>
            <strong>POLLIN</strong> Data other than high priority data may be read without blocking.<br /><strong>POLLRDNORM</strong> Normal data may be read without blocking.<br /><strong>POLLRDBAND</strong> Data with a non-zero priority may be read without blocking.<br /><strong>POLLPRI</strong> High priority data may be read without blocking.<br /><strong>POLLOUT</strong> Normal data may be written without blocking.<br /><strong>POLLWRNORM</strong> Normal data may be written without blocking.<br /><strong>POLLWRBAND</strong> Data with a non-zero priority may be written without blocking.<br /><strong>POLLERR</strong> An exceptional condition has occurred on the device or socket. This flag is always checked, even if not present in the events bitmask.<br /><strong>POLLHUP</strong> The device or socket has been disconnected. This flag is always checked, even if not present in the events bitmask.<br /><strong>POLLNVAL</strong> The file descriptor is not open. This flag is always checked, even if not present in the events bitmask.</p>
          <p>
            <br />
          </p>
          <p>Note that <em>POLLHUP</em> and <em>POLLOUT</em> should never be present in the revents bitmask at the same time.</p>
          <p>
            <br />
          </p>
          <p>If <em>timeout</em> is neither zero nor <em>INFTIM (-1)</em>, it specifies a maximum interval to wait for any file descriptor to become ready, in milliseconds. If <em>timeout</em> is <em>INFTIM (-1)</em>, the poll blocks indefinitely. If <em>timeout</em> is zero, then <em>poll()</em> will return without blocking.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Number of descriptors that are ready for I/O, or -1 if an error occurred. If the time limit expires, <em>poll()</em> returns 0. If <em>poll()</em> returns with an error, file descriptor array will be unmodified.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EInval</strong> The specified time limit is invalid. One of its components is negative or too large.<br /><strong>EInval </strong>The <em>fds</em> argument is null with non-zero <em>nfds</em> argument.<br /><strong>EFault</strong> The address range referred to by <em>fds</em> and <em>nfds</em> * sizeof(<em>pullfd</em>) does not refer to a valid part of the process address space.<br /><strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <strong>ENOTSOCK</strong> The&nbsp;<em>fds </em>argument does not refer to a socket.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=poll&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=poll&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_36">fcntl()</h4>
        <p>
          <br />
        </p>
        <p>
          <span style="color: rgb(68,68,68);">int <strong>fcntl</strong>(int&nbsp;</span>
          <em>fildes</em>
          <strong>, </strong>int<span style="color: rgb(68,68,68);">&nbsp;</span><em>cmd</em><strong>, </strong>...);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>fcntl()</em> routine provides control over descriptors. The argument <em>fildes</em> is a descriptor to be operated on by <em>cmd</em> as described below.</p>
          <p>
            <br />
          </p>
          <p>Depending on the value of command, <em>fcntl()</em> can take additional arguments.</p>
          <p>Supported commands:</p>
          <p>
            <strong>F_GETFL</strong> Get descriptor status flags. Additional arguments are ignored. The descriptor flags for the <em>F_GETFL</em> command are returned from <em>fcntl()</em>. Flags that are supported to be modified are documented in the <em>F_SETFL</em> command below.</p>
          <p>
            <strong>F_SETFL</strong> Set descriptor status flags. Takes an additional argument - 'flags'. The flags for the <em>F_SETFL</em> flags are as follows:</p>
          <p>
            <strong>O_NONBLOCK</strong> Non-blocking I/O; if no data is available to a <em>read()</em> system call, or if a <em>write()</em> operation would block, the <em>read()</em> or <em>write()</em> call returns -1 with the error <em>EAgain</em>.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Return</u>
            </strong>
          </p>
          <p>Returns the value 0 if successful; otherwise the value -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The argument @a socket is not a valid descriptor.</p>
          <p>
            <strong>ENotSock</strong> The argument @a socket does not refer to a socket.</p>
          <p>
            <strong>EOpNotSupp</strong> Command is not supported.</p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=fcntl&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=fcntl&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_37">select()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>select</strong>(int <em>nfds</em>, fd_set *restrict <em>readfds</em>, fd_set *restrict <em>writefds</em>, fd_set *restrict <em>errorfds</em>, struct timeval *restrict <em>timeout</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>select()</em> routine examines the I/O descriptor sets whose addresses are passed in <em>readfds</em>, <em>writefds</em>, and <em>errorfds</em> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. The only exceptional condition detectable is out-of-band data received on a socket. The first <em>nfds</em> descriptors are checked in each set; i.e., the descriptors from 0 through <em>nfds</em>-1 in the descriptor sets are examined. On return, <em>select()</em> replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. The <em>select()</em> system call returns the total number of ready descriptors in all the sets.</p>
          <p>
            <br />
          </p>
          <p>The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets:</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <strong>FdSetZero()</strong> initializes a descriptor set <em>fdset</em> to the null set.</p>
          <p>
            <strong>FdSetSet()</strong> includes a particular descriptor <em>fd</em> in <em>fdset</em>.</p>
          <p>
            <strong>FdSetClr()</strong> removes <em>fd</em> from <em>fdset</em>. <em>FdSetIsSet()</em> is non-zero if <em>fd</em> is a member of <em>fdset</em>, zero otherwise. The behavior of these functions is undefined if a descriptor value is less than zero or greater than or equal to <em>FdSetSize</em>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
          <p>
            <br />
          </p>
          <p>If <em>timeout</em> is not a null pointer, it specifies the maximum interval to wait for the selection to complete. System activity can lengthen the interval by an indeterminate amount.</p>
          <p>
            <br />
          </p>
          <p>If <em>timeout</em> is a null pointer, the select blocks indefinitely.</p>
          <p>
            <br />
          </p>
          <p>To effect a poll, the <em>timeout</em> argument should not be a null pointer, but it should point to a zero-valued <em>timeval</em> structure.</p>
          <p>
            <br />
          </p>
          <p>Any of descriptor sets may be given as null pointers if no descriptors are of interest.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX Specific</u>
            </strong>
          </p>
          <p>The Posix <em>select()</em> function requires that the first parameter be one higher than a NNMUSL fd because NNMUSL will translate the first parameter to a NATIVE fd before calling the Nintendo C++ <em><span class="ApiLink_nn__socket__Select">nn::socket::Select</span>()</em> function. Calling <em>select()</em> without the first parameter one higher than a NNMUSL fd will return -1 and set <em>errno</em> to <em>EINVAL</em>.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns the number of ready descriptors that are contained in the descriptor sets, or -1 if an error occurred. If the time limit expires, <em>select()</em> returns 0. If <em>select()</em> returns with an error, the descriptor sets will be unmodified.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> One of the descriptor sets specified an invalid descriptor.</p>
          <p>
            <strong>EInval</strong> The specified time limit is invalid. One of its components is negative or too large.</p>
          <p>
            <strong>EInval</strong> The <em>nfds</em> argument was invalid.</p>
          <p>
            <strong>EFault</strong> One of the arguments <em>readfds</em>, <em>writefds</em>, <em>errorfds</em> or <em>timeout</em> points to an invalid address.</p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <strong>ENOTSOCK</strong> The&nbsp;<em>nfds </em>argument does not refer to a socket.</p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=select&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=select&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_38">ioctl()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>ioctl</strong>(int <em>fildes</em>, int <em>request</em>, ... /* arg */);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>The <em>ioctl()</em> routine manipulates the underlying device parameters of special files. The argument <em>fildes</em> must be an open file descriptor obtained with either <em>socket()</em>, <em>accept()</em>.</p>
          <p>
            <br />
          </p>
          <p>The following <em>ioctl()</em> commands are supported:</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <strong>FIONREAD</strong> Get the number of bytes that are immediately available for reading. For this command, <em>pData</em> of var arg should be a pointer to an int.</p>
          <p>
            <strong>FIONWRITE</strong> Get the number of bytes in the descriptor's send queue. These bytes are data which has been written to the descriptor but which are being held by the kernel for further processing. The nature of the required processing depends on the underlying device. For TCP sockets, these bytes have not yet been acknowledged by the other side of the connection. For this command, <em>pData</em> of var arg should be a pointer to an int. This command is not supported on Windows builds.</p>
          <p>
            <strong>FIONSPACE</strong> Get the free space in the descriptor's send queue. This value is the size of the send queue minus the number of bytes being held in the queue. Note: while this value represents the number of bytes that may be added to the queue, other resource limitations may cause a write not larger than the send queue's space to be blocked. One such limitation would be a lack of network buffers for a write to a network connection. For this command, <em>pData </em>of var arg should be a pointer to an int. This command is not supported on Windows builds.</p>
          <p>
            <br />
          </p>
          <p>Please note that <em>FIONWRITE</em> and <em>FIONSPACE</em> are not supported in Windows builds. In the case that these commands are used for Windows builds, this function will return -1 and the global variable errno will be set to <em>EInval</em>.</p>
          <p>
            <br />
          </p>
          <p>This function requires calling <em>__nnmusl_socket_socket_init()</em> before it can be used.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Return</strong>
            </u>
          </p>
          <p>Returns result of the <em>ioctl()</em> operation. If an error has occurred, a value of -1 is returned.</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBadf</strong> The <em>fildes</em> argument is not a valid descriptor.</p>
          <p>
            <strong>ENotTy</strong> The specified request does not apply to the kind of object that the descriptor fd references.</p>
          <p>
            <strong>EInval</strong> The request or <em>pData </em>of var arg argument is not valid.</p>
          <p>
            <strong>EAcces</strong> Command is not allowed.</p>
          <p>
            <strong>EAgain</strong> Resources to complete the request are temporarily unavailable.</p>
          <p>
            <br />
          </p>
          <p>NX provides the following additional errno information:</p>
          <p>
            <strong>EMFILE</strong> Too many file descriptors in use by process.</p>
          <p>
            <strong>ENOTSOCK</strong> The&nbsp;<em>fildes </em>argument does not refer to a socket.</p>
          <p>
            <strong>EINVAL</strong> <em>request </em>is not one of FIONREAD, IRONWRITE or FIONSPACE, or var arg is a null pointer.</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>More Info</strong>
            </u>
          </p>
          <p>
            <a href="https://www.freebsd.org/cgi/man.cgi?query=ioctl&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html">https://www.freebsd.org/cgi/man.cgi?query=ioctl&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+10.1-RELEASE+and+Ports&amp;arch=default&amp;format=html</a>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<h1 id="Anchor_683549336_h1_2">Additional Function Support</h1>
<p>
  <br />
</p>
<table class="relative-table wrapped" style="width: 2000.0px;">
  <colgroup>
    <col style="width: 0.0px;" />
    <col style="width: 0.0px;" />
  </colgroup>
  <tbody>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_39">nx_socket_init()</h4>
        <p>
          <br />
        </p>
        <p>void<strong> nx_socket_init</strong>();</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
            <br />
            <span style="color: rgb(68,68,68);">This function initializes NX socket memory configuration with default values, which is required before using NX network socket functions.</span>
          </p>
          <p>To use this function: <code>#include &lt;nx_socket.h&gt;</code></p>
          <p>
            <span style="color: rgb(68,68,68);">
              <br />
            </span>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">To initialize socket memory with custom configurations, users should use the <code><span class="ApiLink_nn__socket">nn::socket</span></code> API.</span>
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_40">htonll()</h4>
        <p>
          <br />
        </p>
        <p>uint64_t <strong>htonll</strong>(uint64_t <em>hostlonglong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <strong>htonll</strong>
            <span style="color: rgb(68,68,68);">() function converts the unsigned long long integer&nbsp;</span>
            <em>hostlonglong</em>
            <span style="color: rgb(68,68,68);">&nbsp;from host byte order to network byte order.</span>
          </p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_41">ntohll()</h4>
        <p>
          <br />
        </p>
        <p>uint64_t <strong>ntohll</strong>(uint64_t <em>netlonglong</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">The&nbsp;</span>
            <strong>ntohll</strong>
            <span style="color: rgb(68,68,68);">() function converts the unsigned integer&nbsp;</span>
            <em>netlonglong</em>
            <span style="color: rgb(68,68,68);">&nbsp;from network byte order to host byte order.</span>
          </p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>None</p>
        </div>
      </td>
    </tr>
  </tbody>
</table>
<h1 id="Anchor_683549336_h1_3">NNMUSL and NATIVE File Descriptors</h1>
<p>The Posix socket implementation (NNMUSL) uses different file descriptors than the Nintendo C++ implementation (NATIVE).&nbsp; NNMUSL requires that the Posix C socket APIs will be called with NNMUSL fds which will be returned to you when calling select() or accept(). There could be times when you need to translate NNMUSL fds to or from NATIVE fds and that is the purpose of the following utility functions. If there is an error, these functions, which are also used internally, will return -1 and set errno to a value which depends on whether the utility routine expects a NNMUSL or NATIVE fd.</p>
<p>
  <strong>EBADF</strong>&nbsp;- the file descriptor is not open or the function expected a NATIVE fd but didn't get one.</p>
<p>
  <strong>ENOTSOCK</strong>&nbsp;- the function expected a NNMUSL fd but didn't get one.&nbsp;</p>
<p>
  <strong>EMFILE&nbsp;</strong>- too many file descriptors in use by the process.</p>
<table class="relative-table wrapped" style="width: 2272.0px;">
  <colgroup>
    <col style="width: 0.0px;" />
    <col style="width: 0.0px;" />
  </colgroup>
  <tbody>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_42">_nnmusl_socket_IsNnmuslFileDescriptor()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_IsNnmuslFileDescriptor</strong>(int <em>fd</em>);</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <strong>
              <u>Description</u>
            </strong>
            <br />
            <span style="color: rgb(68,68,68);">Returns non-zero if fd is an NNMUSL fd</span>
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_43">_nnmusl_socket_TranslateFileDescriptorFromNnmuslToNative()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_TranslateFileDescriptorFromNnmuslToNative</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">Expects a NNMUSL fd and returns a NATIVE fd if successful</span>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_44">_nnmusl_socket_TranslateFileDescriptorFromNativeToNnmusl()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_TranslateFileDescriptorFromNativeToNnmusl</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <div class="content-wrapper">
          <p>
            <u>
              <strong>Description</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(68,68,68);">Expects a NATIVE fd and returns a NNMUSL fd if successful.</span>
          </p>
          <p>
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_45">_nnmusl_socket_AddNativeSocketFileDescriptorToNnmuslTable()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_AddNativeSocketFileDescriptorToNnmuslTable</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <p>
          <u>
            <strong>Description</strong>
          </u>
        </p>
        <p>Expects an open NATIVE fd, adds it to the NNMUSL table and returns a NNMUSL fd if successful. If already in NNMUSL table, it returns the NNMUSL fd.<u><strong><br /></strong></u></p>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_46">_nnmusl_socket_RemoveNnmuslSocketFileDescriptorFromNnmuslTable()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_RemoveNnmuslSocketFileDescriptorFromNnmuslTable</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <p>
          <u>
            <strong>Description</strong>
          </u>
        </p>
        <p>Expects a NNMUSL fd, remove it from the NNMUSL table and returns 0 if successful. If already removed in NNMUSL table, it returns 0.</p>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_47">_nnmusl_socket_RemoveNativeSocketFileDescriptorFromNnmuslTable()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_RemoveNativeSocketFileDescriptorFromNnmuslTable</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <p>
          <u>
            <strong>Description</strong>
          </u>
        </p>
        <p>Expects a NATIVE fd, remove it from the NNMUSL table and returns 0 if successful. If already removed in NNMUSL table, it returns 0.</p>
      </td>
    </tr>
    <tr>
      <td>
        <h4 id="Anchor_683549336_h4_48">_nnmusl_socket_TranslateNnmuslFileDescriptorOrPassThrough()</h4>
        <p>
          <br />
        </p>
        <p>int <strong>_nnmusl_socket_TranslateNnmuslFileDescriptorOrPassThrough</strong>(int <em>fd</em>);</p>
      </td>
      <td>
        <p>
          <u>
            <strong>Description</strong>
          </u>
        </p>
        <p>Returns fd if it isn't a NNMUSL fd or translates to NNMUSL fd. Does not set errno.</p>
      </td>
    </tr>
  </tbody>
</table>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__socket__Select', '../../../Api/HtmlNX/namespacenn_1_1socket.html#a3a52df3f484b631d21496ff6ad23ec9e' )
SetUrl( 'ApiLink_nn__socket', '../../../Api/HtmlNX/namespacenn_1_1socket.html' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
