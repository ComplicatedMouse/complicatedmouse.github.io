<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Feature Usage | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Feature Usage -->
<div class="pagetitle" id="PageId_114739604">Feature Usage</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_114739604_h1_1">Introduction</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_2">Workflow for Using the nfp Library</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_3">Initialization</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_1">Initializing the nfp Library</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_2">Registering Tag Notification Events</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_3">Destroying Tag Notification Events</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_4">Starting Tag Detection</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_5">Getting Tag Information</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_6">Mounting a Tag</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_4">Restoring Corrupted Tag Data</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_7">Accessing NFP Tag Regions</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_5">Getting the Character ID</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_6">Getting the Owner and Nickname</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_7">Accessing the Application-Specific Region</a>
      </li>
      <ul>
        <li>
          <a href="#Anchor_114739604_h3_1">Reading From the Application-Specific Region</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_2">Creating an Application-Specific Region</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_3">Writing to the Application-Specific Region</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_4">Using and Overwriting the amiibo Game Data by Applications with Different Access IDs</a>
        </li>
      </ul>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_8">Waiting for Tag Loss Notifications</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_9">Finalization</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_10">Common Error Handling</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_11">Displaying Messages Using the Error Viewer</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_8">Displaying the Error Viewer From the Application</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_9">Displaying the Error Viewer Using the nfp Library</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_12">amiibo Settings</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_10">Setting the Owner and Nickname</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_11">Restoring Data</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_12">Deleting Game Data</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_13">Using Multiple NFC Devices Simultaneously</a>
    </li>
  </ul>
</p>
<h1 id="Anchor_114739604_h1_1">Introduction</h1>
<p>This page provides an overview of how to use the <code>nfp</code> library features.</p>
<h1 id="Anchor_114739604_h1_2">Workflow for Using the nfp Library</h1>
<p>The following figure illustrates the basic workflow for using the <code>nfp</code> library.</p>
<!--figure001-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure001"></a>Figure 3  Basic Workflow for Using the nfp Library</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039824.png" width="500" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_3">Initialization</h1>
<h2 id="Anchor_114739604_h2_1">Initializing the nfp Library</h2>
<p>Call the <code><span class="ApiLink_nn__nfp__Initialize">nn::nfp::Initialize</span>()</code> function to initialize the <code>nfp</code> library.</p>
<p>User operations can cause NFC devices to become unavailable at unintended times while the <code>nfp</code> library is being used. To prepare for this situation ahead of time, call the <code><span class="ApiLink_nn__nfp__AttachAvailabilityChangeEvent">nn::nfp::AttachAvailabilityChangeEvent</span>()</code> function after initializing the <code>nfp</code> library, and set an event that notifies about the changes in the availability of NFC devices.</p>
<p>After this event has been configured, a notification will be received whenever any of the following changes take place.</p>
<ul>
  <li>An NFC device is disconnected</li>
  <li>An NFC device is connected</li>
  <li>The application that has the focus has changed</li>
  <li>The system wakes up from sleep</li>
  <li>The NFC feature is disabled</li>
  <li>The NFC feature is enabled </li>
</ul>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>This event is triggered when the NFC feature is enabled and disabled while no NFC device is connected.</p>
  </div>
</div>
<p>If you pass an uninitialized <code><span class="ApiLink_nn__os__SystemEventType">nn::os::SystemEventType</span></code> structure to the <code><span class="ApiLink_nn__nfp__AttachAvailabilityChangeEvent">nn::nfp::AttachAvailabilityChangeEvent</span>()</code> function, the event will be initialized so that notifications can be received. For more information about controlling system events, see the System Events section in the <code>os</code> library.</p>
<p>When this notification is received, you can use the <code><span class="ApiLink_nn__nfp__GetDeviceState">nn::nfp::GetDeviceState</span>()</code> function, if necessary, to check the state of the <code>nfp</code> library.</p>
<!--figure002-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure002"></a>Figure 4  Initialization</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039834.png" width="200" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_2">Registering Tag Notification Events</h2>
<p>Before working with tags, you must set events so the application can receive tag detection notifications from the <code>nfp</code> library.</p>
<p>The <code>nfp</code> library sends tag detection notifications to the application at the following times.</p>
<ol>
  <li>Tag detection notification<ul><li>The NFC device detected an NFC tag.</li></ul></li>
  <li>Tag loss notification<ul><li>The detected NFC tag was removed from the NFC device.</li><li>The <code><span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>()</code> or <code><span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>()</code> function was called when a tag had been detected.</li></ul></li>
</ol>
<p>First, get the information of the NFC device you will be using to work with NFC tags.</p>
<p>After initializing the <code>nfp</code> library, get the list of NFC device handles. Use the <code><span class="ApiLink_nn__nfp__ListDevices">nn::nfp::ListDevices</span>()</code> function to get this list of NFC device handles.</p>
<p>Next, call the <code><span class="ApiLink_nn__nfp__GetNpadId">nn::nfp::GetNpadId</span>()</code> function to get the <code>NpadId</code> of the controller that will be used for working with the NFC tags. Specify the device handles returned by the <code><span class="ApiLink_nn__nfp__ListDevices">nn::nfp::ListDevices</span>()</code> function as a parameter when calling the <code><span class="ApiLink_nn__nfp__GetNpadId">nn::nfp::GetNpadId</span>()</code> function. Get the <code>NpadId</code> for each device handle, and use the <code>NpadId</code> to identify the device handle of the controller you will be using to work with NFC tags. For more information about <code>NpadId</code>, see the <code>hid</code> library.</p>
<p>Next, register the tag detection notification event and the tag loss notification events to each NFC device you will be using to work with NFC tags. Call the <code><span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>()</code> function to register the tag detection notification event, and call the <code><span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>()</code> function to register the tag loss notification event. Pass an uninitialized instance of the <code><span class="ApiLink_nn__os__SystemEventType">nn::os::SystemEventType</span></code> structure when calling these functions to initialize the events and make it possible to receive the notifications. For more information about controlling system events, see the System Events section in the <code>os</code> library.</p>
<p>The event set using the <code><span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>()</code> function is signaled to notify the application that a tag has been detected.</p>
<p>The event set using the <code><span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>()</code> function is signaled to notify the application that the tag has been lost.</p>
<p>The following figure presents an example of the flow from the acquisition of the NFC device handle to the registration of the event.</p>
<!--figure050-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure050"></a>Figure 5  Getting the NFC Device Handle List and Attaching the Notification Events</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039835.png" width="500" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_3">Destroying Tag Notification Events</h2>
<p>The events initialized using the <code><span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>()</code> and <code><span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>()</code> functions must always be freed after they have been used. Also, before re-attaching events after an error occurs, make sure that you free any events currently attached to the NFC device handle. Call the <code><span class="ApiLink_nn__os__DestroySystemEvent">nn::os::DestroySystemEvent</span>()</code> function to free an event.</p>
<h1 id="Anchor_114739604_h1_4">Starting Tag Detection</h1>
<p>Call the <code><span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>()</code> function to start tag detection. Specify the applicable NFC device handle as a parameter when calling this function. Before starting tag detection, the <code><span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>()</code> function must be called if a tag has previously been detected or if a tag is currently being detected.</p>
<p>While the tag detection process is running, the <code>nfp</code> library periodically checks whether any tags have been detected and whether it can communicate with the detected tags. There can be a time lag of up to approximately one second between when the event that causes the tag detection state to change occurs and when the application is notified of the event. There can be be a time lag of up to approximately one to three seconds until the application is notified of tag loss. Do not implement your application in a way that requires careful timing when applying and removing tags.</p>
<p>After tag detection starts, the event set using the <code><span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>()</code> function is signaled to notify the application that a tag has been detected. When a tag is detected, the following processes become available.</p>
<ul>
  <li>Getting Tag Information</li>
  <li>Mounting a Tag</li>
</ul>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>Detection will fail if you transition to the HOME Menu, or to sleep mode, while waiting for notification that a tag has been discovered. If a notification event for a change in NFC device availability is received before a tag discovery notification has been received, call the <code><span class="ApiLink_nn__nfp__GetDeviceState">nn::nfp::GetDeviceState</span>()</code> function to determine the state and check whether detection failed.</p>
  </div>
</div>
<p>The following figure presents an example of the flow for tag detection.</p>
<!--figure003-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure003"></a>Figure 6  Starting Tag Detection</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039819.png" width="500" class="embedded-image" />
  </span>
</p>
<p>After a tag is detected, if the tag is removed from the NFC device, the <code>nfp</code> library loses the tag. When this happens, the event set using the <code><span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>()</code> function is signaled to notify the application that the tag has been lost. While the tag is in this lost state, data cannot be read from or written to the tag. To re-enable access to the tag, call the <code><span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>()</code> function again.</p>
<h1 id="Anchor_114739604_h1_5">Getting Tag Information</h1>
<p>Call the <code><span class="ApiLink_nn__nfp__GetTagInfo">nn::nfp::GetTagInfo</span>()</code> function to get tag information. Only call this function after a tag has been detected or mounted.</p>
<p>Tag information is defined as an instance of the <code><span class="ApiLink_nn__nfp__TagInfo">nn::nfp::TagInfo</span></code> structure. The values for the detected tag are written to the instance of the <code><span class="ApiLink_nn__nfp__TagInfo">nn::nfp::TagInfo</span></code> structure passed as a parameter to the <code><span class="ApiLink_nn__nfp__GetTagInfo">nn::nfp::GetTagInfo</span>()</code> function.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>The <code>nfp</code> library can only get the UID of an NFC tag from this tag information.</p>
    <p>Because the tag information only contains information that can be retrieved from any tag type that is accessible to the <code>nfp</code> library, there is no way to determine whether the detected tag is an NFP tag.</p>
  </div>
</div>
<p>The example in the following flowchart shows how to get the tag information and then use the UID to check whether the detected tag is suitable for use with the application.</p>
<!--figure015-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure015"></a>Figure 7  Getting Tag Information</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039833.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_Mount"></a>
</p>
<h1 id="Anchor_114739604_h1_6">Mounting a Tag</h1>
<p>Before accessing the information on an NFP tag, you must first call the <code><span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code> function to mount the detected tag.</p>
<p>There are two versions of the <code><span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code> function: one where the regions that can be accessed are specified and one where they are not.</p>
<div class="code">
  <a name="AutoAnchor_114739604_code001"></a>Code 1  Mounting a Tag</div>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">Mount</span> <span class="p">(</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="nn">nn::nfp::</span><span class="n">DeviceHandle</span> <span class="o">&amp;</span>     <span class="n">deviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">ModelType</span>                <span class="n">modelType</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">);</span>

<span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">Mount</span> <span class="p">(</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="nn">nn::nfp::</span><span class="n">DeviceHandle</span> <span class="o">&amp;</span>     <span class="n">deviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">ModelType</span>                <span class="n">modelType</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">MountTarget</span>              <span class="n">mountTarget</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>When specifying the regions to mount, specify an <code><span class="ApiLink_nn__nfp__MountTarget">nn::nfp::MountTarget</span></code>-typed value for the parameter. The version of the function that does not take a region specification does the same thing as when the <code>MountTarget_All</code> (all regions) value is specified in the version of the function that does take a region specification.</p>
<p>The behavior of the function differs according to the specified mount target region. When a mount target region other than <code>MountTarget_Rom</code> is specified, the backup data is automatically updated if the mount process is successful.</p>
<!--table002-->
<div class="table">
  <a name="AutoAnchor_114739604_table002"></a>Table 5  Specifying Mount Target, and Resulting Behavior When Mount Process Succeeds</div>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>Specified Parameter</th>
      <th>Mount Target Region</th>
      <th>Backup Data Updated When Mount Process Succeeds?</th>
    </tr>
    <tr>
      <td>
        <code>MountTarget_Rom</code>
      </td>
      <td>Read-only regions.</td>
      <td>Not updated</td>
    </tr>
    <tr>
      <td>
        <code>MountTarget_Ram</code>
      </td>
      <td>Read/write regions.</td>
      <td>Updated</td>
    </tr>
    <tr>
      <td>
        <code>MountTarget_All</code>
        <br />or region not specified</td>
      <td>All regions.</td>
      <td>Updated</td>
    </tr>
  </tbody>
</table>
<p>If the detected tag is not an NFP tag, the <code><span class="ApiLink_nn__nfp__ResultNotSupported">nn::nfp::ResultNotSupported</span></code> value is returned.</p>
<p>If the tag cannot be mounted because it has an unknown format version, the <code><span class="ApiLink_nn__nfp__ResultInvalidFormatVersion">nn::nfp::ResultInvalidFormatVersion</span></code> value is returned (even if the detected tag is an NFP tag).</p>
<p>If the detected tag is an NFP tag and is mounted successfully, the <code><span class="ApiLink_nn__ResultSuccess">nn::ResultSuccess</span></code> value is returned.</p>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>If the tag is removed and communication is cut while the tag is being read, the <code><span class="ApiLink_nn__nfp__ResultNotSupported">nn::nfp::ResultNotSupported</span></code> value is returned even if the tag is a proper NFP tag.</p>
  </div>
</div>
<p>When <code><span class="ApiLink_nn__nfp__ResultNeedRetry">nn::nfp::ResultNeedRetry</span></code> is returned, the mounting process may succeed if the <code><span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code> function is called again.</p>
<p>If the tag data is corrupted, the <code><span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span></code> or <code><code><span class="ApiLink_nn__nfp__ResultNeedFormat">nn::nfp::ResultNeedFormat</span></code></code> value is returned. However, even if the tag is corrupted, <code>ResultSuccess</code> is returned if <code>MountTarget_Rom</code> was specified when the tag was mounted. When <code><span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span></code> is returned, you can restore the tag. (Also see <a href="#Anchor_114739604_whenRepairable">Restoring Corrupted Tag Data</a>.) When <code><span class="ApiLink_nn__nfp__ResultNeedFormat">nn::nfp::ResultNeedFormat</span></code> is returned, you can restore the tag if other game consoles have used the tag. Recovery is not possible if no other game consoles have used it. Perform initialization from the amiibo Settings in the HOME Menu.</p>
<p>
  <code>
    <span class="ApiLink_nn__nfp__ResultNeedRestart">nn::nfp::ResultNeedRestart</span>
  </code> is returned if the tag to mount could not be found. To keep the tag mounted, the <code><span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>()</code> function must be called again.</p>
<p>The <code><span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>()</code> function must also be called again if a tag loss notification is received. If you attempt to mount a tag after the tag loss notification is received without doing this, the <code><span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code> function returns <code><span class="ApiLink_nn__nfp__ResultNfcDeviceNotFound">nn::nfp::ResultNfcDeviceNotFound</span></code>.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>Mounting the tag requires approximately one second.</p>
  </div>
</div>
<p>
  <br />
</p>
<p>The following figure presents an example of the flow for mounting a tag.</p>
<!--figure004-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure004"></a>Figure 8  Mounting a Tag</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039836.png" width="500" class="embedded-image" />
  </span>
</p>
<p>If an error occurs during the process and it is possible to retry, you do not necessarily need to use exactly the same number of attempts as in the flowchart.</p>
<p>
  <a name="Anchor_114739604_whenRepairable"></a>
</p>
<h2 id="Anchor_114739604_h2_4">Restoring Corrupted Tag Data</h2>
<p>When the <code><span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code> function returns <code><span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span></code>, the application can restore the NFP tag. Do one of the following to restore the data.</p>
<ul>
  <li>Call the <code><span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span>()</code> function from the application.</li>
  <li>Call the <code><span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>()</code> function from the amiibo Settings application.</li>
</ul>
<p>When calling the <code><span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span>()</code> function, make sure that the tag has been detected but not yet mounted or lost.</p>
<p>If the <code><span class="ApiLink_nn__nfp__ResultNeedRetry">nn::nfp::ResultNeedRetry</span></code> value is returned, the tag restoration process may succeed if the <code><span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span></code> function is called again.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>Restoring the tag takes approximately one to two seconds.</p>
  </div>
</div>
<p>The tag is restored using the data that was backed up by the <code>nfp</code> library when mounting the tag or immediately before writing to the tag. Consequently, the restored data is the data that the application is attempting to write, not the data that was on the tag before the write process failed.</p>
<p>The following figure presents an example of the flow for restoring a tag. If a different tag is tapped to the device during this process, the process is restarted from the step of starting tag detection.</p>
<!--figure005-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure005"></a>Figure 9  Restoring a Tag</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039838.png" width="500" class="embedded-image" />
  </span>
</p>
<p>If an error occurs during the process and it is possible to retry, you do not necessarily need to use exactly the same number of attempts as in the flowchart.</p>
<h1 id="Anchor_114739604_h1_7">Accessing NFP Tag Regions</h1>
<p>After a tag is successfully mounted, you can access the regions on the NFP tag. NFP tags have the following regions.</p>
<!--table003-->
<div class="table">
  <a name="AutoAnchor_114739604_table003"></a>Table 6  NFP Tag Regions</div>
<table class="wrapped">
  <tbody>
    <tr>
      <th>NFP Tag Region</th>
      <th>Overview</th>
    </tr>
    <tr>
      <td>Shared Region</td>
      <td>This region stores NFP tag information such as owner-registered information and the character ID. This region is read-only and the application cannot write to it.</td>
    </tr>
    <tr>
      <td>Application-Specific Region</td>
      <td>This read/write region is created specifically for the application. This region can store up to 216 bytes of data.</td>
    </tr>
  </tbody>
</table>
<p>For more information about the shared region and the application-specific region, see the NFP Guide.</p>
<h2 id="Anchor_114739604_h2_5">Getting the Character ID</h2>
<p>Before using the information stored on a mounted NFP tag in the application, you must get the character ID. The application must then check whether the retrieved character ID is for a character that can be used in that application. For more information about which character IDs can be used by which applications, see the NFP Guide.</p>
<p>Call the <code><span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>()</code> function to get the character ID. When mounting the tag, <code>MountTarget_Rom</code> or <code>MountTarget_All</code> must be specified for the mount region. The shared region information retrieved by the <code><span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>()</code> function is defined as an instance of the <code><span class="ApiLink_nn__nfp__ModelInfo">nn::nfp::ModelInfo</span></code> structure. The retrieved values are written to the instance of the <code><span class="ApiLink_nn__nfp__ModelInfo">nn::nfp::ModelInfo</span></code> structure passed as a parameter to the <code><span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>()</code> function.</p>
<p>The following figure presents an example of the flow for getting the character ID.</p>
<!--figure006-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure006"></a>Figure 10  Getting the Character ID</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039830.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_GetRegisterInfo"></a>
</p>
<h2 id="Anchor_114739604_h2_6">Getting the Owner and Nickname</h2>
<p>Call the <code><span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>()</code> function to get the owner and nickname information stored on the NFP tag. When mounting the tag, <code>MountTarget_Ram</code> or <code>MountTarget_All</code> must be specified for the mount region.</p>
<p>The owner and nickname information are defined as an instance of the <code><span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span></code> structure. These values are written to the instance of the <code><span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span></code> structure passed as a parameter to the <code><span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>()</code> function. The <code><span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span></code> structure also contains the font region information used to display the nickname.</p>
<p>If the <code><span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span></code> value is returned, an owner has not yet been registered for the NFP tag in the amiibo Settings application. Make sure that applications that require NFP tags to have an owner and a nickname registered start the amiibo Settings application at this point.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>Applications that display the nickname must take care in the handling of amiibo nicknames and Mii nicknames. In particular, avoid displaying the nickname in a manner that implies it is the name of the owner&rsquo;s Mii. Also make sure that you display a substitute string such as &quot;(Owner name)'s amiibo,&quot; &quot;(amiibo character name),&quot; or just &quot;amiibo&quot; in cases where the nickname is not set.</p>
  </div>
</div>
<p>If an owner is registered, Mii data is definitely available, but in some cases a nickname might not be set (it might be an empty string). If your application requires a nickname, start the amiibo Settings application using the same procedure described for <code><span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span></code>.</p>
<p>The nickname is stored as a UTF-8 string. The terminating character is NULL (<code>0x00</code>). Nicknames may include characters from different font regions that the application does not support. Handle the display of unsupported characters in a way that does not corrupt the display or prevent the application from proceeding. For example, you can use the system font specified in the font region or display substitute characters for characters that are not included in the application font.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>We recommend using &ldquo;□&rdquo; (<code>U+25A1</code>) as the substitute character. This practice increases consistency in the overall user experience, because the NX system features also use &ldquo;□&rdquo; (<code>U+25A1</code>) as a substitute character.</p>
    <p>We do not recommend using white space or hiding characters that are not included in the application fonts. In some cases, leaving out characters can potentially make the nickname appear to be profanity.</p>
  </div>
</div>
<p>The following figure presents an example of the flow for getting the owner and nickname.</p>
<!--figure007-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure007"></a>Figure 11  Getting the Owner and Nickname</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039832.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_OpenApplicationArea"></a>
</p>
<h2 id="Anchor_114739604_h2_7">Accessing the Application-Specific Region</h2>
<p>The application-specific region contains data for applications that support an amiibo figure. The application can read and write data to and from this region.</p>
<p>Access privileges to the application-specific region are controlled using an access ID. Before accessing the application-specific region, you must first check whether the application has access privileges to that region. Call the <code><span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</code> function to check the state of the application-specific region on the NFP tag.</p>
<p>If the access IDs do not match, the <code><span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</code> function returns <code><span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span></code>. In this case, both reading and writing are restricted. To use the application-specific region for an application, any data written to the application-specific region using the amiibo Settings application must be deleted.</p>
<p>If no application-specific region is present, the <code><span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</code> function returns <code><span class="ApiLink_nn__nfp__ResultNeedCreate">nn::nfp::ResultNeedCreate</span></code>. In this case, have the application create an application-specific region.</p>
<p>If the data written to the application-specific region will also be read by Cafe, we recommend standardizing the byte order because the Cafe and NX architectures have different endianness.</p>
<p>The following figure presents an example of the flow for accessing the application-specific region.</p>
<!--figure008-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure008"></a>Figure 12  Accessing the Application-Specific Region</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039837.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_1">Reading From the Application-Specific Region</h3>
<p>Call the <code><span class="ApiLink_nn__nfp__GetApplicationArea">nn::nfp::GetApplicationArea</span>()</code> function to read the data written to the application-specific region.</p>
<p>This call enables you to read the specified number of bytes from the beginning of the application-specific region. The maximum size of the data that can be read from the application-specific region can be retrieved from the <code>applicationAreaSize</code> member of the <code><span class="ApiLink_nn__nfp__CommonInfo">nn::nfp::CommonInfo</span></code> structure that can be retrieved using the <code><span class="ApiLink_nn__nfp__GetCommonInfo">nn::nfp::GetCommonInfo</span>()</code> function.</p>
<p>The following figure presents an example of the flow for reading the application-specific region.</p>
<!--figure010-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure010"></a>Figure 13  Reading From the Application-Specific Region</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039829.png" width="450" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_2">Creating an Application-Specific Region</h3>
<p>Call the <code><span class="ApiLink_nn__nfp__CreateApplicationArea">nn::nfp::CreateApplicationArea</span>()</code> function to create an application-specific region.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>Creating the application-specific region takes approximately one to two seconds. Because this function performs the same work as the <code><span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>()</code> function, you do not need to call <code><span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>()</code> after calling the <code><span class="ApiLink_nn__nfp__CreateApplicationArea">nn::nfp::CreateApplicationArea</span>()</code> function.</p>
  </div>
</div>
<p>The following figure presents an example of the flow for creating an application-specific region.</p>
<!--figure009-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure009"></a>Figure 14  Creating an Application-Specific Region</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039827.png" width="500" class="embedded-image" />
  </span>
</p>
<p>If an error occurs during the process and it is possible to retry, you do not necessarily need to use exactly the same number of attempts as in the flowchart.</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_3">Writing to the Application-Specific Region</h3>
<p>Call the <code><span class="ApiLink_nn__nfp__SetApplicationArea">nn::nfp::SetApplicationArea</span>()</code> function followed by the <code><span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>()</code> function to write data to the application-specific region.</p>
<p>The data is not actually written to the application-specific region when <code><span class="ApiLink_nn__nfp__SetApplicationArea">nn::nfp::SetApplicationArea</span>()</code> finishes executing. Instead, it is stored in a cache in the <code>nfp</code> library. The data is actually written to the application-specific region of the NFP tag when the <code><span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>()</code> function is called.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>Writing to the application-specific region of the NFP tag takes approximately one to two seconds.</p>
  </div>
</div>
<p>The following figure presents an example of the flow for writing to an application-specific region.</p>
<!--figure011-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure011"></a>Figure 15  Writing to the Application-Specific Region</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039818.png" width="500" class="embedded-image" />
  </span>
</p>
<p>If an error occurs during the process and it is possible to retry, you do not necessarily need to use exactly the same number of attempts as in the flowchart.</p>
<p>
  <a name="Anchor_114739604_a_RecreateApplicationArea"></a>
</p>
<h3 id="Anchor_114739604_h3_4">Using and Overwriting the amiibo Game Data by Applications with Different Access IDs</h3>
<p>The <code><span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>()</code> function is used to overwrite the access ID and the data format on the amiibo. Used when applications with different access IDs will be using and overwriting the amiibo game data. To perform this, you need the information for the access ID of the application that wrote game data to the amiibo.</p>
<p>Here is an example of the flow for the use of this function. (In this description, the access ID of the running application is <strong>A</strong>, and the access ID of another application known to this application is <strong>B</strong>.)</p>
<ol>
  <li>First, check whether the game data registered in the touched amiibo is the game data for the running application. Call <code><span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</code> using access ID <strong>A</strong>.<ol><li>If the function succeeds, then you can proceed with data reading and writing in the usual way.</li><li>If the function returns <code><span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span></code> then proceed to step 2.</li></ol></li>
  <li>Call <code><span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</code> again, this time using access ID <strong>B</strong>.<ol><li>If the function succeeds with access ID <strong>B</strong>, then you can use <code><span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>()</code>. Get confirmation from the user to overwrite the game data in the amiibo, and then proceed to use the game data.</li><li>If the function also returns <code><span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span></code> with access ID <strong>B</strong>, then the running application cannot access the amiibo game data. Inform the user that the game data in the amiibo cannot be handed over to the application.</li></ol></li>
</ol>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>The <code><span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>()</code> function overwrites the access ID, so the original application can no longer access the amiibo after the function has executed. Inform the user that the original application will not be able to access the data in the amiibo after it is handed over to the other application.</p>
  </div>
</div>
<p>The following figure presents an example of the flow for handing the data over after user consent.</p>
<!--figure021-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure021"></a>Figure 16  Handing the Application-Specific Region Data to Another Application</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/517089911.png" width="500" class="embedded-image" />
  </span>
</p>
<p>If an error occurs during the process and it is possible to retry, you do not necessarily need to use exactly the same number of attempts as in the flowchart.</p>
<h1 id="Anchor_114739604_h1_8">Waiting for Tag Loss Notifications</h1>
<p>After tag access is complete or a different tag is tapped to the NFC device, if tag detection remains enabled, the <code>nfp</code> library discards the information for the currently mounted tag and returns to a state in which tags can be detected again.</p>
<p>Call the <code><span class="ApiLink_nn__nfp__Unmount">nn::nfp::Unmount</span>()</code> function to unmount a tag.</p>
<p>Then, notify the user to remove the tag. After the tag is removed from the NFP device, a tag loss notification is sent to the application.</p>
<p>Call the <code><span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>()</code> function to stop tag detection.</p>
<p>The following figure presents an example of the flow for waiting for a lost tag.</p>
<!--figure012-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure012"></a>Figure 17  Waiting for Tag Loss Notifications</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039823.png" width="350" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_9">Finalization</h1>
<p>Call the <code><span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>()</code> function to finalize the <code>nfp</code> library. This function unmounts the tag, stops tag detection, and, if a tag had been detected, issues a tag loss notification. When you finalize the <code>nfp</code> library, remember to destroy the following events.</p>
<ul>
  <li>Notification of a change in NFC device availability</li>
  <li>Tag detection notification</li>
  <li>Tag loss notification</li>
</ul>
<!--figure013-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure013"></a>Figure 18  Finalizing the nfp Library</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039828.png" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_10">Common Error Handling</h1>
<p>The following figure provides an example of a sequence that can be used to handle errors that returned by any of the functions in the <code>nfp</code> library. Errors handled with this sequence generally require retrying from the start of tag detection. This example assumes that the same tag will stay touching the device until communication finishes, and an error will occur when the tag is swapped with a different tag.</p>
<p>If there is a way for the user to resolve the error, display a notification instructing the user what to do. If the NFC feature is currently disabled, for example, display a notification instructing the user to enable the NFC feature.</p>
<!--figure014-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure014"></a>Figure 19  Common Error Handling</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039826.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h1 id="Anchor_114739604_h1_11">Displaying Messages Using the Error Viewer</h1>
<h2 id="Anchor_114739604_h2_8">Displaying the Error Viewer From the Application</h2>
<p>You can use the error viewer to display error messages for errors returned by the <code>nfp</code> library.</p>
<p>You can display messages, using Error Viewer, for nearly all of the errors. For more information about the Error Viewer messages that appear for each error, see the error code list in the online documentation.</p>
<p>As an exception, however, Error Viewer does not support the following errors. Support this error handling within the application.</p>
<!--table005-->
<div class="table">
  <a name="AutoAnchor_114739604_table005"></a>Table 7  Errors With No Messages in Error Viewer</div>
<table class="wrapped relative-table" style="width: 96.6599%;">
  <colgroup>
    <col style="width: 24.9458%;" />
    <col style="width: 19.8498%;" />
    <col style="width: 20.4106%;" />
    <col style="width: 34.7938%;" />
  </colgroup>
  <tbody>
    <tr>
      <th>Return Values</th>
      <th>Error Description</th>
      <th>Sample Messages</th>
      <th>Related Topic</th>
    </tr>
    <tr>
      <td>
        <p>
          <code>
            <span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span>
          </code>
        </p>
        <p>
          <br />
        </p>
        <p>
          <strong>Function That Returns This Error</strong>
        </p>
        <p>
          <span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>()</p>
      </td>
      <td>
        <p>Registration data is not set. Settings are required in the amiibo settings.</p>
        <p>
          <br />
        </p>
      </td>
      <td>Register an owner and nickname to the amiibo.</td>
      <td>
        <p>
          <a href="#Anchor_114739604_a_GetRegisterInfo">Getting Owners and Nicknames</a> for accessing NFP tag areas.</p>
        <p>
          <a href="#Anchor_114739604_a_OwnerSetings">Adding Owners and Nicknames</a> for amiibo settings.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          <code>
            <span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span>
          </code>
        </p>
        <p>
          <br />
        </p>
        <p>
          <strong>Function That Returns This Error</strong>
        </p>
        <p>
          <code>
            <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</code>
        </p>
      </td>
      <td>
        <p>Tag data is corrupted.</p>
        <p>You must use the <code>Restore()</code> function to restore the tags.</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <p>The amiibo data is corrupted.</p>
        <p>Do you want to restore the amiibo with the data saved on the system?</p>
      </td>
      <td>
        <p>
          <a href="#Anchor_114739604_whenRepairable">Corrupted Tag Data Could Be Recoverable</a> <a href="#Anchor_114739604_a_Mount">for mounting tags.</a><br /><a href="#Anchor_114739604_a_StartRestorer">Restore Data</a> for amiibo settings.</p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          <code>
            <span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span>
          </code>
        </p>
        <p>
          <br />
        </p>
        <p>
          <strong>Function That Returns This Error</strong>
        </p>
        <p>
          <span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</p>
      </td>
      <td>
        <p>Cannot access the application-specific region because the access ID does not match.</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <p>Cannot write data for this game because data for a different game has been recorded. Erase the data recorded to the amiibo for the different game and enable writing?</p>
      </td>
      <td>
        <a href="#Anchor_114739604_a_OpenApplicationArea">Accessing the Application-Specific Region</a> for accessing NFP tag areas.<br /><a href="#Anchor_114739604_a_RecreateApplicationArea">Using and Overwriting the amiibo Game Data by Applications With Different Access IDs</a></td>
    </tr>
  </tbody>
</table>
<p>You do not need to display a message when no notification to the user is necessary, such as when error processing is at the application's discretion.</p>
<h2 id="Anchor_114739604_h2_9">Displaying the Error Viewer Using the nfp Library</h2>
<p>In some cases, you may need to display the error viewer using the <code>nfp</code> library, such as when a fatal system error occurs or the controller breaks.</p>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>Note that when the error viewer is displayed by the <code>nfp</code> library, it will take a period of time for control to return to the application. Depending on the timing, the error viewer might not display until after the application has canceled the use of NFC.</p>
  </div>
</div>
<h1 id="Anchor_114739604_h1_12">amiibo Settings</h1>
<p>The amiibo Settings application can be used to set owner information, delete game data, and perform other special operations on NFP tags. Applications have access to the following features of the amiibo Settings application.</p>
<ul>
  <li>Setting the owner and nickname</li>
  <li>Restoring data</li>
  <li>Deleting game data.</li>
</ul>
<p>The amiibo Settings application retains program control and does not return it to the game application until the operation that is being performed is complete.</p>
<p>
  <a name="Anchor_114739604_a_OwnerSetings"></a>
</p>
<h2 id="Anchor_114739604_h2_10">Setting the Owner and Nickname</h2>
<p>Call the <code><span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>()</code> function to access the owner and nickname registration feature of the amiibo Settings application. There are two versions of the <code><span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>()</code> function: one which takes an instance of <code>RegisterInfo</code> as a parameter and one which does not.</p>
<!--code101-->
<div class="code">
  <a name="AutoAnchor_114739604_code101"></a>Code 2  Setting the Owner and Nickname</div>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">StartNicknameAndOwnerSettings</span>     <span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">DeviceHandle</span> <span class="o">*</span>                        <span class="n">pOutDeviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">bool</span> <span class="o">*</span>                                <span class="n">pOutIsRegistered</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">RegisterInfo</span> <span class="o">*</span>                        <span class="n">pOutRegisterInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">AmiiboSettingsStartParam</span> <span class="o">&amp;</span>      <span class="n">startParam</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">TagInfo</span> <span class="o">&amp;</span>                       <span class="n">tagInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">RegisterInfo</span> <span class="o">&amp;</span>                  <span class="n">registerInfo</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">)</span>

<span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">StartNicknameAndOwnerSettings</span>     <span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">DeviceHandle</span> <span class="o">*</span>                        <span class="n">pOutDeviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">bool</span> <span class="o">*</span>                                <span class="n">pOutIsRegistered</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">RegisterInfo</span> <span class="o">*</span>                        <span class="n">pOutRegisterInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">AmiiboSettingsStartParam</span> <span class="o">&amp;</span>      <span class="n">startParam</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">TagInfo</span> <span class="o">&amp;</span>                       <span class="n">tagInfo</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">)</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The following figure presents an example of the flow for registering an owner and nickname by using the amiibo settings.</p>
<!--figure101-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure101"></a>Figure 20  amiibo Settings – Setting the Owner and Nickname</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039821.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_StartRestorer"></a>
</p>
<h2 id="Anchor_114739604_h2_11">Restoring Data</h2>
<p>Call the <code><span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>()</code> function to access the data restoration feature of the amiibo Settings application.</p>
<p>The following figure presents an example of the flow for restoring data using the amiibo settings.</p>
<!--figure102-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure102"></a>Figure 21  amiibo Settings – Restoring Data</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039822.png" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_12">Deleting Game Data</h2>
<p>Call the <code><span class="ApiLink_nn__nfp__StartGameDataEraser">nn::nfp::StartGameDataEraser</span>()</code> function to access the game data deletion feature of the amiibo Settings application.</p>
<p>The following figure shows an example of the flow for deleting game data using the amiibo Settings.</p>
<!--figure103-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure103"></a>Figure 22  amiibo Settings – Deleting Game Data</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/193039820.png" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_13">Using Multiple NFC Devices Simultaneously</h1>
<p>When using multiple NFC devices simultaneously, it is possible to use a thread to manipulate each NFC.</p>
<!--figure201-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure201"></a>Figure 23 Example of Managing Multiple NFC Devices by Thread</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/199795117.png" width="500" class="embedded-image" />
  </span>
</p>
<p>In the example in the figure, the <code>nfp</code> library is initialized and NFC device handles are acquired. A thread is used to manage each NFC device handle that is acquired, and they can be called with multithreaded APIs.</p>
<p>Consider the following when using multiple NFC devices simultaneously.</p>
<ul>
  <li>Call <code><span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>()</code> after completing operation for all tags.</li>
  <li>amiibo settings (<code><span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>()</code>, <code><span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>()</code>, or <code><span class="ApiLink_nn__nfp__StartGameDataEraser">nn::nfp::StartGameDataEraser</span>()</code>) can only be performed for one thread at a time, even if multiple threads are called simultaneously. amiibo settings for other threads are blocked until the amiibo settings that are currently in progress have completed.</li>
  <li>A maximum of four NFC devices may be connected. If five or more controllers are connected, only one device may use NFC features.<br /><p><br /></p></li>
</ul>
<p>
  <br />
</p>
<p>
  <br />
</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__nfp__Initialize', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#afa344c4dc54ca2a562b3ddfee0742f99' )
SetUrl( 'ApiLink_nn__nfp__AttachAvailabilityChangeEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a0e70bf61d3d0f6c7c3c9dd63a6e7db04' )
SetUrl( 'ApiLink_nn__os__SystemEventType', '../../../Api/HtmlNX/structnn_1_1os_1_1_system_event_type.html' )
SetUrl( 'ApiLink_nn__nfp__GetDeviceState', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aeb240b6269510ef739fb4a820ee3601a' )
SetUrl( 'ApiLink_nn__nfp__StopDetection', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aa8bd12f4e1b4b206463047e3142a261a' )
SetUrl( 'ApiLink_nn__nfp__Finalize', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a217aa0ade4696c4f68c5574e6e2ed3e0' )
SetUrl( 'ApiLink_nn__nfp__ListDevices', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a8e7488fa2c37e3b7b3c8624699c8ce7e' )
SetUrl( 'ApiLink_nn__nfp__GetNpadId', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ab15d52a3089002edbf40e1ecebf2b490' )
SetUrl( 'ApiLink_nn__nfp__AttachActivateEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a2a08ccb321632168ac7c0d9003336f11' )
SetUrl( 'ApiLink_nn__nfp__AttachDeactivateEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a898bfa0687f44dc0f4220f989563c6a8' )
SetUrl( 'ApiLink_nn__os__DestroySystemEvent', '../../../Api/HtmlNX/namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338' )
SetUrl( 'ApiLink_nn__nfp__StartDetection', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#afd22b7158c9c5ef8ab0a59db89e7d351' )
SetUrl( 'ApiLink_nn__nfp__GetTagInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a45e88ea137a0212dad4a44de072c5abc' )
SetUrl( 'ApiLink_nn__nfp__TagInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_tag_info.html' )
SetUrl( 'ApiLink_nn__nfp__Mount', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aef2cbec549b247b6dcc7afff15fdc5b3' )
SetUrl( 'ApiLink_nn__nfp__MountTarget', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a9f52385485f17ebfad924d6e72ab4356' )
SetUrl( 'ApiLink_nn__nfp__ResultNotSupported', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_not_supported.html' )
SetUrl( 'ApiLink_nn__nfp__ResultInvalidFormatVersion', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_invalid_format_version.html' )
SetUrl( 'ApiLink_nn__ResultSuccess', '../../../Api/HtmlNX/classnn_1_1_result_success.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRetry', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_retry.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRestore', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_restore.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedFormat', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_format.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRestart', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_restart.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNfcDeviceNotFound', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_nfc_device_not_found.html' )
SetUrl( 'ApiLink_nn__nfp__Restore', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a7292375a9a80f936d505ddb20cb74d5e' )
SetUrl( 'ApiLink_nn__nfp__StartRestorer', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a909114bcc708d55de460c9b35a314695' )
SetUrl( 'ApiLink_nn__nfp__GetModelInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a6795ef429b2d1effe1039a6f02c403b3' )
SetUrl( 'ApiLink_nn__nfp__ModelInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_model_info.html' )
SetUrl( 'ApiLink_nn__nfp__GetRegisterInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aa2b8e18324f250c48eba82378f4002e5' )
SetUrl( 'ApiLink_nn__nfp__RegisterInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_register_info.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRegister', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_register.html' )
SetUrl( 'ApiLink_nn__nfp__OpenApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ae031efebb24d01f253819e7051ee5b8b' )
SetUrl( 'ApiLink_nn__nfp__ResultAccessIdMisMatch', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_access_id_mis_match.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedCreate', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_create.html' )
SetUrl( 'ApiLink_nn__nfp__GetApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a4627e180bdb0dc997d904ac57f8cab04' )
SetUrl( 'ApiLink_nn__nfp__CommonInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_common_info.html' )
SetUrl( 'ApiLink_nn__nfp__GetCommonInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aed274413977d6c21166fa434315a6ff9' )
SetUrl( 'ApiLink_nn__nfp__CreateApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#adf02884c6bcd5dc0b8cc7d55309f2903' )
SetUrl( 'ApiLink_nn__nfp__Flush', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ade408175b18f37cc322c863e0d3c2129' )
SetUrl( 'ApiLink_nn__nfp__SetApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a33928ed61aa99decae7127c1d6a65e2a' )
SetUrl( 'ApiLink_nn__nfp__RecreateApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a6cd074db4990e0ec7d2caf4f939ec808' )
SetUrl( 'ApiLink_nn__nfp__Unmount', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a8d45eed0a3f22de6c244e629609287ba' )
SetUrl( 'ApiLink_nn__nfp__StartNicknameAndOwnerSettings', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a5e004446eb43894480e5dfb95e90c4e3' )
SetUrl( 'ApiLink_nn__nfp__StartGameDataEraser', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a37ae933f9548417263e1002d032a34c6' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
