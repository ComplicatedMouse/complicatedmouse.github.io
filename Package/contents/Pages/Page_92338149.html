<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Toolchain for NX | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Toolchain for NX -->
<div class="pagetitle" id="PageId_92338149">Toolchain for NX</div>
<div class="text_separate">
<p>Toolchain for NX&nbsp;provides a set of cross-toolchain technologies that significantly enhance and optimize the compile and build time of applications targeted for the Nintendo NX platform (AArch32 and AArch64 targets).</p>
<p>The Toolchain for NX is based on:</p>
<ul>
  <li>
    <strong> <a href="http://llvm.org">LLVM</a> </strong> and <strong> <a href="http://clang.llvm.org/">Clang</a> </strong> for the compiler, compiler-rt, and C++ system libraries</li>
  <li>
    <strong> <a href="http://www.musl-libc.org/">musl</a> </strong> for the libc</li>
  <li>
    <strong> <a href="https://sourceware.org/binutils/docs/ld/Overview.html#Overview">binutils</a> </strong> for the linker and the binary utilities</li>
</ul>
<p>For the complete list of utilized third-party software, refer to the LICENSE.txt file in NintendoSDK\Compilers\NX\license. Please note that the exact location of this file is based on the path used when the Nintendo SDK&nbsp;development environment is installed using NDI.</p>
<h1 id="Anchor_92338149_h1_1">LLVM and Clang. . . What are They?</h1>
<p>
  <strong>LLVM</strong> is a collection of modular and reusable compiler and toolchain technologies that enable users to leverage &quot;best in class&quot; components to optimize the compiling, parsing, and linking of arbitrary programming languages. LLVM is designed as a set of reusable libraries with well-defined interfaces, that provide code generation support for numerous&nbsp;popular platforms such as x86, ARM, MIPS, AArch64, and others.</p>
<p>The LLVM target-independent code generator is a framework that provides a suite of reusable components for translating the LLVM internal representation (IR) to the machine code for a specified target; either in assembly form (suitable for a static compiler) or in binary machine code format (usable for a Just-In-Time [JIT ]compiler). LLVM provides numerous advantages over other compiler offerings, such as GCC, and is a widely accepted tool that is currently being used in production by a wide variety of <a href="http://llvm.org/Users.html">commercial and open source projects</a>.</p>
<p>LLVM is publicly available under an open source License. For details on LLVM licensing, see the <a href="http://llvm.org/docs/DeveloperPolicy.html#license">License</a> page on the LLVM web site.</p>
<p>For additional information on LLVM, refer to the following web sites:</p>
<ul>
  <li>
    <a href="http://llvm.org">LLVM official web site</a>: Provides a good starting point for understand LLVM and all of its potential components.</li>
  <li>
    <a href="http://blog.llvm.org/">LLVM Blog</a>: Provides weekly updates and current news on the LLVM project.</li>
  <li>
    <a href="http://www.aosabook.org/en/llvm.html">LLVM/The Architecture of Open Source Applications</a>: Provides a high-level overview of LLVM's implementation/design.</li>
</ul>
<p>
  <strong>Clang</strong> is an open-source compiler for the C family of programming languages, that serves as the front-end for LLVM and is responsible for converting C, C++, and ObjC source into LLVM IR. Clang builds on the LLVM optimizer and code generator, allowing it to provide high-quality optimization and code generation support for many targets. It was designed as an API from its inception, allowing it to be reused by source analysis tools, refactoring, integrated development environments (IDEs), as well as for code generation.</p>
<p>Clang inherits a number of features from its use of LLVM as its backend, including support for a bytecode representation for intermediate code, pluggable optimizers, link-time optimization support, JIT compilation, ability to link in multiple code generators, and others.</p>
<p>In addition, Clang provides the following advantages:</p>
<ul>
  <li>Much faster than most compilers and uses far less memory</li>
  <li>Easily integrates with integrated development environments (IDEs); IDEs can index the output of the compiler during compilation</li>
  <li>Has expressive diagnostics, including column numbers, caret diagnostics, range highlighting for related text, and &quot;Fix-it&quot; hints. For more details, see <a href="http://clang.llvm.org/diagnostics.html">Expressive Diagnostics</a>.</li>
  <li>Has wider support for multithreading</li>
  <li>Provides attributes for checking thread safety and extended vector types</li>
  <li>Consistently preserves typedefs in diagnostics</li>
  <li>Provides automatic macro expansion</li>
  <li>Retains more information during the compilation process and preserves the overall form of the original code; making it easier to map errors back into the original source</li>
  <li>Can serialize its AST out to disk and read it back into another program, which is useful for whole program analysis</li>
  <li>Provides static analyzer. For more information, see <a href="../Pages/Page_1191571147.html">Using Static Analyzer with Clang</a>..</li>
</ul>
<p>For additional information on Clang, refer to the following web sites:</p>
<ul>
  <li>
    <a href="http://clang.llvm.org">Clang official web site</a>: Provides a good starting point for understand the functionality Clang offers.</li>
  <li>
    <a href="http://clang.llvm.org/comparison.html">Clang vs Other Open Source Compilers</a>: Provides a comparison of Clang features against other popular open source compilers such as GCC and Elsa.</li>
  <li>
    <a href="http://llvm.linuxfoundation.org/index.php/Main_Page">LLVMLinux</a>: Provides an example project that shows how to build the Linux kernel using Clang.</li>
  <li>
    <a href="http://infocenter.arm.com">ARM ABI docs</a> : Application Binary Interface (ABI) for the ARM Architecture.</li>
</ul>
<h2 id="Anchor_92338149_h2_1">What is the difference between clang and clang++ executable?</h2>
<p>In short, clang compiles and links C code and clang++ compiles and links C++ code.</p>
<p>It may help to think of them as aliases for two different sets of default compiler and linker flags; each able to accept flags that alter their default settings. In a polar hypothetical case, they are interchangeable if all of the compiler and the linker flags are explicitly specified.</p>
<p>Technically speaking, neither clang nor clang++ are compilers; they are both drivers that analyze input arguments, including the name with which they were invoked, and the integrated compiler that the driver should invoke. Using the specified input arguments, they determine which compilers, assemblers, and linkers to invoke, the files to work on, the command line arguments to utilize. There are heuristics in the driver that determine the flags, list and order of the libraries, temporary placed objects, and such, so the rule of thumb is: Use clang for C code and use clang++ for C++ code (unless you know exactly what you are doing).</p>
<p>The&nbsp;-x=&lt;language&gt;&nbsp;option overrides the driver's heuristics for determining the source file language; it directs the driver to invoke the compiler for &lt;language&gt; regardless.</p>
<p>The&nbsp;-std=&lt;dialect&gt;&nbsp;option picks the dialect of a particular language to use. For example, if you need to ensure that your C++ program is portable to an old C++98 compiler,&nbsp;compile it with&nbsp;-std=c++98.</p>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>
      <span style="white-space: normal;">-std</span>
      <span style="white-space: normal;">&nbsp;flag only applies to the target language. It will not try to compile something distinct, such as Java as C++98; only source files that the driver believes to be C++.</span>
    </p>
  </div>
</div>
<p>The&nbsp;-x&nbsp;and&nbsp;-std&nbsp;flags only operate against the source language; they do not specify the libraries to link against or any other functionality not directly associated to the source language.&nbsp;There are reasonable use cases for compiling C++, but not linking against the C++ standard library.</p>
<h2 id="Anchor_92338149_h2_2">Debug information and size considerations</h2>
<p>The compiler emits quite sizable debug information along with the executable code. This debug information is used later on for debugging or core dump analyses. By default the compiler optimizes the debug information to reduce the size by removing data it considers redundant. Smaller debug information means faster linking.</p>
<p>In some situations this may lead to missing pieces of the debug information, for example, when compiler has a strong reason to believe that type information has been emitted in to a different module, but it was stripped from there later on.</p>
<p>
  <span style="color: rgb(51,51,51);">If you cannot refer to a class member variable in the watch window, or the inheritance chain seems missing some classes, the problem may be resolved by setting&nbsp;</span>-fstandalone-debug&nbsp;flag when you build the code in question. This would increase the size of your object file, of course, but may provide the missing debug information.</p>
<p>Having&nbsp;-fstandalone-debug&nbsp;flag set for a whole program might not be suitable, as for a large codebase debug info could get too huge to link.</p>
<h1 id="Anchor_92338149_h1_2">Linkers</h1>
<p>The Toolchain for NX now officially supports only one linker:</p>
<ul>
  <li>
    <strong>lld&nbsp;</strong>&nbsp;This linker functions much faster than our previously supported ld linker and has shown to have better support then gold for all current LLVM functionality.&nbsp; It also supports LTO and PGO for much improved code output.&nbsp; Please see&nbsp;<a href="../Pages/Page_417581939.html">SDK LTO Supplemental Information</a>&nbsp;for more information.</li>
</ul>
<p>In addition, the following 2 linkers were supported in the past, but use of these is now deprecated:</p>
<ul>
  <li>
    <strong>ld</strong>&nbsp; (deprecated) A reliable and well tested linker.</li>
  <li>
    <strong>gold&nbsp;</strong>(deprecated)&nbsp;Not as well tested as ld, but much faster. Tests have shown the gold linker to be three to five times faster than ld in a typical use case; usage of linker scripts however can slow the gold linker down.&nbsp;</li>
</ul>
<p>All these linkers have been enhanced to support NX specific features. For instance, the option --build-id=uuid is supported by all linkers however, gold does not support the stack usage report. For additional information on the stack usage report, refer to&nbsp;<a href="#Anchor_92338149_Toolchain_for_NX_Specific_Features">Toolchain for NX Specific Feature</a>.</p>
<h1 id="Anchor_92338149_h1_3">Supported Platforms</h1>
<p>The Toolchain for NX runs on &quot;NintendoSDK Operating Environment&quot;&nbsp;and supports the following targets:</p>
<ul>
  <li>
    <span style="color: rgb(44,45,48);">armv7l</span>-nintendo-nx-eabihf&nbsp;for&nbsp;ARMv7 and AArch32</li>
  <li>aarch64-nintendo-nx-elf&nbsp;for&nbsp;AArch64</li>
</ul>
<h1 id="Anchor_92338149_h1_4">Toolchain for NX&nbsp;Enhancements</h1>
<p>In addition to the significant benefits provided by LLVM and Clang, the Toolchain for NX&nbsp;provides numerous enhancements that further optimize the build process of NX-targeted applications.</p>
<ul>
  <li>Provides specific target triples for the NX platform (for details see <a href="http://clang.llvm.org/docs/CrossCompilation.html">Cross-Compilation Using Clang</a>).</li>
  <li>Provides support for stack frame record size emission, which is located inside the special section <code>.frame_sizes</code>, and can be consumed by the linker.</li>
  <li>Provides built-in defines:<ul><li><code>__NX_TOOLCHAIN_MAJOR__</code>, <code>__NX_TOOLCHAIN_MINOR__</code>, <code>__NX_TOOLCHAIN_PATCHLEVEL__</code> contains the various point levels of the compiler version.</li><li><code>__NX_TOOLCHAIN_VERSION__</code> contains the entire compiler version string.</li></ul></li>
  <li>Support some of the Clang built-in functions. For details, please see <a href="../Pages/Page_768705906.html">Built-in Function Support</a>.&nbsp;</li>
  <li>Uses hard floating point ABI, whereby all floating point operations are performed by the hardware, thus improving overall performance.</li>
  <li>Automatically sets the default triplet:<ul><li>ARMv7 = armv7l-nintendo-nx-eabihf</li><li>AArch64 = aarch64-nintendo-nx-elf</li></ul></li>
  <li>Provides special handling for <code>__cxa_atexit</code>. The constructor and destructor arrays are emitted into the <code>.atexit</code> section, so that the number of static <code>ctors</code> / <code>dtors</code> are known at compile time (no dynamic memory allocation is necessary for static <code>dtor</code> registration).</li>
  <li>Automatically passes <code>-build-id=uuid</code> to the linker by default. This ID is used later on for debugging, core dump analyzes, and other functionality. Automatically generating this ID makes the process faster and does not depend on the object file size. If desired, you can overwrite this value by specifying a different type of build ID. For additional information on using build IDs, refer to  <a href="#Anchor_92338149_Utilizing_Build_IDs">Utilizing Build IDs</a> .</li>
  <li>Uses the artificial strings <code>/lib/ld-nx-aarch64.so.1</code>&nbsp;and <code>/lib/ld-nx-armhf.so.3</code>&nbsp;as dynamic loaders on AArch64 / ARMv7 in order to separate NX ELF binaries from Linux binaries. This functionality prevents the loading of NX binaries on different platforms where ELF is supported, such as with Linux and FreeBSD.</li>
  <li>Supports a new&nbsp;<code>nx-mangle&nbsp;</code>attribute to protect a private C++ and C API. The usage<p><code>#define HIDE __attribute__((annotate(&quot;nx-mangle&quot;)))</code><br /><code>...</code><br /><code>HIDE int privateFunc() { ... }</code></p></li>
</ul>
<h2 id="Anchor_92338149_h2_3">binutils Changes</h2>
<ul>
  <li>Provides NX target recognition</li>
  <li>Provides the following linker flags:<ul><li><code>--check-max-stack-size</code>: Generates a stack usage report that provides details about function stack frames that exceed a specified threshold. For details, see <a href="#Anchor_92338149_h2_10">Stack Usage Report</a>.</li><li><code>--print-callgraph</code>, <code>--print-direct-callgraph</code>: Provides the ability to print call graphs. For details, see&nbsp;<a href="#Anchor_92338149_h2_10">Stack Usage Report</a>.</li><li><code>--build-id=uuid</code>: Generates a build ID by default. For additional information on using build IDs, refer to  <a href="#Anchor_92338149_Utilizing_Build_IDs">Utilizing Build IDs</a> .</li></ul></li>
</ul>
<h2 id="Anchor_92338149_h2_4">libc Changes</h2>
<p>For the list of libc APIs that are supported in a particular version of the toolchain, refer to&nbsp;<a href="Page_106359562.html">C/C++ Standard Library API</a>.</p>
<h2 id="Anchor_92338149_h2_5">libc++ Changes</h2>
<ul>
  <li>Always uses the NX native thread API instead of pthreads in <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;future&gt;</code>, and <code>&lt;condition_variable&gt;</code>. The default thread stack size is 81920 bytes.</li>
  <li>Uses NX time API functions for <code>&lt;chrono&gt;</code></li>
  <li>Supports a subset of the methods in the standard API</li>
  <li>Supports C locale only</li>
</ul>
<p>For the list of libc++ APIs that are not supported in a particular version of the toolchain, refer to&nbsp;<a href="Page_106359562.html">C/C++ Standard Library API</a>.</p>
<p>libc++ for NX does not introduce any limitations other than those introduced by the platform and the C library.</p>
<h2 id="Anchor_92338149_h2_6">compiler-rt Changes</h2>
<ul>
  <li>Always ARM, no Thumb or Thumb2</li>
  <li>Supports most AArch64 library functions (from mainline)</li>
  <li>Supports the Vptr sanitizer</li>
  <li>Supports&nbsp;SafeStack for applications<ul><li>Use -fsanitize=safe-stack for both compilation and linking&nbsp;to turn this feature on.&nbsp;For more information please see <a href="http://clang.llvm.org/docs/SafeStack.html">SafeStack at llvm.org</a>.</li></ul></li>
  <li>Provides UBSan support through the native NX API. Does not currently support other sanitizers.<br /><ul><li>Use <code>-fsanitize</code>=undefined compiler and linker flag to turn this feature on. It enables the default set of undefined behavior checks that have a small runtime cost and no impact on address space layout or ABI. It is possible to specify particular checks or groups of checks. See <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks">the list of available undefined behavior checks and groups of checks</a>.<br />For more details and the list of flags that provide more fine-grained checks, see <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation">Controlling code generation</a> .</li></ul></li>
</ul>
<h2 id="Anchor_92338149_h2_7">libc++abi and libunwind Changes</h2>
<ul>
  <li>Both libc++ and libunwind use the NX&nbsp;native API, instead of pthreads, for the following:<ul><li>Mutexes / Condition variables (to implement such functions as <code>__cxa_guard_acquire</code> / <code>__cxa_guard_release</code> / <code>__cxa_guard_abort</code>)</li><li>TLS slots (for EH globals)</li></ul></li>
  <li>Provides support for bare metal configuration: libraries are expected to be statically linked, hence the&nbsp;sections, related to the&nbsp;exception handling,&nbsp;are found through special symbols. This behavior is standard for bare metal ARMv7 (<code>__exidx_start</code> / <code>__exidx_end</code> are emitted around <code>.ARM.exidx</code> section) and did not exist for bare metal AArch64. For bare metal AArch64, the <code>.eh_frame_hdr</code> section boundaries are expected to be found using the <code>__eh_frame_hdr_start</code> and <code>__eh_frame_hdr_end</code> symbol.</li>
</ul>
<h1 id="Anchor_92338149_h1_5">Toolchain for NX Internals</h1>
<p>The Toolchain for NX&nbsp;is distributed&nbsp;along with the Nintendo SDK.&nbsp;Typically you will use Visual Studio IDE as your development environment.</p>
<p>If you would also like to build your program from the command line, refer to the document&nbsp;<a href="../Pages/Page_94757421.html">Guide to Building a Build System for the NX Hardware Environment</a>.</p>
<p>The Toolchain for NX has a directory structure similar to the following:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>NintendoSDK/Compilers/NX
     +-- bin&lt;-- Contains generic nx-clang.exe and nx-clang++.exe executables
     +-- nx &lt;-- Contains all the NX target-specific files
         +-- aarch64&lt;-- Contains AArch64 toolchain
             +-- aarch64-nintendo-nx-elf
             +-- bin
             +-- include
             +-- lib
         +-- armv7l &lt;-- Contains ARMv7 toolchain
             +-- armv7l-nintendo-nx-eabihf
             +-- bin
             +-- include
             +-- lib
     +-- src &lt;-- Contains the archive with binutils source code.</pre>
  </div>
</div>
<h2 id="Anchor_92338149_h2_8">ARMv7</h2>
<p>To compile a simple application, invoke Clang using command syntax similar to the following:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>nx-clang++ -L&lt;path-to-sdk-libs&gt; -o dummy dummy.cpp</pre>
  </div>
</div>
<p>By default the compiler will target <code>armv7l-nintendo-nx-eabihf</code> triple, but you can also&nbsp;explicitly pass the target triple to the compiler:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>nx-clang++ --target=armv7l-nintendo-nx-eabihf -L&lt;path-to-libs&gt; -o dummy dummy.cpp</pre>
  </div>
</div>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>The current version of the Toolchain for NX provides a restricted subset of the C and C++ API.</p>
  </div>
</div>
<h2 id="Anchor_92338149_h2_9">AArch64</h2>
<p>To compile a simple application for an AArch64 target, invoke Clang using command syntax similar to the following:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>nx-clang++ --target=aarch64-nintendo-nx-elf  -L&lt;path-to-libs&gt; -c hello_world.cpp -o hello_world.o</pre>
  </div>
</div>
<p>You must explicitly specify a target triple for the <code>aarch64</code> targets using <code>--target</code> option.</p>
<div class="note_new">
  <div class="note_new_left">Note</div>
  <div class="note_new_right">
    <p>For AArch64 targets, the frame pointer is always used, even for leaf functions, in order to facilitate unwinding without unwind/debug information. (For additional information, refer to the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html">AArch64 manual</a>).</p>
  </div>
</div>
<p>For additional information on using Clang, see  <a href="http://clang.llvm.org/docs/UsersManual.html">http://clang.llvm.org/docs/UsersManual.html</a> .</p>
<h1 id="Anchor_92338149_h1_6">
  <a name="Anchor_92338149_Toolchain_for_NX_Specific_Features"></a>Toolchain for NX&nbsp;Specific Features</h1>
<p>This section describes the Toolchain for NX&nbsp;specific functionality.</p>
<h2 id="Anchor_92338149_h2_10">
  <a name="Anchor_92338149_StackUsageReport"></a>Stack Usage Report</h2>
<p>The stack usage report enables you to obtain and analyze information on any function that increases the stack size more than a specified number of bytes.</p>
<p>Use the linker flag <code>--check-max-stack-size</code> to generate the stack usage report.</p>
<p>For example:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>nx-clang++ -L&lt;path-to-sdk-libs&gt; -Wl,--check-max-stack-size=&lt;N&gt; -o dummy dummy.cpp</pre>
  </div>
</div>
<p>where&nbsp;<code>N</code>&nbsp;is the stack size threshold in bytes.</p>
<p>It is also possible to display a call graph for a given symbol. A call graph shows a stack usage for that function and an estimate for its children. From this information, you can find functions that, while they themselves may not have used much stack, called other functions that did add to the stack usage.</p>
<p>To invoke this functionality, use the linker flag:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>--print-callgraph=&lt;symbol&gt;</pre>
  </div>
</div>
<p>where&nbsp;<code>&lt;symbol&gt;</code> is the mangled symbol for which to print the call graph.</p>
<p>You can also use the following linker flag to print a direct call graph:</p>
<div style="border-width: 1px;" class="preformatted panel">
  <div class="preformattedContent panelContent">
    <pre>--print-direct-callgraph=&lt;symbol&gt;</pre>
  </div>
</div>
<p>This graph only identifies direct function calls, not nested function calls as provided by <code>--print-callgraph</code>.</p>
<h2 id="Anchor_92338149_h2_11">
  <a name="Anchor_92338149_Utilizing_Build_IDs"></a>Utilizing Build IDs</h2>
<p>
  <code>--build-id</code> requires that the compiled and linked binary file (executable or a library) be stamped with a unique build ID.</p>
<p>When generating the build, there are a number of possible build ID formats that can be produced:</p>
<ul>
  <li>
    <p>
      <code>--build-id=uuid</code>: Produces a randomly generated unique 128-bit value<br />Pros: Quick; does not depend on the binary file size.<br />Cons: Generates a different ID every time; even for the same file.&nbsp;If the build's obj files are not stored somewhere for later reference, there is no way to restore them from the same source code.<code><br /></code></p>
  </li>
  <li>
    <p>
      <code>--build-id=md5</code>: Produces a MD5 hash</p>
  </li>
  <li>
    <p>
      <code>--build-id=sha1</code>: Produces a SHA-1 hash</p>
  </li>
  <li>
    <p>
      <code>--build-id=none</code>: Disables build ID generation</p>
  </li>
</ul>
<p>The MD5 and SHA1 hash value depends on the content of the binary file. With either of these build optons it is possible to rebuild the source code with the same parameters and get the missing debug info, for example, for later debug or core dump analysis.</p>
<p>SHA-1 is longer than MD5 (160 bits vs 128 bits) and produces less collisions (less probability that two different obj files would have the same build ID), however generating this type of build ID is slower and requires more CPU cycles; MD5 is comparatively faster. Still, it may be fast enough for your particular case.</p>
<h2 id="Anchor_92338149_h2_12">Known Issues</h2>
<ul style="margin-left: 28.0px;">
  <li>Only C locale is supported.</li>
  <li>FEnv is not supported.</li>
</ul>
<h2 id="Anchor_92338149_h2_13">What is missing in Toolchain for NX</h2>
<p>Not all features offered by LLVM and Clang are available for NX. Some are not applicable by design, some are not yet implemented but we have them on the road map, and some are work in progress. If you want a particular feature for your project, please talk to us and we will adjust our priorities accordingly.</p>
<p>Here is what currently missing:</p>
<ul style="margin-left: 28.0px;">
  <li>Support for ThinLTO.</li>
  <li>XRay and compiler generated instrumentation.</li>
  <li>Support for C++ Modules.</li>
  <li>AddressSanitizer.</li>
  <li>MemorySanitizer.</li>
  <li>ThreadSanitizer.</li>
</ul>
<h1 id="Anchor_92338149_h1_7">Best Practices</h1>
<p>There are many common C++ best practices, which are applicable here, like, for example, &quot;Treat Compiler Warnings Like Errors&quot;, &quot;Write Portable Code&quot;, &quot;Use auto Type Deduction to Make Code More Readable&quot;, &quot;Beware unnecessary copies with auto&quot;, &quot;#include as Little as Possible&quot;, &quot;Keep &ldquo;Internal&rdquo; Headers Private&quot;, and such. LLVM is a large and very dynamic C++ code base, and here is the list of practices that actually work there:&nbsp;<a href="http://llvm.org/docs/CodingStandards.html">http://llvm.org/docs/CodingStandards.html</a>.</p>
<p>In addition to these, there are few things we would like to mention in the context of the&nbsp;Toolchain for NX.</p>
<h2 id="Anchor_92338149_h2_14">Do Not Invoke the Linker Directly</h2>
<p>Do not invoke the linker directly. Instead, call <code>nx-clang</code>&nbsp;or&nbsp;<code>nx-clang++</code>&nbsp;&nbsp;with the needed linker parameters passed as <code>-Wl</code>,. Toolchain performs a significant amount of work figuring out the exact set of linker parameters, depending on the provided parameters and default compiler flags, as well as the order of the libraries to link. Instead of interfering with this process, let the compiler handle all the necessary tuning of the linker invocation.&nbsp;</p>
<h2 id="Anchor_92338149_h2_15">Do Not Introduce a Dependency on Internal Toolchain Directory Structure</h2>
<p>Toolchain for NX was not designed to use static internal directory structures; the structure may change in any given release. If you try and access a specific file within the internal directory structure within your application, there is no guarantee that your application will work between releases.</p>
<h1 id="Anchor_92338149_h1_8">Tips and Tricks</h1>
<p>There are some tricks you may use to unify or simplify your build setup.</p>
<h2 id="Anchor_92338149_h2_16">Response files</h2>
<p>Clang&nbsp;<span style="color: rgb(51,51,51);">is a paths style neutral when taking command line arguments. It dials with backslashes and forward slashes in file paths transparently, so whatever is given in a shell works.</span></p>
<p>
  <span style="color: rgb(51,51,51);">Response files, however, is a different story. The same response file could be used when the compiler is invoked from different shells, so you either use POSIX-style paths, which is native for Clang, or explicitly specify a response file format by using&nbsp;</span>--rsp-quoting={posix|windows}<span style="color: rgb(51,51,51);">&nbsp;flag to make it clear for the compiler what is given.</span></p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
</body>
</html>
