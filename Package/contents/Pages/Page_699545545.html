<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>C++ Standard Library Supported Functions | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- C++ Standard Library Supported Functions -->
<div class="pagetitle" id="PageId_699545545">C++ Standard Library Supported Functions</div>
<div class="text_separate">
<p class="auto-cursor-target">
  <br />
</p>
<table style="margin-left: 24.0px;" class="table">
  <colgroup>
    <col />
    <col />
    <col />
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <td class="highlight-grey" style="text-align: center;">
        <pre>              <strong>Supported?</strong>
(Clang Rel)</pre>
      </td>
      <td class="highlight-grey">
        <strong>Standard</strong>
      </td>
      <td class="highlight-grey">
        <strong>Header</strong>
      </td>
      <td class="highlight-grey">
        <strong>Function</strong>
      </td>
      <td class="highlight-grey">
        <strong>Description</strong>
      </td>
    </tr>
    <tr>
      <td>
        <p>0.10.0</p>
      </td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>adjacent_find</td>
      <td>
        <p>Searches the range for two consecutive identical elements</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>all_of</td>
      <td>Checks if the predicate returns true for all the elements in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>any_of</td>
      <td>Checks if the predicate returns true for any of the elements in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>binary_search</td>
      <td>Binary search of an element in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>copy</td>
      <td>Copies the range of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>copy_backward</td>
      <td>Copies the elements in reverse order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>copy _if</td>
      <td>Copies the elements in the range for which the predicate returns true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>copy_n</td>
      <td>Copies the first N elements from the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>count</td>
      <td>Counts appearances of the value in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>count_if</td>
      <td>Returns the number of elements in the range for which the predicate is true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>equal</td>
      <td>Tests whether the elements in two ranges are equal</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>equal_range</td>
      <td>Returns a range containing all elements equivalent to the given value in the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>fill</td>
      <td>Assigns the given value to the elements in the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>fill_n</td>
      <td>Assigns the given value to the first N elements in the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>find_end</td>
      <td>Searches for the last subsequence of elements in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>find_first_of</td>
      <td>Searches the range for any of the elements from another range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>find_if</td>
      <td>Searches for an element for which the predicate is true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>find_if_not</td>
      <td>Searches for an element for which the predicate is false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>for_each</td>
      <td>Applies the given function object to the result of dereferencing every iterator in the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>generate</td>
      <td>Assigns each element in the range a value generated by the given function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>generate_n</td>
      <td>Assigns N first elements in the range a value generated by the given function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>includes</td>
      <td>Returns true if every element from the sorted range is found within another sorted range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>inplace_merge</td>
      <td>Merges two consecutive sorted ranges into one sorted range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_heap</td>
      <td>Returns true if the range forms a heap, as if constructed with std::make_heap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_heap_until</td>
      <td>Returns an iterator to the first element in the range which is not in a valid position if the range is considered a heap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_partitioned</td>
      <td>Returns true if all the elements in the range for which the predicate returns true precede those for which it returns false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_permutation</td>
      <td>Returns true if all of the elements in two ranges match, even in a different order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_sorted</td>
      <td>Returns true if the range is sorted in ascending order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>is_sorted_until</td>
      <td>Returns an iterator to the first element in the range which does not follow an ascending order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>iter_swap</td>
      <td>Swaps the values of the elements the given iterators are pointing to</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>lexicographical_compare</td>
      <td>Lexicographically compares two input ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>lower_bound</td>
      <td>Returns an iterator pointing to the first element in the range that is not less than the given value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>make_heap</td>
      <td>Rearranges the elements in the range in such a way that they form a heap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>max</td>
      <td>Returns the greater of the given values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>max_element</td>
      <td>Finds the greatest element in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>merge</td>
      <td>Merges two sorted ranges into one sorted range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>min</td>
      <td>Returns the smaller of the given values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>min_element</td>
      <td>Finds the smallest element in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>minmax</td>
      <td>Returns the lowest and the greatest of the given values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>minmax_element</td>
      <td>Returns the lowest and the greatest element in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>mismatch</td>
      <td>Returns the first mismatching pair of elements from two ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>move</td>
      <td>Moves the elements in the range to another range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>move_backward</td>
      <td>Moves the elements in the range to another range in reverse order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>next_permutation</td>
      <td>Rearranges the elements in the range into the next lexicographically greater permutation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>none_of</td>
      <td>Returns true if the predicate returns false for all the elements in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>nth_element</td>
      <td>Rearranges the elements in the range in such a way that the element at the Nth position is the element that would be in that position in a sorted sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>partial_sort</td>
      <td>Rearranges the elements such that the range [first, middle) contains the sorted middle-first smallest elements in the range [first, last)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>partial_sort_copy</td>
      <td>Rearranges the elements such that the range [first, middle) contains the sorted middle-first smallest elements in the range [first, last)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>partition</td>
      <td>Rearranges the elements from the range in such a way that all the elements for which the predicate returns true precede all those for which it returns false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>partition_copy</td>
      <td>Copies the elements from the range to two different ranges depending on the value returned by the predicate</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>partition_point</td>
      <td>Returns an iterator to the first element in the partitioned range for which the predicate is not true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>pop_heap</td>
      <td>Rearranges the elements in the heap range in such a way that the part considered a heap is shortened by one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>prev_permutation</td>
      <td>Transforms the range into the previous permutation from the set of all lexicographically ordered permutations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>push_heap</td>
      <td>Inserts the element at the last position into the heap defined by the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>random_shuffle</td>
      <td>
        <p>Rearranges the elements in the range randomly.</p>
        <p>Note: Due to dependencies the parameter-less constructor and the constructor with a locale name only are tested.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>remove</td>
      <td>Removes all elements that are equal to the given value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>remove_copy</td>
      <td>Copies elements from the range to another range, omitting the elements equal to the given value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>remove_copy_if</td>
      <td>Copies elements from the range to another range, omitting the elements for which the predicate returns true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>remove_if</td>
      <td>Removes all elements for which the predicate returns true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>replace</td>
      <td>Replaces all elements that are equal to the given value with the new value&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>replace_copy</td>
      <td>Copies the all elements from the range to another range replacing all elements that are equal to the given value with the new value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>replace_copy_if</td>
      <td>Copies the all elements from the range to another range replacing all elements for which the predicate returns true with the new value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>replace_if</td>
      <td>Replaces all elements for which the predicate returns true with the new value&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>reverse</td>
      <td>Reverses the order of the elements in the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>reverse_copy</td>
      <td>Copies the elements from the range to another range in such a way that the elements in the new range are in reverse order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>rotate</td>
      <td>Performs a left rotation on a range of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>rotate_copy</td>
      <td>Copies the elements in the range to another range rotating the order of the elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>search</td>
      <td>Searches the range for the first occurrence of the sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>search_n</td>
      <td>Searches the range for the first sequence of N identical elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>set_difference</td>
      <td>Copies the elements from the sorted range which are not found in another sorted range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>set_intersection</td>
      <td>Copies the elements from the sorted range which are found in another sorted range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>set_symmetric_difference</td>
      <td>Computes symmetric difference of two sorted ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>set_union</td>
      <td>Constructs a sorted range consisting of all elements present in one or both sorted input ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>algorithm</td>
      <td>shuffle</td>
      <td>Shuffles the elements in the given range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>sort</td>
      <td>Sorts the elements in the range in ascending order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>sort_heap</td>
      <td>Converts the heap into a sorted range in ascending order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>stable_partition</td>
      <td>Reorders the elements in the range in such a way that all elements for which the predicate returns true precede the elements for which the predicate returns false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>stable_sort</td>
      <td>Sorts the elements in the range in ascending order, preserving the order of equal elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>swap</td>
      <td>Exchanges values of two objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>swap_ranges</td>
      <td>Exchanges elements between two ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>transform</td>
      <td>Applies the given function to a range and stores the result in another range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>unique</td>
      <td>Removes all consecutive duplicate elements from the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>unique_copy</td>
      <td>Copies the elements from the range to another range in such a way that there are no consecutive equal elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>algorithm</td>
      <td>upper_bound</td>
      <td>Returns an iterator pointing to the first element in the range that is greater than the value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::at</td>
      <td>Returns a reference to the element at the specified location, with bounds checking</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::back</td>
      <td>Returns reference to the last element in the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::begin</td>
      <td>Returns an iterator to the beginning of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::end</td>
      <td>Returns an iterator to the end of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::cbegin</td>
      <td>Returns a const iterator to the beginning of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::cend</td>
      <td>Returns a const iterator to the end of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::crbegin</td>
      <td>Returns a const reverse iterator to the first element of the reversed container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::crend</td>
      <td>Returns a const reverse iterator to the element following the last element of the reversed container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::rbegin</td>
      <td>Returns a reverse iterator to the first element of the reversed container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::rend</td>
      <td>Returns a reverse iterator to the element following the last element of the reversed container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::data</td>
      <td>Returns pointer to the underlying array serving as element storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::empty</td>
      <td>Checks whether the container is empty&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::fill</td>
      <td>Fills the container with the specified value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::front</td>
      <td>Returns a reference to the first element in the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::begin</td>
      <td>Returns an iterator pointing to the first element in the&nbsp;array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::end</td>
      <td>Returns an iterator pointing to the &nbsp;past-the-end&nbsp;element in the&nbsp;array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::get</td>
      <td>Extracts an element element from the array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>
        <p>array::operator&gt;</p>
        <p>array::operator&gt;=</p>
        <p>array::operator&lt;</p>
        <p>array::operator&lt;=</p>
        <p>array::operator==</p>
        <p>array::operator!=</p>
      </td>
      <td>Lexicographically compares the contents of two containers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::operator[]</td>
      <td>Returns a reference to the element at the specified location, without bounds checking</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::max_size</td>
      <td>Returns the maximum possible number of elements in the array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>array::swap</td>
      <td>Swaps the contents of the array with those of another array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::swap</td>
      <td>Swaps the contents of two arrays</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::tuple_element</td>
      <td>Compile-time indexed access to the type of the elements of the array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>array</td>
      <td>std::tuple_size</td>
      <td>The number of elements in an std::array as a compile-time constant expression</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic</td>
      <td>Object of atomic type containing a value of a particular type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic::atomic</td>
      <td>Constructs new atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>atomic::compare_exchange_strong</p>
        <p>atomic::compare_exchange_weak</p>
      </td>
      <td>Performs read-modify-write operation on the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::exchange</td>
      <td>Atomically replaces the underlying atomic value with the new one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::fetch_add</td>
      <td>Atomically adds the argument to the value stored in the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::fetch_and</td>
      <td>Atomically performs bitwise AND between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::fetch_or</td>
      <td>Atomically performs bitwise OR between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::fetch_sub</td>
      <td>Atomically subtracts the argument from the value stored in the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::fetch_xor</td>
      <td>Atomically performs bitwise XOR between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::is_lock_free</td>
      <td>
        <p>Checks if the atomic object is lock-free.</p>
        <p>Note: This is implemented only for the lock-free types; for&nbsp;not-lock-free types it depends on the libatomic to work.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::load</td>
      <td>Atomically obtains the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator&amp;=</td>
      <td>Performs bitwise AND with the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator|=</td>
      <td>Performs bitwise OR with the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator^=</td>
      <td>Performs bitwise XOR with the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator=</td>
      <td>Stores a value into an atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator++</td>
      <td>Increments the atomic value by one&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator--</td>
      <td>Decrements the atomic value by one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator+=</td>
      <td>Atomically adds a value to the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator-=</td>
      <td>Atomically subtracts a value from the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::operator T</td>
      <td>Loads the value from the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic::store</td>
      <td>Atomically replaces the value of the atomic object with a non-atomic argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic_flag</td>
      <td>Atomic boolean type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic_flag::atomic_flag</td>
      <td>Constructs an atomic_flag</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic_flag::clear</td>
      <td>Atomically sets the flag to false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>atomic_flag::test_and_set</td>
      <td>Atomically sets the flag to true and obtains its previous value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_compare_exchange_strong</p>
        <p>std::atomic_compare_exchange_strong_explicit</p>
        <p>std::atomic_compare_exchange_weak</p>
        <p>std::atomic_compare_exchange_weak_explicit</p>
      </td>
      <td>Performs atomic read-modify-write operation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_exchange</p>
        <p>std::atomic_exchange_explicit</p>
      </td>
      <td>Atomically replaces the atomic value with the new one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_fetch_add</p>
        <p>std::atomic_fetch_add_explicit</p>
      </td>
      <td>Atomically adds the argument to the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_fetch_and</p>
        <p>std::atomic_fetch_and_explicit</p>
      </td>
      <td>Atomically performs bitwise AND between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_fetch_or</p>std::atomic_fetch_or_explicit</td>
      <td>Atomically performs bitwise OR between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_fetch_sub</p>
        <p>std::atomic_fetch_sub_explicit&nbsp;</p>
      </td>
      <td>Atomically substructs the argument from the atomic value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_fetch_xor</p>std::atomic_fetch_xor_explicit</td>
      <td>Atomically performs bitwise XOR between the argument and the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_flag_clear</p>
        <p>std::atomic_flag_clear_explicit</p>
      </td>
      <td>Atomically sets the flag to false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_FLAG_INIT&nbsp;</td>
      <td>Initializes std::atomic_flag to clear (false) state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_flag_test_and_set</p>std::atomic_flag_test_and_set_explicit</td>
      <td>Atomically sets the flag to true and obtains its previous value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic_init</td>
      <td>Initializes the default-constructed atomic object object with the given value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic_is_lock_free</td>
      <td>
        <p>Determines if the atomic object is implemented lock-free.</p>
        <p>Note: This is implemented only for the lock-free types; for&nbsp;not-lock-free types it depends on the libatomic to work.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_load</p>
        <p>std::atomic_load_explicit</p>
      </td>
      <td>Atomically obtains the value of the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic_signal_fence</td>
      <td>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses between a thread and a signal handler</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>
        <p>std::atomic_store</p>
        <p>std::atomic_store_explicit</p>
      </td>
      <td>Atomically stores the value to the atomic object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::atomic_thread_fence</td>
      <td>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_VAR_INIT&nbsp;</td>
      <td>Initializes the std::atomic object that can be initialized from value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::kill_dependency&nbsp;</td>
      <td>Breaks the dependency tree started by an std::memory_order_consume atomic load operation&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>std::memory_order&nbsp;</td>
      <td>Specifies how non-atomic memory accesses are to be ordered around an atomic operation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_BOOL_LOCK_FREE&nbsp;</td>
      <td>Indicates whether bool atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_CHAR_LOCK_FREE</td>
      <td>Indicates whether char atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_CHAR16_T_LOCK_FREE</td>
      <td>Indicates whether char16_t atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_CHAR32_T_LOCK_FREE</td>
      <td>Indicates whether char32_t atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_WCHAR_T_LOCK_FREE</td>
      <td>Indicates whether wchar atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_SHORT_LOCK_FREE</td>
      <td>Indicates whether short int atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_INT_LOCK_FREE</td>
      <td>Indicates whether int atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_LONG_LOCK_FREE</td>
      <td>Indicates whether long int atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_LLONG_LOCK_FREE</td>
      <td>Indicates whether long long atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>atomic</td>
      <td>ATOMIC_POINTER_LOCK_FREE</td>
      <td>Indicates whether pointer atomic type is lock-free</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>std::bitset</td>
      <td>
        <p>Fixed-size sequence of bits</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>bitset</td>
      <td>bitset::all</td>
      <td>Tests if all bits are set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::any</td>
      <td>Tests if any bit is set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::bitset</td>
      <td>Constructs a bitset object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::count</td>
      <td>Counts bits set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::flip</td>
      <td>Flips the bits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::none</td>
      <td>Tests if no bit is set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator[]</td>
      <td>Accesses the bit</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator==</td>
      <td>Checks if the bitset is equal to another bitset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator!=</td>
      <td>Checks if the bitset is not equal to another bitset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator&amp;=</td>
      <td>Performs binary AND on the bitset with the argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator|=</td>
      <td>Performs binary OR on the bitset with the argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator^=</td>
      <td>Performs binary XOR on the bitset with the argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::operator~</td>
      <td>Returns a temporary copy of the bitset with all bits flipped</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>
        <p>bitset::operator&lt;&lt;=</p>
        <p>std::operator&lt;&lt;</p>
      </td>
      <td>Binary shift left</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>
        <p>bitset::operator&gt;&gt;=</p>
        <p>std::operator&gt;&gt;</p>
      </td>
      <td>Binary shift right</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>std::operator&amp;</td>
      <td>Performs binary AND on two bitsets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>std::operator|</td>
      <td>Performs binary OR on two bitsets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>std::operator^</td>
      <td>Performs binary XOR on two bitsets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::reference</td>
      <td>The type returned by bitset::operator[]</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::reset</td>
      <td>Resets the bits to zero</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::set</td>
      <td>Sets bits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::size</td>
      <td>Returns the number of bits in the bitset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::test</td>
      <td>Returns whether the bit at the given position is set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::to_string</td>
      <td>Constructs a string that represents the bits in the bitset as a succession of zeros and/or ones</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>bitset</td>
      <td>bitset::to_ullong</td>
      <td>Converts the bitset to unsigned long long</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>bitset</td>
      <td>bitset::to_ulong</td>
      <td>Converts the bitset to unsigned long integer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>bitset</td>
      <td>std::hash&lt;std::bitset&gt;</td>
      <td>Hash support for std::bitset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration_cast</td>
      <td>Converts the duration into some other duration type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::hours</td>
      <td>Duration in hours</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::microseconds</td>
      <td>Duration in microseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::milliseconds</td>
      <td>Duration in milliseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::minutes</td>
      <td>Duration in minutes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::nanoseconds</td>
      <td>Duration in nanoseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::seconds</td>
      <td>Duration in seconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>
        <p>chrono::operator+</p>
        <p>chrono::operator-</p>
        <p>chrono::operator*</p>
        <p>chrono::operator/</p>
        <p>chrono::operator%</p>
      </td>
      <td>Implements arithmetic operations with durations as arguments</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>
        <p>chrono::operator==</p>
        <p>chrono::operator!=</p>
        <p>chrono::operator&gt;</p>
        <p>chrono::operator&gt;=</p>
        <p>chrono::operator&lt;</p>
        <p>chrono::operator&lt;=</p>
      </td>
      <td>Compares two durations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::time_point_cast</td>
      <td>Converts the value of the time point into a time_point type with a different duration internal object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::treat_as_floating_point</td>
      <td>Indicates that a duration is convertible to duration with different tick period</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono:: duration</td>
      <td>Represents a time interval</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::duration</td>
      <td>
        <p>Constructs a new duration</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::count</td>
      <td>Returns the internal count of the duration object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::max</td>
      <td>Duration maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::min</td>
      <td>Duration minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::operator=</td>
      <td>Assigns the contents of one duration to another</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>
        <p>chrono::duration::operator++</p>
        <p>chrono::duration::operator--</p>
        <p>chrono::duration::operator+=</p>
        <p>chrono::duration::operator-=</p>
        <p>chrono::duration::operator*=</p>
        <p>chrono::duration::operator/=</p>
        <p>chrono::duration::operator%=</p>
        <p>chrono::duration::operator+</p>
        <p>chrono::duration::operator-</p>
      </td>
      <td>Implements arithmetic operations on the duration</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration::zero&nbsp;</td>
      <td>Returns a duration value of zero</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; h</td>
      <td>A std::chrono::duration literal representing hours</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; min</td>
      <td>A std::chrono::duration literal representing minutes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; s</td>
      <td>A std::chrono::duration literal representing seconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; ms</td>
      <td>A std::chrono::duration literal representing milliseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; us</td>
      <td>A std::chrono::duration literal representing microseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>chrono</td>
      <td>operator&quot;&quot; ns</td>
      <td>A std::chrono::duration literal representing nanoseconds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>chrono</td>
      <td>std::floor</td>
      <td>Converts a duration to another, rounding down</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>chrono</td>
      <td>std::ceil</td>
      <td>Converts a duration to another, rounding up</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>chrono</td>
      <td>std::round</td>
      <td>Converts a duration to another, rounding to nearest, ties to even&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>chrono</td>
      <td>std::abs</td>
      <td>Obtains the absolute value of the duration</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>std::common_type</td>
      <td>
        <p>Exposes the type, which is the common type of two std::chrono::durations</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration_values&nbsp;</td>
      <td>Traits class to provide the limits and zero value of the type used to represent the count in a duration object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration_values::max&nbsp;</td>
      <td>Returns the largest possible representation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration_values::min&nbsp;</td>
      <td>Returns the smallest possible representation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::duration_values::zero&nbsp;</td>
      <td>Returns a zero-length representation</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::high_resolution_clock</td>
      <td>The clock with the shortest tick period</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::high_resolution_clock::now</td>
      <td>
        <p>Gets the current <em>time_point</em>.</p>
        <p>
          <br />
        </p>
        <p>Please note that the origin of the clock&rsquo;s <em>time_point</em> is referred to as the clock&rsquo;s epoch. One must not assume any particular epoch value, as it depends on implementation and could be changed between compiler or standard library versions. See the C++ standard, Section 20.12.3 &quot;Clock requirements [time.clock.req]&quot; for more details.</p>
      </td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::steady_clock</td>
      <td>Monotonic clock</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::steady_clock::now</td>
      <td>Gets the current <em>time_point</em>. Please note that the origin of the clock&rsquo;s <em>time_point</em> is referred to as the clock&rsquo;s epoch. See the C++ standard, Section 20.12.3 &quot;Clock requirements [time.clock.req]&quot; for more details</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::system_clock</td>
      <td>System-wide real time wall clock</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::system_clock::now</td>
      <td>
        <div class="content-wrapper">
          <p>Gets the current <em>time_point</em>.</p>
          <p>
            <br />
          </p>
          <p>Please note that the origin of the clock&rsquo;s <em>time_point</em> is referred to as the clock&rsquo;s epoch. One must not assume any particular epoch value, as it depends on implementation and could be changed between compiler or standard library versions. Please see the C++ standard, Section 20.12.3 &quot;Clock requirements [time.clock.req]&quot; for more details. If desired, epoch could be found with a help of a <em>time_point</em> with zero duration.</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre><span class="nn">std::chrono::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="nn">std::chrono::</span><span class="n">system_clock</span><span class="o">&gt;</span> <span class="n">tp_epoch</span><span class="p">;</span>    <span class="c1">// epoch value
</span> 
<span class="nn">std::</span><span class="kt">time_t</span> <span class="n">epoch</span> <span class="o">=</span> <span class="nn">std::chrono::system_clock::</span><span class="kt">to_time_t</span><span class="p">(</span><span class="n">tp_epoch</span><span class="p">);</span>
<span class="nn">std::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;system_clock epoch is: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epoch</span><span class="p">);</span></pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p class="auto-cursor-target">
            <br />
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::system_clock::from_time_t</td>
      <td>Converts std::time_t to a system clock time point&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::system_clock::to_time_t</td>
      <td>Converts a system clock time point to std::time_t</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::time_point</td>
      <td>
        <p>Point in time relative to a clock's epoch.</p>
        <p>
          <br />
        </p>
        <p>Please note that one must not assume any particular epoch value, as it depends on implementation and could be changed between compiler or standard library versions. Please see the C++ standard, Section 20.12.3 &quot;Clock requirements [time.clock.req]&quot; for more details.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::time_point::max</td>
      <td>Maximum value of time_point</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::time_point::min</td>
      <td>Minimum value of time_point</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>
        <p>chrono::time_point::operator+=</p>
        <p>chrono::time_point::operator-=</p>
      </td>
      <td>Implements arithmetic operations on the time point</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>chrono</td>
      <td>chrono::time_point::time_since_epoch</td>
      <td>
        <p>Time since epoch.</p>
        <p>
          <br />
        </p>
        <p>Please note that one must not assume any particular epoch value, as it depends on implementation and could be changed between compiler or standard library versions. Please see the C++ standard, Section 20.12.3 &quot;Clock requirements [time.clock.req]&quot; for more details.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::complex</td>
      <td>Complex number class</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::complex::complex</td>
      <td>Constructs a complex value object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::complex::real</td>
      <td>Real part of the complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::complex::imag</td>
      <td>Imaginary part of the complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::complex::operator=</td>
      <td>Assigns a new value to the complex object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>
        <p>std::complex::operator+=</p>
        <p>std::complex::operator-=</p>
        <p>std::complex::operator*=</p>
        <p>std::complex::operator/=</p>
      </td>
      <td>Implements arithmetic operations on the complex value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>
        <p>operator+</p>
        <p>operator-</p>
        <p>operator*</p>
        <p>operator/</p>
      </td>
      <td>Non-member arithmetic operations on complex values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>
        <p>operator==</p>
        <p>operator!=</p>
      </td>
      <td>Compares two complex values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>
        <p>operator&gt;&gt;</p>
      </td>
      <td>Extracts a complex from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>
        <p>operator&lt;&lt;</p>
      </td>
      <td>Inserts a complex into output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::abs</td>
      <td>Absolute value of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::arg&nbsp;</td>
      <td>Phase angle of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::norm&nbsp;</td>
      <td>Norm of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::conj&nbsp;</td>
      <td>Complex conjugate</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::polar&nbsp;</td>
      <td>Complex from polar components</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::proj&nbsp;</td>
      <td>Complex projection</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::cos&nbsp;</td>
      <td>Cosine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::cosh&nbsp;</td>
      <td>Hyperbolic cosine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::exp&nbsp;</td>
      <td>Exponential of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::log&nbsp;</td>
      <td>Natural logarithm of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::log10&nbsp;</td>
      <td>
        <p>Common logarithm of complex</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::pow&nbsp;</td>
      <td>Power of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::real</td>
      <td>Real part of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::sin&nbsp;</td>
      <td>Sine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::sinh&nbsp;</td>
      <td>Hyperbolic sine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::sqrt&nbsp;</td>
      <td>Square root of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::tan&nbsp;</td>
      <td>Tangent of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>complex</td>
      <td>std::tanh&nbsp;</td>
      <td>Hyperbolic tangent of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::acos</td>
      <td>Arc cosine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::acosh</td>
      <td>Arc hyperbolic cosine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::asin</td>
      <td>Arc sine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::asinh</td>
      <td>Arc hyperbolic sine of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::atan</td>
      <td>Arc tangent of complex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>complex</td>
      <td>std::atanh</td>
      <td>Arc hyperbolic tangent of complex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable</td>
      <td>Condition variable class</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::condition_variable</td>
      <td>Constructs a new condition variable object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::~condition_variable</td>
      <td>Destructs the condition variable</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::native_handle</td>
      <td>Returns the native handle</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::notify_all</td>
      <td>Notifies all waiting threads&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::notify_one</td>
      <td>Notifies one waiting thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::wait</td>
      <td>
        <p>Blocks the current thread until the condition variable is woken up.</p>
        <p>Note: This API has not yet been tested well for std::terminate gets called when post conditions are not met.</p>
      </td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::wait_for</td>
      <td>Blocks the current thread until the condition variable is woken up or after the specified timeout duration&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::wait_until</td>
      <td>Blocks the current thread until the condition variable is woken up or until specified time point has been reached&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any</td>
      <td>Condition variable class whose wait functions can take any lockable type as an argument</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::condition_variable_any</td>
      <td>Constructs a new condition variable object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::~condition_variable_any</td>
      <td>Destructs the condition variable</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::notify_all</td>
      <td>Notifies all waiting threads&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::notify_one</td>
      <td>Notifies one waiting thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::wait</td>
      <td>Blocks the current thread until the condition variable is woken up&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable_any::wait_for</td>
      <td>Blocks the current thread until the condition variable is woken up or after the specified timeout duration&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::condition_variable::wait_until</td>
      <td>Blocks the current thread until the condition variable is woken up or until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::cv_status</td>
      <td>Condition variable status, indicates whether a function returned because of a timeout or not</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>condition_variable</td>
      <td>std::notify_all_at_thread_exit</td>
      <td>Notifies all threads waiting on a condition when the calling thread exits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque</td>
      <td>Double-ended queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::deque</td>
      <td>Construct a new deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::~deque</td>
      <td>Destructs the deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::assign</td>
      <td>Assigns container content</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::at</td>
      <td>Accesses a deque element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::back</td>
      <td>Accesses the last element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::begin</td>
      <td>Returns the iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::end</td>
      <td>Returns the iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::cbegin</td>
      <td>Returns the const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::cend</td>
      <td>Returns the const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::rbegin</td>
      <td>Returns the reverse iterator to the reverse beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::rend</td>
      <td>Returns the reverse iterator to the reverse end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::crbegin</td>
      <td>Returns the const reverse iterator to the reverse beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::crend</td>
      <td>Returns the reverse iterator to the reverse end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::clear</td>
      <td>Empties the deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::emplace</td>
      <td>Constructs and inserts a new deque element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::emplace_back</td>
      <td>Constructs and inserts a new element at the deque end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::emplace_front</td>
      <td>Constructs and inserts a new element at the deque beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::empty</td>
      <td>Tests whether the deque is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::front</td>
      <td>Accesses the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::get_allocator</td>
      <td>Gets the deque allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::insert</td>
      <td>Inserts new elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::max_size</td>
      <td>Returns the maximum deque size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::operator=</td>
      <td>Assigns a new value to the deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::operator[]</td>
      <td>Accesses a deque element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares two deques</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::push_back</td>
      <td>Adds a new element at the end of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::push_front</td>
      <td>Adds a new element at the beginning of the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::pop_back</td>
      <td>Deletes the last element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::pop_front&nbsp;</td>
      <td>Deletes the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::resize&nbsp;</td>
      <td>Changes the deque size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::deque::shrink_to_fit&nbsp;</td>
      <td>Requests the container to reduce its memory usage to fit its size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::size&nbsp;</td>
      <td>Returns the deque size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::deque::swap&nbsp;</td>
      <td>Exchanges the content of the deque by the content of another deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::begin</td>
      <td>Returns an iterator pointing to the first element in the&nbsp;deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>deque</td>
      <td>std::end</td>
      <td>Returns an iterator pointing to the &nbsp;past-the-end&nbsp;element in the&nbsp;deque</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>deque</td>
      <td>std::swap&nbsp;</td>
      <td>Exchanges the content of two deques</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::bad_exception</td>
      <td>Exception thrown by unexpected handler</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::exception</td>
      <td>Base class for the standard exceptions</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::exception::operator=</td>
      <td>Copies the exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::exception::what</td>
      <td>Gets the string identifying the exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::exception_ptr</td>
      <td>Smart pointer type that can refer to exception objects</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::nested_exception</td>
      <td>Nested exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::nested_exception::nested_exception</td>
      <td>Constructs a new nested exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::nested_exception::nested_ptr</td>
      <td>Obtains a pointer to the stored exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::nested_exception::rethrow_nested</td>
      <td>Throws the stored exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::nested_exception::operator=</td>
      <td>Replaces the contents of a nested_exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::current_exception</td>
      <td>Captures the current exception object</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::get_terminate</td>
      <td>Returns the currently installed std::terminate_handler</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::get_unexpected</td>
      <td>Returns the currently installed std::unexpected_handler</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::make_exception_ptr</td>
      <td>Creates an std::exception_ptr that holds a reference to a copy of the given exception object</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::rethrow_exception</td>
      <td>Throws the previously captured exception object referred to by the exception pointer</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::rethrow_if_nested</td>
      <td>Throws the exception nested in the argument exception &quot;e&quot;, if &quot;e&quot; is publicly and unambiguously derived from nested_exception</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::set_terminate</td>
      <td>Sets the global terminate handler function</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::terminate</td>
      <td>
        <p>Calls the current terminate handler.</p>
        <p>Note: Due to dependencies and conditions this API has not yet been tested well. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::terminate_handler</td>
      <td>Type of terminate handler function</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::set_unexpected</td>
      <td>Sets the global std::unexpected_handler</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>exception</td>
      <td>std::throw_with_nested</td>
      <td>Throws an exception that combines both the currently handled exception and the exception given</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::uncaught_exception</td>
      <td>Detects if stack unwinding is currently in progress</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::unexpected</td>
      <td>
        <p>Calls the currently installed std::unexpected_handler.</p>
        <p>Note: Due to dependencies the parameter-less constructor and the constructor with a locale name only are tested.</p>
      </td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++98</td>
      <td>exception</td>
      <td>std::unexpected_handler</td>
      <td>Type of unexpected handler function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list</td>
      <td>Sequence container that allow constant time insert and erase operations anywhere within the sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::forward_list</td>
      <td>Constructs a new forward_list object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::~forward_list</td>
      <td>Destructs the forward_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::begin</td>
      <td>Returns the iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::end</td>
      <td>Returns the iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::cbegin</td>
      <td>Returns the const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::cend</td>
      <td>Returns the const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::before_begin</td>
      <td>Returns the iterator to the before beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::cbefore_begin</td>
      <td>Returns the const iterator to the before beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::assign</td>
      <td>Assigns the contents of another forward list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::emplace_after</td>
      <td>Constructs and inserts an element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::emplace_front</td>
      <td>Constructs and inserts an element at the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::empty</td>
      <td>Tests if the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::erase_after</td>
      <td>Erases the elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::front</td>
      <td>Accesses the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::get_allocator</td>
      <td>Gets the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::insert_after</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::max_size</td>
      <td>Returns the maximum list size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::merge</td>
      <td>Merges sorted lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::operator=</td>
      <td>Assigns new content to the list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>
        <p>std::forward_list::operator==</p>
        <p>std::forward_list::operator!=</p>
        <p>std::forward_list::operator&gt;</p>
        <p>std::forward_list::operator&gt;=</p>
        <p>std::forward_list::operator&lt;</p>
        <p>std::forward_list::operator&lt;=</p>
      </td>
      <td>Compares forward lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::pop_front</td>
      <td>Deletes the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::push_front</td>
      <td>Inserts a new element at beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::remove</td>
      <td>Removes the elements with a specific value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::remove_if</td>
      <td>Removes the elements fulfilling the condition</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::resize</td>
      <td>Changes the list size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::reverse</td>
      <td>Reverses the order of the elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::sort</td>
      <td>Sorts the list elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::splice_after</td>
      <td>Transfers the elements from another forward_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::swap</td>
      <td>Exchanges the content of two lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::forward_list::unique</td>
      <td>Removes duplicate values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::begin</td>
      <td>Returns the iterator to the beginning of a forward_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::end</td>
      <td>Returns the iterator to the end of a forward_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>forward_list</td>
      <td>std::swap</td>
      <td>Exchanges the content of two lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::binary_function</td>
      <td>Binary function object base class</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::unary_function</td>
      <td>Unary function object base class</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::is_bind_expression</td>
      <td>Indicates that an object is std::bind expression or can be used as one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::is_placeholder</td>
      <td>Indicates that an object is a standard placeholder or can be used as one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::bind1st</td>
      <td>Returns a function object with the first parameter bound</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::bind2nd</td>
      <td>Returns a function object with the second parameter bound</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::binder1st</td>
      <td>Type of the function object that binds the first argument to a binary function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::binder2nd</td>
      <td>Type of the function object that binds the second argument to a binary function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::logical_and</td>
      <td>Function object implementing x&amp;&amp;y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::logical_or</td>
      <td>Function object implementing x||y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::logical_not</td>
      <td>Function object implementing !x</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun</td>
      <td>Converts a member function to a function object (pointer version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun_ref</td>
      <td>Converts a member function to a function object (reference version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::ptr_fun</td>
      <td>Converts a function pointer to a function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::unary_negate</td>
      <td>Wrapper function object returning the complement of the unary predicate it holds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::binary_negate</td>
      <td>Wrapper function object returning the complement of the binary predicate it holds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::not1</td>
      <td>Constructs custom std::unary_negate object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::not2</td>
      <td>Constructs custom std::binary_negate object&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::bind</td>
      <td>Binds one or more arguments to a function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::ref</td>
      <td>Creates a std::reference_wrapper with a type deduced from its argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::cref</td>
      <td>Creates a const std::reference_wrapper with a type deduced from its argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>placeholders (_1, _2,...)</td>
      <td>Placeholders for the unbound arguments in a std::bind expression</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper</td>
      <td>Copy-constructible and copy-assignable wrapper object over a reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper::reference_wrapper</td>
      <td>Constructs a new reference wrapper</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper::get</td>
      <td>Accesses the stored reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper::operator()</td>
      <td>Calls the stored function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper::operator=</td>
      <td>Rebinds a std::reference_wrapper</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::reference_wrapper::operator T&amp;</td>
      <td>Accesses the stored reference&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function</td>
      <td>Wraps callable object of any type with specified function call signature</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::function</td>
      <td>Constructs a new function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::~function</td>
      <td>Destructs the function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::assign</td>
      <td>Assigns a new target</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::operator=</td>
      <td>Assigns a new target</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::operator bool</td>
      <td>Checks if a valid target is contained</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::operator()</td>
      <td>Invokes the target</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::operator==</td>
      <td>Compares a std::function with a null pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::operator!=</td>
      <td>Compares a std::function with a null pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::swap</td>
      <td>Swaps the contents with another function object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::swap</td>
      <td>Swaps the contents of two function objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::target</td>
      <td>Obtains a pointer to the stored target</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::function::target_type</td>
      <td>Obtains the typeid of the stored target</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::plus</td>
      <td>Function object implementing x+y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::minus</td>
      <td>Function object implementing x-y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::multiplies</td>
      <td>Function object implementing x*y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::divides</td>
      <td>Function object implementing x/y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::modulus</td>
      <td>Function object implementing x%y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::negate</td>
      <td>Function object implementing -x</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::bad_function_call</td>
      <td>The exception thrown when invoking an empty std::function&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::bit_and</td>
      <td>Function object implementing x&amp;y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::bit_or</td>
      <td>Function object implementing x|y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::bit_xor</td>
      <td>Function object implementing x^y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>functional</td>
      <td>std::bit_not</td>
      <td>Function object implementing ~x</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::equal_to</td>
      <td>Function object implementing x==y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::not_equal_to</td>
      <td>Function object implementing x!=y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::greater</td>
      <td>Function object implementing x&gt;y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::less</td>
      <td>Function object implementing x&lt;y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::greater_equal</td>
      <td>Function object implementing x&gt;=y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::less_equal</td>
      <td>Function object implementing x&lt;=y</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::hash</td>
      <td>Function object that implements a hash function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun_t</td>
      <td>Function object that acts as a wrapper over a parameterless member function of a class (pointer version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun1_t</td>
      <td>Function object that acts as a wrapper over a single-parameter member function of a class (pointer version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::const_mem_fun_t</td>
      <td>Function object that acts as a wrapper over a const parameterless member function of a class (pointer version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::const_mem_fun1_t</td>
      <td>Function object that acts as a wrapper over a const single-parameter member function of a class (pointer version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun_ref_t</td>
      <td>Function object that acts as a wrapper over a parameterless member function of a class (reference version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::mem_fun1_ref_t</td>
      <td>Function object that acts as a wrapper over a single-parameter member function of a class (reference version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::const_mem_fun_ref_t</td>
      <td>Function object that acts as a wrapper over a const parameterless member function of a class (reference version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::const_mem_fun1_ref_t</td>
      <td>Function object that acts as a wrapper over a const single-parameter member function of a class (reference version)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::pointer_to_unary_function</td>
      <td>Type of a function object that acts as a wrapper around a unary function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>functional</td>
      <td>std::pointer_to_binary_function</td>
      <td>Type of a function object that acts as a wrapper around a binary function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>functional</td>
      <td>std::mem_fn</td>
      <td>Generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future</td>
      <td>Mechanism to access the result of asynchronous operations</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::future</td>
      <td>Construct a new future object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::~future</td>
      <td>Destructs the future object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::get</td>
      <td>Returns the operation result&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::operator=</td>
      <td>Moves the future object&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::share</td>
      <td>Transfers the shared state from *this to a shared_future and returns it&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::valid</td>
      <td>Checks if the future has a shared state</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::wait</td>
      <td>Waits for the result to become available</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::wait_for</td>
      <td>Waits for the result, returns if it is not available for the specified timeout duration&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future::wait_until</td>
      <td>Waits for the result, returns if it is not available until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_errc</td>
      <td>Enum type that defines the error codes reported by std::future and related classes</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_status</td>
      <td>Enum type that defines the possible return values of the wait_for and wait_until member functions of future and shared_future</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::launch</td>
      <td>Enum type which is a bitmask type that defines the launching policy in calls to async</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task</td>
      <td>Wraps a callable element  and allows its result to be retrieved asynchronously</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::packaged_task</td>
      <td>Constructs a new packaged task</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::~packaged_task</td>
      <td>Destructs the packaged task</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::get_future</td>
      <td>Returns a future  object associated with the object's shared state</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::make_ready_at_thread_exit</td>
      <td>Executes the function ensuring that the result is ready only once the current thread exits</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::operator()</td>
      <td>Calls the stored task</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::operator=</td>
      <td>Moves the task object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::reset</td>
      <td>Resets the state abandoning any stored results of previous executions</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::swap</td>
      <td>Swaps two task objects&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::packaged_task::valid</td>
      <td>Returns whether the packaged_task is currently associated with a shared state</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::swap</td>
      <td>S waps two task objects&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::uses_allocator</td>
      <td>Specialization for std::packaged_task</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise</td>
      <td>Provides a facility to store a value or an exception that is later acquired asynchronously via a std::future &nbsp;object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::promise</td>
      <td>Constructs a new std::promise object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::~promise</td>
      <td>Destructs the promise object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::get_future</td>
      <td>Returns a future &nbsp;associated with the promised result</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::operator=</td>
      <td>Move-assign promise</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::set_exception</td>
      <td>Sets the result to indicate an exception&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::set_exception_at_thread_exit</td>
      <td>Sets the result to indicate an exception while delivering the notification only at thread exit</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::set_value</td>
      <td>Sets the result to specific value&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::set_value_at_thread_exit</td>
      <td>Sets the result to specific value while delivering the notification only at thread exit&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::promise::swap</td>
      <td>Swaps two promise objects</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::swap</td>
      <td>S waps two promise objects</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::uses_allocator</td>
      <td>Specialization for std::promise</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future</td>
      <td>Provides access the result of asynchronous operations, similar to std::future , except that multiple threads are allowed to wait for the same shared state</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::shared_future</td>
      <td>Constructs a new std::shared_future object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::~shared_future</td>
      <td>Destructs the std::shared_future object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::get</td>
      <td>Returns the result</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::valid</td>
      <td>Checks if the future has a shared state</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::wait</td>
      <td>Waits for the result to become available</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::wait_for</td>
      <td>Waits for the result, returns if it is not available for the specified timeout duration</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::shared_future::wait_until</td>
      <td>Waits for the result, returns if it is not available until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_error</td>
      <td>Exceptions thrown to report invalid operations on future &nbsp;objects or other elements of the library that may access a future 's shared state</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_error::future_error</td>
      <td>Constructs a new std::future_error object</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_error::code</td>
      <td>Returns the error code</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_error::what</td>
      <td>Returns the explanatory string specific to the error code</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::future_category</td>
      <td>Obtains a reference to the static error category object for the errors related to futures and promises</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::async</td>
      <td>Runs a function&nbsp; asynchronously and returns a std::future &nbsp;that will eventually hold the result of that function call</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::make_error_code</td>
      <td>Creates an error_code &nbsp;object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::make_error_condition</td>
      <td>Creates an error_condition  object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>future</td>
      <td>std::swap</td>
      <td>Swaps two future objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::initializer_list</td>
      <td>Provides access to an array of objects of type&nbsp; <code>const T</code></td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::initializer_list::initializer_list</td>
      <td>Constructs a new std::initializer_list object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::initializer_list::size</td>
      <td>Returns the number of elements in the initializer list&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::initializer_list::begin</td>
      <td>Returns a pointer to the first element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::initializer_list::end</td>
      <td>Returns a pointer to one past the last element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::begin</td>
      <td>Returns a pointer to the first element in the&nbsp;std::initializer_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>initializer_list</td>
      <td>std::end</td>
      <td>Returns a pointer to one past the last element&nbsp; in the&nbsp;std::initializer_list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::resetiosflags</td>
      <td>Clears all format flags of the stream&nbsp; as specified by the&nbsp; <code>mask</code></td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::setiosflags</td>
      <td>Sets the specified ios_base flags&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::setbase</td>
      <td>Changes the base used for integer I/O&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::setfill</td>
      <td>Changes the base used for integer I/O&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::setprecision</td>
      <td>Changes floating-point precision&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iomanip</td>
      <td>std::setw</td>
      <td>Changes floating-point precision&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iomanip</td>
      <td>std::get_money</td>
      <td>
        <p>Parses a monetary value.</p>
        <p>Note: Due to dependencies this API has not yet been tested well. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.<br /></p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iomanip</td>
      <td>std::put_money</td>
      <td>
        <p>Formats and outputs a monetary value.</p>
        <p>Note: Due to dependencies this API has not yet been tested well. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.<br /></p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iomanip</td>
      <td>std::get_time</td>
      <td>Parses a date/time value of specified format&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iomanip</td>
      <td>std::put_time</td>
      <td>Formats and outputs a date/time value according to the specified format</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iomanip</td>
      <td>std::quoted</td>
      <td>Inserts and extracts quoted strings with embedded spaces</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base</td>
      <td>Base class for all I/O stream classes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::ios_base</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::~ios_base</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::flags</td>
      <td>Manages format flags&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::setf</td>
      <td>Sets specific format flag</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::unsetf</td>
      <td>Clears specific format flag&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::precision</td>
      <td>Manages decimal precision of floating point operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::width</td>
      <td>Manages field width&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::imbue</td>
      <td>Sets locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::getloc</td>
      <td>Returns the current locale&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::xalloc</td>
      <td>Returns a program-wide unique integer that is safe to use as index to pword() and iword()&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::iword</td>
      <td>Resizes the private storage if necessary and access to the long&nbsp; element at the given index&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::pword</td>
      <td>Resizes the private storage if necessary and access to the void*&nbsp; element at the given index</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::register_callback</td>
      <td>Registers event callback function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ios_base::sync_with_stdio</td>
      <td>Sets whether C++ and C IO libraries are interoperable</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::io_errc</td>
      <td>IO stream error codes&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::fpos</td>
      <td>Identifies absolute positions in a stream or in a file</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::fpos::state</td>
      <td>Gets/sets the value of the shift state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios</td>
      <td>Provides facilities for interfacing with objects that have std::basic_streambuf&nbsp; interface</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::basic_ios</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::basic_ios::operator bool</td>
      <td>Checks if no error has occurred</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::operator !</td>
      <td>Checks if an error has occurred</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::rdsatate</td>
      <td>Returns state flags</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::basic_ios::clear</p>
      </td>
      <td>Clears error and eof flags&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::setstate</td>
      <td>Sets state flags&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::good</td>
      <td>Checks if no error has occurred i.e. I/O operations are available</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::eof</td>
      <td>Checks if end-of-file has been reached</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::fail</td>
      <td>Checks if a recoverable error has occurred&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::bad</td>
      <td>Checks if a non-recoverable error has occurred</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::exceptions</td>
      <td>Manages exception mask&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::tie</td>
      <td>Manages tied stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::rdbuf</td>
      <td>Manages associated stream buffer&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::copyfmt</td>
      <td>Copies formatting information</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::fill</td>
      <td>Manages the fill character&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::imbue</td>
      <td>Sets the locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::narrow</td>
      <td>Narrows the characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::basic_ios::widen</td>
      <td>Widens the characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::boolalpha</p>
        <p>std::noboolalpha</p>
      </td>
      <td>Switches between textual and numeric representation of booleans</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::dec</p>
        <p>std::oct</p>
        <p>std::hex</p>
      </td>
      <td>Changes the base used for integer I/O</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::fixed</p>
        <p>std::scientific</p>
      </td>
      <td>Changes formatting used for floating-point I/O&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>
        <p>std::hexfloat</p>
        <p>std::defaultfloat</p>
      </td>
      <td>Changes formatting used for floating-point I/O&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::internal</p>
        <p>std::left</p>
        <p>std::right</p>
      </td>
      <td>Sets the placement of fill characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::iostream_category</td>
      <td>Obtains a reference to the static error category object for iostream errors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::is_error_code_enum</td>
      <td>Informs other library components that values of type std::io_errc  are enumerations that hold error codes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::make_error_code</td>
      <td>Constructs an std::error_code  object from a value of type std::io_errc <span class="t-lc">&nbsp;</span></td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ios</td>
      <td>std::make_error_condition</td>
      <td>Constructs an std::error_condition &nbsp;object from a value of type  std::io_errc </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::showbase</p>
        <p>std::noshowbase</p>
      </td>
      <td>Controls whether prefix is used to indicate numeric base</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::showpoint</p>
        <p>std::noshowpoint</p>
      </td>
      <td>Controls whether decimal point is always included in floating-point representation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::showpos</p>
        <p>std::noshowpos</p>
      </td>
      <td>Controls whether the&nbsp; <code>+</code> &nbsp;sign used with non-negative numbers&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::skipws</p>
        <p>std::noskipws</p>
      </td>
      <td>Controls whether leading whitespace is skipped on input&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::unitbuf</p>
        <p>std::nounitbuf</p>
      </td>
      <td>Controls whether output is flushed after each operation&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>
        <p>std::uppercase</p>
        <p>std::nouppercase</p>
      </td>
      <td>Controls whether uppercase characters are used with some output formats&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::ws</td>
      <td>Discards leading whitespace from an input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::streamoff</td>
      <td>Signed integral type of sufficient size to represent the maximum possible file size supported by the operating system</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ios</td>
      <td>std::streamsize</td>
      <td>Signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream</td>
      <td>Provides support for high level input operations on character streams</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::gcount</td>
      <td>
        <p>Returns the number of characters extracted by the last unformatted input operation&nbsp;</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::get</td>
      <td>Extracts the characters&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::getline</td>
      <td>Extracts the characters until the given character is found&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::ignore</td>
      <td>Extracts and discards the characters until the given character is found&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::operator&gt;&gt;</td>
      <td>Extracts characters and character arrays</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::operator&gt;&gt;</td>
      <td>Extracts characters and character arrays</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::peek</td>
      <td>Reads the next character without extracting it&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::putback</td>
      <td>Puts the character into the input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::read</td>
      <td>Extracts blocks of characters&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::readsome</td>
      <td>Extracts already available blocks of characters&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::seekg</td>
      <td>Sets the input position indicator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::sync</td>
      <td>Synchronizes with the underlying storage device&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::tellg</td>
      <td>Returns the input position indicator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::unget</td>
      <td>Unextracts a character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::sentry</td>
      <td>Implements basic logic for preparation of the stream for input operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::sentry::sentry</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::sentry::~sentry</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>istream</td>
      <td>std::basic_istream::sentry::operator bool</td>
      <td>Checks if the preparation of the stream object was successful</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_insert_iterator</td>
      <td>Output iterator that appends elements to a container for which it was constructed</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_insert_iterator::back_insert_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_insert_iterator::operator=</td>
      <td>Inserts an object into the associated container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_insert_iterator::operator*</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_insert_iterator::operator++</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_insert_iterator</td>
      <td>Output iterator that prepends elements to a container for which it was constructed</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_insert_iterator::front_insert_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_insert_iterator::operator=</td>
      <td>Inserts an object into the associated container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_insert_iterator::operator*</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_insert_iterator::operator++</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::insert_iterator</td>
      <td>Output iterator&nbsp;that inserts elements into a container for which it was constructed, at the position pointed to by the supplied iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::insert_iterator::insert_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::insert_iterator::operator=</td>
      <td>Inserts an object into the associated container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::insert_iterator::operator*</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::insert_iterator::operator++</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istream_iterator</td>
      <td>Single-pass input iterator that reads successive objects of a particular type&nbsp; from the std::basic_istream &nbsp;object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istream_iterator::istream_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istream_iterator::operator*</td>
      <td>Returns the current element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istream_iterator::operator-&gt;</td>
      <td>Returns the current element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istream_iterator::operator++</td>
      <td>Advances the iterator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two istream iterators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator</td>
      <td>Single-pass input iterator that reads successive characters from the std::basic_streambuf object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator::istreambuf_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator::equal</td>
      <td>Tests if both istreambuf iterators  are end-of-stream or if both are valid</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator::operator*</td>
      <td>Obtains a copy of the current character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator::operator-&gt;</td>
      <td>Accesses a member of the current character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::istreambuf_iterator::operator++</td>
      <td>Advances the iterator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>C ompares two istreambuf iterators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::move_iterator</td>
      <td>Converts the value returned by the underlying iterator into an rvalue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::move_iterator::move_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::move_iterator::base</td>
      <td>Accesses the underlying iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>
        <p>std::move_iterator::operator*</p>
        <p>std::move_iterator::operator-&gt;</p>
      </td>
      <td>Accesses the pointed-to element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::move_iterator::operator=</td>
      <td>Assigns another iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::move_iterator::operator[]</td>
      <td>Accesses an element by index&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>
        <p>std::move_iterator::operator++</p>
        <p>std::move_iterator::operator--</p>
        <p>std::move_iterator::operator-</p>
        <p>std::move_iterator::operator+</p>
        <p>std::move_iterator::operator-=</p>
        <p>std::move_iterator::operator+=</p>
      </td>
      <td>Advances or decrements the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares the underlying iterators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::operator-</td>
      <td>Computes the distance between two iterator adaptors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::operator+</td>
      <td>Advances the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostream_iterator</td>
      <td>Single-pass output iterator  that writes successive objects of a particular type&nbsp; into an std::basic_ostream  object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostream_iterator::ostream_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostream_iterator::operator=</td>
      <td>Writes an object to the associated output sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostream_iterator::operator*</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostream_iterator::operator++</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator</td>
      <td>Single-pass&nbsp;output iterator   that writes successive characters into an std::basic_streambuf  object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator::ostreambuf_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator::failed</td>
      <td>Tests if output failed&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator::operator=</td>
      <td>Writes a character to the associated output sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator::operator*</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::ostreambuf_iterator::operator++</td>
      <td>No-op</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::reverse_iterator</td>
      <td>Iterator adaptor that reverses the direction of a given iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::reverse_iterator::reverse_iterator</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::reverse_iterator::base</td>
      <td>Accesses the underlying iterator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::reverse_iterator::operator*</p>
        <p>std::reverse_iterator::operator-&gt;</p>
      </td>
      <td>Accesses the pointed-to element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::reverse_iterator::operator=</td>
      <td>Assigns another iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::reverse_iterator::operator[]</td>
      <td>Accesses an element by index</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::reverse_iterator::operator++</p>
        <p>std::reverse_iterator::operator--</p>
        <p>std::reverse_iterator::operator-</p>
        <p>std::reverse_iterator::operator+</p>
        <p>std::reverse_iterator::operator-=</p>
        <p>std::reverse_iterator::operator+=</p>
      </td>
      <td>Advances or decrements the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares the underlying iterators&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::operator-</td>
      <td>Computes the distance between two iterator adaptors&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::operator+</td>
      <td>Advances the iterator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>
        <p>std::input_iterator_tag</p>
        <p>std::output_iterator_tag</p>
        <p>std::forward_iterator_tag</p>
        <p>std::bidirectional_iterator_tag</p>
        <p>std::random_access_iterator_tag</p>
      </td>
      <td>Iterator categories</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::iterator_traits</td>
      <td>Type trait class that provides uniform interface to the properties of iterator type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::front_inserter</td>
      <td>Convenience function template that constructs a std::front_insert_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::back_inserter</td>
      <td>Convenience function template that constructs a std::back_insert_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::inserter</td>
      <td>Convenience function template that constructs a std::insert_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::make_move_iterator</td>
      <td>Convenience function template that constructs a std::move_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::advance</td>
      <td>Increments given iterator it by N elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::begin</td>
      <td>Returns an iterator to the beginning of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::cbegin</td>
      <td>Returns a const iterator to the beginning of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::rbegin</td>
      <td>Returns a reverse iterator of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::crbegin</td>
      <td>Returns a const reverse iterator of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>iterator</td>
      <td>std::distance</td>
      <td>Returns the number of elements between</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::end</td>
      <td>Returns an iterator to the end of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::cend</td>
      <td>Returns a const iterator to the end of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::rend</td>
      <td>Returns a reverse iterator of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>iterator</td>
      <td>std::crend</td>
      <td>Returns a const reverse iterator of the given container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::next</td>
      <td>Returns the Nth successor of the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>iterator</td>
      <td>std::prev</td>
      <td>Returns the Nth predecessor of the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::float_denorm_style</td>
      <td>Enumeration indicating support of subnormal values by floating-point types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::float_round_style</td>
      <td>Enumeration indicating the rounding style used by floating-point arithmetic</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits</td>
      <td>Provides a standardized way to query various properties of arithmetic types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::denorm_min</td>
      <td>Returns the smallest positive subnormal value of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::digits</td>
      <td>Number of radix digits that can be represented without change</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::digits10</td>
      <td>Number of decimal digits that can be represented without change</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::epsilon</td>
      <td>Returns the difference between 1.0 and the next representable value of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::has_denorm</td>
      <td>Identifies the denormalization style used by the floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::has_denorm_loss</td>
      <td>Identifies the floating-point types that detect loss of precision as denormalization loss rather than inexact result</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::has_infinity</td>
      <td>Identifies floating-point types that can represent the special value &quot;positive infinity&quot;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::has_quiet_NaN</td>
      <td>Identifies floating-point types that can represent the special value &quot;quiet not-a-number&quot; (NaN)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::has_signaling_NaN</td>
      <td>Identifies floating-point types that can represent the special value &quot;signaling not-a-number&quot; (NaN)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::infinity</td>
      <td>Returns the positive infinity value of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_bounded</td>
      <td>Identifies types that represent a finite set of values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_exact</td>
      <td>Identifies exact types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_iec559</td>
      <td>Identifies the IEC 559/IEEE 754 floating-point types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_integer</td>
      <td>Identifies the integer types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_modulo</td>
      <td>Identifies the types that handle overflows with modulo arithmetic</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_signed</td>
      <td>Identifies the signed types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::is_specialized</td>
      <td>Identifies types for which std::numeric_limits is specialized</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>limits</td>
      <td>std::numeric_limits::lowest</td>
      <td>Returns the lowest finite value of the given type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::max</td>
      <td>Returns the largest finite value of the given type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>limits</td>
      <td>std::numeric_limits::max_digits10</td>
      <td>Number of decimal digits necessary to differentiate all values of this type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::max_exponent</td>
      <td>One more than the largest integer power of the radix that is a valid finite floating-point value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::max_exponent10</td>
      <td>The largest integer power of 10 that is a valid finite floating-point value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::min</td>
      <td>Returns the smallest finite value of the given type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::min_exponent</td>
      <td>One more than the smallest negative power of the radix that is a valid normalized floating-point value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::min_exponent10</td>
      <td>The smallest negative power of ten that is a valid normalized floating-point value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::quiet_NaN</td>
      <td>Returns a quiet NaN value of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::radix</td>
      <td>The radix or integer base used by the representation of the given type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::round_error</td>
      <td>Returns the maximum rounding error of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::round_style</td>
      <td>Identifies the rounding style used by the type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::signaling_NaN</td>
      <td>Rturns a signaling NaN value of the given floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::tinyness_before</td>
      <td>Identifies floating-point types that detect tinyness before rounding</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>limits</td>
      <td>std::numeric_limits::traps</td>
      <td>Identifies types which can cause arithmetic operations to trap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list</td>
      <td>Container that supports constant time insertion and removal of elements from anywhere in the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::list</td>
      <td>Constructs the list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::~list</td>
      <td>Destructs the list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::assign</td>
      <td>Assigns values to the container&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::back</td>
      <td>Accesses the last element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::cend</td>
      <td>R eturns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::crbegin</td>
      <td>R eturns a const reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::crend</td>
      <td>R eturns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::rbegin</td>
      <td>R eturns a reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::rend</td>
      <td>R eturns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::clear</td>
      <td>Empties the list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>list</td>
      <td>std::list::emplace</td>
      <td>Constructs an element in-place&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>list</td>
      <td>std::list::emplace_back</td>
      <td>Constructs an element in-place at the end&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>list</td>
      <td>std::list::emplace_front</td>
      <td>Constructs an element in-place at the beginning&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::empty</td>
      <td>Checks whether the container is empty&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::front</td>
      <td>Accesses the first element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::get_allocator</td>
      <td>Returns the associated allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::insert</td>
      <td>Inserts elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::merge</td>
      <td>Merges two sorted lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in two lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::pop_back</td>
      <td>Removes the last element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::pop_front</td>
      <td>Removes the first element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::push_back</td>
      <td>Adds an element to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::push_front</td>
      <td>Adds an element to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::remove</td>
      <td>Removes all elements that are equal to the given value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::remove_if</td>
      <td>Re moves all elements for which the predicate returns true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::resize</td>
      <td>Changes the number of elements stored</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::reverse</td>
      <td>Reverses the order of the elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::size</td>
      <td>Returns the number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::sort</td>
      <td>Sorts the elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::splice</td>
      <td>Moves the elements from another list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::swap</td>
      <td>Swaps the contents with another list</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::swap</td>
      <td>Swaps the contents of two lists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>list</td>
      <td>std::list::unique</td>
      <td>Removes consecutive duplicate elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::out</td>
      <td>Translates sequentially the characters in the input range from intern type to extern type and places them in the output range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::in</td>
      <td>Translates sequentially the characters in the input range&nbsp;from extern type to intern type and places them in the output range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::unshift</td>
      <td>Unshifts the translation state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::encoding</td>
      <td>Returns the encoding width</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::always_noconv</td>
      <td>Returns the noconv characteristics</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::length</td>
      <td>Return the translated sequence length</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt::max_length</td>
      <td>Returns the max length of one character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt_base</td>
      <td>Base class for codecvt facet classes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::codecvt_byname</td>
      <td>Facet that overrides codecvt virtual members to implement its semantics for particular named locales</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::collate::compare</td>
      <td>Compares two character sequences using the rules of the associated locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::collate::transform</td>
      <td>Returns a string object whose character values are such that when compared lexicographically with the character values resulting from calling this same function on another string, gives the same result as comparing the strings using collate::compare</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::collate::hash</td>
      <td>Converts the input character sequence to an integer value that is equal to the hash obtained for all strings that collate equivalent in this locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::collate_byname</td>
      <td>Facet that encapsulates locale-specific collation (comparison) and hashing of strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype</td>
      <td>Encapsulates character classification features</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::ctype</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::is</td>
      <td>Classifies characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::scan_is</td>
      <td>Returns the first character in the range that classifies into any of the categories specified</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::scan_not</td>
      <td>Returns the first character in the range that does not classify into any of the categories specified</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::toupper</td>
      <td>Converts to uppercase</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::tolower</td>
      <td>Converts to lowercase</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::widen</td>
      <td>Widens characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype::narrow</td>
      <td>Narrows characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype_base</td>
      <td>Base class that defines the mask bitmask member type to be inherited by ctype facet classes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ctype_byname</td>
      <td>Facet that encapsulates character classification rules of the locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale</td>
      <td>
        <p>Encapsulates a set of culture-specific features.</p>
        <p>Note: Due to dependencies the parameter-less constructor and the constructor with a locale name only are tested.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::locale</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::combine</td>
      <td>Constructs a copy of the locale modifying one facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::name</td>
      <td>Gets the locale name</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>
        <p>std::locale::operator==</p>
        <p>std::locale::operator!=</p>
      </td>
      <td>Compares locales</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::operator=</td>
      <td>Copies locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::operator()</td>
      <td>Lexicographically compares two strings using this locale's collate facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::global</td>
      <td>Sets the global locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::classic</td>
      <td>Returns the classic locale, which corresponds in semantics to the &quot;C&quot; locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::facet</td>
      <td>Locale facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::facet::facet</td>
      <td>Constructs the facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::facet::~facet</td>
      <td>Destructs the facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::id</td>
      <td>Facet index type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::id::id</td>
      <td>Constructs the facet index</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::collate</td>
      <td>Bitmask value of type category indicating the collate facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::ctype</td>
      <td>Bitmask value of type category indicating the ctype facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::messages</td>
      <td>Bitmask value of type category indicating the messages facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::monetary</td>
      <td>B itmask value of type category indicating the monetary facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::none</td>
      <td>Zero value of type category indicating no facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::numeric</td>
      <td>B itmask value of type category indicating the numeric facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::time</td>
      <td>Bitmask value of type category indicating the time facet category</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::locale::all</td>
      <td>collate | ctype | monetary | numeric | time | messages</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert</td>
      <td>Converts between byte string and wide string using an individual code conversion facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert::wstring_convert</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert::from_bytes</td>
      <td>Converts a byte string into a wide string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert::to_bytes</td>
      <td>Converts a wide string into a byte string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert::converted</td>
      <td>Returns the number of characters successfully converted</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wstring_convert::state</td>
      <td>Returns the current conversion state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wbuffer_convert</td>
      <td>Wrapper over stream buffer of type std::basic_streambuf&lt;char&gt; which gives it the appearance of std::basic_streambuf&lt;Elem&gt;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wbuffer_convert::wbuffer_convert</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wbuffer_convert::rdbuf</td>
      <td>Returns or replaces the underlying narrow stream buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>locale</td>
      <td>std::wbuffer_convert::state</td>
      <td>Returns the current conversion state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::messages::open</td>
      <td>Obtains a value of type catalog, which can be passed to get() to retrieve messages from the message catalog</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::messages::get</td>
      <td>Obtains a message from the open message catalog</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::messages::close</td>
      <td>Releases the implementation-defined resources associated with an open catalog</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::messages_base</td>
      <td>Base type for the std::messages facets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::messages_byname</td>
      <td>std::messages facet which encapsulates retrieval of strings from message catalogs of the locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::money_base</td>
      <td>Provides constants which are inherited and used by the std::moneypunct, std::money_get and std::money_put facets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::money_get</td>
      <td>Encapsulates the rules for parsing monetary values from character streams</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::money_get::get</td>
      <td>
        <p>Extracts a monetary value from the input sequence.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for long double. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::money_put</td>
      <td>Encapsulates the rules for formatting monetary values as strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::money_put::put</td>
      <td>
        <p>Formats monetary value and writes the result to output stream.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for long double. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct</td>
      <td>Facet that encapsulates monetary value format preferences</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::decimal_point</td>
      <td>Returns the decimal point character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::thousands_sep</td>
      <td>Returns the thousands separator character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::grouping</td>
      <td>Returns grouping of digits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::curr_symbol</td>
      <td>Returns the currency symbol</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::positive_sign</td>
      <td>Returns the positive sign string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::negative_sign</td>
      <td>Returns the negative sign string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::frac_digits</td>
      <td>Returns fractional digits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::pos_format</td>
      <td>Returns format for positive monetary expressions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct::neg_format</td>
      <td>Returns format of negative monetary expressions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::moneypunct_byname</td>
      <td>std::moneypunct facet which encapsulates monetary formatting preferences of a locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::num_get</td>
      <td>Encapsulates the rules for parsing string representations of numeric values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::num_get::get</td>
      <td>Extracts a number from the input character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::num_put</td>
      <td>Encapsulates the rules for formatting numeric values as strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::num_put::put</td>
      <td>Formats a number and writes to the output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct</td>
      <td>Facet that encapsulates numeric punctuation preferences</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct::decimal_point</td>
      <td>Provides the character to use as decimal point</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct::thousands_sep</td>
      <td>Provides the character to use as thousands separator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct::grouping</td>
      <td>Provides the numbers of digits between each pair of thousands separators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct::truename</td>
      <td>Provides the string to use as the name of the boolean true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct::falsename</td>
      <td>Provides the string to use as the name of the boolean false</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::numpunct_byname</td>
      <td>std::numpunct facet which encapsulates numeric punctuation preferences of a locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_base</td>
      <td>Provides the date order constants which are inherited by the std::time_get facets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get</td>
      <td>Encapsulates date and time parsing rules</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::date_order</td>
      <td>Obtains preferred ordering of day, month, and year</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get_time</td>
      <td>Extracts hours, minutes, and seconds from input stream&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get_date</td>
      <td>Extracts month, day, and year from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get_weekday</td>
      <td>Extracts the name of a day of the week from input stream&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get_monthname</td>
      <td>E xtracts a month name from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get_year</td>
      <td>Extracts a year from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get::get</td>
      <td>Extracts date/time components from input stream according to the specified format</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_get_byname</td>
      <td>std::time_get facet which encapsulates time and date parsing rules of the locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_put</td>
      <td>Encapsulates date and time formatting rules</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_put::put</td>
      <td>Formats date/time and writes to output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::time_put_byname</td>
      <td>std::time_put facet which encapsulates time and date formatting rules of the locale specified at its construction</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::use_facet</td>
      <td>Obtains a reference to a facet implemented by the locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::has_facet</td>
      <td>Checks if the locale implements the facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isspace</td>
      <td>Checks if the given character is classified as a whitespace character by the given locale's ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isprint</td>
      <td>Checks if the given character classified as a printable character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::iscntrl</td>
      <td>Checks if the given character is classified as a control character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isupper</td>
      <td>Checks if the given character is classified as an uppercase alphabetic character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::islower</td>
      <td>Checks if the given character is classified as a lowercase alphabetic character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isalpha</td>
      <td>Checks if the given character is classified as an alphabetic character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isdigit</td>
      <td>Checks if the given character is classified as a digit by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::ispunct</td>
      <td>Checks if the given character is classified as an punctuation character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isxdigit</td>
      <td>Checks if the given character is classified as a hexadecimal digit by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isalnum</td>
      <td>Checks if the given character classified as an alphanumeric character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::isgraph</td>
      <td>Checks if the given character classified as a graphic character by the given locale's std::ctype facet</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::toupper</td>
      <td>Converts the character to uppercase</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>locale</td>
      <td>std::tolower</td>
      <td>Converts the character to lowercase</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map</td>
      <td>Sorted associative container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::map</td>
      <td>Constructs the map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::~map</td>
      <td>Destructs the map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::rbegin</td>
      <td>Returns a reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::rend</td>
      <td>Returns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>map</td>
      <td>std::map::at</td>
      <td>Accesses the specified element with bounds checking</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::clear</td>
      <td>Empties the map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::count</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::crbegin</td>
      <td>Returns a const reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::crend</td>
      <td>Returns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>map</td>
      <td>std::map::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>map</td>
      <td>std::map::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::empty</td>
      <td>Checks if the map is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::find</td>
      <td>Finds an element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>map</td>
      <td>std::map::insert_or_assign</td>
      <td>Inserts an element or assigns to the current element if the key already exists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::key_comp</td>
      <td>Returns the function that compares keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::lower_bound</td>
      <td>Returns an iterator to the first element not less than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::max_size</td>
      <td>Returns the maximum number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::operator[]</td>
      <td>Accesses the specified element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::size</td>
      <td>Returns the current number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::swap</td>
      <td>Swaps the contents of the map with another map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::swap</td>
      <td>Swaps the contents of two maps</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>map</td>
      <td>std::map::try_emplace</td>
      <td>Inserts in-place if the key does not exist, does nothing if the key exists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::upper_bound</td>
      <td>Returns an iterator to the first element greater than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::map::value_comp</td>
      <td>Returns the function that compares keys in objects of type value_type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap</td>
      <td>Associative container that contains a sorted list of key-value pairs</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::multimap</td>
      <td>Construct the multimap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::~multimap</td>
      <td>Destruct the multimap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::rbegin</td>
      <td>Returns a reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::rend</td>
      <td>Returns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::crbegin</td>
      <td>Returns a const reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::crend</td>
      <td>Returns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::count</td>
      <td>Returns the number of elements matching specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>map</td>
      <td>std::multimap::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>map</td>
      <td>std::multimap::emplace_hint</td>
      <td>Constructs element in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::empty</td>
      <td>Checks if the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::find</td>
      <td>Finds elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::key_comp</td>
      <td>Returns the function that compares keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::lower_bound</td>
      <td>Returns an iterator to the first element not less than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::max_size</td>
      <td>Returns the maximum number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in two multimaps</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::swap</td>
      <td>Swaps the contents of the map with another map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::swap</td>
      <td>Swaps the contents of two maps</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::upper_bound</td>
      <td>Returns an iterator to the first element greater than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>map</td>
      <td>std::multimap::value_comp</td>
      <td>Returns the function that compares keys in objects of type value_type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator</td>
      <td>Default allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::allocator</td>
      <td>Constructs the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::~allocator</td>
      <td>Desstructs the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::address</td>
      <td>Obtains the address of an object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::allocate</td>
      <td>Allocates uninitialized storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::construct</td>
      <td>Constructs an object in allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::deallocate</td>
      <td>Deallocates the storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::destroy</td>
      <td>Destructs an object in the allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::allocator::max_size</td>
      <td>Returns the largest supported allocation size</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two allocator instances</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits</td>
      <td>Provides the standardized way to access various properties of allocators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::allocate</td>
      <td>Allocates uninitialized storage using the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::construct</td>
      <td>Constructs an object in the allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::deallocate</td>
      <td>Deallocates storage using the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::destroy</td>
      <td>Destructs an object stored in the allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::max_size</td>
      <td>Returns the maximum object size supported by the allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_traits::select_on_container_copy_construction</td>
      <td>Obtains the allocator to use after copying a standard container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr</td>
      <td>Smart pointer that manages an object obtained via new expression and deletes that object when auto_ptr itself is destroyed</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::auto_ptr</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::~auto_ptr</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::operator=</td>
      <td>Transfers ownership from another std::auto_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>
        <p>std::auto_ptr::operator auto_ptr&lt;Y&gt;</p>
        <p>std::auto_ptr::operator auto_ptr_ref&lt;Y&gt;</p>
      </td>
      <td>Converts the managed pointer to a pointer to different type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::get</td>
      <td>Returns a pointer to the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>
        <p>std::auto_ptr::operator*</p>
        <p>std::auto_ptr::operator-&gt;</p>
      </td>
      <td>Accesses the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::reset</td>
      <td>Destroys the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::auto_ptr::release</td>
      <td>Releases ownership of the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::enable_shared_from_this</td>
      <td>Base class that enables the shared_from_this member function in derived classes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::enable_shared_from_this::enable_shared_from_this</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::enable_shared_from_this::~enable_shared_from_this</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::enable_shared_from_this::operator=</td>
      <td>Does nothing, returns *this</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::enable_shared_from_this::shared_from_this</td>
      <td>Returns a shared_ptr which shares ownership of *this</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::hash</td>
      <td>Hash support for std::unique_ptr and std::shared_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::owner_less</td>
      <td>This class defines function objects that perform an owner-based comparison between shared_ptr and/or weak_ptr objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::pointer_traits</td>
      <td>Provides the standardized way to access certain properties of pointer-like types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::pointer_traits::pointer_to</td>
      <td>Obtains a dereferencable pointer to its argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::raw_storage_iterator</td>
      <td>Output iterator that makes it possible for standard algorithms to store results in uninitialized memory</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::raw_storage_iterator::raw_storage_iterator</td>
      <td>Constructs the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++17</td>
      <td>memory</td>
      <td>std::raw_storage_iterator::base</td>
      <td>Provides access to the iterator passed in the constructor of this raw_storage_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::raw_storage_iterator::operator=</td>
      <td>Constructs an object at the pointed-to location in the buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::raw_storage_iterator::operator*</td>
      <td>Dereferences the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::raw_storage_iterator::operator++</td>
      <td>Advances the iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr</td>
      <td>Smart pointer that retains shared ownership of an object through a pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::shared_ptr</td>
      <td>Constructs the pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::~shared_ptr</td>
      <td>Destructs the pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocate_shared</td>
      <td>Creates a shared pointer that manages a new object allocated using an allocator</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>
        <p>std::atomic_compare_exchange_strong</p>
        <p>std::atomic_compare_exchange_strong_explicit</p>
        <p>std::atomic_compare_exchange_weak</p>
        <p>std::atomic_compare_exchange_weak_explicit</p>
        <p>std::atomic_exchange</p>
        <p>std::atomic_exchange_explicit</p>
        <p>std::atomic_is_lock_free</p>
        <p>std::atomic_load</p>
        <p>std::atomic_load_explicit</p>
        <p>std::atomic_store</p>
        <p>std::atomic_store_explicit</p>
      </td>
      <td>Specializes atomic operations for std::shared_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::const_pointer_cast</td>
      <td>Applies const_cast to the stored pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::dynamic_pointer_cast</td>
      <td>Applies dynamic_cast to the stored pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::static_pointer_cast</td>
      <td>Applies static_cast to the stored pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::get</td>
      <td>Returns the stored pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::get_deleter</td>
      <td>Returns the deleter of specified type, if owned</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::make_shared</td>
      <td>Creates a shared pointer that manages a new object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>
        <p>std::shared_ptr::operator*</p>
        <p>std::shared_ptr::operator-&gt;</p>
      </td>
      <td>Dereferences the stored pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::operator=</td>
      <td>Assigns the shared_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::operator bool</td>
      <td>Checks if there is associated managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares with another shared_ptr or with nullptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::operator&lt;&lt;</td>
      <td>Outputs the value of the pointer stored in the std::shared_ptr to an output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::owner_before</td>
      <td>Provides owner-based ordering of shared pointers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::reset</td>
      <td>Replaces the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::swap</td>
      <td>Swaps the managed objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::swap</td>
      <td>Swaps two shared_ptrs</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::unique</td>
      <td>Checks whether the managed object is managed only by the current shared_ptr instance</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::shared_ptr::use_count</td>
      <td>
        <p>Returns the number of shared_ptr objects referring to the same managed object.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for race condition. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr</td>
      <td>Smart pointer that retains sole ownership of an object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::unique_ptr</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::~unique_ptr</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::get</td>
      <td>Returns a pointer to the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::get_deleter</td>
      <td>Returns the deleter that is used for destruction of the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>
        <p>std::unique_ptr::operator*</p>
        <p>std::unique_ptr::operator-&gt;</p>
      </td>
      <td>Dereferences pointer to the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::operator=</td>
      <td>Assigns the unique_ptr&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::operator[]</td>
      <td>Provides indexed access to the managed array&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::operator bool</td>
      <td>Checks if there is associated managed object&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares to another unique_ptr or with nullptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::release</td>
      <td>Returns a pointer to the managed object and releases the ownership</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::reset</td>
      <td>Replaces the managed object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::unique_ptr::swap</td>
      <td>Swaps the managed objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::swap</td>
      <td>Swaps two unique ptrs</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr</td>
      <td>Smart pointer that holds a non-owning reference to an object that is managed by std::shared_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::weak_ptr</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::~weak_ptr</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::expired</td>
      <td>Checks whether the referenced object was already deleted</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::lock</td>
      <td>Creates a shared_ptr that manages the referenced object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::operator=</td>
      <td>Assigns the weak_ptr</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::owner_before</td>
      <td>Provides owner-based ordering of weak pointers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::reset</td>
      <td>Releases the ownership of the managed objec</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::swap</td>
      <td>Swaps the managed objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::swap</td>
      <td>Swaps two weak ptrs</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::weak_ptr::use_count</td>
      <td>
        <p>Returns the number of shared_ptr objects that manage the object.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for race condition. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_arg_t</td>
      <td>Empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::allocator_arg</td>
      <td>An object of type std::allocator_arg_t used to select allocator-aware constructors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::addressof</td>
      <td>Obtains the actual address of the object or function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::align</td>
      <td>Returns a pointer aligned by the specified alignment</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::bad_weak_ptr</td>
      <td>Exception thrown by the constructors of std::shared_ptr that take std::weak_ptr as the argument, when the std::weak_ptr refers to an already deleted object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::declare_no_pointers</td>
      <td>Informs the garbage collector or leak detector that the specified memory region contains no traceable pointers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::declare_reachable</td>
      <td>Declares the object reachable</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::default_delete</td>
      <td>The default destruction policy used by std::unique_ptr when no deleter is specified</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::get_pointer_safety</td>
      <td>Obtains the implementation-defined pointer safety model</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::get_temporary_buffer</td>
      <td>Allocates uninitialized contiguous storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>memory</td>
      <td>std::make_unique</td>
      <td>C reates a unique pointer that manages a new object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::pointer_safety</td>
      <td>Enumeration type that lists the pointer safety modes supported by C++</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::return_temporary_buffer</td>
      <td>Deallocates storage previously allocated with std::get_temporary_buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::undeclare_no_pointers</td>
      <td>Unregisters a range earlier registered with std::declare_no_pointers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::undeclare_reachable</td>
      <td>Removes the reachable status of the object if it was previously set by std::declare_reachable</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::uninitialized_copy</td>
      <td>Copies elements to an uninitialized memory area</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::uninitialized_copy_n</td>
      <td>
        <p>Copies N elements to an uninitialized memory area</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>memory</td>
      <td>std::uninitialized_fill</td>
      <td>Copies the given value to an uninitialized memory area</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::uninitialized_fill_n</td>
      <td>Copies the given value value to the first N elements in an uninitialized memory area</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>memory</td>
      <td>std::uses_allocator</td>
      <td>Trait class that identifies whether a type accepts an allocator convertible from Alloc</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>
        <p>std::adopt_lock</p>
        <p>std::try_to_lock</p>
        <p>std::defer_lock</p>
      </td>
      <td>Specifies locking strategies for std::lock_guard and std::unique_lock</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::call_once</td>
      <td>Executes the callable object exactly once, even if called from several threads</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::lock</td>
      <td>Locks the given Lockable objects using a deadlock avoidance algorithm to avoid deadlock</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::try_lock</td>
      <td>Tries to lock each of the given lockable objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::swap</td>
      <td>Specialization of std::swap for unique_lock</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::lock_guard</td>
      <td>RAII-style mechanism for owning a mutex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::lock_guard::lock_guard</td>
      <td>Constructs the guard, optionally locking the given mutex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::lock_guard::~lock_guard</td>
      <td>Destructs the guard, unlocks the underlying mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex</td>
      <td>Mutex synchronization primitive</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::mutex</td>
      <td>Constructs the mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::~mutex</td>
      <td>Destructs the mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::lock</td>
      <td>Locks the mutex, blocks if the mutex is not available</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::native_handle</td>
      <td>Returns the underlying implementation-defined thread handle</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::try_lock</td>
      <td>Tries to lock the mutex, returns if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::mutex::unlock</td>
      <td>Unlocks the mutex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::once_flag</td>
      <td>Helper structure for std::call_once</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::once_flag::once_flag</td>
      <td>Constructs an once_flag object. The internal state is set to indicate that no function has been called yet</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex</td>
      <td>Recursive mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::recursive_mutex</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::~recursive_mutex</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::lock</td>
      <td>Locks the mutex, blocks if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::native_handle</td>
      <td>Returns the underlying implementation-defined thread handle</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::try_lock</td>
      <td>Tries to lock the mutex, returns if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_mutex::unlock</td>
      <td>Unlocks the mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex</td>
      <td>Recursive timed mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::recursive_timed_mutex</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::~recursive_timed_mutex</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::lock</td>
      <td>L ocks the mutex, blocks if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::try_lock</td>
      <td>Tries to lock the mutex, returns if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::try_lock_for</td>
      <td>Tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::try_lock_until</td>
      <td>Tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::recursive_timed_mutex::unlock</td>
      <td>Unlocks the mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex</td>
      <td>Timed mutex</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::timed_mutex</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::~timed_mutex</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::lock</td>
      <td>L ocks the mutex, blocks if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::try_lock</td>
      <td>Tries to lock the mutex, returns if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::try_lock_for</td>
      <td>Tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::try_lock_until</td>
      <td>Tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::timed_mutex::unlock</td>
      <td>Unlocks the mutex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock</td>
      <td>General-purpose mutex ownership wrapper</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::unique_lock</td>
      <td>Constructs a unique_lock, optionally locking the supplied mutex&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::~unique_lock</td>
      <td>Unlocks the associated mutex, if owned&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::lock</td>
      <td>Locks the associated mutex</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::mutex</td>
      <td>Returns a pointer to the associated mutex&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::operator=</td>
      <td>Unlocks the mutex, if owned, and acquires ownership of another</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::operator bool</td>
      <td>Tests whether the lock owns its associated mutex&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::owns_lock</td>
      <td>Tests whether the lock owns its associated mutex&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::release</td>
      <td>Disassociates the associated mutex without unlocking it&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::swap</td>
      <td>Swaps state with another std::unique_lock</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::swap</td>
      <td>Swaps two unique locks</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::try_lock</td>
      <td>Tries to lock the associated mutex, returns if the mutex is not available&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::try_lock_for</td>
      <td>Attempts to lock the associated TimedLockable mutex, returns if the mutex has been unavailable for the specified time duration</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::try_lock_until</td>
      <td>Tries to lock the associated TimedLockable mutex, returns if the mutex has been unavailable until specified time point has been reached</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>std::unique_lock::unlock</td>
      <td>Unlocks the associated mutex&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>mutex</td>
      <td>
        <p>std::defer_lock_t</p>
        <p>std::try_to_lock_t</p>
        <p>std::adopt_lock_t</p>
      </td>
      <td>Specifies locking strategy for std::lock_guard, std::unique_lock and std::shared_lock</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::bad_alloc</td>
      <td>Exception thrown to report failure to allocate storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::bad_array_new_length</td>
      <td>Exception thrown by the new-expressions&nbsp;to report invalid array lengths</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::nothrow_t</td>
      <td>Empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::nothrow</td>
      <td>Object of type nothrow_t used to select an non-throwing allocation function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::get_new_handler</td>
      <td>Returns the currently installed new-handler</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::set_new_handler</td>
      <td>Sets a new global new-handler function&nbsp;and returns the previously installed new-handler</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>new (placement)</td>
      <td>Placement new</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>delete (placement)</td>
      <td>Placement delete</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>new</td>
      <td>Allocates dynamic memory</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>delete</td>
      <td>Deallocates dynamic memory</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>new</td>
      <td>std::new_handler</td>
      <td>Function pointer type, which is used by the functions std::set_new_handler and std::get_new_handler</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>numeric</td>
      <td>std::accumulate</td>
      <td>Computes the sum of the given value and the elements in the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>numeric</td>
      <td>std::adjacent_difference</td>
      <td>Computes the differences between the second and the first of each adjacent pair of elements of the input range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>numeric</td>
      <td>std::inner_product</td>
      <td>Computes inner product of two ranges</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>numeric</td>
      <td>std::iota</td>
      <td>Fills the range with sequentially increasing values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>numeric</td>
      <td>std::partial_sum</td>
      <td>
        <p>Computes the partial sums of the elements in the subranges of the input range</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::endl</td>
      <td>Inserts a newline character into the output sequence and flushes it</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::ends</td>
      <td>Inserts a null character into the output sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::flush</td>
      <td>Flushes the output sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream</td>
      <td>Provides support for high level output operations on character streams</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::operator&lt;&lt;</td>
      <td>Inserts formatted data</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::put</td>
      <td>Inserts a character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::seekp</td>
      <td>Sets the output position indicator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::tellp</td>
      <td>Returns the output position indicator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::write</td>
      <td>Inserts blocks of characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::flush</td>
      <td>Synchronizes with the underlying storage device</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::sentry</td>
      <td>Implements basic logic for preparation of the stream for output operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::sentry::sentry</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::sentry::~sentry</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::sentry::operator bool</td>
      <td>Checks if the preparation of the stream object was successful</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::basic_ostream::swap</td>
      <td>Swaps stream objects, except for the associated buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>operator&lt;&lt;(std::basic_ostream)</td>
      <td>Inserts a character or a character string into std::basic_ostream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::ostream</td>
      <td>basic_ostream&lt;char&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>ostream</td>
      <td>std::wostream</td>
      <td>basic_ostream&lt;wchar_t&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue</td>
      <td>
        <p>Priority queue container adapter</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::priority_queue</td>
      <td>Constructs the queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>queue</td>
      <td>std::priority_queue::emplace</td>
      <td>Constructs element in-place and sorts the underlying container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::empty</td>
      <td>Checks whether the underlying container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::operator=</td>
      <td>Assigns values to the priority queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::pop</td>
      <td>Removes the top element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::push</td>
      <td>Inserts element and sorts the underlying container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::size</td>
      <td>Returns the number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::swap</td>
      <td>Swaps the contents&nbsp;with another priority queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::swap</td>
      <td>S waps the contents&nbsp;of two priority queues</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::priority_queue::top</td>
      <td>Accesses the top element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue</td>
      <td>Queue container adapter</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::queue</td>
      <td>Constructs the queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::back</td>
      <td>Accesses the last element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>queue</td>
      <td>std::queue::emplace</td>
      <td>Constructs element in-place at the end&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::empty</td>
      <td>Checks whether the underlying container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::front</td>
      <td>Accesses the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::operator=</td>
      <td>Assigns values to the queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::pop</td>
      <td>Removes the first element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::push</td>
      <td>Inserts element at the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::queue::swap</td>
      <td>Swaps the contents with another queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::swap</td>
      <td>Swaps the contents&nbsp;of two queues</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>queue</td>
      <td>std::uses_allocator</td>
      <td>Specializes the std::uses_allocator type trait for std::queue and std::priority_queue</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::default_random_engine</td>
      <td>Random number engine class that generates pseudo-random numbers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::generate_canonical</td>
      <td>Evenly distributes real values of given precision across [0, 1)&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::knuth_b</td>
      <td>Engine adaptor that returns shuffled sequences generated with the simple pseudo-random number generator engine minstd_rand0</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::minstd_rand</td>
      <td>Multiplicative congruential pseudo-random number generator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::minstd_rand0</td>
      <td>Multiplicative congruential pseudo-random number generator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mt19937</td>
      <td>Mersenne Twister pseudo-random generator of 32-bit numbers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mt19937_64</td>
      <td>Mersenne Twister pseudo-random generator of 64-bit numbers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::ranlux24</td>
      <td>
        <p>Subtract-with-carry pseudo-random generator of 24-bit numbers with accelerated advancement</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::ranlux24_base</td>
      <td>Subtract-with-carry pseudo-random generator of 24-bit numbers, generally used as the base engine for the ranlux24 generator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::ranlux48</td>
      <td>Subtract-with-carry pseudo-random generator of 48-bit numbers with accelerated advancement</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::ranlux48_base</td>
      <td>Subtract-with-carry pseudo-random generator of 48-bit numbers, generally used as the base engine for the ranlux48 generator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uint64_t</td>
      <td>Unsigned integer type with width of exactly 64 bits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution</td>
      <td>Random number distribution that produces bool values according to a Bernoulli distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::bernoulli_distribution</td>
      <td>Constructs Bernoulli distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two Bernoulli distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>Inserts into output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>Extracts from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::p</td>
      <td>Probability of true</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::param</td>
      <td>Returns the distribution parameters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::bernoulli_distribution::reset</td>
      <td>Resets the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution</td>
      <td>Random number distribution that produces integers according to a binomial discrete distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::binomial_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two binomial distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>Extracts from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>Inserts into output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::p</td>
      <td>Probability of success</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::param</td>
      <td>Returns the distribution parameters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::reset</td>
      <td>Resets the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::binomial_distribution::t</td>
      <td>Upper bound of the range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution</td>
      <td>Random number distribution that produces floating-point values according to a Cauchy distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::cauchy_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::a</td>
      <td>Returns the parameter a</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::b</td>
      <td>Returns the p arameter b</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two Cauchy distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>Extracts from input stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>Inserts into output stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::param</td>
      <td>Returns the distribution parameters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::cauchy_distribution::reset</td>
      <td>Resets the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution</td>
      <td>Random number distribution that produces floating-point values according to a chi-squared distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::chi_squared_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::n</td>
      <td>Returns the degrees of freedom</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;chi-squared distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::param</td>
      <td>Returns the distribution parameters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::chi_squared_distribution::reset</td>
      <td>Resets the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine</td>
      <td>Engine adaptor that adapts a pseudo-random number generator by using only R elements of each block of P elements from the sequence it produces, discarding the rest</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::discard_block_engine</td>
      <td>Constructs the adaptor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::base</td>
      <td>Returns the base engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::discard</td>
      <td>Advances internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;discard_block_engine distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discard_block_engine::seed</td>
      <td>Re-initializes the state of the base engine, by calling its seed member function with the same argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution</td>
      <td>Random number distribution that produces integer values according to a discrete distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::discrete_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;discrete_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::param</td>
      <td>Returns the distribution parameters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::probabilities</td>
      <td>Returns a vector with the probabilities of each of the possible values the distribution can produce</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::discrete_distribution::reset</td>
      <td>Resets the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution</td>
      <td>Random number distribution that produces floating-point values according to an exponential distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::exponential_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::lambda</td>
      <td>Returns the parameter lambda</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;exponential distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::exponential_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution</td>
      <td>Random number distribution that produces floating-point values according to a Type I extreme value distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::extreme_value_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::a</td>
      <td>Returns the parameter a</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::b</td>
      <td>Returns the p arameter b</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;extreme_value_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::extreme_value_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution</td>
      <td>Random number distribution that produces floating-point values according to a Fisher F-distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::fisher_f_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::m</td>
      <td>Returns the degrees of freedom (numerator)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::n</td>
      <td>Returns the d egrees of freedom (denominator)</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;fisher_f_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::fisher_f_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution</td>
      <td>Random number distribution that produces floating-point values according to a gamma distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::gamma_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::alpha</td>
      <td>Returns the parameter alpha</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::beta</td>
      <td>Returns the p arameter beta</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;gamma distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::gamma_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution</td>
      <td>Random number distribution that produces integers according to a geometric discrete distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::geometric_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;geometric distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::p</td>
      <td>Returns the probability of success</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::geometric_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine</td>
      <td>Engine adaptor class template that adapts a pseudo-random number generator to produce random numbers with a specific number of bits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::independent_bits_engine</td>
      <td>Constructs the adaptor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::base</td>
      <td>Returns the base engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::discard</td>
      <td>Advances the internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;independent_bits_engine objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::independent_bits_engine::seed</td>
      <td>Re-initializes the state of the base engine, by calling its seed member function with the same argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine</td>
      <td>Pseudo-random number generator engine that produces unsigned integer numbers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::linear_congruential_engine</td>
      <td>Constructs the engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::discard</td>
      <td>Advances the internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;linear_congruential_engine objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::linear_congruential_engine::seed</td>
      <td>Re-initializes the internal state value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution</td>
      <td>Random number distribution that produces floating-point values according to a lognormal distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::lognormal_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::m</td>
      <td>Returns the parameter m</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;lognormal distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::lognormal_distribution::s</td>
      <td>Returns the parameter s</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine</td>
      <td>Pseudo-random number generator engine that produces unsigned integer numbers in the closed interval [0.2^w-1]</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::mersenne_twister_engine</td>
      <td>Constructs the engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::discard</td>
      <td>Advances the internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;mersenne_twister_engine objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::mersenne_twister_engine::seed</td>
      <td>Re-initializes the internal state value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution</td>
      <td>Random number distribution that produces integers according to a negative binomial discrete distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::negative_binomial_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::k</td>
      <td>Returns the parameter k</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp; binomial distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::p</td>
      <td>Returns the parameter p</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::negative_binomial_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution</td>
      <td>Random number distribution that produces floating-point values according to a normal distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::normal_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::mean</td>
      <td>Returns the distribution mean</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;normal distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::normal_distribution::stddev</td>
      <td>Returns the standard deviation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution</td>
      <td>Random number distribution that produces floating-point values that are uniformly distributed over each of a sequence of contiguous subintervals, as defined by the probability density function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::piecewise_constant_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::densities</td>
      <td>Returns a vector with the probability densities of each of the distribution subintervals</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::intervals</td>
      <td>Returns a vector with the subinterval bounds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;piecewise_constant_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_constant_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution</td>
      <td>Random number distribution that produces floating-point values that are distributed over a sequence of contiguous subintervals</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::piecewise_linear_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::densities</td>
      <td>
        <p>Returns a vector with the probability densities of each of the distribution subintervals</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::intervals</td>
      <td>Returns a vector with the subinterval bounds</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;piecewise_linear_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::piecewise_linear_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution</td>
      <td>Random number distribution that produces integers according to a Poisson distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::poisson_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::mean</td>
      <td>Returns the distribution mean</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;poisson_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::poisson_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.17.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.17.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device::random_device</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.17.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device::entropy</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.17.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device::max</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.17.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device::min</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::random_device::operator()</td>
      <td>
        <br />
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::seed_seq</td>
      <td>Consumes a sequence of integer-valued data and produces a requested number of unsigned integer values, based on the consumed data</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::seed_seq::seed_seq</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::seed_seq::generate</td>
      <td>Calculates the bias-eliminated, evenly distributed 32-bit values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::seed_seq::param</td>
      <td>Obtains the 32-bit values stored in std::seed_seq</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::seed_seq::size</td>
      <td>Returns the number of 32-bit values stored in std::seed_seq&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine</td>
      <td>Engine adaptor that adapts a pseudo-random number generator so that the numbers are delivered in a different sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::shuffle_order_engine</td>
      <td>Constructs the adaptor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::base</td>
      <td>Returns the base engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::discard</td>
      <td>Advances the internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;shuffle_order_engine objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::shuffle_order_engine::seed</td>
      <td>Re-initializes the state of the base engine</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution</td>
      <td>Random number distribution that produces floating-point values according to a Student T-distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::student_t_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::n</td>
      <td>Returns the degrees of freedom</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;student_t_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::student_t_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine</td>
      <td>Pseudo-random number generator engine that produces unsigned integer numbers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::subtract_with_carry_engine</td>
      <td>Constructs the generator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::discard</td>
      <td>Advances the internal state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;subtract_with_carry_engine generators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::subtract_with_carry_engine::seed</td>
      <td>Re-initializes the internal state sequence to pseudo-random values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution</td>
      <td>Random number distribution that produces integer values according to a uniform discrete distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::uniform_int_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::a</td>
      <td>Lower bound of the range&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::b</td>
      <td>Upper bound of the range&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;uniform_int_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_int_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution</td>
      <td>Random number distribution that produces floating-point values according to a uniform distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::uniform_real_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::a</td>
      <td>Lower bound of the range&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::b</td>
      <td>Upper bound of the range&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;uniform_real_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::uniform_real_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution</td>
      <td>Random number distribution that produces floating-point values according to a 2-parameter Weibull distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::weibull_distribution</td>
      <td>Constructs the distribution</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::a</td>
      <td>Returns the parameter a</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::b</td>
      <td>Returns the parameter b</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::max</td>
      <td>Maximum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::min</td>
      <td>Minimum value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::operator()</td>
      <td>Generates random number</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two&nbsp;weibull_distribution distributions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&gt;&gt;</td>
      <td>
        <p>Extracts from input stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::operator&lt;&lt;</td>
      <td>
        <p>Inserts into output stream</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::param</td>
      <td>
        <p>Returns the distribution parameters</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>random</td>
      <td>std::weibull_distribution::reset</td>
      <td>
        <p>Resets the distribution</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio</td>
      <td>Represent a finite rational number denoted by a numerator and a denominator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_add</td>
      <td>Adds two ratio objects at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_divide</td>
      <td>Divides two ratio objects at compile-time&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_equal</td>
      <td>Compares two ratio objects for equality at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_greater</td>
      <td>Compares two ratio objects for greater than at compile-time&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_greater_equal</td>
      <td>Compares two ratio objects for greater than or equal to at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_less</td>
      <td>Compares two ratio objects for less than at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_less_equal</td>
      <td>Compares two ratio objects for less than or equal to at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_multiply</td>
      <td>Multiplies two ratio objects at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_not_equal</td>
      <td>Compares two ratio objects for inequality at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>ratio</td>
      <td>std::ratio_subtract</td>
      <td>Subtracts two ratio objects at compile-time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex</td>
      <td>Provides a general framework for holding regular expressions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::basic_regex</td>
      <td>Constructs the regex object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::~basic_regex</td>
      <td>Destructs the regex object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::operator=</td>
      <td>Assigns the contents of the regex object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::assign</td>
      <td>Assigns the contents of the regex object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::mark_count</td>
      <td>Returns the number of marked sub-expressions within the regular expression</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::flags</td>
      <td>Returns the syntax flags</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::imbue</td>
      <td>Sets locale information</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::getloc</td>
      <td>Returns the locale information</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::basic_regex::swap</td>
      <td>Swaps the contents of two regex objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_constants</td>
      <td>Namespace that declares three bitmask types used with elements of the regex library along with constant values of these types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_constants::syntax_option_type</td>
      <td>Type for the general options controlling regex behavior</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_constants::match_flag_type</td>
      <td>Type of the options specific to matching</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_constants::error_type</td>
      <td>Describes different types of matching errors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_error</td>
      <td>Defines the type of exception object thrown to report errors in the regular expressions library</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_error::regex_error</td>
      <td>Constructs the regex_error object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_error::code</td>
      <td>Gets the std::regex_constants::error_type for a regex_error</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_error::what</td>
      <td>Returns an explanatory string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits</td>
      <td>Supplies std::basic_regex with the set of types and functions necessary to operate on a particular character type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::regex_traits</td>
      <td>Constructs the regex_traits object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::length</td>
      <td>Calculates the length of a null-terminated character string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::translate</td>
      <td>Determines the equivalence key for a character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::translate_nocase</td>
      <td>Determines the case-insensitive equivalence key for a character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::transform</td>
      <td>Determines the sort key for the given string, used to provide collation order</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::transform_primary</td>
      <td>Determines the primary sort key for the character sequence, used to determine equivalence class</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::lookup_collatename</td>
      <td>Returns a collation element by name</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::lookup_classname</td>
      <td>Returns a character class by name</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::isctype</td>
      <td>Indicates membership in a localized character class</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::value</td>
      <td>Translates the character representing a numeric digit into an integral value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::imbue</td>
      <td>Sets the locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_traits::getloc</td>
      <td>Returns the locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match</td>
      <td>Used by the regular expression engine to denote sequences of characters matched by marked sub-expressions</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match::sub_match</td>
      <td>Constructs the match object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match::length</td>
      <td>Returns the length of the match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match::string_type</td>
      <td>Type of string for the characters type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match::str</td>
      <td>Converts to the underlying string type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::sub_match::compare</td>
      <td>Compares the matched subsequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>operator==</p>
        <p>operator!=</p>
        <p>operator&gt;</p>
        <p>operator&gt;=</p>
        <p>operator&lt;</p>
        <p>operator&lt;=</p>
      </td>
      <td>Compares two sub_match objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>operator&lt;&lt;</td>
      <td>Outputs the matched character subsequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results</td>
      <td>Holds a collection of character sequences that represent the result of a regular expression match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::match_result</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::ready</td>
      <td>Checks if the results are available</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::size</td>
      <td>Returns the number of matches in a fully-established result state</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::max_size</td>
      <td>Returns the maximum possible number of sub-matches</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::empty</td>
      <td>Checks whether the match was successful</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::length</td>
      <td>Returns the length of the particular sub-match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::position</td>
      <td>Returns the position of the first character of the particular sub-match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::str</td>
      <td>Returns the sequence of characters for the particular sub-match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::operator[]</td>
      <td>Returns the specified sub-match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::prefix</td>
      <td>Returns sub-sequence between the beginning of the target sequence and the beginning of the full match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::suffix</td>
      <td>Returns sub-sequence between the end of the full match and the end of the target sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::begin</td>
      <td>Returns an iterator to the beginning of the list of sub-matches</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::end</td>
      <td>Returns an iterator to the end of the list of sub-matches</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::cbegin</td>
      <td>Returns a const iterator to the beginning of the list of sub-matches</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::cend</td>
      <td>Returns a const iterator to the end of the list of sub-matches</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::format</td>
      <td>Formats match results for output</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::match_results::swap</td>
      <td>Swaps the contents with another std::match_results object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::swap</td>
      <td>Swaps the contents of two std::match_results or std::basic_regex objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>operator==</p>
        <p>operator!=</p>
      </td>
      <td>Lexicographically compares the values in the two match result</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_match</td>
      <td>Returns whether the target sequence matches the regular expression</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_search</td>
      <td>Returns whether some sub-sequence in the target sequence matches the regular expression</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_replace</td>
      <td>Makes a copy of the target sequence with all matches of the regular expression replaced by the given replacement string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_iterator</td>
      <td>Forward iterator that accesses the individual matches of a regular expression within the underlying character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_iterator::regex_iterator</td>
      <td>Constructs the regex_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>std::regex_iterator::operator==</p>
        <p>std::regex_iterator::operator!=</p>
      </td>
      <td>Compares two regex_iterators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>std::regex_iterator::operator*</p>
        <p>std::regex_iterator::operator-&gt;</p>
      </td>
      <td>Accesses the current match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_iterator::operator++</td>
      <td>Advances the iterator to the next match</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_token_iterator</td>
      <td>Forward iterator that accesses the individual sub-matches of every match of a regular expression within the underlying character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_token_iterator::regex_token_iterator</td>
      <td>Constructs the regex_token_iterator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>std::regex_token_iterator::operator==</p>
        <p>std::regex_token_iterator::operator!=</p>
      </td>
      <td>Compares two regex_token_iterators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>
        <p>std::regex_token_iterator::operator*</p>
        <p>std::regex_token_iterator::operator-&gt;</p>
      </td>
      <td>Accesses the current submatch</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>regex</td>
      <td>std::regex_token_iterator::operator++</td>
      <td>Advances the iterator to the next submatch</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor</td>
      <td>Allocator for use with multilevel containers&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::scoped_allocator_adaptor</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::allocate</td>
      <td>Allocates uninitialized storage using the outer allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::construct</td>
      <td>Constructs an object in allocated storage, passing the inner allocator to its constructor if appropriate</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::deallocate</td>
      <td>Deallocates storage using the outer allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::destroy</td>
      <td>Destructs an object in the allocated storage&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::inner_allocator</td>
      <td>Returns the inner_allocator reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::max_size</td>
      <td>Returns the largest allocation size supported by the outer allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::operator=</td>
      <td>Assigns a scoped_allocator_adaptor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares two scoped_allocator_adaptor instances&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::outer_allocator</td>
      <td>Returns the outer_allocator reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>scoped_allocator</td>
      <td>std::scoped_allocator_adaptor::select_on_container_copy_construction</td>
      <td>Copies the state of scoped_allocator_adaptor and all its allocators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set</td>
      <td>Associative container that contains a sorted set of unique objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::set</td>
      <td>Constructs the set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::~set</td>
      <td>Destructs the set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::end</td>
      <td>Returns an iterator to the end&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::cbegin</td>
      <td>R eturns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::cend</td>
      <td>R eturns a const iterator to the end&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::count</td>
      <td>Returns the number of elements matching specific key&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>set</td>
      <td>std::set::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>set</td>
      <td>std::set::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::empty</td>
      <td>Checks whether the container is empty&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::find</td>
      <td>Finds element with a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::get_allocator</td>
      <td>Returns the associated allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::key_comp</td>
      <td>Returns the function that compares keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::lower_bound</td>
      <td>Returns an iterator to the first element not less than the given key&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::max_size</td>
      <td>Returns the maximum possible number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::operator=</td>
      <td>Assigns values to the container&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::rbegin</td>
      <td>
        <p>Returns a reverse iterator to the beginning</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::rend</td>
      <td>Returns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::crbegin</td>
      <td>
        <p>Returns a const reverse iterator to the beginning</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::crend</td>
      <td>Returns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::size</td>
      <td>Returns the number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::swap</td>
      <td>Swaps the contents with another std::set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::upper_bound</td>
      <td>Returns an iterator to the first element greater than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::set::value_comp</td>
      <td>Returns the function that compares keys in objects of type value_type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset</td>
      <td>Associative container that contains a sorted set of objects. Key duplicates are allowed</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::multiset</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::~multiset</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::operator=</td>
      <td>Assigns values to the container&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::get_allocator</td>
      <td>Returns the associated allocator&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::rbegin</td>
      <td>
        <p>Returns a reverse iterator to the beginning</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::rend</td>
      <td>
        <p>Returns a reverse iterator to the end</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::crbegin</td>
      <td>
        <p>Returns a const reverse iterator to the beginning</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::crend</td>
      <td>Returns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::empty</td>
      <td>Checks whether the container is empty&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::size</td>
      <td>Returns the number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::max_size</td>
      <td>Returns the maximum possible number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>set</td>
      <td>std::multiset::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>set</td>
      <td>std::multiset::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::swap</td>
      <td>Swaps the contents with another std::multiset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::key_comp</td>
      <td>Returns the function that compares keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::value_comp</td>
      <td>Returns the function that compares keys in objects of type value_type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::find</td>
      <td>Finds element with a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::count</td>
      <td>Returns the number of elements matching the specific key&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::lower_bound</td>
      <td>Returns an iterator to the first element not less than the given key&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::upper_bound</td>
      <td>Returns an iterator to the first element greater than the given key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::multiset::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the multiset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>set</td>
      <td>std::swap</td>
      <td>Swaps the contents of two std::sets or std::multisets</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock</td>
      <td>Owns shared mutex allowing deferred locking, timed locking and transfer of lock ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::shared_lock</td>
      <td>Constructs lock object, optionally locking suplied mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::~shared_lock</td>
      <td>Unlocks associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::operator=</td>
      <td>Unlocks associated mutex and acquires ownership of another</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::lock</td>
      <td>Locks associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::try_lock</td>
      <td>Tries to lock associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::try_lock_for</td>
      <td>Tries to lock associated mutex for specified timeout duration</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::try_lock_until</td>
      <td>Tries to lock associated mutex until specified time point</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::unlock</td>
      <td>Unlock associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::mutex</td>
      <td>Returns associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::owns_lock</td>
      <td>Tells if lock owns associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::operator bool</td>
      <td>Tells if lock owns associated mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::release</td>
      <td>Releases ownershim of mutex without unlocking it</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_lock::swap</td>
      <td>Swaps lock contents with another shared_lock object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::swap</td>
      <td>Swaps contenst of two shared_lock objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex</td>
      <td>Mutex class with support for ownership shared by multiple threads</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::shared_mutex</td>
      <td>Constructs mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::~shared_mutex</td>
      <td>Destructs mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::lock</td>
      <td>Locks mutex if not locked yet</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::try_lock</td>
      <td>Tries to lock mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::lock_shared</td>
      <td>Locks mutex for shared ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::try_lock_shared</td>
      <td>Tries to lock mutex for shared ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::unlock</td>
      <td>Unlocks mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++17</td>
      <td>shared_mutex</td>
      <td>std::shared_mutex::unlock_shared</td>
      <td>Unlocks mutex with shared ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex</td>
      <td>Mutex class with support for ownership shared by multiple threads. Supports timeouts for attempts to acquire lock</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::shared_timed_mutex</td>
      <td>Constructs mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::~shared_timed_mutex</td>
      <td>Destructs mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::lock</td>
      <td>Locks mutex if not locked yet</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock</td>
      <td>Tries to lock mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock_for</td>
      <td>Tries to lock mutex for specified timeout duration</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock_until</td>
      <td>Tries to lock mutex until specified time point</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::lock_shared</td>
      <td>Locks mutex for shared ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock_shared</td>
      <td>Tries to lock mutex for shared ownership</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock_shared_for</td>
      <td>Tries to lock mutex for shared ownership for specified timeout duration</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::try_lock_shared_until</td>
      <td>Tries to lock mutex for shared ownership until specified time point</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::unlock</td>
      <td>Unlocks mutex</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++14</td>
      <td>shared_mutex</td>
      <td>std::shared_timed_mutex::unlock_shared</td>
      <td>Unlocks mutex with shared ownership</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringbuf</td>
      <td>Stream buffer to read from and write to basic_string objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringbuf::basic_stringbuf</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>sstream</td>
      <td>std::basic_stringbuf::operator=</td>
      <td>Moves the string stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringbuf::swap</td>
      <td>Swaps two basic_stringbuf objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringbuf::str</td>
      <td>Replaces or obtains a copy of the associated character string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_istringstream</td>
      <td>Input stream class to operate on strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_istringstream::basic_istringstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>sstream</td>
      <td>std::basic_istringstream::operator=</td>
      <td>Moves the string stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_istringstream::rdbuf</td>
      <td>Returns pointer to the underlying raw string device object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_istringstream::swap</td>
      <td>Swaps two basic_istringstream objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_istringstream::str</td>
      <td>Replaces or obtains a copy of the associated character string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_ostringstream</td>
      <td>Output stream class to operate on strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_ostringstream::basic_ostringstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>sstream</td>
      <td>std::basic_ostringstream::operator=</td>
      <td>Moves the string stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_ostringstream::rdbuf</td>
      <td>Returns the underlying raw string device object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_ostringstream::swap</td>
      <td>Swaps two basic_ostringstream objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_ostringstream::str</td>
      <td>Gets or sets the contents of underlying string device object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringstream</td>
      <td>Implements input/output operations on memory (std::basic_string) based streams</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>sstream</td>
      <td>std::basic_stringstream::operator=</td>
      <td>Moves the string stream</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringstream::swap</td>
      <td>Swaps two basic_stringstream objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringstream::rdbuf</td>
      <td>Returns the underlying raw string device object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::basic_stringstream::str</td>
      <td>Gets or sets the contents of underlying string device object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>sstream</td>
      <td>std::swap</td>
      <td>Swaps the contents of two basic_stringbuf, basic_ostringstream, basic_ostringstream or  basic_stringstream  objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack</td>
      <td>Stack container adapter</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::stack</td>
      <td>Constructs the stack</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::~stack</td>
      <td>Destructs the stack</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>stack</td>
      <td>std::stack::emplace</td>
      <td>Constructs an element in-place at the top</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::empty</td>
      <td>Checks whether the underlying container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::operator=</td>
      <td>Assigns values to the container adaptor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the stack</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::pop</td>
      <td>Removes the top element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::push</td>
      <td>Inserts element at the top</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::swap</td>
      <td>Swaps the contents with another stack</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::swap</td>
      <td>Swaps the contents of two stacks</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::stack::top</td>
      <td>Accesses the top element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stack</td>
      <td>std::uses_allocator</td>
      <td>Specializes the std::uses_allocator type trait for std::stack</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::logic_error</td>
      <td>Exception thrown to report faulty logic within the program</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::domain_error</td>
      <td>Exception thrown to report the inputs that are outside of the domain on which an operation is defined</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::invalid_argument</td>
      <td>Exception thrown to report errors that arise because an argument value has not been accepted</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::length_error</td>
      <td>Exception thrown to report errors that are consequence of attempt to exceed implementation defined length limits for some object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::out_of_range</td>
      <td>Exception thrown to report errors that are consequence of attempt to access elements out of defined range</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::runtime_error</td>
      <td>Exception thrown to report errors that are due to events beyond the scope of the program</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::range_error</td>
      <td>Exception thrown to report report range errors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::overflow_error</td>
      <td>Exception thrown to report report arithmetic overflow errors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>stdexcept</td>
      <td>std::underflow_error</td>
      <td>Exception thrown to report arithmetic underflow errors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf</td>
      <td>Controls input and output to a character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::basic_streambuf</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::getloc</td>
      <td>Returns a copy of the associated locale</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::pubimbue</td>
      <td>Changes the associated local</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::pubsetbuf</td>
      <td>Invokes setbuf()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::pubseekoff</td>
      <td>Invokes seekoff()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::pubseekpos</td>
      <td>Invokes seekpos()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::pubsync</td>
      <td>Invokes sync()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::in_avail</td>
      <td>Returns the number of characters immediately available in the get area</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::snextc</td>
      <td>Advances the input sequence, then reads one character without advancing again</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sbumpc</td>
      <td>Reads one character from the input sequence and advances the sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sgetc</td>
      <td>Reads one character from the input sequence without advancing the sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sgetn</td>
      <td>Invokes xsgetn()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sputbackc</td>
      <td>Puts one character back in the input sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sungetc</td>
      <td>Moves the next pointer in the input sequence back by one</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sputc</td>
      <td>Writes one character to the put area and advances the next pointer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::basic_streambuf::sputn</td>
      <td>Invokes xsputn()</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::streambuf</td>
      <td>std::basic_streambuf&lt;char&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>streambuf</td>
      <td>std::wstreambuf</td>
      <td>std::basic_streambuf&lt;wchar_t&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stod</td>
      <td>Converts a string to double</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stof</td>
      <td>Converts a string to float</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stoi</td>
      <td>Converts a string to integer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stol</td>
      <td>Converts a string to long integer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stold</td>
      <td>Converts a string to long double</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stoll</td>
      <td>Converts a string to double</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stoul</td>
      <td>Converts a string to unsigned long</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::stoull</td>
      <td>Converts a string to unsigned long long</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::to_string</td>
      <td>Converts a numeric value to std::string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::to_wstring</td>
      <td>Converts a numeric value to std::wstring</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string</td>
      <td>Stores and manipulates sequences of char-like objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::basic_string</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::~basic_string</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::append</td>
      <td>Appends characters to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::assign</td>
      <td>Assigns characters to the string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::at</td>
      <td>Accesses the specified character with bounds checking</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::back</td>
      <td>Accesses the last character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::rbegin</td>
      <td>Returns a reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::rend</td>
      <td>Returns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::crbegin</td>
      <td>Returns a const reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::crend</td>
      <td>Returns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::capacity</td>
      <td>Returns the number of characters that can be held in currently allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::clear</td>
      <td>Empties the string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::compare</td>
      <td>Compares two strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::copy</td>
      <td>Copies the characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::c_str</td>
      <td>Returns a non-modifiable standard C character array version of the string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::data</td>
      <td>Returns a pointer to the first character of a string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::empty</td>
      <td>Checks whether the string is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::erase</td>
      <td>Removes characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::find</td>
      <td>Finds characters in the string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::find_first_not_of</td>
      <td>Finds the first character equal to none of the characters in the given character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::find_first_of</td>
      <td>Finds the first character equal to one of the characters in the given character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::find_last_not_of</td>
      <td>Finds the last character equal to none of the characters in the given character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::find_last_of</td>
      <td>Finds the last character equal to one of characters in the given character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::front</td>
      <td>Accesses the first character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::getline</td>
      <td>Reads data from an I/O stream into a string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::insert</td>
      <td>Inserts characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::length</td>
      <td>Returns the number of characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::max_size</td>
      <td>Returns the maximum number of characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::operator=</td>
      <td>Assigns values to the string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::operator[]</td>
      <td>Accesses the specified character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares two strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>
        <p>std::operator&gt;&gt;</p>
        <p>std::operator&lt;&lt;</p>
      </td>
      <td>Performs stream input and output on strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::operator+</td>
      <td>Concatenates two strings or a string and a char</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::operator+=</td>
      <td>Appends characters to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::pop_back</td>
      <td>Removes the last character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::push_back</td>
      <td>Appends a character to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::replace</td>
      <td>Replaces the specified portion of a string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::reserve</td>
      <td>Reserves storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::resize</td>
      <td>Changes the number of characters stored</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::rfind</td>
      <td>Finds the last occurrence of a substring</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::shrink_to_fit</td>
      <td>Reduces memory usage by freeing unused memory</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::size</td>
      <td>Returns the number of characters</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::substr</td>
      <td>Returns a substring</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::basic_string::swap</td>
      <td>Swaps the contents with another string</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::swap</td>
      <td>Swaps the contents of two strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits</td>
      <td>Traits class template that abstracts basic character and string operations for a given character type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::assign</td>
      <td>Assigns a character</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::compare</td>
      <td>Lexicographically compares two character sequences</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::copy</td>
      <td>Copies a character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::eof</td>
      <td>Returns an eof value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::eq</td>
      <td>Compares two characters for equality</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::eq_int_type</td>
      <td>Compares two int_type values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::find</td>
      <td>Finds a character in a character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::length</td>
      <td>Returns the length of a character sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::lt</td>
      <td>Returns whether one character goes before another character when ordered</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::move</td>
      <td>Moves one character sequence onto another</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::not_eof</td>
      <td>Checks whether a character is eof value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::to_char_type</td>
      <td>Converts int_type to equivalent char_type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::char_traits::to_int_type</td>
      <td>Converts char_type to equivalent int_type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>string</td>
      <td>operator &quot;&quot; s</td>
      <td>Forms a string literal of the desired type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::string</td>
      <td>std::basic_string&lt;char&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::wstring</td>
      <td>std::basic_string&lt;wchar_t&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::u16string</td>
      <td>std::basic_string&lt;char16_t&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::u32string</td>
      <td>std::basic_string&lt;char32_t&gt; typedef</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::hash</td>
      <td>Hash support for strings</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::istrstream</td>
      <td>Implements character array input operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::istrstream::istrstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::istrstream::rdbuf</td>
      <td>Obtains a pointer to the associated strstreambuf</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::istrstream::str</td>
      <td>Accesses the output buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::istrstream::swap</td>
      <td>Swaps contents with another std::istrstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>string</td>
      <td>std::istrstream::operator=</td>
      <td>Move-assigns the istrstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::ostrstream</td>
      <td>Implements character array output operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>string</td>
      <td>std::ostrstream::ostrstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::ostrstream::rdbuf</td>
      <td>Obtains a pointer to the associated strstreambuf</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::ostrstream::str</td>
      <td>Accesses the output buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::ostrstream::swap</td>
      <td>Swaps contents with another std::ostrstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>strstream</td>
      <td>std::ostrstream::operator=</td>
      <td>Move-assigns the ostrstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream</td>
      <td>Implements character array input/output operations</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::strstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::rdbuf</td>
      <td>Obtains a pointer to the associated strstreambuf</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::str</td>
      <td>Accesses the output buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::freeze</td>
      <td>Disables/enables automatic reallocation</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::pcount</td>
      <td>Obtains the number of characters written</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstream::swap</td>
      <td>Swaps contents with another std::strstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>strstream</td>
      <td>std::strstream::operator=</td>
      <td>Move-assigns the strstream object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf</td>
      <td>std::basic_streambuf whose associated character sequence is a character array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf::strstreambuf</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf::freeze</td>
      <td>Sets/clears the frozen state of the buffer</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>strstream</td>
      <td>std::strstreambuf::operator=</td>
      <td>Move-assign the strstreambuf object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf::pcount</td>
      <td>Returns the next pointer minus the beginning pointer in the output sequence: the number of characters written</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf::str</td>
      <td>Marks the buffer frozen and returns the beginning pointer of the input sequence</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>strstream</td>
      <td>std::strstreambuf::swap</td>
      <td>Swaps contents with another std::strstreambuf object</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::system_error</td>
      <td>Exception thrown by various library functions when the exception has an associated std::error_code, which may be reported</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::error_category</td>
      <td>Base class for specific error category types</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::error_condition</td>
      <td>Holds a portable error code</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::generic_category</td>
      <td>Identifies the generic error category</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::hash</td>
      <td>Hash support for std::error_code</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::system_category</td>
      <td>Identifies the operating system error category</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::error_code</td>
      <td>Holds a platform-dependent error code</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::errc</td>
      <td>Enum class type defines the error conditions of the generic category</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::is_error_code_enum</td>
      <td>Informs other library components that values of type std::io_errc are enumerations that hold error codes</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::is_error_condition_enum</td>
      <td>Identifies whether a particular type is an error condition enum type</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::make_error_code</td>
      <td>Constructs an std::error_code object from a value of type std::io_errc</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>std::make_error_condition</td>
      <td>Creates an error condition for an errc value</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>
        <p>operator==</p>
        <p>operator!=</p>
        <p>operator&lt;</p>
      </td>
      <td>Compares error_conditions and error_codes</td>
    </tr>
    <tr>
      <td>0.15.0</td>
      <td>C++11</td>
      <td>system_error</td>
      <td>operator&lt;&lt;</td>
      <td>Outputs the value and the category name to an output stream</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::this_thread</td>
      <td>Provides functions that access the current the thread of execution</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::this_thread::get_id</td>
      <td>Returns the thread id of the current thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::this_thread::sleep_for</td>
      <td>Stops the execution of the current thread for a specified time duration</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::this_thread::sleep_until</td>
      <td>Stops the execution of the current thread until a specified time point</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::this_thread::yield</td>
      <td>Suggests that the implementation reschedule execution of threads</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread</td>
      <td>
        <p>Manages a separate thread.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for all allocations are done in the parent thread only and exceptions in the constructor, if any, are properly handled and do not leak memory.</p>
        <p>
          <br />
        </p>
        <p>The current&nbsp;std::thread::detach()&nbsp;implementation has a thread descriptor stored in a pool to handle a correct thread destruction. That descriptor is 32 bytes long, and the pool could&nbsp;grow as large as the number of concurrently live std::thread objects, reusing the freed objects&nbsp;when needed. The memory allocated for that pool is controlled by&nbsp;libc++&nbsp;and&nbsp;gets released by the system when the process ends.</p>
        <p>This could trigger false positive memory leak reporting by various memory leak checkers.</p>
      </td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::thread</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::~thread</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.14.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::detach</td>
      <td>Permits the thread to execute independently from the thread handle</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::get_id</td>
      <td>Returns the id of the thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::hardware_concurrency</td>
      <td>Returns the number of concurrent threads supported by the implementation</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::id</td>
      <td>Represents the id of a thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::join</td>
      <td>Waits for a thread to finish its execution</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::joinable</td>
      <td>Checks whether the thread is joinable, i.e. potentially running in parallel context</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::native_handle</td>
      <td>Returns the underlying implementation-defined thread handle</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::operator=</td>
      <td>Moves the thread object</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::thread::swap</td>
      <td>Swaps the thread with another thread</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::swap</td>
      <td>Swaps two thread objects</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>std::hash</td>
      <td>Hash support for thread::id</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>operator== operator!= operator&lt; operator&lt;= operator&gt; operator&gt;=</td>
      <td>Compares two thread::id objects</td>
    </tr>
    <tr>
      <td>0.13.0</td>
      <td>C++11</td>
      <td>thread</td>
      <td>operator&lt;&lt;</td>
      <td>Serializes a thread::id object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple</td>
      <td>Fixed-size collection of heterogeneous values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple::tuple</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::forward_as_tuple</td>
      <td>Creates a tuple of rvalue references</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::get</td>
      <td>Accesses a tuple element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the tuple</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::ignore</td>
      <td>Placeholder to skip an element when unpacking a tuple using tie</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple::operator=</td>
      <td>Assigns the contents of one tuple to another</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::make_tuple</td>
      <td>Creates a tuple object of the type defined by the argument types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple::swap</td>
      <td>Swaps the contents of the tuple with another tuple</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::swap</td>
      <td>Swaps the contents of two tuples</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tie</td>
      <td>Creates a tuple of lvalue references or unpacks a tuple into individual objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple_cat</td>
      <td>Creates a tuple by concatenating any number of tuples</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple_size</td>
      <td>Obtains the size of tuple at compile time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::tuple_element</td>
      <td>Obtains the type of the specified element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>tuple</td>
      <td>std::uses_allocator</td>
      <td>Specializes the std::uses_allocator type trait</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::type_index</td>
      <td>Wrapper class around a std::type_info object, that can be used as index in associative and unordered associative containers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::type_index::type_index</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::type_index::operator=</td>
      <td>Assigns a type_index object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>
        <p>std::type_index::operator==</p>
        <p>std::type_index::operator!=</p>
        <p>std::type_index::operator&gt;</p>
        <p>std::type_index::operator&gt;=</p>
        <p>std::type_index::operator&lt;</p>
        <p>std::type_index::operator&lt;=</p>
      </td>
      <td>Compares the underlying std::type_info objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::type_index::hash_code</td>
      <td>Returns the hash code of the associated std::type_info object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::type_index::name</td>
      <td>Returns implementation defined name of the type, associated with underlying type_info object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeindex</td>
      <td>std::hash</td>
      <td>Hash support for std::type_index</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::bad_cast</td>
      <td>Exception thrown when a dynamic_cast to a reference type fails the run-time check</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::bad_typeid</td>
      <td>Exception &nbsp;thrown when a typeid operator is applied to a dereferenced null pointer value of a polymorphic type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::type_info</td>
      <td>Holds implementation-specific information about a type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::type_info::type_info</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::type_info::~type_info</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::type_info::before</td>
      <td>
        <p>Checks whether the referred type precedes referred type of another type_index object in the implementation defined order</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>typeinfo</td>
      <td>std::type_info::hash_code</td>
      <td>Returns a value which is identical for the same types&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>std::type_info::name</td>
      <td>Returns implementation defined name of the type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>typeinfo</td>
      <td>
        <p>std::type_info::operator==</p>
        <p>std::type_info::operator!=</p>
      </td>
      <td>Checks whether the objects refer to the same type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_const</td>
      <td>Adds the const specifier to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_cv</td>
      <td>A dds the const volatile specifier to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_lvalue_reference</td>
      <td>Adds lvalue reference to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_pointer</td>
      <td>Adds pointer to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_rvalue_reference</td>
      <td>Adds rvalue reference to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::add_volatile</td>
      <td>A dds the volatile specifier to the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::aligned_storage</td>
      <td>Defines the type suitable for use as uninitialized storage for types of given size&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::aligned_union</td>
      <td>Defines the type suitable for use as uninitialized storage for all given types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::alignment_of</td>
      <td>Obtains the type's alignment requirement</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::common_type</td>
      <td>Deduces the result type of a mixed-mode arithmetic expression&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::conditional</td>
      <td>Chooses one type or another based on compile-type boolean&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::decay</td>
      <td>Applies type transformations as when passing a function argument by value&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::enable_if</td>
      <td>Hides a function overload or template specialization based on compile-time boolean</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::extent</td>
      <td>Obtains the size of an array type along a specified dimension&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::has_virtual_destructor</td>
      <td>Checks if a type has a virtual destructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::integral_constant</td>
      <td>Compile-time constant of specified type with specified value&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_abstract</td>
      <td>Checks if a type is an abstract class type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_arithmetic</td>
      <td>Checks if a type is an arithmetic type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_array</td>
      <td>Checks if a type is an array type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_assignable</td>
      <td>Checks if a type has a assignment operator for a specific argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_base_of</td>
      <td>Checks if a type is derived from the other type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_class</td>
      <td>Checks if a type is a non-union class type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_compound</td>
      <td>Checks if a type is compound type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_const</td>
      <td>Checks if a type is const-qualified</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_constructible</td>
      <td>Checks if a type has a constructor for specific arguments&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_convertible</td>
      <td>Checks if a type can be converted to the other type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_copy_assignable</td>
      <td>Checks if a type has a copy assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_copy_constructible</td>
      <td>Checks if a type has a copy constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_default_constructible</td>
      <td>Checks if a type has a default constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_destructible</td>
      <td>Checks if a type has a non-deleted destructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_empty</td>
      <td>Checks if a type is class (but not union) type and has no data&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_enum</td>
      <td>Checks if a type is an enumeration type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_floating_point</td>
      <td>Checks if a type is a floating-point type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_function</td>
      <td>Checks if a type is a function type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_fundamental</td>
      <td>Checks if a type is a fundamental type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_integral</td>
      <td>Checks if a type is an integral type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_literal_type</td>
      <td>Checks if a type is literal type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_lvalue_reference</td>
      <td>Checks if a type is lvalue reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_member_function_pointer</td>
      <td>
        <p>Checks if a type is a pointer to a non-static member function.</p>
        <p>Note: Due to dependencies this API has not yet been tested well for the case when no variadics are available. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_member_object_pointer</td>
      <td>Checks if a type is a pointer to a non-static member object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_member_pointer</td>
      <td>Checks if a type is a pointer to a non-static member function or object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_move_assignable</td>
      <td>Checks if a type has a move assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_move_constructible</td>
      <td>Checks if a type has a move constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_assignable</td>
      <td>Checks if a type has a assignment operator with noexcept for a specific argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_constructible</td>
      <td>Checks if a type has a nothrow constructor for specific arguments&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_copy_assignable</td>
      <td>Checks if a type has a nothrow copy assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_copy_constructible</td>
      <td>Ch ecks if a type has a nothrow copy constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_default_constructible</td>
      <td>C hecks if a type has a nothrow default constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_destructible</td>
      <td>C hecks if a type has a non-deleted nothrow destructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_move_assignable</td>
      <td>C hecks if a type has a nothrow move assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_nothrow_move_constructible</td>
      <td>C hecks if a type has a nothrow move constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>type_traits</td>
      <td>std::is_null_pointer</td>
      <td>Checks if a type is std::nullptr_t</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_object</td>
      <td>Checks if a type is an object type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_pod</td>
      <td>Checks if a type is plain-old data (POD) type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_pointer</td>
      <td>Checks if a type is a pointer type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_polymorphic</td>
      <td>Checks if a type is polymorphic class type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_reference</td>
      <td>Checks if a type is either lvalue reference or rvalue reference&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_rvalue_reference</td>
      <td>Checks if a type is rvalue reference</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_same</td>
      <td>Checks if two types are the same</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_scalar</td>
      <td>Checks if a type is scalar type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_signed</td>
      <td>Checks if a type is signed arithmetic type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_standard_layout</td>
      <td>Checks if a type is standard-layout type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivial</td>
      <td>Checks if a type is trivial&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_assignable</td>
      <td>Checks if a type has a trivial assignment operator for a specific argument</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_constructible</td>
      <td>Checks if a type has a trivial constructor for specific arguments&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_copyable</td>
      <td>Checks if a type is trivially copyable</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_copy_assignable</td>
      <td>C hecks if a type has a trivial copy assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_copy_constructible</td>
      <td>Ch ecks if a type has a trivial copy constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_default_constructible</td>
      <td>C hecks if a type has a trivial default constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_destructible</td>
      <td>C hecks if a type has a non-deleted trivial destructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_move_assignable</td>
      <td>C hecks if a type has a trivial move assignment operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_trivially_move_constructible</td>
      <td>C hecks if a type has a trivial move constructor</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_union</td>
      <td>Checks if a type is an union type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_unsigned</td>
      <td>Checks if a type is unsigned arithmetic type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_void</td>
      <td>Checks if a type is void&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::is_volatile</td>
      <td>Checks if a type is volatile-qualified&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::make_signed</td>
      <td>Makes the given integral type signed&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::make_unsigned</td>
      <td>Makes the given integral type unsigned&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::rank</td>
      <td>Obtains the number of dimensions of an array type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_all_extents</td>
      <td>Removes all extents from the given array type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_const</td>
      <td>Removes the const specifier from the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_cv</td>
      <td>R emoves the const volatile specifier from the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_extent</td>
      <td>Removes one extent from the given array type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_pointer</td>
      <td>Removes pointer from the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_reference</td>
      <td>Removes reference from the given type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::remove_volatile</td>
      <td>R emoves the volatile specifier from the given type&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::result_of</td>
      <td>Deduces the return type of a function call expression&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>type_traits</td>
      <td>std::underlying_type</td>
      <td>Obtains the underlying integer type for a given enumeration type</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map</td>
      <td>Associative container that contains key-value pairs with unique keys and has average constant-time complexity for search, insertion and removal of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::unordered_map</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::~unordered_map</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::empty</td>
      <td>Checks whether the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::begin(int)</td>
      <td>Returns an iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::end(int)</td>
      <td>Returns an iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::cbegin(int)</td>
      <td>Returns a const iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::cend(int)</td>
      <td>Returns a const iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::insert_or_assign</td>
      <td>Inserts an element or assigns to the current element if the key already exists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::swap</td>
      <td>Swap the contents with another unordered_map</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::hash_function</td>
      <td>Returns function used to hash the keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::key_eq</td>
      <td>Returns the function used to compare keys for equality</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::find</td>
      <td>Finds element with specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::count</td>
      <td>Returns the number of elements matching specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::operator[]</td>
      <td>Accesses the specified element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::at</td>
      <td>Accesses the specified element with bounds checking</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::bucket_count</td>
      <td>Returns the number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::max_bucket_count</td>
      <td>Returns the maximum number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::bucket_size</td>
      <td>Returns the number of elements in specific bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::bucket</td>
      <td>Returns the bucket for specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::load_factor</td>
      <td>Returns average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::max_load_factor</td>
      <td>Manages maximum average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::rehash</td>
      <td>Reserves at least the specified number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::reserve</td>
      <td>Reserves space for at least the specified number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_map::try_emplace</td>
      <td>Inserts in-place if the key does not exist, does nothing if the key exists</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap</td>
      <td>Associative container that contains key-value pairs with possibly non-unique keys and has average constant-time complexity for search, insertion and removal of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::unordered_multimap</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::~unordered_multimap</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::begin(int)</td>
      <td>Returns an iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::end(int)</td>
      <td>Returns an iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::bucket</td>
      <td>Returns the bucket for specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::bucket_count</td>
      <td>Returns the number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::bucket_size</td>
      <td>Returns the number of elements in specific bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::cbegin(int)</td>
      <td>Returns a const iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::cend(int)</td>
      <td>Returns a const iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::count</td>
      <td>Returns the number of elements matching specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::empty</td>
      <td>Checks whether the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::find</td>
      <td>Finds elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::hash_function</td>
      <td>Returns function used to hash the keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::key_eq</td>
      <td>Returns the function used to compare keys for equality</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::load_factor</td>
      <td>Returns average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::max_bucket_count</td>
      <td>Returns the maximum number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::max_load_factor</td>
      <td>Manages maximum average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares the values in the unordered_multimap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::rehash</td>
      <td>Reserves at least the specified number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::reserve</td>
      <td>Reserves space for at least the specified number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::unordered_multimap::swap</td>
      <td>Swaps the contents with another std::unordered_multimap</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_map</td>
      <td>std::swap</td>
      <td>Swaps the contents of two std::unordered_multimap's</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset</td>
      <td>Associative container that contains a set of possibly non-unique objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::unordered_multiset</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::~unordered_multiset</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::begin(int)</td>
      <td>Returns an iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::end(int)</td>
      <td>Returns an iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::bucket</td>
      <td>Returns the bucket for specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::bucket_count</td>
      <td>Returns the number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::bucket_size</td>
      <td>Returns the number of elements in specific bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::cbegin(int)</td>
      <td>Returns a const iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::cend(int)</td>
      <td>Returns a const iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::count</td>
      <td>Returns the number of elements matching specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::empty</td>
      <td>Checks whether the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::find</td>
      <td>Finds elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::hash_function</td>
      <td>Returns function used to hash the keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::key_eq</td>
      <td>Returns the function used to compare keys for equality</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::load_factor</td>
      <td>Returns average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::max_bucket_count</td>
      <td>Returns the maximum number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::max_load_factor</td>
      <td>Manages maximum average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
      </td>
      <td>Compares the values in the unordered_multiset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::rehash</td>
      <td>Reserves at least the specified number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::reserve</td>
      <td>Reserves space for at least the specified number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_multiset::swap</td>
      <td>Swaps the contents with another std::unordered_multiset</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::swap</td>
      <td>Swaps the contents of two std::unordered_multiset's</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set</td>
      <td>Associative container that contains a set of unique objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::unordered_set</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::~unordered_set</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::end</td>
      <td>Returns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::begin(int)</td>
      <td>Returns an iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::end(int)</td>
      <td>Returns an iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::bucket</td>
      <td>Returns the bucket for specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::bucket_count</td>
      <td>Returns the number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::bucket_size</td>
      <td>Returns the number of elements in specific bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::cbegin</td>
      <td>Returns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::cend</td>
      <td>Returns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::cbegin(int)</td>
      <td>Returns a const iterator to the beginning of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::cend(int)</td>
      <td>Returns a const iterator to the end of the specified bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::count</td>
      <td>Returns the number of elements matching specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::emplace</td>
      <td>Constructs element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::emplace_hint</td>
      <td>Constructs elements in-place using a hint</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::empty</td>
      <td>Checks whether the container is empty</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::equal_range</td>
      <td>Returns range of elements matching a specific key</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::find</td>
      <td>Finds elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::hash_function</td>
      <td>Returns function used to hash the keys</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::key_eq</td>
      <td>Returns the function used to compare keys for equality</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::load_factor</td>
      <td>Returns average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::max_bucket_count</td>
      <td>Returns the maximum number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::max_load_factor</td>
      <td>Manages maximum average number of elements per bucket</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::operator=</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>
        <p>std:::operator==</p>
        <p>std:::operator!=</p>
      </td>
      <td>Compares the values in the unordered_set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::rehash</td>
      <td>Reserves at least the specified number of buckets</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::reserve</td>
      <td>Reserves space for at least the specified number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::size</td>
      <td>Returns the number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::unordered_set::swap</td>
      <td>Swaps the contents with another std::unordered_set</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>unordered_set</td>
      <td>std::swap</td>
      <td>Swaps the contents of two std::unordered_set's</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::declval</td>
      <td>Converts a type to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::forward</td>
      <td>Forwards the argument to another function with the value category it had when passed to the calling function</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::get</td>
      <td>Accesses an element of a pair</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++14</td>
      <td>utility</td>
      <td>std::integer_sequence</td>
      <td>Implements compile-time sequence of integers</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::move</td>
      <td>Obtains an rvalue reference&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::move_if_noexcept</td>
      <td>Obtains an rvalue reference if the move constructor does not throw&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::piecewise_construct</td>
      <td>Object used to disambiguate functions for piecewise construction&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::piecewise_construct_t</td>
      <td>Tag type used to select correct function overload for piecewise construction&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::rel_ops</td>
      <td>Provides automatic comparison operators</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::swap</td>
      <td>Swaps the values of two objects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::tuple_element</td>
      <td>Accesses a field of std::pair</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::tuple_size</td>
      <td>Obtains the size of a pair at compile time</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::pair</td>
      <td>
        <p>A pair of values.</p>
        <p>Note: This API has not yet been tested well for C++98 specific assignment, nor that only the default constructor is <code>constexpr</code> in the С++11 mode. Most likely everything just works, but if your code depends on this API, you may want to perform some more testing on your own to make sure it works for you. If you do so, and will discover any issue, please report so we could fix it.</p>
      </td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::pair::pair</td>
      <td>Constructs a pair</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::pair::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>utility</td>
      <td>std::pair::swap</td>
      <td>Swaps the contents&nbsp;with another std::pair</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>std::make_pair</td>
      <td>Creates a pair object of type, defined by the argument types</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>utility</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the pair</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice</td>
      <td>Selector class that identifies a subset of std::valarray indices defined by a multi-level set of strides and sizes</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice::gslice</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice::size</td>
      <td>Returns a valarray with the number of elements in each dimension of the gslice object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice::start</td>
      <td>Returns the index of the first element in the valarray that the gslice object selects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice::stride</td>
      <td>Returns a valarray with the separation of the elements in each of the dimensions the gslice object selects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice_array</td>
      <td>Helper template used by the std::gslice subscript operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice_array::gslice_array</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::gslice_array::operator+=</p>
        <p>std::gslice_array::operator-=</p>
        <p>std::gslice_array::operator*=</p>
        <p>std::gslice_array::operator/=</p>
        <p>std::gslice_array::operator&amp;=</p>
        <p>std::gslice_array::operator|=</p>
        <p>std::gslice_array::operator^=</p>
        <p>std::gslice_array::operator&lt;&lt;=</p>
        <p>std::gslice_array::operator&gt;&gt;=</p>
        <p>std::gslice_array::operator%=</p>
      </td>
      <td>Performs an arithmetic operation on the array referred by generic slice</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::gslice_array::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::indirect_array</td>
      <td>Helper template used by the std::indirect_array subscript operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::indirect_array::indirect_array</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::indirect_array::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::indirect_array::operator+=</p>
        <p>std::indirect_array::operator-=</p>
        <p>std::indirect_array::operator*=</p>
        <p>std::indirect_array::operator/=</p>
        <p>std::indirect_array::operator&amp;=</p>
        <p>std::indirect_array::operator|=</p>
        <p>std::indirect_array::operator^=</p>
        <p>std::indirect_array::operator&lt;&lt;=</p>
        <p>std::indirect_array::operator&gt;&gt;=</p>
        <p>std::indirect_array::operator%=</p>
      </td>
      <td>Performs an arithmetic operation on the array referred by indirect array</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::mask_array</td>
      <td>Helper template used by the std::mask_array subscript operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::mask_array::mask_array</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::mask_array::operator+=</p>
        <p>std::mask_array::operator-=</p>
        <p>std::mask_array::operator*=</p>
        <p>std::mask_array::operator/=</p>
        <p>std::mask_array::operator&amp;=</p>
        <p>std::mask_array::operator|=</p>
        <p>std::mask_array::operator^=</p>
        <p>std::mask_array::operator&lt;&lt;=</p>
        <p>std::mask_array::operator&gt;&gt;=</p>
        <p>std::mask_array::operator%=</p>
      </td>
      <td>Performs arithmetic operation on the array referred by mask</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::mask_array::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice</td>
      <td>Represents a valarray slice selector</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice::slice</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice::size</td>
      <td>Returns the size of the slice</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice::start</td>
      <td>Returns the index of the first element in the valarray that the slice object selects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice::stride</td>
      <td>Returns the separation of the elements in the valarray that the slice object selects</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice_array</td>
      <td>Helper template used by std::slice subscript operator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::slice_array::slice_array</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::slice_array::operator+=</p>
        <p>std::slice_array::operator-=</p>
        <p>std::slice_array::operator*=</p>
        <p>std::slice_array::operator/=</p>
        <p>std::slice_array::operator&amp;=</p>
        <p>std::slice_array::operator|=</p>
        <p>std::slice_array::operator^=</p>
        <p>std::slice_array::operator&lt;&lt;=</p>
        <p>std::slice_array::operator&gt;&gt;=</p>
        <p>std::slice_array::operator%=</p>
      </td>
      <td>Performs arithmetic operation on the array referred by slice</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray</td>
      <td>Represents and manipulates arrays of values</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::valarray</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::~valarray</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::abs</td>
      <td>Applies the function std::abs to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::acos</td>
      <td>Applies the function std::acos to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::apply</td>
      <td>Applies a function to every element of the valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::asin</td>
      <td>Applies the function std::asin to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::atan</td>
      <td>Applies the function std::atan to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::atan2</td>
      <td>Applies the function std::atan2 to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>valarray</td>
      <td>std::begin</td>
      <td>Specializes std::begin&nbsp;for std::valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::cos</td>
      <td>Applies the function std::cos to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::cosh</td>
      <td>Applies the function std::cosh to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::cshift</td>
      <td>Circular shift of the elements of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>valarray</td>
      <td>std::end</td>
      <td>S pecializes std::end for std::valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::exp</td>
      <td>Applies the function std::exp to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::log</td>
      <td>Applies the function std::log to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::log10</td>
      <td>Applies the function std::log10 to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::max</td>
      <td>Returns the largest element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::min</td>
      <td>Returns the smallest element&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::operator+</p>
        <p>std::operator-</p>
        <p>std::operator*</p>
        <p>std::operator/</p>
        <p>std::operator%</p>
        <p>std::operator&amp;</p>
        <p>std::operator|</p>
        <p>std::operator^</p>
        <p>std::operator&gt;&gt;</p>
        <p>std::operator&lt;&lt;</p>
        <p>std::operator&amp;&amp;</p>
        <p>std::operator||</p>
      </td>
      <td>Applies binary operators to each element of two valarrays, or a valarray and a value&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::valarray::operator+=</p>
        <p>std::valarray::operator-=</p>
        <p>std::valarray::operator|=</p>
        <p>std::valarray::operator&amp;=</p>
        <p>std::valarray::operator^=</p>
        <p>std::valarray::operator/=</p>
        <p>std::valarray::operator&gt;&gt;=</p>
        <p>std::valarray::operator&lt;&lt;=</p>
        <p>std::valarray::operator*=</p>
        <p>std::valarray::operator%=</p>
      </td>
      <td>Applies compound assignment operator to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::operator=</td>
      <td>Assigns the contents</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::operator[]</td>
      <td>Gets / sets valarray element, slice, or mask&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Compares two valarrays or a valarray with a value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>
        <p>std::valarray::operator+</p>
        <p>std::valarray::operator-</p>
        <p>std::valarray::operator~</p>
        <p>std::valarray::operator!</p>
      </td>
      <td>Applies a unary arithmetic operator to each element of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::pow</td>
      <td>Applies the function std::pow to two valarrays or a valarray and a value</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::resize</td>
      <td>Changes the size of the valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::shift</td>
      <td>Returns a new valarray of the same size with elements whose positions are shifted by N elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::sin</td>
      <td>Applies the function std::sin to each element of valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::sinh</td>
      <td>A pplies the function std::sinh to each element of valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::size</td>
      <td>Returns the size of the valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::sqrt</td>
      <td>Applies the function std::sqrt to each element of valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::sum</td>
      <td>Calculates the sum of all elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::valarray::swap</td>
      <td>Swaps the contents with another valarray</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>valarray</td>
      <td>std::swap</td>
      <td>Swaps the contents of two valarrays</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::tan</td>
      <td>A pplies the function std::tan to each element of valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>valarray</td>
      <td>std::tanh</td>
      <td>A pplies the function std::tanh to each element of valarray&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector</td>
      <td>Sequence container that encapsulates dynamic size arrays</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::vector</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::~vector</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::assign</td>
      <td>Assigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::at</td>
      <td>Accesses the specified element with bounds checking&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::back</td>
      <td>Accesses the last element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::begin</td>
      <td>Returns an iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::capacity</td>
      <td>Returns the number of elements that can be held in currently allocated storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::cbegin</td>
      <td>R eturns a const iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::cend</td>
      <td>R eturns a const iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::clear</td>
      <td>Empties the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::crbegin</td>
      <td>R eturns a const reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::crend</td>
      <td>R eturns a const reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>vector</td>
      <td>std::vector::data</td>
      <td>Direct access to the underlying array&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>vector</td>
      <td>std::vector::emplace</td>
      <td>Constructs an element in-place</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>vector</td>
      <td>std::vector::emplace_back</td>
      <td>Constructs an element in-place at the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::empty</td>
      <td>Checks whether the container is empty&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::end</td>
      <td>R eturns an iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::erase</td>
      <td>Erases elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::front</td>
      <td>A ccesses the first element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::get_allocator</td>
      <td>Returns the associated allocator</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::insert</td>
      <td>Inserts elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::max_size</td>
      <td>Returns the maximum possible number of elements</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::operator=</td>
      <td>A ssigns values to the container</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::operator[]</td>
      <td>Accesses the specified element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>
        <p>std::operator==</p>
        <p>std::operator!=</p>
        <p>std::operator&gt;</p>
        <p>std::operator&gt;=</p>
        <p>std::operator&lt;</p>
        <p>std::operator&lt;=</p>
      </td>
      <td>Lexicographically compares the values in the vector</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::pop_back</td>
      <td>Removes the last element</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::push_back</td>
      <td>Adds an element to the end&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::rbegin</td>
      <td>R eturns a reverse iterator to the beginning</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::rend</td>
      <td>R eturns a reverse iterator to the end</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::reserve</td>
      <td>Reserves storage</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::resize</td>
      <td>Changes the number of elements stored</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++11</td>
      <td>vector</td>
      <td>std::vector::shrink_to_fit</td>
      <td>Reduces memory usage by freeing unused memory</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::size</td>
      <td>Returns the number of elements&nbsp;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector::swap</td>
      <td>Swaps the contents&nbsp;with another vector</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::vector&lt;bool&gt;::flip</td>
      <td>Flips all the bits</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::hash&lt;std::vector&lt;bool&gt;&gt;</td>
      <td>Hash support for std::vector&lt;bool&gt;</td>
    </tr>
    <tr>
      <td>0.10.0</td>
      <td>C++98</td>
      <td>vector</td>
      <td>std::swap</td>
      <td>S waps the contents of two vectors</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf</td>
      <td>Stream buffer to read from and write to files</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::basic_filebuf</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::~basic_filebuf</td>
      <td>Destructs the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_filebuf::operator=</td>
      <td>Move-assigns another basic_filebuf object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_filebuf::swap</td>
      <td>Swaps two basic_filebuf objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::open</td>
      <td>Opens a file and associates it with the current basic_filebuf object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::close</td>
      <td>Flushes the buffer and closes the associated file</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::is_open</td>
      <td>Tells whether the file is open</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pubimbue</td>
      <td>Associates a new locale to the stream buffer</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::getloc</td>
      <td>Returns the current locale associated with the stream buffer</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pubsetbuf</td>
      <td>Calls the protected virtual member setbuf with the same arguments</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pubseekoff</td>
      <td>Calls the protected virtual member seekoff with the same arguments</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pubseekpos</td>
      <td>Calls the protected virtual member seekpos with the same arguments</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pubsync</td>
      <td>Calls the protected virtual member sync</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::in_avail</td>
      <td>Returns the number of characters immediately available for reading</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::snextc</td>
      <td>Advances the current position of the controlled input sequence to the next character, and returns that next character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sbumpc</td>
      <td>Returns the character at the current position of the controlled input sequence, and advances the position indicator to the next character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sgetc</td>
      <td>Returns the character at the current position of the controlled input sequence, without modifying the current position</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sgetn</td>
      <td>Calls the protected virtual member xsgetn with the same arguments</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sputbackc</td>
      <td>Puts one character back in the input sequence</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sungetc</td>
      <td>Moves the current position of the input sequence back one position to the character that precedes the current one, making the character at that position available once again for the next input operation</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sputc</td>
      <td>Writes one character to the put area and advances the buffer pointer</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sputn</td>
      <td>Calls the protected virtual member xsputn with the same arguments</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::showmanyc</td>
      <td>Protected virtual function. If implemented, returns the number of characters left to read from the file.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::underflow</td>
      <td>Protected virtual function. Returns the character at the current input position, without advancing the input position pointer.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::uflow</td>
      <td>Protected virtual function. Returns the character at the current input position, and advances the input position pointer.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::pbackfail</td>
      <td>Protected virtual function. Moves the current input position on position back to point to the previous character and makes the argument available as that next character to be read</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::overflow</td>
      <td>Protected virtual function. Writes the contents of the intermediate output buffer to the associated file, followed by the character specified in the argument.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::seekoff</td>
      <td>Protected virtual function. Sets a new position for the internal position pointers.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::seekpos</td>
      <td>Protected virtual function. Sets the absolute new position for the internal position pointers.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::sync</td>
      <td>Protected virtual function. Synchronizes the intermediate buffers with the associated file.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::imbue</td>
      <td>Protected virtual function. Specifies the locale object to be used for conversions on input/output operations performed on the file stream buffer.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_filebuf::setbuf</td>
      <td>Protected virtual function. Provides user-supplied buffer or turns this filebuf unbuffered.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::swap</td>
      <td>Swaps the contents of two basic_filebuf objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::filebuf</td>
      <td>Template instantiation of std::basic_filebuf. Stream buffer to read from and write to files.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::wfilebuf</td>
      <td>Template instantiation of std::basic_filebuf. Stream buffer to read from and write to files using wide characters.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream</td>
      <td>Input stream class to operate on files</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::basic_ifstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ifstream::operator=</td>
      <td>Move-assigns another basic_ifstream object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ifstream::swap</td>
      <td>Swaps two basic_ifstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::open</td>
      <td>Opens a file and associates it with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::close</td>
      <td>Closes the file currently associated with the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::is_open</td>
      <td>Tells whether the file is open</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::rdbuf</td>
      <td>Returns a pointer to the internal std::basic_filebuf object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::operator&gt;&gt;</td>
      <td>Extracts formatted data from the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::gcount</td>
      <td>Returns the number of characters extracted by the last unformatted input operation performed on the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::get</td>
      <td>Extracts characters from the stream as unformatted input</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::getline</td>
      <td>Extracts characters from the stream as unformatted input until the given character is found</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::ignore</td>
      <td>Extracts and discards characters until the given character is found</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::peek</td>
      <td>Returns the next character in the input sequence, without extracting it</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::read</td>
      <td>Extracts n characters from the stream and stores them in the passed C array</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::readsome</td>
      <td>Extracts up to n characters available for reading from the associated stream buffer object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::putback</td>
      <td>Puts the given character back to the input stream so that it will be the next extracted character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::unget</td>
      <td>Makes the most recently extracted character available again</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::tellg</td>
      <td>Returns the position of the current character in the input stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::seekg</td>
      <td>Sets the position of the next character to be extracted from the input stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::sync</td>
      <td>Synchronizes the input buffer with the associated data source</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::good</td>
      <td>Checks whether state of stream is good</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::eof</td>
      <td>Checks whether the eofbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::fail</td>
      <td>Checks whether the failbit or the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::bad</td>
      <td>Checks whether the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::operator!</td>
      <td>Returns true if no error flag is set, and false otherwise</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ifstream::operator bool</td>
      <td>Returns whether an error flag is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::rdstate</td>
      <td>Returns the current internal error state flags of the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::setstate</td>
      <td>Modifies the current internal error state flags by combining the current flags with those in the argument</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::clear</td>
      <td>Sets a new value for the stream's internal error state flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::copyfmt</td>
      <td>Copies the formatting information from the given stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::fill</td>
      <td>Gets/sets the fill character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::exceptions</td>
      <td>Gets/sets the exceptions mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::imbue</td>
      <td>Associates a new locale to the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::getloc</td>
      <td>Returns the current locale associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::tie</td>
      <td>Gets/sets the tied stream (an output stream object which is flushed before each I/O operation in this stream object)</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::rdbuf</td>
      <td>Gets/sets the stream buffer object currently associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::narrow</td>
      <td>Returns the transformation of a wide character to its equivalent of type char</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::widen</td>
      <td>Returns the transformation of a narrow character to a wide character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::flags</td>
      <td>Gets/sets the format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::setf</td>
      <td>Sets specific format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::unsetf</td>
      <td>Clears the format flags selected in the given mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::precision</td>
      <td>Gets/sets the floating-point decimal precision</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::width</td>
      <td>Gets/sets the field width</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::xalloc</td>
      <td>Returns a program-wide unique integer that is safe to use as index to pword() and iword()</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::iword</td>
      <td>Returns a reference to the long element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::pword</td>
      <td>Returns a reference to the void* element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::register_callback</td>
      <td>Registers event callback function</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ifstream::sync_with_stdio</td>
      <td>Toggles synchronization with cstdio streams</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::swap</td>
      <td>Swaps the contents of two basic_ifstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::ifstream</td>
      <td>Template instantiation of std::basic_ifstream. Input stream class to operate on files.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::wifstream</td>
      <td>Template instantiation of std::basic_ifstream. Input stream class to operate on files using wide characters.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream</td>
      <td>Output stream class to operate on files</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::basic_ofstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::open</td>
      <td>Opens a file and associates it with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::close</td>
      <td>Closes the associated file</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::is_open</td>
      <td>Tells whether the file is open</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::rdbuf</td>
      <td>Returns a pointer to the internal std::basic_filebuf object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ofstream::operator=</td>
      <td>Move-assigns another basic_ofstream object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ofstream::swap</td>
      <td>Swaps two basic_ofstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::operator&lt;&lt;</td>
      <td>Inserts formatted data into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::put</td>
      <td>Inserts a character into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::write</td>
      <td>Inserts the characters from the given C string into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::tellp</td>
      <td>Returns the position of the current character in the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::seekp</td>
      <td>Sets the position where the next character is to be inserted into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::flush</td>
      <td>Flushes the stream buffer</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::good</td>
      <td>Checks whether state of stream is good</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::eof</td>
      <td>Checks whether the eofbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::fail</td>
      <td>Checks whether the failbit or the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::bad</td>
      <td>Checks whether the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::operator!</td>
      <td>Returns true if no error flag is set, and false otherwise</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_ofstream::operator bool</td>
      <td>Returns whether an error flag is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::rdstate</td>
      <td>Returns the current internal error state flags of the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::setstate</td>
      <td>Modifies the current internal error state flags by combining the current flags with those in the argument</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::clear</td>
      <td>Sets a new value for the stream's internal error state flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::copyfmt</td>
      <td>Copies the formatting information from the given stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::fill</td>
      <td>Gets/sets the fill character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::exceptions</td>
      <td>Gets/sets the exceptions mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::imbue</td>
      <td>Associates a new locale to the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::getloc</td>
      <td>Returns the current locale associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::tie</td>
      <td>Gets/sets the tied stream (an output stream object which is flushed before each I/O operation in this stream object)</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::rdbuf</td>
      <td>Gets/sets the stream buffer object currently associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::narrow</td>
      <td>Returns the transformation of a wide character to its equivalent of type char</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::widen</td>
      <td>Returns the transformation of a narrow character to a wide character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::flags</td>
      <td>Gets/sets the format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::setf</td>
      <td>Sets specific format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::unsetf</td>
      <td>Clears the format flags selected in the given mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::precision</td>
      <td>Gets/sets the floating-point decimal precision</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::width</td>
      <td>Gets/sets the field width</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::xalloc</td>
      <td>Returns a program-wide unique integer that is safe to use as index to pword() and iword()</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::iword</td>
      <td>Returns a reference to the long element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::pword</td>
      <td>Returns a reference to the void* element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::register_callback</td>
      <td>Registers event callback function</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_ofstream::sync_with_stdio</td>
      <td>Toggles synchronization with cstdio streams</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::swap</td>
      <td>Swaps the contents of two basic_ofstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::ofstream</td>
      <td>Template instantiation of std::basic_ofstream. Output stream class to operate on files.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::wofstream</td>
      <td>Template instantiation of std::basic_ofstream. Output stream class to operate on files using wide characters.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream</td>
      <td>Input/output stream class to operate on files</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::basic_fstream</td>
      <td>Constructs the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::open</td>
      <td>Opens a file and associates it with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::close</td>
      <td>Closes the associated file</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::is_open</td>
      <td>Tells whether the file is open</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::rdbuf</td>
      <td>Returns a pointer to the internal std::basic_filebuf object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_fstream::operator=</td>
      <td>Move-assigns another basic_fstream object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_fstream::swap</td>
      <td>Swaps two basic_fstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::operator&gt;&gt;</td>
      <td>Extracts formatted data from the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::operator&lt;&lt;</td>
      <td>Inserts formatted data into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::gcount</td>
      <td>Returns the number of characters extracted by the last unformatted input operation performed on the object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::get</td>
      <td>Extracts characters from the stream as unformatted input</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::getline</td>
      <td>Extracts characters from the stream as unformatted input until the given character is found</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::ignore</td>
      <td>Extracts and discards characters until the given character is found</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::peek</td>
      <td>Returns the next character in the input sequence, without extracting it</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::read</td>
      <td>Extracts n characters from the stream and stores them in the passed C array</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::readsome</td>
      <td>Extracts up to n characters available for reading from the associated stream buffer object</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::putback</td>
      <td>Puts the given character back to the input stream so that it will be the next extracted character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::unget</td>
      <td>Makes the most recently extracted character available again</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::tellg</td>
      <td>Returns the position of the current character in the input sequence</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::seekg</td>
      <td>Sets the position of the next character to be extracted from the input sequence</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::sync</td>
      <td>Synchronizes the input buffer with the associated data source</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::put</td>
      <td>Inserts a character into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::write</td>
      <td>Inserts the characters from the given C string into the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::tellp</td>
      <td>Returns the position of the current character in the output sequence</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::seekp</td>
      <td>Sets the position where the next character is to be inserted into the output sequence</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::flush</td>
      <td>Flushes the output stream buffer</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::good</td>
      <td>Checks whether state of stream is good</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::eof</td>
      <td>Checks whether the eofbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::fail</td>
      <td>Checks whether the failbit or the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::bad</td>
      <td>Checks whether the badbit is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::operator!</td>
      <td>Returns true if no error flag is set, and false otherwise</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::basic_fstream::operator bool</td>
      <td>Returns whether an error flag is set</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::rdstate</td>
      <td>Returns the current internal error state flags of the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::setstate</td>
      <td>Modifies the current internal error state flags by combining the current flags with those in the argument</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::clear</td>
      <td>Sets a new value for the stream's internal error state flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::copyfmt</td>
      <td>Copies the formatting information from the given stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::fill</td>
      <td>Gets/sets the fill character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::exceptions</td>
      <td>Gets/sets the exceptions mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::imbue</td>
      <td>Associates a new locale to the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::getloc</td>
      <td>Returns the current locale associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::tie</td>
      <td>Gets/sets the tied stream (an output stream object which is flushed before each I/O operation in this stream object)</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::rdbuf</td>
      <td>Gets/sets the stream buffer object currently associated with the stream</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::narrow</td>
      <td>Returns the transformation of a wide character to its equivalent of type char</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::widen</td>
      <td>Returns the transformation of a narrow character to a wide character</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::flags</td>
      <td>Gets/sets the format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::setf</td>
      <td>Sets specific format flags</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::unsetf</td>
      <td>Clears the format flags selected in the given mask</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::precision</td>
      <td>Gets/sets the floating-point decimal precision</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::width</td>
      <td>Gets/sets the field width</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::xalloc</td>
      <td>Returns a program-wide unique integer that is safe to use as index to pword() and iword()</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::iword</td>
      <td>Returns a reference to the long element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::pword</td>
      <td>Returns a reference to the void* element of the private storage with the given index</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::register_callback</td>
      <td>Registers event callback function</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::basic_fstream::sync_with_stdio</td>
      <td>Toggles synchronization with cstdio streams</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++11</td>
      <td>fstream</td>
      <td>std::swap</td>
      <td>Swaps the contents of two basic_fstream objects</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::fstream</td>
      <td>Template instantiation of std::basic_fstream. Input/output stream class to operate on files.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>fstream</td>
      <td>std::wfstream</td>
      <td>Template instantiation of std::basic_fstream. Input/output stream class to operate on files using wide characters.</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::cout</td>
      <td>Global objects that controls output to the standard output stream oriented to narrow characters (of type 'char')</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::wcout</td>
      <td>Global objects that controls output to the standard output stream oriented to wide characters (of type 'wchar_t')</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::cerr</td>
      <td>Global objects that controls output to the standard error stream oriented to narrow characters (of type 'char')</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::wcerr</td>
      <td>Global objects that controls output to the standard error stream oriented to wide characters (of type 'wchar_t')</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::clog</td>
      <td>Global objects that controls output to the standard logging stream oriented to narrow characters (of type 'char')</td>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td>C++98</td>
      <td>iostream</td>
      <td>std::wclog</td>
      <td>Global objects that controls output to the standard logging stream oriented to wide characters (of type 'wchar_t')</td>
    </tr>
  </tbody>
</table>
<p class="auto-cursor-target">
  <br />
</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
</body>
</html>
