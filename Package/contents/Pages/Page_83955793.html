<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Texture | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Texture -->
<div class="pagetitle" id="PageId_83955793">Texture</div>
<div class="text_separate">
<h1 id="Anchor_83955793_h1_1">Texture</h1>
<h2 id="Anchor_83955793_h2_1">Overview</h2>
<p>The texture feature provides options for managing textures that are referenced by the GPU. The texture sampling behavior is handled by a <a href="../Pages/Page_83955849.html">sampler</a>.<br />Textures differ from buffers in the features provided, cache management, and optimization method for GPU access. When determining which to use, refer to the properties of each.</p>
<p>A <em>texture</em> is a container, in which a single pixel array is meaningless, that stores multiple pixel arrays with the same format and the same dimension. A single pixel array is called an <em>image</em>, and a portion of a texture is called a <em>sub-resource</em>. When a texture has a mipmap, or when the texture dimension is an array, that texture contains multiple images.</p>
<p>The texture feature does not provide a way for being set directly in the GPU. To set a texture, you must build a texture view, color target view, or depth stencil view.</p>
<h2 id="Anchor_83955793_h2_2">Information<a name="Anchor_83955793_Info"></a></h2>
<p>Texture information is defined as <span class="ApiLink_nn__gfx__TextureInfo"><code>nn::gfx::TextureInfo</code></span>.</p>
<h3 id="Anchor_83955793_h3_1">Dimension</h3>
<p>
  <strong>Dimension</strong> indicates all image dimensions contained in the texture.<br />Choose from among 1D, 2D, or 3D.<br />In addition to dimension, you have array length, which indicates whether you have an array, and the number of multi-samples, which indicates whether you have a multi-sample.<br /><strong>Dimension</strong> is set with the <span class="ApiLink_void_nn__gfx__TextureInfo__SetImageStorageDimension(ImageStorageDimension_value)_NN_NOEXCEPT">SetImageStorageDimension</span> function. </p>
<h3 id="Anchor_83955793_h3_2">Image Format</h3>
<p>
  <strong>Image Format</strong> indicates all image formats contained in the texture.<br />Use <span class="ApiLink_void_nn__gfx__TextureInfo__SetImageFormat(ImageFormat_value)_NN_NOEXCEPT"><code>SetImageFormat</code></span> to specify an enumerated value indicating the number of elements, the number of bits for each element, the element type, and whether there is a compression format.</p>
<h3 id="Anchor_83955793_h3_3">GPU Access Method</h3>
<p>
  <span class="ApiLink_void_nn__gfx__TextureInfo__SetGpuAccessFlags(int_value)_NN_NOEXCEPT">
    <code>SetGpuAccessFlag</code>
  </span> specifies how the GPU uses the texture.</p>
<h3 id="Anchor_83955793_h3_4">Tiling Mode</h3>
<p>Specifies whether to use lines or to use tiling optimized for the GPU for all image pixel arrays contained in the texture.</p>
<p>The tiling mode is set with <span class="ApiLink_void_nn__gfx__TextureInfo__SetTileMode(TileMode_value)_NN_NOEXCEPT"><code>SetTileMode</code></span>.</p>
<h3 id="Anchor_83955793_h3_5">Size</h3>
<p>The width, height, and depth of base level images are set using <code><span class="ApiLink_void_nn__gfx__TextureInfo__SetWidth(int_value)_NN_NOEXCEPT"><code>SetWidth</code></span></code>, <span class="ApiLink_void_nn__gfx__TextureInfo__SetHeight(int_value)_NN_NOEXCEPT"><code>SetHeight</code></span>, and <span class="ApiLink_void_nn__gfx__TextureInfo__SetDepth(int_value)_NN_NOEXCEPT"><code>SetDepth</code></span>, respectively.</p>
<h3 id="Anchor_83955793_h3_6">Array Length</h3>
<p>When the image format is an array, the array length is set using <span class="ApiLink_void_nn__gfx__TextureInfo__SetArrayLength(int_value)_NN_NOEXCEPT"><code>SetArrayLength</code></span>.</p>
<h3 id="Anchor_83955793_h3_7">Swizzling</h3>
<p>The base value for swizzling can be set using <span class="ApiLink_void_nn__gfx__TextureInfo__SetSwizzle(int_value)_NN_NOEXCEPT"><code>SetSwizzle</code></span>.<br />This parameter may be ignored by several low-level graphics APIs.</p>
<h3 id="Anchor_83955793_h3_8">Number of Multi-Samples</h3>
<p> When the dimension is multi-sample, the number of multi-samples is set using<code><span class="ApiLink_void_nn__gfx__TextureInfo__SetMultiSampleCount(int_value)_NN_NOEXCEPT"><code>SetMultiSampleCount</code></span></code>.</p>
<h3 id="Anchor_83955793_h3_9">Mipmap Count</h3>
<p>The number of mipmaps is specified using <code><span class="ApiLink_void_nn__gfx__TextureInfo__SetMipCount(int_value)_NN_NOEXCEPT"><code>SetMipCount</code></span></code>.</p>
<h2 id="Anchor_83955793_h2_3">Object<a name="Anchor_83955793_Object"></a></h2>
<p>The texture object is defined as <span class="ApiLink_nn__gfx__Texture"><code>nn::gfx::Texture</code></span>.</p>
<h3 id="Anchor_83955793_h3_10">Initialization and Destruction</h3>
<p>Initializing and freeing textures generally follows the method for <a href="../Pages/Page_83955654.html">objects</a></p>
<h3 id="Anchor_83955793_h3_11">Memory Pool</h3>
<p>The <span class="ApiLink_nn__gfx__TTexture__IsMemoryPoolRequired"><code>IsMemoryPoolRequired</code></span> static variable is defined to indicate whether a memory pool is required to handle architecture that shares memory between the CPU and the GPU, and architecture that does not.</p>
<p>When <span class="ApiLink_nn__gfx__TTexture__IsMemoryPoolRequired"><code>IsMemoryPoolRequired</code></span> is set to <code>true</code>, a valid memory pool must be passed at initialization. Without a memory pool, a texture initialization failure occurs. In addition, the following restrictions apply to the memory pool.</p>
<p>When <span class="ApiLink_nn__gfx__TTexture__IsMemoryPoolRequired"><code>IsMemoryPoolRequired</code></span> is set to <code>false</code>, it is possible to pass <code>NULL</code> as a memory pool argument to initialize the texture. In this case, only the texture memory allocation is performed on the device side, and the content is undefined. When a valid memory pool is set, it is considered as the initial value, and texture memory is allocated on the device side with the same content.</p>
<h3 id="Anchor_83955793_h3_12">Memory Pool Limitations</h3>
<p>A memory pool set at initialization must comply with the following restrictions. To get the content of these restrictions, several static variables have been prepared. These variables take the information to be initialized into parameters. The initialization information used and the parameter values must match.</p>
<h4 id="Anchor_83955793_h4_1">Base Level Image Alignment</h4>
<p>There is a limit on alignment on the base level image position specified as the memory pool offset. This value is calculated using the <span class="ApiLink_static_size_t_nn__gfx__TTexture__CalculateMipDataAlignment(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT"><code>CalculateMipDataAlignment</code></span> static function.</p>
<h4 id="Anchor_83955793_h4_2">Offset to Each Mipmap Image</h4>
<p>The offset for each level's mipmap image must be in accordance with the appropriate offset from the base level offset. This value is calculated using the <span class="ApiLink_static_void_nn__gfx__TTexture__CalculateMipDataOffsets(ptrdiff_t_*pMipOffsets|_TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT"><code>CalculateMipDataOffset</code></span> static function.</p>
<h4 id="Anchor_83955793_h4_3">Overall Data Size</h4>
<p>The size request for the overall data can be calculated using the <span class="ApiLink_static_size_t_nn__gfx__TTexture__CalculateMipDataSize(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT"><code>CalculateMipDataSize</code></span> static function.</p>
<h4 id="Anchor_83955793_h4_4">Linear Image Row Pitch</h4>
<p>To get the number of bytes from a pixel in the linear image to the pixel in the next row of the same column, use the <span class="ApiLink_static_size_t_nn__gfx__TTexture__GetRowPitch(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT"><code>GetRowPitch</code></span> static function. Note that the end of each row may have padding depending on the texture image format and width.</p>
<h2 id="Anchor_83955793_h2_4">Copying Images</h2>
<p>A specific pixel range of a specific image in a texture can be copied to a specific image portion of a specific image in another texture.<br />A command to copy images is added by calling the <span class="ApiLink_nn__gfx__CommandBuffer"><code>CopyImage</code></span> function of the <span class="ApiLink_void_nn__gfx__TCommandBuffer__CopyImage(TTexture__Target___*pDstTexture|_const_TextureSubresource_&dstSubresource|_int_dstOffsetU|_int_dstOffsetV|_int_dstOffsetW|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcCopyRegion)_NN_NOEXCEPT"><code>nn::gfx::CommandBuffer</code></span> class.</p>
<h3 id="Anchor_83955793_h3_13">Restrictions on Image Copying<a name="Anchor_83955793_image_copy_restriction"></a></h3>
<p>In copying an image, the texture that is the copy source must be initialized by including <span class="ApiLink_nn__gfx__GpuAccess_Read"><code>nn::gfx::GpuAcessFlag_Read</code></span> as the GPU access method, and the texture that is the copy destination must be initialized by including <span class="ApiLink_nn__gfx__GpuAccess_Write"><code>nn::gfx::GpuAccessFlag_Write</code></span> as the GPU access method.<br />The dimension of each texture must match. Also, the range of the copy source and the copy destination must not overlap.</p>
<p>Ultimately, the command for image copying must be provided in a queue that has copy functionality.</p>
<h2 id="Anchor_83955793_h2_5">Copying Scaled Images</h2>
<p>It is also possible to copy images that have been scaled up or down. Commands to copy scaled images are set by calling the <code><span class="ApiLink_nn__gfx__CommandBuffer">BlitImage</span></code> member function of the <code><span class="ApiLink_void_nn__gfx__TCommandBuffer__BlitImage(TTexture__Target___*pDstTexture|_const_TextureCopyRegion_&dstRegion|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcRegion|_int_copyFlags)_NN_NOEXCEPT">nn::gfx::CommandBuffer</span></code> class.<br />Unlike regular image copying, in this case you specify the copy range for both the source and the destination. If the two copy ranges do not match, the image is scaled while being filtered as specified by <code><span class="ApiLink_nn__gfx__ImageCopyFlag">nn::gfx::ImageCopyFlag</span></code>.</p>
<h3 id="Anchor_83955793_h3_14">Restrictions on Copying Scaled Images</h3>
<p>The same restrictions apply as for <a href="#Anchor_83955793_image_copy_restriction">Restrictions on Image Copying</a>.</p>
<h2 id="Anchor_83955793_h2_6">Copying Between the Buffer and the Image</h2>
<p>It is possible to copy an image to or from a buffer to update the content of an image, or to exchange linear and tiling data. Use <span class="ApiLink_void_nn__gfx__TCommandBuffer__CopyBufferToImage(TTexture__Target___*pDstTexture|_const_TextureCopyRegion_&dstRegion|_const_TBuffer__Target___*pSrcBuffer|_ptrdiff_t_srcOffset)_NN_NOEXCEPT"><code>nn::gfx::CommandBuffer::CopyBufferToImage</code></span> to copy the image from the buffer, and <span class="ApiLink_void_nn__gfx__TCommandBuffer__CopyImageToBuffer(TBuffer__Target___*pDstBuffer|_ptrdiff_t_dstOffset|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcRegion)_NN_NOEXCEPT"><code>nn::gfx::CommandBuffer::CopyImageToBuffer</code></span> to copy the image to the buffer. The data is handled as linear data while in the buffer, and handled according to the tiling mode defined in the content while in the texture.</p>
<h2 id="Anchor_83955793_h2_7">Image Format Queries</h2>
<p>To dynamically get the property of the specified image format, call <code><span class="ApiLink_void_nn__gfx__GetImageFormatProperty(ImageFormatProperty_*pOutImageFormatProperty|_TDevice__TTarget___*pDevice|_ImageFormat_imageFormat)_NN_NOEXCEPT">nn::gfx::GetImageFormatProperty</span></code>. You can use this function, for example, to determine whether a particular image format can be used as a color target. The value for the returned property differs depending on the low-level graphics API.</p>
<h2 id="Anchor_83955793_h2_8">Texture Resource State</h2>
<p>To maintain cache consistency, the command buffer is notified of the state changes when the usage method of the texture changes.<br />Texture resource state changes are performed using <span class="ApiLink_nn__gfx__CommandBuffer"><code>SetTextureStateTransition</code></span> in the <span class="ApiLink_void_nn__gfx__TCommandBuffer__SetTextureStateTransition(TTexture__Target___*pTexture|_TextureSubresourceRange_*pRange|_int_oldState|_int_oldStageBits|_int_newState|_int_newStageBits)_NN_NOEXCEPT"><code>nn::gfx::CommandBuffer</code></span> namespace. This function specifies the usage method before and after calling the function using shader stage arguments.<br />The most common case is a state change from a rendered color target to a texture. In this case, the state changes from <span class="ApiLink_nn__gfx__TextureState_ColorTarget"><code>TextureState_ColorTarget</code></span> to <span class="ApiLink_nn__gfx__TextureState_ShaderRead"><code>TextureState_ShaderRead</code></span>.</p>
<p>Using the resource states may allow for operations with a wider range of APIs, but a majority of these may be replaced with the <span class="ApiLink_nn__gfx__CommandBuffer"><code>FlushMemory</code></span> and <span class="ApiLink_void_nn__gfx__TCommandBuffer__FlushMemory(int_gpuAccessFlags)_NN_NOEXCEPT"><code>InvalidateMemory</code></span> functions from the <span class="ApiLink_void_nn__gfx__TCommandBuffer__InvalidateMemory(int_gpuAccessFlags)_NN_NOEXCEPT"><code>nn::gfx::CommandBuffer</code></span> namespace.</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__gfx__TextureInfo', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetImageStorageDimension(ImageStorageDimension_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#ac1912ab092b3f1acd897e96ea4eb7ffc' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetImageFormat(ImageFormat_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#aabd5c4ee3aaf0dfc3577843da1d8bc1f' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetGpuAccessFlags(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a214c396c13c6086b75cf63dc374f14ab' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetTileMode(TileMode_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a8c5d2d45349d88498a860af810a23727' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetWidth(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#aa9542aaf7fe4dea102f8ec01188c3227' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetHeight(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a2351f69b4b5c3bece70bfc416a74f96a' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetDepth(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a4c466cda0b7988c88afa89929a6f2ba5' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetArrayLength(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a1b6439172b5749537b1a6020a2a8b5ec' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetSwizzle(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a7e0bdbcb011d1f9a47bbddb77c38c62a' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetMultiSampleCount(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a1632b883ce5919120a9720a893187256' )
SetUrl( 'ApiLink_void_nn__gfx__TextureInfo__SetMipCount(int_value)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_texture_info.html#a8187f32da9bbbed65c49a1c00932d796' )
SetUrl( 'ApiLink_nn__gfx__Texture', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#a1aaa1504dbd528662d53ba66faba4313' )
SetUrl( 'ApiLink_nn__gfx__TTexture__IsMemoryPoolRequired', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_texture.html#ad72a001ac78d43ddcd4858d9b7793005' )
SetUrl( 'ApiLink_static_size_t_nn__gfx__TTexture__CalculateMipDataAlignment(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_texture.html#a6580c829bab613b6e9850e543f9a7203' )
SetUrl( 'ApiLink_static_void_nn__gfx__TTexture__CalculateMipDataOffsets(ptrdiff_t_*pMipOffsets|_TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_texture.html#a17ca46f2f683062163aaaa0ba3e2d7c4' )
SetUrl( 'ApiLink_static_size_t_nn__gfx__TTexture__CalculateMipDataSize(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_texture.html#ac9d3334566c6451da3f015e5ed1fd1ad' )
SetUrl( 'ApiLink_static_size_t_nn__gfx__TTexture__GetRowPitch(TDevice__Target___*pDevice|_const_InfoType_&info)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_texture.html#a1cb515928e54198e11bdad346f61f3ca' )
SetUrl( 'ApiLink_nn__gfx__CommandBuffer', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#af719859a76c249a182d878f0cffd47c5' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__CopyImage(TTexture__Target___*pDstTexture|_const_TextureSubresource_&dstSubresource|_int_dstOffsetU|_int_dstOffsetV|_int_dstOffsetW|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcCopyRegion)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#afd05d1e63d9009d74cf7de5088dab91c' )
SetUrl( 'ApiLink_nn__gfx__GpuAccess_Read', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#a24dbcd6d86531138895622b5a854e4f5ac1b684c53b2d80f1692d75485018a5d6' )
SetUrl( 'ApiLink_nn__gfx__GpuAccess_Write', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#a24dbcd6d86531138895622b5a854e4f5a4119e17a73b3f0569dfff61b11af8caa' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__BlitImage(TTexture__Target___*pDstTexture|_const_TextureCopyRegion_&dstRegion|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcRegion|_int_copyFlags)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a230f6874832504f69e1f8f79a153f7cf' )
SetUrl( 'ApiLink_nn__gfx__ImageCopyFlag', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#ab4ec3f26b32ff15b2eec7eae4a229f05' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__CopyBufferToImage(TTexture__Target___*pDstTexture|_const_TextureCopyRegion_&dstRegion|_const_TBuffer__Target___*pSrcBuffer|_ptrdiff_t_srcOffset)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a095e642fd735cffd203522b54fd32b0f' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__CopyImageToBuffer(TBuffer__Target___*pDstBuffer|_ptrdiff_t_dstOffset|_const_TTexture__Target___*pSrcTexture|_const_TextureCopyRegion_&srcRegion)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a2dd01209c849897716bea6e871112d45' )
SetUrl( 'ApiLink_void_nn__gfx__GetImageFormatProperty(ImageFormatProperty_*pOutImageFormatProperty|_TDevice__TTarget___*pDevice|_ImageFormat_imageFormat)_NN_NOEXCEPT', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#a21c5e5a1eb8c95aedd04be175b23192e' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__SetTextureStateTransition(TTexture__Target___*pTexture|_TextureSubresourceRange_*pRange|_int_oldState|_int_oldStageBits|_int_newState|_int_newStageBits)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a9d3efd13c434bb824fadb39977b1d6df' )
SetUrl( 'ApiLink_nn__gfx__TextureState_ColorTarget', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#ab4aaf139c1aa33c4c175e21423cc86fda6bb2a9982ebe869b8e6f4d4b4678f875' )
SetUrl( 'ApiLink_nn__gfx__TextureState_ShaderRead', '../../../Api/HtmlNX/namespacenn_1_1gfx.html#ab4aaf139c1aa33c4c175e21423cc86fda954cebcb3b7eab59c779a7cff2b20ae2' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__FlushMemory(int_gpuAccessFlags)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a3b43b17e57f564190229a914370bfb9b' )
SetUrl( 'ApiLink_void_nn__gfx__TCommandBuffer__InvalidateMemory(int_gpuAccessFlags)_NN_NOEXCEPT', '../../../Api/HtmlNX/classnn_1_1gfx_1_1_t_command_buffer.html#a7e5cade7802122a5272657dfaec5d1f1' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
