<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<script type="text/javascript" src="../tocDataApi.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>Quick Start | NintendoSDK Documents</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="text-align: center;"><img src="../template/img/noscript.svg" /></div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- Quick Start -->
<div class="pagetitle" id="PageId_83956051">Quick Start</div>
<div class="text_separate">
<h1 id="Anchor_83956051_h1_1">Contents</h1>
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_83956051_h2_1">Building a Development Environment</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_2">Building and Running the Sample Program</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_3">Sample Program Source Code</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_4">Initialization</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_5">Loading Sound Data</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_6">Frame Processing</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_7">Playing and Stopping Sounds</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_8">Sound Handles</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_9">Hold Play</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_10">Preparing Sounds (Preparing for Playback)</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_11">Playback Using a String</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_12">Types of Sounds</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_13">Getting Rendering Results</a>
    </li>
  </ul>
</p>
<h1 id="Anchor_83956051_h1_2">Quick Start</h1>
<p>This section first describes the method for building a development environment, and then describes how to assemble a simple audio program while referencing a sample program.</p>
<p>After building and executing the sample, you look at the sample's source code while reviewing how to assemble a sound program.</p>
<h2 id="Anchor_83956051_h2_1">Building a Development Environment</h2>
<p>This chapter describes how to build the audio program development environment.</p>
<h3 id="Anchor_83956051_h3_1">NintendoWare Audio Toolkit Library</h3>
<p>The <code>atk</code> library is used to assemble audio programs.<br />The <code>atk</code> library corresponds to the functions of the <code><span class="ApiLink_nn__atk">nn::atk</span></code> namespace included in the NintendoWare package.</p>
<h3 id="Anchor_83956051_h3_2">Directory Structure</h3>
<p>The <code>atk</code> library has the following directory structure.<br />In this figure, <code>%NINTENDO_SDK_ROOT%</code> denotes the <code>NintendoSDK</code> directory where NintendoWare was installed.</p>
<p>Figure 1. Directory Structure</p>
<table class="table">
  <tbody>
    <tr>
      <td>
        <div class="container" title="Hint: double-click to select code">
          <div class="line number1 index0 alt2">
            <code class="plain plain">%NINTENDO_SDK_ROOT%</code>
          </div>
          <div class="line number2 index1 alt1">
            <code class="plain plain">　　|</code>
          </div>
          <div class="line number3 index2 alt2">
            <code class="plain plain">　　+-- Libraries\                                   // Library files</code>
          </div>
          <div class="line number4 index3 alt1">
            <code class="plain plain">　　+-- Sources\Libraries\atk\                       // atk library source code</code>
          </div>
          <div class="line number5 index4 alt2">
            <code class="plain plain">　　+-- Samples\Sources\Applications\AtkSimple\ etc. // atk sample programs</code>
          </div>
          <div class="line number6 index5 alt1">
            <code class="plain plain">　　+-- Documents\Package\                           // Development environment documentation</code>
          </div>
          <div class="line number7 index6 alt2">
            <code class="plain plain">　　+-- Tools\Audio\SoundMaker\                      // SoundMaker tool</code>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_3">Development Environment Used With the atk Library</h3>
<p>The preparations required for development using the <code>atk</code> library can be broadly classified into four steps.</p>
<ul>
  <li>Configure the library file links.</li>
  <li>Configure the include path.</li>
  <li>Place the sound data.</li>
  <li>Reference the sound ID file.</li>
</ul>
<h4 id="Anchor_83956051_h4_1">Configuring the Library File Links</h4>
<p>To use the <code>atk</code> library, you must link the <code>atk</code> library and any library files that depend on the <code>atk</code> library.</p>
<p>Link <code>libnn_atk.lib</code> and <code>libnn_audio.lib</code>, located below <code>%NINTENDO_SDK_ROOT%\Libraries\</code>.<br />(Also link <code>libnn_codec.lib</code> when using compressed audio.) </p>
<h4 id="Anchor_83956051_h4_2">Configuring the Include Path</h4>
<p>Add <code>%NINTENDO_SDK_ROOT%\Include</code> to the include path.</p>
<h4 id="Anchor_83956051_h4_3">Placing Sound Data</h4>
<p>The sound data created by the sound designer is passed to the developer as a folder containing the sound archive (BFSAR) files and multiple sets of stream data (BFSTM) files. The sound archive is a single file that groups multiple sets of sound data other than stream data.</p>
<p>The developer places this sound data in storage to make use of it. Place the files in the contents directory set for each application.</p>
<h4 id="Anchor_83956051_h4_4">Including the Sound ID File</h4>
<p>The sound ID (FSID) file contains definitions of labels for using the sound archive. This file is exported at the same time that the sound archive is created. Like the header files, the developer includes this by referencing it in the source file.</p>
<p>In the AtkSimple demo, this would be <code>%NINTENDO_SDK_ROOT%\Samples\Sources\Applications\AtkSimple\Common.fsid</code>.</p>
<h2 id="Anchor_83956051_h2_2">Building and Running the Sample Program</h2>
<p>For more information about building and executing a sample program, see the section about building sample programs in <a href="../Pages/Page_95692646.html">Atk Start Guide</a>.</p>
<h2 id="Anchor_83956051_h2_3">Sample Program Source Code</h2>
<p>This section describes the sound program by showing the contents of the source code.</p>
<p>The source code used for the following description is from <span class="ApiLink_PageSampleAtkSimple">AtkSimple.cpp</span>.<br />Describes a basic sound program using references to this sample program.</p>
<p> </p>
<div>
  <h3 id="Anchor_83956051_h3_4">Referencing Header Files</h3>
</div>
<p>
  <code>AtkSimple.cpp</code> references the following header files.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="cp">#include &quot;Common.fsid&quot;
#include &lt;nn/atk.h&gt;
</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <code>nn/atk.h</code> is the <code>atk</code> library header file. To use the <code>atk</code> library, you must reference this header file.</p>
<p>
  <code>Common.fsid</code> is the sound ID file. By using the labels defined in this file, you can use specific sets of sound data in the sound archive.</p>
<h3 id="Anchor_83956051_h3_5">Namespace</h3>
<p>The <code>atk</code> library is defined in the <code><span class="ApiLink_nn__atk">nn::atk</span></code> namespace.</p>
<p> </p>
<!--Remove-->
<p> </p>
<h2 id="Anchor_83956051_h2_4">Initialization</h2>
<p>The basic initialization process involves the following steps.</p>
<ol>
  <li>Initialize the sound system.</li>
  <li>Initialize the sound archive.</li>
  <li>Initialize the sound data manager.</li>
  <li>Initialize the sound archive player.</li>
  <li>Construct the sound heap.</li>
</ol>
<p> </p>
<div>
  <h3 id="Anchor_83956051_h3_6">Initialize the sound system.</h3>
</div>
<p>To initialize the sound system, call the <code><span class="ApiLink_nn__atk__SoundSystem">nn::atk::SoundSystem</span></code> class API as follows.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// Initialize SoundSystem.
</span><span class="nn">nn::atk::SoundSystem::</span><span class="n">SoundSystemParam</span> <span class="n">param</span><span class="p">;</span>
<span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundSystem</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="n">param</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundSystem</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundSystem</span><span class="p">,</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">WorkMemoryAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">param</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">g_pMemoryForSoundSystem</span> <span class="p">),</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">memSizeForSoundSystem</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundSystem&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>Initialize the sound system using the <code><span class="ApiLink_nn__atk__SoundSystem__Initialize">nn::atk::SoundSystem::Initialize</span></code> function.<br />Initializing the sound system starts the sound thread and the task thread that will run in the <code>atk</code> library.</p>
<p>For the parameters, pass the priority of the sound thread and the task thread, in addition to the <code><span class="ApiLink_nn__atk__SoundSystem__SoundSystemParam">nn::atk::SoundSystem::SoundSystemParam</span></code> structure that holds such information as the stack size for each thread.<br />The sound thread handles sound playback. To prevent delays in playback, the sound thread must be set to a high priority.</p>
<p>The task thread reads stream data and loads the data to the player heap. If there are delays in loading stream data, there will be interruptions in sound, so the task thread must also be set to a high priority.</p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>To prevent sound skipping, we recommend setting the task thread to a higher priority than the sound thread.</p>
  </div>
</div>
<h3 id="Anchor_83956051_h3_7">Initializing the Sound Archive</h3>
<p>The next step is to initialize the sound archive.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">FsSoundArchive</span>    <span class="n">g_SoundArchive</span><span class="p">;</span>

<span class="c1">// Initialize SoundArchive.
</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">archiveAbsolutePath</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">GetAbsolutePath</span><span class="p">(</span><span class="n">ArchiveRelativePath</span><span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">Open</span><span class="p">(</span><span class="n">archiveAbsolutePath</span><span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot open SoundArchive(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">archiveAbsolutePath</span> <span class="p">);</span>

<span class="c1">// Load SoundArchive parameter information to memory.
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">infoBlockSize</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">GetHeaderSize</span><span class="p">();</span>
<span class="n">g_pMemoryForInfoBlock</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">infoBlockSize</span><span class="p">,</span> <span class="nn">nn::atk::FsSoundArchive::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">LoadHeader</span><span class="p">(</span> <span class="n">g_pMemoryForInfoBlock</span><span class="p">,</span> <span class="n">infoBlockSize</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot load InfoBlock&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code><span class="ApiLink_nn__atk__FsSoundArchive">nn::atk::FsSoundArchive</span></code> class instance <code>s_SoundArchive</code> is secured ahead of time.</p>
<p>Open the sound archive using the <code><span class="ApiLink_nn__atk__FsSoundArchive__Open">nn::atk::FsSoundArchive::Open</span></code> function. For an argument, specify the path located in the FS file system.</p>
<p>Next, call the <code><span class="ApiLink_nn__atk__FsSoundArchive__LoadHeader">nn::atk::FsSoundArchive::LoadHeader</span></code> function to load the minimum essential amount of information.<br />For the parameters of the function, the size of memory required for loading this information is passed. Use the <code><span class="ApiLink_nn__atk__FsSoundArchive__GetHeaderSize">nn::atk::FsSoundArchive::GetHeaderSize</span></code> function to get the required size of this memory region.</p>
<h3 id="Anchor_83956051_h3_8">Initializing the Sound Data Manager</h3>
<p>The next step is to initialize the Sound Data Manager. The <code>SoundDataManager</code> class is for loading and managing data in sound archives.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundDataManager</span>   <span class="n">g_SoundDataManager</span><span class="p">;</span>

<span class="c1">// Initialize SoundDataManager.
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundDataManager</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundDataManager</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundDataManager</span><span class="p">,</span> <span class="nn">nn::atk::SoundDataManager::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundArchive</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForSoundDataManager</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">memSizeForSoundDataManager</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundDataManager&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code><span class="ApiLink_nn__atk__SoundDataManager">nn::atk::SoundDataManager</span></code> class instance <code>s_SoundDataManager</code> is secured ahead of time.</p>
<p>You can initialize the sound data manager using the <code><span class="ApiLink_nn__atk__SoundDataManager__Initialize">nn::atk::SoundDataManager::Initialize</span></code> function.</p>
<p>For the parameters of the function, the address to the sound archive (<code>&amp;s_SoundArchive</code>) and the size of the memory required to initialize the sound data manager are passed.<br />Use the <code><span class="ApiLink_nn__atk__SoundDataManager__GetRequiredMemSize">nn::atk::SoundDataManager::GetRequiredMemSize</span></code> function to get the required size of this memory region.</p>
<h3 id="Anchor_83956051_h3_9">Initializing the Sound Archive Player</h3>
<p>The next step is to initialize the sound archive player. This class uses the sound archive to play sounds.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundArchivePlayer</span> <span class="n">g_SoundArchivePlayer</span><span class="p">;</span>

<span class="c1">// Initialize SoundArchivePlayer.
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundArchivePlayer</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundArchivePlayer</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundArchivePlayer</span><span class="p">,</span> <span class="nn">nn::atk::SoundArchivePlayer::</span><span class="n">BufferAlignSize</span><span class="p">);</span>
<span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForStreamBuffer</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">GetRequiredStreamBufferSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForStreamBuffer</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForStreamBuffer</span><span class="p">,</span> <span class="nn">nn::audio::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundArchive</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundDataManager</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForSoundArchivePlayer</span><span class="p">,</span> <span class="n">memSizeForSoundArchivePlayer</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForStreamBuffer</span><span class="p">,</span> <span class="n">memSizeForStreamBuffer</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundArchivePlayer&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code><span class="ApiLink_nn__atk__SoundArchivePlayer">nn::atk::SoundArchivePlayer</span></code> class instance <code>g_SoundArchivePlayer</code> is secured ahead of time.</p>
<p>The sound archive player is initialized by the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__Initialize">nn::atk::SoundArchivePlayer::Initialize</span></code> function.<br />For the parameters of the function, pass the address to the sound archive (<code>&amp;g_SoundArchive</code>), the address to the sound data manager (<code>&amp;g_SoundDataManager</code>), and two memory regions, both required for initialization.<br />One memory region is used as a work region and for instances of sounds kept in the sound archive player. The other is used as a buffer for the playback of stream sounds.<br />Note that the stream buffer must be aligned with <code>nn:audio::BufferAlignSize</code>. </p>
<p>Get the sizes of these memory regions using the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__GetRequiredMemSize">nn::atk::SoundArchivePlayer::GetRequiredMemSize</span></code> and <code><span class="ApiLink_nn__atk__SoundArchivePlayer__GetRequiredStreamBufferSize">nn::atk::SoundArchivePlayer::GetRequiredStreamBufferSize</span></code> functions.</p>
<h3 id="Anchor_83956051_h3_10">Constructing the Sound Heap</h3>
<p>The final process is to construct the sound heap. This class is used to manage the memory regions for loading sound data.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundHeap</span>          <span class="n">g_SoundHeap</span><span class="p">;</span>

<span class="c1">// Initialize SoundHeap.
</span><span class="n">g_pMemoryForSoundHeap</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">SoundHeapSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundHeap</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span> <span class="n">g_pMemoryForSoundHeap</span><span class="p">,</span> <span class="n">SoundHeapSize</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot create SoundHeap&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>The <code><span class="ApiLink_nn__atk__SoundHeap">nn::atk::SoundHeap</span></code> class instance <code>g_SoundHeap</code> is secured ahead of time.</p>
<p>The sound heap is constructed by the <code><span class="ApiLink_nn__atk__SoundHeap__Create">nn::atk::SoundHeap::Create</span></code> function. The function takes the memory region assigned to the sound heap as an argument.</p>
<h2 id="Anchor_83956051_h2_5">Loading Sound Data</h2>
<p>To play wave sounds and sequence sounds, you must load the sound data needed for playback ahead of time.<br />The sound data can be loaded in set units of groups, or it can be loaded in units of sequence data, wave sound data, bank data, and waveform archive data.</p>
<p>The determination of what data to include in a group is configured on SoundMaker.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">LoadData</span><span class="p">(</span> <span class="n">SEQ_MARIOKART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_SoundHeap</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;LoadData(SEQ_MARIOKART) failed.&quot;</span> <span class="p">);</span>

<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">LoadData</span><span class="p">(</span> <span class="n">SE_YOSHI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_SoundHeap</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;LoadData(SE_YOSHI) failed.&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>Load the sound data using the <code><span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span></code> function.</p>
<p>The arguments take the sound data to load or the group&rsquo;s label, and the sound heap for storing the loaded data.</p>
<p>The group labels <code>SEQ_MARIOKART</code> and <code>SE_YOSHI</code> are defined in the sound ID file (<code>Common.fsid</code>). Confirm with the sound designer which data to load at which times.</p>
<p>The AtkSimple sample loads all data for the sequence sound <code>SEQ_MARIOKART</code> (sequence data, bank data, waveform archive data), and all data for the wave sound <code>SE_YOSHI</code> (wave sound data, waveform archive data).</p>
<p> </p>
<div class="info_new">
  <div class="info_new_left">Info</div>
  <div class="info_new_right">
    <p>
      <strong>Note:</strong>
      <br />The <code><span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span></code> function loads data synchronously. No asynchronous version of this function is provided.<br />If you want to load the data asynchronously, call this function in a different thread. For more information about calling the <code><span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span></code> function in a separate thread, see the API Reference Manual.</p>
  </div>
</div>
<h2 id="Anchor_83956051_h2_6">Frame Processing</h2>
<p>The sound archive player must be updated in every frame.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>This update process is normally called from the main loop. It does not need to be called in every video frame.</p>
<p>For processes like fading the volume, a call to this function is figured as one frame.</p>
<h2 id="Anchor_83956051_h2_7">Playing and Stopping Sounds</h2>
<p> </p>
<div>
  <h3 id="Anchor_83956051_h3_11">Plays a sound</h3>
</div>
<p>Sounds are played using code like the following.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">soundId</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>Sounds are played using the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__StartSound">nn::atk::SoundArchivePlayer::StartSound</span></code> function.<br />The arguments take the sound handle and the label for the sound being played.</p>
<p>The address to the <code><span class="ApiLink_nn__atk__SoundHandle">nn::atk::SoundHandle</span></code> class instance (<code>&amp;g_SoundHandle</code>) is passed for the sound handle.</p>
<p>A description of sound handles follows.</p>
<p>The label for the sound being played is defined in the sound ID file <code>Common.fsid</code>. You must confirm with the sound designer which label is for which sound.</p>
<h3 id="Anchor_83956051_h3_12">Stopping Sounds</h3>
<p>A sound handle is used to stop its associated sound.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">g_SoundHandle</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>Sounds are stopped using the <code><span class="ApiLink_nn__atk__SoundHandle__Stop">nn::atk::SoundHandle::Stop</span></code> function.<br />The argument takes the number of fadeout frames. The volume is gradually decreased for the duration of the specified number of fadeout frames and then playback is stopped. <br />The number of fadeout frames corresponds to the number of calls to the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__Update">nn::atk::SoundArchivePlayer::Update</span></code> function.</p>
<p>As mentioned previously, it is okay if the sound stops before the call to the <code><span class="ApiLink_nn__atk__SoundHandle__Stop">nn::atk::SoundHandle::Stop</span></code> function. If this occurs, the function returns without doing anything.</p>
<h2 id="Anchor_83956051_h2_8">Sound Handles</h2>
<h3 id="Anchor_83956051_h3_13">What Is a Sound Handle?</h3>
<p>A sound handle is an object for stopping a playing sound, changing the volume, and so on.<br />Each sound handle can control one sound. When the sound starts playing successfully, the sound and a sound handle are linked.</p>
<p>Until that link is broken, the sound handle can be used to control that sound.</p>
<p>Figure 2. A Sound and a Sound Handle Become Linked When Sound Playback Succeeds</p>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_83956051/1229087098.png" class="embedded-image" />
  </span>
</p>
<p>This means that the developer does not need to be concerned with whether a sound is still playing.<br />You can run the same process on a sound whether it is playing or already stopped without mistakenly performing the operation on a different sound.</p>
<h3 id="Anchor_83956051_h3_14">Tips for Creating Sound Handles</h3>
<p>For sounds like one-time sound effects that play without stopping or being manipulated, you only need to prepare one sound handle, using it repeatedly to play each sound in turn.<br />Also, you can use it immediately after a sound to change the volume and other parameters before playing the next sound.</p>
<p>For persistent effects like background music and engine noise, you must stop the sound at some point, so you need a sound handle for each individual sound.</p>
<h2 id="Anchor_83956051_h2_9">Hold Play</h2>
<p>
  <span style="background-color: rgb(255,255,255);">Normally, the <code>StartSound</code> and <code>Stop</code> functions are used to play and stop sounds. However, the implementation of a program can sometimes make it troublesome to call the <code>Stop</code> function at the appropriate times.</span>
</p>
<p>
  <span style="background-color: rgb(255,255,255);">In these cases, the <code>HoldSound</code> function can be used in place of the <code>StartSound</code> function.</span>
</p>
<h3 id="Anchor_83956051_h3_15">Using the HoldSound Function</h3>
<p>To keep playing a sound, the <code>HoldSound</code> function must be called in every frame. When the function is called in consecutive frames this way, the process of starting playback is performed only the first time, and nothing is done for the second and subsequent calls.</p>
<p>This method of playback is called Hold Play in the NintendoWare sound library.</p>
<p>Sound continues to play while the <code>HoldSound</code> function is being called, but as soon as the function stops being called, the sound stops automatically inside the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__Update">nn::atk::SoundArchivePlayer::Update</span></code> function.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">HoldSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandleHold</span><span class="p">,</span> <span class="n">soundId</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>As this code suggests, the <code>HoldSound</code> function is simply called instead of <code>StartSound</code>, and nothing else.</p>
<h3 id="Anchor_83956051_h3_16">Resuming Playback After Losing Player Priority</h3>
<p>When the <code>StartSound</code> and <code>Stop</code> functions are used to play a sound, if the sound is forcibly stopped due to loss of player priority, playback does not resume unless <code>StartSound</code> is explicitly called.</p>
<p>When the <code>HoldSound</code> function is used to play a sound, even if player priority is lost, an attempt to resume playback occurs in the next frame because the function is called in each frame. For this reason, playback automatically resumes when the playback of a higher priority sound completes.</p>
<p>However, because playback resumes from the beginning rather than from the middle, note that some sound data may sound unnatural.</p>
<h3 id="Anchor_83956051_h3_17">Player Priority and the HoldSound Function</h3>
<p>The processing of player priority is different when the <code>HoldSound</code> function is used to play sounds. Assuming that the player priority value is <code>64</code>, when playback starts the priority is 63 (one less than 64). If playback is successful, the player priority is set to <code>64</code>.</p>
<p>So whereas the latter of two processes with the same player priority normally takes precedence, when you use <code>HoldSound</code> the former process takes precedence.</p>
<h2 id="Anchor_83956051_h2_10">
  <a name="Anchor_83956051_SND_PREPARE"></a>Preparing Sounds (Preparing for Playback)</h2>
<p>Depending on the sound data type, playback might not start immediately when the <code>StartSound</code> function is called. When playing stream sounds, because some data must be pre-loaded, playback does not begin until loading completes.</p>
<p>In addition, when you use the player heap to play wave sounds and sequence sounds, playback does not begin until the necessary data is finished loading into the player heap. (For more information about the player heap, see <a href="../Pages/Page_83956038.html#Anchor_83956038_PLAYER_HEAP">Memory Management - Player Heap</a>.)</p>
<p>Normally, this issue is not important, but a problem can arise in cases where the timing of the start of playback is inconsistent, such as when synchronizing images and sound. In situations like that, you can use the <code>PrepareSound</code> function in place of the <code>StartSound</code> function.</p>
<h3 id="Anchor_83956051_h3_18">Using the PrepareSound Function</h3>
<p>The <code>PrepareSound</code> function performs only the preparations for starting sound playback. For this reason, sound does not play if you only call <code>PrepareSound</code>.</p>
<p>The preparations for sound playback are implemented asynchronously. Use the <code><span class="ApiLink_nn__atk__SoundHandle__IsPrepared">nn::atk::SoundHandle::IsPrepared</span></code> function to determine whether preparations have completed. After confirming that preparations are finished, start sound playback by calling the <code><span class="ApiLink_nn__atk__SoundHandle__StartPrepared">nn::atk::SoundHandle::StartPrepared</span></code> function.</p>
<p>If preparations are complete, the sound begins playing immediately when the <code>StartPrepared</code> function is called. If <code>StartPrepared</code> is called before preparations are complete, the sound begins to play automatically after waiting for preparations to complete.</p>
<h2 id="Anchor_83956051_h2_11">Playback Using a String</h2>
<p>In the sample codes described previously, the ID of the sound to play was passed to the playback function in the following way.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">SEQ_MARIOKART</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>You must include a sound ID (FSID) file ahead of time because this sound ID is defined in a sound ID file. This requirement is a drawback because you must recompile each time the sound ID file is updated.</p>
<p>In addition, a method of playing back sounds using a string is also provided.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="s">&quot;SEQ_MARIOKART&quot;</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>A sound ID file does not need to be included in this case because a string is used under this method. Note, however, that you must add the following type of initialization.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">Load</span> <span class="c1">// SoundArchive label string information into memory
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForLabelString</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">GetLabelStringDataSize</span><span class="p">();</span>
<span class="n">g_pMemoryForLabelData</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForLabelString</span><span class="p">,</span> <span class="nn">nn::atk::FsSoundArchive::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">LoadLabelStringData</span><span class="p">(</span> <span class="n">g_pMemoryForLabelData</span><span class="p">,</span> <span class="n">memSizeForLabelString</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>Playback using a string has the following characteristics compared to playback using a sound ID. Use string playback according to your needs.</p>
<ul>
  <li>Because the sound ID file is not included, programs do not need to be recompiled even if sound data is updated.</li>
  <li>It is necessary to load label string data.</li>
  <li>There is execution cost due to converting the string to a sound ID.</li>
  <li>Spelling mistakes in sound specifications cannot be detected during compilation.</li>
</ul>
<h2 id="Anchor_83956051_h2_12">Types of Sounds</h2>
<p>There are three different types of sounds that can be played with the <code>atk</code> library.</p>
<ul>
  <li>Stream sounds</li>
  <li>Wave Sounds</li>
  <li>Sequence sounds</li>
</ul>
<p>All of these sounds can be played using the <code><span class="ApiLink_nn__atk__SoundArchivePlayer__StartSound">nn::atk::SoundArchivePlayer::StartSound</span></code> function. As a result, the developer does not need to be concerned about which types of sounds were created by the sound designer.</p>
<p>Functions are prepared for all of the basic operations of the sound handle (for example, pausing, stopping, and changing the volume and pitch) so that common operations can be used to control playback.</p>
<p>To perform operations that can only be performed on sequence sounds, such as changing the tempo, use a sequence sound handle.</p>
<p>Sequence sound handles are treated the same as regular sound handles, but they have additional functions specific to sequence control.</p>
<p>To use a sequence sound handle, call the <code><span class="ApiLink_nn__atk__SequenceSoundHandle">nn::atk::SequenceSoundHandle</span></code> class constructor with a sound handle passed as the argument. Then call functions for specific sequence operations.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="k">if</span> <span class="p">(</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">SEQ_MARIOKART</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">()</span> <span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::atk::</span><span class="n">SequenceSoundHandle</span> <span class="n">seqHandle</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span> <span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">seqHandle</span><span class="p">.</span><span class="n">SetTempoRatio</span><span class="p">(</span> <span class="mf">2.0f</span> <span class="p">);</span>
<span class="p">}</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>If a handle linked to a sound other than a sequence sound is passed to the <code><span class="ApiLink_nn__atk__SequenceSoundHandle">nn::atk::SequenceSoundHandle</span> </code> class constructor, that sequence sound handle is invalidated. Function calls to an invalidated sequence sound handle are ignored.</p>
<h2 id="Anchor_83956051_h2_13">Getting Rendering Results</h2>
<p>After sound playback processing, you can use the <code>CircularBufferSink</code> feature to get the results of the rendering by the audio renderer.</p>
<h3 id="Anchor_83956051_h3_19">Enabling CircularBufferSink</h3>
<p>To use <code>CircularBufferSink</code>, you must enable it when initializing the sound system.</p>
<p>The following two settings must be set with <code><span class="ApiLink_nn__atk__SoundSystem__SoundSystemParam">nn::atk::SoundSystem::SoundSystemParam</span></code> to enable <code>CircularBufferSink</code>.</p>
<ul>
  <li>Flag for enabling <code>CircularBufferSink</code></li>
  <li>The size of the buffer used to store the rendering results</li>
</ul>
<p>The size of the buffer is specified by the number of audio frames. If the buffer is large, the buffer size required for initializing the sound system and the return value of <code><span class="ApiLink_nn__atk__SoundSystem__GetCircularBufferSinkBufferSize">nn::atk::SoundSystem::GetCircularBufferSinkBufferSize</span>()</code> will also be large.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// Enabling CircularBufferSink.
</span><span class="nn">nn::atk::SoundSystem::</span><span class="n">SoundSystemParam</span> <span class="n">param</span><span class="p">;</span>
<span class="n">param</span><span class="p">.</span><span class="n">enableCircularBufferSink</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">param</span><span class="p">.</span><span class="n">recordingAudioFrameCount</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">...</span>
<span class="nn">nn::atk::SoundSystem::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="p">...);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_20">Loading CircularBufferSink</h3>
<p>If you enable <code>CircularBufferSink</code>, the rendering result of each audio frame will be stored in <code>CircularBufferSink</code>.</p>
<p>You can load the stored sample data using <code><span class="ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink">nn::atk::SoundSystem::ReadCircularBufferSink</span>()</code>.<br />The stored data must be loaded correctly. If there is data that has not been read exceeding the number of audio frames specified during sound system initialization, the data is destroyed starting with the oldest.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// Loading CircularBufferSink.
</span><span class="kt">size_t</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetCircularBufferSinkBufferSize</span><span class="p">();</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">Allocate</span><span class="p">(</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">readSize</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">ReadCircularBufferSink</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_21">Using Sample Data Obtained From CircularBufferSink</h3>
<p>For more information about the loaded sample data, see <code><span class="ApiLink_nn__audio__ReadCircularBufferSink">nn::audio::ReadCircularBufferSink</span>()</code>.<br />The sample data is equivalent in size to one audio frame (number of rendering samples) * (number of channels) * (2 bytes),<br />and sample data of this integer multiple is loaded each time <code><span class="ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink">nn::atk::SoundSystem::ReadCircularBufferSink</span>()</code> is called.</p>
<p>The obtained sample data is block-interleaved, so use the following API for processing the sample data.</p>
<ul>
  <li>
    <code>
      <span class="ApiLink_nn__atk__SoundSystem__GetRendererSampleCount">nn::atk::SoundSystem::GetRendererSampleCount</span>()</code>: Gets the number of samples the audio renderer renders for one audio frame.</li>
  <li>
    <code>
      <span class="ApiLink_nn__atk__SoundSystem__GetRendererChannelCountMax">nn::atk::SoundSystem::GetRendererChannelCountMax</span>() :</code>: Gets the number of channels rendered by the renderer.</li>
</ul>
<p>The following example shows the code that processes the obtained sample data for each channel.</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// Using the sample data obtained from CircularBufferSink.
</span><span class="kt">uint32_t</span> <span class="n">rendererSampleCount</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRendererSampleCount</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">channelCountMax</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRendererChannelCountMax</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">BytesPerSample</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// The rendering results are 2 bytes per sample because of PCM16;
</span>
<span class="kt">int</span> <span class="n">readSizePerAudioFrame</span> <span class="o">=</span> <span class="n">rendererSampleCount</span> <span class="o">*</span> <span class="n">channelCountMax</span> <span class="o">*</span> <span class="n">BytesPerSample</span><span class="p">;</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span><span class="n">readSize</span> <span class="o">%</span> <span class="n">readSizePerAudioFrame</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">readAudioFrameCount</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">readSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">readSizePerAudioFrame</span><span class="p">;</span> <span class="c1">// How many audio frames of sample data was loaded?
</span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">readAudioFrameCount</span><span class="p">;</span> <span class="o">++</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">int16_t</span><span class="o">*</span> <span class="n">audioFrameBase</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int16_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">frame</span> <span class="o">*</span> <span class="n">rendererSampleCount</span> <span class="o">*</span> <span class="n">channelCountMax</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">channelCountMax</span><span class="p">;</span> <span class="o">++</span><span class="n">channel</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">int16_t</span><span class="o">*</span> <span class="n">channelBase</span> <span class="o">=</span> <span class="n">audioFrameBase</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">*</span> <span class="n">rendererSampleCount</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// Perform processing for each channel.
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">...</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
<span class="p">}</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
<p>&nbsp;</p>
<hr />
<p>CONFIDENTIAL</p>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank" rel="noopener noreferrer" >';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__atk', '../../../Api/HtmlNX/namespacenn_1_1atk.html' )
SetUrl( 'ApiLink_PageSampleAtkSimple', '../../../Api/HtmlNX/_page_sample_atk_simple.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a3dbeeceef71d2c2a527732d82d923671' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__SoundSystemParam', '../../../Api/HtmlNX/structnn_1_1atk_1_1_sound_system_1_1_sound_system_param.html' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__Open', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#ad8ef1e305d1da1d478c4af3a78528931' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__LoadHeader', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#ae35a81cb38094a2f2a9ae12d179b9622' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__GetHeaderSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#ad09c1b9648843e5e650350faffcf9e2b' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_data_manager.html' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_data_manager.html#a671e6256ee7b9f5bbd6871b7672475a5' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__GetRequiredMemSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_data_manager.html#afb9bb6557c8bfa17f1ed8eb31bcbd0e8' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__GetRequiredMemSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__GetRequiredStreamBufferSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227' )
SetUrl( 'ApiLink_nn__atk__SoundHeap', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_heap.html' )
SetUrl( 'ApiLink_nn__atk__SoundHeap__Create', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_heap.html#aca08fb7027062df41f26798f4d41f6a2' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__LoadData', '../../../Api/HtmlNX/classnn_1_1atk_1_1detail_1_1_sound_archive_loader.html#a3c8676a9807a4940a79a5c39546ab4f0' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__StartSound', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_startable.html#a9a075bc1dea627defdc533d514e50c33' )
SetUrl( 'ApiLink_nn__atk__SoundHandle', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__Stop', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a2ef2040a3bc7b007bc19a6efc26a88bb' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__Update', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a22e4ef8d9785639f48343fd84aba6d3a' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__IsPrepared', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a18fec84f97d735de838d09391be6d06c' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__StartPrepared', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07' )
SetUrl( 'ApiLink_nn__atk__SequenceSoundHandle', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sequence_sound_handle.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetCircularBufferSinkBufferSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a3174c4b4141eb0d2be2e7419427a9a09' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#af2699af79bd3461ec029afa019773fda' )
SetUrl( 'ApiLink_nn__audio__ReadCircularBufferSink', '../../../Api/HtmlNX/namespacenn_1_1audio.html#a38ea8ebfb7f48ae04043e2103d4c8a58' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetRendererSampleCount', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a1f4a70a2753f463116e7c81dbfa7a0d1' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetRendererChannelCountMax', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#aa5374101036ad73f60ffea371a881eb7' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
